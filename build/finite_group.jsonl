{"goal":"s.contains(x) implies G.elements.contains(x)","proof":["not G.elements.contains_every or x ∈ G.elements","not G.elements.contains_every","G.elements.contains_every"]}
{"goal":"subgroup_of_finite_group_is_finite","proof":["let [T0] (s0: (T0 -> Bool) -> List[T0], s1: (T0 -> Bool, List[T0]) -> T0) satisfy { forall(x0: T0 -> Bool, x1: T0) { not finite_constraint[T0](x0) or not x0(x1) or x1 ∈ s0(x0) } and forall(x2: T0 -> Bool, x3: List[T0]) { finite_constraint[T0](x2) or x2(s1(x2, x3)) } and forall(x4: List[T0], x5: T0 -> Bool) { not s1(x5, x4) ∈ x4 or finite_constraint[T0](x5) } }","not s1(s.contains, G.elements) ∈ s or s1(s.contains, G.elements) ∈ G.elements","not s1(s.contains, G.elements) ∈ G.elements or finite_constraint[G](s.contains)","finite_constraint[G](s.contains) or s1(s.contains, G.elements) ∈ s","s1(s.contains, G.elements) ∈ s","not s1(s.contains, G.elements) ∈ G.elements"]}
{"goal":"not identity_subgroup[G].contains(x)","proof":["List.cons(x, List.nil[G]) != s or x != x or x ∈ s","not x ∈ identity_subgroup[G] or G.1 = x","G.1 = x","List.singleton(x) = s","List.cons(x, List.nil[G]) = List.singleton(x)","List.cons(x, List.nil[G]) != s or x ∈ s","List.cons(x, List.nil[G]) != s"]}
{"goal":"not List.nil[G].contains(x)","proof":["not x ∈ List.nil[G] or List.nil[G] != List.nil[G]"]}
{"goal":"List.cons(G.1, List.nil[G]) = List.singleton(G.1)","proof":["List.cons(G.1, List.nil[G]) = List.singleton(G.1)"]}
{"goal":"s.contains(x) = (x = G.1)","proof":["not x ∈ s or List.cons(G.1, List.nil[G]) != s or x ∈ List.nil[G] or G.1 = x","List.cons(G.1, List.nil[G]) != s or G.1 != G.1 or G.1 ∈ s","List.cons(G.1, List.nil[G]) = s","List.cons(G.1, List.nil[G]) != s or G.1 ∈ s","G.1 ∈ s","List.cons(G.1, List.nil[G]) != s or not x ∈ s or G.1 = x","not x ∈ s or G.1 = x","G.1 = x","not x ∈ s","x ∈ s"]}
{"goal":"s.contains(x) = identity_subgroup[G].contains(x)","proof":["x ∈ identity_subgroup[G] or x ∈ s","x ∈ s","G.1 = x","not x ∈ identity_subgroup[G]","not subgroup_constraint[G](is_identity[G]) or x ∈ Subgroup.new[G](is_identity[G]) = is_identity(x)","Subgroup.new[G](is_identity[G]) = identity_subgroup[G]","G.1 != x or is_identity(x)","subgroup_constraint[G](is_identity[G])","is_identity(x)","not subgroup_constraint[G](is_identity[G]) or not is_identity(x) or x ∈ Subgroup.new[G](is_identity[G])","not x ∈ Subgroup.new[G](is_identity[G])","x ∈ Subgroup.new[G](is_identity[G])"]}
{"goal":"s.contains = identity_subgroup[G].contains","proof":["let s0: G satisfy { s0 ∈ identity_subgroup[G] != s0 ∈ s }","s0 ∈ identity_subgroup[G] = s0 ∈ s"]}
{"goal":"subgroup_constraint[G](s.contains)","proof":["not subgroup_constraint[G](identity_subgroup[G].contains)","subgroup_constraint[G](identity_subgroup[G].contains)"]}
{"goal":"exists(k0: List[G]) { k0.is_unique and subgroup_constraint[G](k0.contains) }","proof":["not subgroup_constraint[G](List.singleton(G.1).contains) or not List.singleton(G.1).is_unique","List.singleton(G.1).is_unique","not subgroup_constraint[G](List.singleton(G.1).contains)"]}
{"goal":"s.elements.unique.length <= G.elements.length","proof":["let s0[T0]: (List[T0], List[T0]) -> T0 satisfy { forall(x0: List[T0], x1: List[T0]) { x0.unique.length <= x1.length or s0(x0, x1) ∈ x0 } and forall(x2: List[T0], x3: List[T0]) { not s0(x3, x2) ∈ x2 or x3.unique.length <= x2.length } }","not s0(s.elements, G.elements) ∈ G.elements or s.elements.unique.length <= G.elements.length","not G.elements.contains_every or s0(s.elements, G.elements) ∈ G.elements","G.elements.contains_every","not s0(s.elements, G.elements) ∈ G.elements"]}
{"goal":"s.elements.is_unique","proof":["s.elements.is_unique"]}
{"goal":"subgroup_has_order_at_most_G_order","proof":["s.elements.length = s.order","not s.elements.is_unique or s.elements.unique = s.elements","G.elements.length = G.order","s.elements.unique.length <= G.order","not s.elements.length <= G.order","s.elements.unique = s.elements"]}
{"goal":"map[Nat, G](n.range, f).length = n.range.length","proof":["map[Nat, G](n.range, f).length = n.range.length"]}
{"goal":"n.range.length = n","proof":["n.range.length = n"]}
{"goal":"cyclic_subgroup.length = n","proof":[]}
{"goal":"map[Nat, G](n.range, f).unique.length <= G.elements.length","proof":["not cyclic_subgroup.unique.length <= G.elements.length","let s0[T0]: (List[T0], List[T0]) -> T0 satisfy { forall(x0: List[T0], x1: List[T0]) { x0.unique.length <= x1.length or s0(x0, x1) ∈ x0 } and forall(x2: List[T0], x3: List[T0]) { not s0(x3, x2) ∈ x2 or x3.unique.length <= x2.length } }","not s0(cyclic_subgroup, G.elements) ∈ G.elements or cyclic_subgroup.unique.length <= G.elements.length","not G.elements.contains_every or s0(cyclic_subgroup, G.elements) ∈ G.elements","G.elements.contains_every","not s0(cyclic_subgroup, G.elements) ∈ G.elements"]}
{"goal":"cyclic_subgroup.unique.length <= G.elements.length","proof":["not map[Nat, G](n.range, f).unique.length <= G.elements.length"]}
{"goal":"G.elements.length < n","proof":["not G.order <= n or G.order < n or G.order = n","G.order + 1 != n or G.order <= n","G.order + 1 = G.order.suc","G.order.suc = n","G.elements.length = G.order","not G.order < n","n.suc != n","G.order <= n","G.order = n"]}
{"goal":"cyclic_subgroup.unique.length < n","proof":["not G.elements.length < n or not cyclic_subgroup.unique.length <= G.elements.length or cyclic_subgroup.unique.length < n","not cyclic_subgroup.unique.length <= G.elements.length or not G.elements.length < n"]}
{"goal":"cyclic_subgroup.unique.length < cyclic_subgroup.length","proof":["not cyclic_subgroup.unique.length < n"]}
{"goal":"map[Nat, G](n.range, f).unique.length < n","proof":["not cyclic_subgroup.unique.length < n"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < cyclic_subgroup.length and f(k0) = f(k1) }","proof":["let [T0] (s0: (Nat, Nat -> T0) -> Nat, s1: (Nat, Nat -> T0) -> Nat) satisfy { forall(x0: Nat, x1: Nat -> T0) { not map[Nat, T0](x0.range, x1).unique.length < x0 or s0(x0, x1) < s1(x0, x1) } and forall(x2: Nat, x3: Nat -> T0) { not map[Nat, T0](x2.range, x3).unique.length < x2 or s1(x2, x3) < x2 } and forall(x4: Nat, x5: Nat -> T0) { not map[Nat, T0](x4.range, x5).unique.length < x4 or x5(s1(x4, x5)) = x5(s0(x4, x5)) } }","not s1(n, f) < cyclic_subgroup.length or not s0(n, f) < s1(n, f) or f(s1(n, f)) != f(s0(n, f))","not map[Nat, G](n.range, f).unique.length < n or s1(n, f) < n","not map[Nat, G](n.range, f).unique.length < n or f(s1(n, f)) = f(s0(n, f))","not map[Nat, G](n.range, f).unique.length < n or s0(n, f) < s1(n, f)","s1(n, f) < n","s0(n, f) < s1(n, f)","f(s1(n, f)) = f(s0(n, f))","s1(n, f) < cyclic_subgroup.length","not s1(n, f) < cyclic_subgroup.length"]}
{"goal":"i + m = j","proof":["not i <= j or j - i + i = j","m + i = i + m","m + i != j","not i < j or i <= j","i <= j","j - i + i != j","j - i + i = j"]}
{"goal":"m < n","proof":["j < n","not j < n or not m <= j or m < n","m + i != j or m <= j","m + i = i + m","not m <= j or not j < n","not m <= j","m + i = j"]}
{"goal":"m <= G.order","proof":["not m.suc <= G.order.suc or m <= G.order","not m < n or m.suc <= n","G.order + 1 = G.order.suc","not m.suc <= G.order.suc","m.suc <= n"]}
{"goal":"g.pow(m) = G.1","proof":["g.pow(i) = f(i)","g.pow(j) = f(j)","not j > i or g.pow(j) != g.pow(i) or g.pow(j - i) = G.1","j > i = i < j","g.pow(j - i) != G.1","j > i","g.pow(j) = f(i)","g.pow(j) != g.pow(i)","g.pow(j) = g.pow(i)"]}
{"goal":"all_elements_have_order_at_most_G","proof":["not m <= G.order or not m > 0 or g.pow(m) != G.1","not j > i or j - i > 0","not m > 0","j > i = i < j","j > i","not j - i > 0","j - i > 0"]}
{"goal":"exists(k0: Nat) { k0 > 0 and k0 <= G.order and g.pow(k0) = G.1 }","proof":["let s0[T0: FiniteGroup]: T0 -> Nat satisfy { forall(x0: T0) { s0(x0) > 0 } and forall(x1: T0) { s0(x1) <= T0.order } and forall(x2: T0) { T0.pow(x2, s0(x2)) = T0.1 } }","not s0(g) <= G.order or not s0(g) > 0 or g.pow(s0(g)) != G.1","g.pow(s0(g)) = G.1","s0(g) <= G.order","s0(g) > 0","not s0(g) <= G.order or not s0(g) > 0"]}
{"goal":"n != 0","proof":["n > n","not n < n or not n < n","n > n = n < n","n < n"]}
{"goal":"all_elements_have_finite_order","proof":["g.pow(n) != G.1 or 0 = n or has_finite_order(g)"]}
