{"goal":"s.contains(x) implies G.elements.contains(x)","proof":["function[T0](x0: List[T0], x1: T0) { not x0.contains_every or x1 ∈ x0 }[G](G.elements, x)","not G.elements.contains_every","function[T0: FiniteGroup] { T0.elements.contains_every }[G]"]}
{"goal":"subgroup_of_finite_group_is_finite","proof":["let [T0] (s0: (T0 -> Bool) -> List[T0], s1: (T0 -> Bool, List[T0]) -> T0) satisfy { forall(x0: T0 -> Bool, x1: T0) { not finite_constraint[T0](x0) or not x0(x1) or x1 ∈ s0(x0) } and forall(x2: T0 -> Bool, x3: List[T0]) { finite_constraint[T0](x2) or x2(s1(x2, x3)) } and forall(x4: List[T0], x5: T0 -> Bool) { not s1(x5, x4) ∈ x4 or finite_constraint[T0](x5) } }","function(x0: G) { not x0 ∈ s or x0 ∈ G.elements }(s1(s.contains, G.elements))","function[T0](x0: List[T0], x1: T0 -> Bool) { not s1(x1, x0) ∈ x0 or finite_constraint[T0](x1) }[G](G.elements, s.contains)","function[T0](x0: T0 -> Bool, x1: List[T0]) { finite_constraint[T0](x0) or x0(s1(x0, x1)) }[G](s.contains, G.elements)","function(x0: List[G]) { s1(s.contains, x0) ∈ s }(G.elements)","function(x0: List[G]) { not s1(s.contains, x0) ∈ x0 }(G.elements)"]}
{"goal":"not identity_subgroup[G].contains(x)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or x3 ∈ x2 }[G](G.1, List.nil[G], s, x)","function[T0: Group](x0: T0) { not x0 ∈ identity_subgroup[T0] or T0.1 = x0 }[G](x)","G.1 = x","function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[G](G.1)","List.cons(G.1, List.nil[G]) = s","function(x0: G, x1: List[G]) { List.cons(x0, x1) != s or x != x0 }(G.1, List.nil[G])"]}
{"goal":"not List.nil[G].contains(x)","proof":["function[T0](x0: List[T0], x1: T0) { not x1 ∈ x0 or List.nil[T0] != x0 }[G](List.nil[G], x)"]}
{"goal":"List.cons(G.1, List.nil[G]) = List.singleton(G.1)","proof":["function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[G](G.1)"]}
{"goal":"s.contains(x) = (x = G.1)","proof":["function[T0](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not x1 ∈ x0 or List.cons[T0](x2, x3) != x0 or x1 ∈ x3 or x1 = x2 }[G](s, x, G.1, List.nil[G])","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or x3 ∈ x2 }[G](G.1, List.nil[G], s, G.1)","List.cons(G.1, List.nil[G]) = s","function(x0: G) { G.1 != x0 or x0 ∈ s }(G.1)","G.1 ∈ s","function(x0: G, x1: List[G]) { List.cons(x0, List.nil[G]) != x1 or not x ∈ x1 or x = x0 }(G.1, s)","not x ∈ s or G.1 = x","G.1 = x","not x ∈ s","x ∈ s"]}
{"goal":"s.contains(x) = identity_subgroup[G].contains(x)","proof":["x ∈ identity_subgroup[G] or x ∈ s","x ∈ s","G.1 = x","not x ∈ identity_subgroup[G]","function[T0: Group](x0: Subgroup[T0], x1: T0 -> Bool, x2: T0) { Option.some[Subgroup[T0]](x0) != Subgroup.new_option[T0](x1) or x2 ∈ x0 = x1(x2) }[G](identity_subgroup[G], is_identity[G], x)","function[T0: Group] { Option.some[Subgroup[T0]](identity_subgroup[T0]) = Subgroup.new_option[T0](is_identity[T0]) }[G]","function[T0: Group](x0: T0) { T0.1 != x0 or is_identity[T0](x0) }[G](x)","is_identity(x)","function[T0: Group](x0: Subgroup[T0], x1: T0 -> Bool, x2: T0) { Option.some[Subgroup[T0]](x0) != Subgroup.new_option[T0](x1) or not x1(x2) or x2 ∈ x0 }[G](identity_subgroup[G], is_identity[G], x)","function(x0: G -> Bool) { Option.some(identity_subgroup[G]) != Subgroup.new_option[G](x0) or not x0(x) }(is_identity[G])"]}
{"goal":"s.contains = identity_subgroup[G].contains","proof":["let s0: G satisfy { s0 ∈ identity_subgroup[G] != s0 ∈ s }","function(x0: G) { x0 ∈ identity_subgroup[G] = x0 ∈ s }(s0)"]}
{"goal":"subgroup_constraint[G](s.contains)","proof":["function[T0: Group](x0: Subgroup[T0]) { subgroup_constraint[T0](x0.contains) }[G](identity_subgroup[G])","identity_subgroup[G].contains = s.contains"]}
{"goal":"exists(k0: List[G]) { k0.is_unique and subgroup_constraint[G](k0.contains) }","proof":["function(x0: List[G]) { not subgroup_constraint[G](x0.contains) or not x0.is_unique }(List.singleton(G.1))","function[T0](x0: T0) { List.singleton[T0](x0).is_unique }[G](G.1)","function(x0: G) { not subgroup_constraint[G](List.singleton(x0).contains) }(G.1)"]}
{"goal":"identity_list_is_unique","proof":["let s0: Bool satisfy { true }","function[T0: Group, T1: Group](x0: T0) { T1.1 = lib(group).trivial_hom[T0, T1](x0) }[Bool, G](s0)","function[T0: Group](x0: T0) { not List.singleton(lib(group).trivial_hom[T0, G](x0)).is_unique }[Bool](s0)","function[T0](x0: T0) { List.singleton[T0](x0).is_unique }[G](lib(group).trivial_hom[Bool, G](s0))"]}
{"goal":"identity_meets_identity_constraint","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or x3 ∈ x2 }[G](G.1, List.nil[G], List.singleton(G.1), G.1)","function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[G](G.1)","function[T0: Group](x0: T0 -> Bool) { identity_constraint[T0](x0) = x0(T0.1) }[G](List.singleton(G.1).contains)","not G.1 ∈ List.singleton(G.1)","function(x0: G, x1: List[G]) { List.singleton(G.1) != List.cons(x0, x1) or G.1 != x0 }(G.1, List.nil[G])"]}
{"goal":"not List.nil[G].contains(a)","proof":["function[T0](x0: List[T0], x1: T0) { not x1 ∈ x0 or List.nil[T0] != x0 }[G](List.nil[G], a)"]}
{"goal":"List.cons(G.1, List.nil[G]) = s","proof":["function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[G](G.1)"]}
{"goal":"a = G.1","proof":["function[T0](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not x1 ∈ x0 or List.cons[T0](x2, x3) != x0 or x1 ∈ x3 or x1 = x2 }[G](s, a, G.1, List.nil[G])","function(x0: List[G], x1: List[G]) { List.cons(G.1, x0) != x1 or not a ∈ x1 or a ∈ x0 }(List.nil[G], s)"]}
{"goal":"b = G.1","proof":["function[T0](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not x1 ∈ x0 or List.cons[T0](x2, x3) != x0 or x1 ∈ x3 or x1 = x2 }[G](s, b, G.1, List.nil[G])","function[T0](x0: List[T0], x1: T0) { not x1 ∈ x0 or List.nil[T0] != x0 }[G](List.nil[G], b)","function(x0: List[G], x1: List[G]) { List.cons(G.1, x0) != x1 or not b ∈ x1 or b ∈ x0 }(List.nil[G], s)","b ∈ List.nil[G]"]}
{"goal":"a * b = G.1","proof":["function[T0: lib(monoid).Monoid](x0: T0) { T0.1 * x0 = x0 }[G](G.1)"]}
{"goal":"s.contains(a * b)","proof":[]}
{"goal":"identity_meets_closure_constraint","proof":["not closure_constraint[G](s.contains)","let [T0: Group] (s0: (T0 -> Bool) -> T0, s1: (T0 -> Bool) -> T0) satisfy { forall(x0: T0 -> Bool, x1: T0, x2: T0) { not closure_constraint[T0](x0) or not x0(x1) or not x0(x2) or x0(T0.mul(x1, x2)) } and forall(x3: T0 -> Bool) { closure_constraint[T0](x3) or x3(s0(x3)) } and forall(x4: T0 -> Bool) { x4(s1(x4)) or closure_constraint[T0](x4) } and forall(x5: T0 -> Bool) { not x5(T0.mul(s0(x5), s1(x5))) or closure_constraint[T0](x5) } }","function(x0: G, x1: G) { not x0 ∈ s or not x1 ∈ s or x0 * x1 ∈ s }(s0(s.contains), s1(s.contains))","function[T0: Group](x0: T0 -> Bool) { not x0(T0.mul(s0(x0), s1(x0))) or closure_constraint[T0](x0) }[G](s.contains)","function[T0: Group](x0: T0 -> Bool) { x0(s1(x0)) or closure_constraint[T0](x0) }[G](s.contains)","function[T0: Group](x0: T0 -> Bool) { closure_constraint[T0](x0) or x0(s0(x0)) }[G](s.contains)","s0(s.contains) ∈ s","s1(s.contains) ∈ s","not G.mul(s0(s.contains), s1(s.contains)) ∈ s"]}
{"goal":"not List.nil[G].contains(a)","proof":["function[T0](x0: List[T0], x1: T0) { not x1 ∈ x0 or List.nil[T0] != x0 }[G](List.nil[G], a)"]}
{"goal":"List.cons(G.1, List.nil[G]) = s","proof":["function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[G](G.1)"]}
{"goal":"a = G.1","proof":["function[T0](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not x1 ∈ x0 or List.cons[T0](x2, x3) != x0 or x1 ∈ x3 or x1 = x2 }[G](s, a, G.1, List.nil[G])","function(x0: List[G], x1: List[G]) { List.cons(G.1, x0) != x1 or not a ∈ x1 or a ∈ x0 }(List.nil[G], s)"]}
{"goal":"G.1.inverse = G.1","proof":["function[T0: Group](x0: T0) { T0.mul(x0, T0.inverse(x0)) = T0.1 }[G](G.1)","function[T0: lib(monoid).Monoid](x0: T0) { T0.1 * x0 = x0 }[G](G.1.inverse)"]}
{"goal":"s.contains(a.inverse)","proof":[]}
{"goal":"identity_meets_inverse_constraint","proof":["let s0[T0: Group]: (T0 -> Bool) -> T0 satisfy { forall(x0: T0 -> Bool, x1: T0) { not inverse_constraint[T0](x0) or not x0(x1) or x0(T0.inverse(x1)) } and forall(x2: T0 -> Bool) { x2(s0(x2)) or inverse_constraint[T0](x2) } and forall(x3: T0 -> Bool) { not x3(T0.inverse(s0(x3))) or inverse_constraint[T0](x3) } }","function(x0: G) { not x0 ∈ s or x0.inverse ∈ s }(s0(s.contains))","not inverse_constraint[G](s.contains)","function[T0: Group](x0: T0 -> Bool) { not x0(T0.inverse(s0(x0))) or inverse_constraint[T0](x0) }[G](s.contains)","function[T0: Group](x0: T0 -> Bool) { x0(s0(x0)) or inverse_constraint[T0](x0) }[G](s.contains)","s0(s.contains) ∈ s","not G.inverse(s0(s.contains)) ∈ s","G.inverse(s0(s.contains)) ∈ s"]}
{"goal":"identity_meets_subgroup_constraint","proof":["function[T0: Group](x0: T0 -> Bool) { not inverse_constraint[T0](x0) or not closure_constraint[T0](x0) or not identity_constraint[T0](x0) or subgroup_constraint[T0](x0) }[G](List.singleton(G.1).contains)","function[T0: FiniteGroup] { inverse_constraint[T0](List.singleton[T0](T0.1).contains) }[G]","function[T0: FiniteGroup] { closure_constraint[T0](List.singleton[T0](T0.1).contains) }[G]","function[T0: FiniteGroup] { identity_constraint[T0](List.singleton[T0](T0.1).contains) }[G]","not inverse_constraint[G](List.singleton(G.1).contains) or not closure_constraint[G](List.singleton(G.1).contains) or not identity_constraint[G](List.singleton(G.1).contains)"]}
{"goal":"identity_meets_fs_constraint","proof":["function[T0: FiniteGroup](x0: List[T0]) { not subgroup_constraint[T0](x0.contains) or not x0.is_unique or FiniteSubgroup.constraint[T0](x0) }[G](List.singleton(G.1))","function[T0: FiniteGroup] { subgroup_constraint[T0](List.singleton[T0](T0.1).contains) }[G]","function[T0](x0: T0) { List.singleton[T0](x0).is_unique }[G](G.1)","not subgroup_constraint[G](List.singleton(G.1).contains) or not List.singleton(G.1).is_unique"]}
{"goal":"not FiniteSubgroup.constraint[G](List.singleton(G.1))","proof":["let s0[T0: FiniteGroup]: List[T0] -> FiniteSubgroup[T0] satisfy { forall(x0: List[T0]) { not FiniteSubgroup.constraint[T0](x0) or Option.some[FiniteSubgroup[T0]](s0(x0)) = FiniteSubgroup.new_option[T0](x0) } }","function[T0: FiniteGroup](x0: List[T0]) { not FiniteSubgroup.constraint[T0](x0) or Option.some[FiniteSubgroup[T0]](s0(x0)) = FiniteSubgroup.new_option[T0](x0) }[G](List.singleton(G.1))","function[T0](x0: T0) { Option.none[T0] != Option.some[T0](x0) }[FiniteSubgroup[G]](s0(List.singleton(G.1)))","function[T0] { none[T0] = Option.none[T0] }[FiniteSubgroup[G]]","FiniteSubgroup.new_option[G](List.singleton(G.1)) = Option.none[FiniteSubgroup[G]]","Option.some[FiniteSubgroup[G]](s0(List.singleton(G.1))) = FiniteSubgroup.new_option[G](List.singleton(G.1))"]}
{"goal":"false","proof":["function[T0: FiniteGroup] { FiniteSubgroup.constraint[T0](List.singleton[T0](T0.1)) }[G]"]}
{"goal":"some(g) = FiniteSubgroup.new_option[G](List.singleton(G.1))","proof":["some(g) != Option.some(g)","function[T0](x0: T0) { some[T0](x0) = Option.some[T0](x0) }[FiniteSubgroup[G]](g)"]}
{"goal":"isg_helper","proof":["let s0: FiniteSubgroup[G] satisfy { FiniteSubgroup.new_option[G](List.singleton[G](G.1)) = some[FiniteSubgroup[G]](s0) }","function(x0: FiniteSubgroup[G]) { FiniteSubgroup.new_option[G](List.singleton(G.1)) != some(x0) }(s0)"]}
{"goal":"exists(k0: FiniteSubgroup[G]) { some(k0) = FiniteSubgroup.new_option[G](List.singleton(G.1)) }","proof":["let s0[T0: FiniteGroup]: FiniteSubgroup[T0] satisfy { FiniteSubgroup.new_option[T0](List.singleton[T0](T0.1)) = some[FiniteSubgroup[T0]](s0) }","function[T0: FiniteGroup](x0: FiniteSubgroup[T0]) { FiniteSubgroup.new_option[T0](List.singleton[T0](T0.1)) != some[FiniteSubgroup[T0]](x0) }[G](s0)","function[T0: FiniteGroup] { FiniteSubgroup.new_option[T0](List.singleton[T0](T0.1)) = some[FiniteSubgroup[T0]](s0) }[G]"]}
{"goal":"s.elements.unique.length <= G.elements.length","proof":["let s0[T0]: (List[T0], List[T0]) -> T0 satisfy { forall(x0: List[T0], x1: List[T0]) { x0.unique.length <= x1.length or s0(x0, x1) ∈ x0 } and forall(x2: List[T0], x3: List[T0]) { not s0(x3, x2) ∈ x2 or x3.unique.length <= x2.length } }","function[T0](x0: List[T0], x1: List[T0]) { not s0(x1, x0) ∈ x0 or x1.unique.length <= x0.length }[G](G.elements, s.elements)","function[T0](x0: List[T0], x1: T0) { not x0.contains_every or x1 ∈ x0 }[G](G.elements, s0(s.elements, G.elements))","function[T0: FiniteGroup] { T0.elements.contains_every }[G]","not s0(s.elements, G.elements) ∈ G.elements"]}
{"goal":"s.elements.is_unique","proof":["function[T0: FiniteGroup](x0: FiniteSubgroup[T0]) { x0.elements.is_unique }[G](s)"]}
{"goal":"subgroup_has_order_at_most_G_order","proof":["function[T0: FiniteGroup](x0: FiniteSubgroup[T0]) { x0.elements.length = x0.order }[G](s)","function[T0](x0: List[T0]) { not x0.is_unique or x0.unique = x0 }[G](s.elements)","function[T0: FiniteGroup] { T0.elements.length = T0.order }[G]","s.elements.unique.length <= G.order","not s.elements.length <= G.order","s.elements.unique = s.elements"]}
{"goal":"map[Nat, G](n.range, f).length = n.range.length","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { map[T0, T1](x0, x1).length = x0.length }[Nat, G](n.range, f)"]}
{"goal":"n.range.length = n","proof":["function(x0: Nat) { x0.range.length = x0 }(n)"]}
{"goal":"cyclic_subgroup.length = n","proof":[]}
{"goal":"map[Nat, G](n.range, f).unique.length <= G.elements.length","proof":["not cyclic_subgroup.unique.length <= G.elements.length","let s0[T0]: (List[T0], List[T0]) -> T0 satisfy { forall(x0: List[T0], x1: List[T0]) { x0.unique.length <= x1.length or s0(x0, x1) ∈ x0 } and forall(x2: List[T0], x3: List[T0]) { not s0(x3, x2) ∈ x2 or x3.unique.length <= x2.length } }","function[T0](x0: List[T0], x1: List[T0]) { not s0(x1, x0) ∈ x0 or x1.unique.length <= x0.length }[G](G.elements, cyclic_subgroup)","function[T0](x0: List[T0], x1: T0) { not x0.contains_every or x1 ∈ x0 }[G](G.elements, s0(cyclic_subgroup, G.elements))","function[T0: FiniteGroup] { T0.elements.contains_every }[G]","not s0(cyclic_subgroup, G.elements) ∈ G.elements"]}
{"goal":"cyclic_subgroup.unique.length <= G.elements.length","proof":["not map[Nat, G](n.range, f).unique.length <= G.elements.length"]}
{"goal":"G.elements.length < n","proof":["function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lte(x0, x1) or T0.lt(x0, x1) or x0 = x1 }[Nat](G.order, n)","function(x0: Nat, x1: Nat, x2: Nat) { x0 + x1 != x2 or x0 <= x2 }(G.order, 1, n)","function(x0: Nat) { x0 + 1 = x0.suc }(G.order)","G.order.suc = n","function[T0: FiniteGroup] { T0.elements.length = T0.order }[G]","not G.order < n","function(x0: Nat) { x0.suc != x0 }(n)","G.order <= n","G.order = n"]}
{"goal":"cyclic_subgroup.unique.length < n","proof":["function(x0: Nat, x1: Nat, x2: Nat) { not x0 < x1 or not x2 <= x0 or x2 < x1 }(G.order, n, cyclic_subgroup.unique.length)","function[T0: FiniteGroup] { T0.elements.length = T0.order }[G]","G.order < n","cyclic_subgroup.unique.length <= G.order","function(x0: Nat) { not cyclic_subgroup.unique.length <= x0 or not x0 < n }(G.order)"]}
{"goal":"cyclic_subgroup.unique.length < cyclic_subgroup.length","proof":["not cyclic_subgroup.unique.length < n"]}
{"goal":"map[Nat, G](n.range, f).unique.length < n","proof":["not cyclic_subgroup.unique.length < n"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < cyclic_subgroup.length and f(k0) = f(k1) }","proof":["let [T0] (s0: (Nat, Nat -> T0) -> Nat, s1: (Nat, Nat -> T0) -> Nat) satisfy { forall(x0: Nat, x1: Nat -> T0) { not map[Nat, T0](x0.range, x1).unique.length < x0 or s0(x0, x1) < s1(x0, x1) } and forall(x2: Nat, x3: Nat -> T0) { not map[Nat, T0](x2.range, x3).unique.length < x2 or s1(x2, x3) < x2 } and forall(x4: Nat, x5: Nat -> T0) { not map[Nat, T0](x4.range, x5).unique.length < x4 or x5(s1(x4, x5)) = x5(s0(x4, x5)) } }","function(x0: Nat, x1: Nat) { not x0 < cyclic_subgroup.length or not x1 < x0 or f(x0) != f(x1) }(s1(n, f), s0(n, f))","function[T0](x0: Nat, x1: Nat -> T0) { not map[Nat, T0](x0.range, x1).unique.length < x0 or s1(x0, x1) < x0 }[G](n, f)","function[T0](x0: Nat, x1: Nat -> T0) { not map[Nat, T0](x0.range, x1).unique.length < x0 or x1(s1(x0, x1)) = x1(s0(x0, x1)) }[G](n, f)","function[T0](x0: Nat, x1: Nat -> T0) { not map[Nat, T0](x0.range, x1).unique.length < x0 or s0(x0, x1) < s1(x0, x1) }[G](n, f)","s1(n, f) < n","s0(n, f) < s1(n, f)","f(s1(n, f)) = f(s0(n, f))","s1(n, f) < cyclic_subgroup.length","not s1(n, f) < cyclic_subgroup.length"]}
{"goal":"i + m = j","proof":["function(x0: Nat, x1: Nat) { not x0 <= x1 or x1 - x0 + x0 = x1 }(i, j)","function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(m, i)","m + i != j","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Nat](i, j)","i <= j","j - i + i != j","j - i + i = j"]}
{"goal":"m < n","proof":["j < n","function(x0: Nat, x1: Nat, x2: Nat) { not x0 < x1 or not x2 <= x0 or x2 < x1 }(j, n, m)","function(x0: Nat, x1: Nat, x2: Nat) { x0 + x1 != x2 or x0 <= x2 }(m, i, j)","function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[Nat](m, i)","function(x0: Nat) { not x0 < n or not m <= x0 }(j)","not m <= j","m + i = j"]}
{"goal":"m <= G.order","proof":["function(x0: Nat, x1: Nat) { not x0.suc <= x1.suc or x0 <= x1 }(m, G.order)","function(x0: Nat, x1: Nat) { not x0 < x1 or x0.suc <= x1 }(m, n)","function(x0: Nat) { x0 + 1 = x0.suc }(G.order)","not m.suc <= G.order.suc","m.suc <= n"]}
{"goal":"g.pow(m) = G.1","proof":["function(x0: Nat) { g.pow(x0) = f(x0) }(i)","function(x0: Nat) { g.pow(x0) = f(x0) }(j)","function[T0: Group](x0: Nat, x1: Nat, x2: T0) { not x0 > x1 or T0.pow(x2, x0) != T0.pow(x2, x1) or T0.pow(x2, x0 - x1) = T0.1 }[G](j, i, g)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](j, i)","g.pow(j - i) != G.1","j > i","g.pow(j) = f(i)","g.pow(j) != g.pow(i)","g.pow(j) = g.pow(i)"]}
{"goal":"all_elements_have_order_at_most_G","proof":["function(x0: Nat) { not x0 > 0 or not x0 <= G.order or g.pow(x0) != G.1 }(m)","function(x0: Nat, x1: Nat) { not x0 > x1 or x0 - x1 > 0 }(j, i)","not m > 0","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](j, i)","j > i","not j - i > 0","j - i > 0"]}
{"goal":"exists(k0: Nat) { k0 > 0 and k0 <= G.order and g.pow(k0) = G.1 }","proof":["let s0[T0: FiniteGroup]: T0 -> Nat satisfy { forall(x0: T0) { s0(x0) > 0 } and forall(x1: T0) { s0(x1) <= T0.order } and forall(x2: T0) { T0.pow(x2, s0(x2)) = T0.1 } }","function(x0: Nat) { not x0 > 0 or not x0 <= G.order or g.pow(x0) != G.1 }(s0(g))","function[T0: FiniteGroup](x0: T0) { T0.pow(x0, s0(x0)) = T0.1 }[G](g)","function[T0: FiniteGroup](x0: T0) { s0(x0) <= T0.order }[G](g)","function[T0: FiniteGroup](x0: T0) { s0(x0) > 0 }[G](g)","not s0(g) > 0 or not s0(g) <= G.order"]}
{"goal":"n != 0","proof":["n > n","function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 < x0 }(n, n)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](n, n)","n < n"]}
{"goal":"all_elements_have_finite_order","proof":["function[T0: Group](x0: T0, x1: Nat) { T0.1 != T0.pow(x0, x1) or 0 = x1 or has_finite_order[T0](x0) }[G](g, n)"]}
