{"goal":"exists(k0: Set[T]) { k0.is_finite }","proof":["function(x0: Set[T]) { not x0.is_finite }(Set.empty_set[T])","function[T0](x0: Set[T0]) { finite_constraint[T0](x0.contains) = x0.is_finite }[T](Set.empty_set[T])","let s0: lib(list.list_base).List[T] satisfy { true }","let [T0] (s1: (T0 -> Bool) -> lib(list.list_base).List[T0], s2: (T0 -> Bool, lib(list.list_base).List[T0]) -> T0) satisfy { forall(x0: T0 -> Bool, x1: T0) { not finite_constraint[T0](x0) or not x0(x1) or x1 ∈ s1(x0) } and forall(x2: T0 -> Bool, x3: lib(list.list_base).List[T0]) { finite_constraint[T0](x2) or x2(s2(x2, x3)) } and forall(x4: lib(list.list_base).List[T0], x5: T0 -> Bool) { not s2(x5, x4) ∈ x4 or finite_constraint[T0](x5) } }","function[T0](x0: T0 -> Bool, x1: lib(list.list_base).List[T0]) { finite_constraint[T0](x0) or x0(s2(x0, x1)) }[T](Set.empty_set[T].contains, s0)","function[T0](x0: Set[T0], x1: T0) { not x0.is_empty or not x1 ∈ x0 }[T](Set.empty_set[T], s2(Set.empty_set[T].contains, s0))","function[T0] { Set.empty_set[T0].is_empty }[T]","function[T0](x0: Set[T0]) { not finite_constraint[T0](x0.contains) or x0.is_finite }[T](Set.empty_set[T])","function(x0: Set[T]) { not finite_constraint[T](x0.contains) }(Set.empty_set[T])","function(x0: Set[T], x1: lib(list.list_base).List[T]) { s2(x0.contains, x1) ∈ x0 }(Set.empty_set[T], s0)","function(x0: Set[T]) { not x0.is_empty }(Set.empty_set[T])"]}
{"goal":"exists(k0: FiniteSet[T]) { FiniteSet.new_option[T](Set.empty_set[T]) = Option.some(k0) }","proof":["let s0[T0]: Set[T0] -> FiniteSet[T0] satisfy { forall(x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) } }","function(x0: FiniteSet[T]) { FiniteSet.new_option[T](Set.empty_set[T]) != Option.some(x0) }(s0(Set.empty_set[T]))","function[T0](x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) }[T](Set.empty_set[T])","not FiniteSet.constraint[T](Set.empty_set[T])","let s1: Nat satisfy { true }","let s2: (Nat -> Bool) -> Nat satisfy { forall(x1: Nat -> Bool, x2: Nat) { not x1(0) or x1(s2(x1)) or x1(x2) } and forall(x3: Nat -> Bool, x4: Nat) { not x3(0) or not x3(s2(x3).suc) or x3(x4) } }","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s2(x0)) or x0(x1) }(Set.empty_set[T].cardinality_is, s1)","function[T0](x0: Set[T0], x1: Nat) { not x0.cardinality_is(x1) or x0.is_finite }[T](Set.empty_set[T], s2(Set.empty_set[T].cardinality_is))","function[T0](x0: Set[T0], x1: Nat) { not x0.cardinality_is(x1) or x0.is_finite }[T](Set.empty_set[T], s1)","function[T0](x0: Set[T0]) { x0.is_finite = FiniteSet.constraint[T0](x0) }[T](Set.empty_set[T])","function[T0] { Set.empty_set[T0].cardinality_is(0) }[T]","not Set.empty_set[T].is_finite","function(x0: Nat) { not Set.empty_set[T].cardinality_is(x0) }(s2(Set.empty_set[T].cardinality_is))","function(x0: Nat) { not Set.empty_set[T].cardinality_is(x0) }(s1)"]}
{"goal":"finite_constraint[T](f)","proof":["function[T0](x0: Set[T0]) { finite_constraint[T0](x0.contains) = x0.is_finite }[T](s.underlying_set)","s.underlying_set.contains = f","function[T0](x0: FiniteSet[T0]) { x0.underlying_set.is_finite }[T](s)","not finite_constraint[T](s.underlying_set.contains)"]}
{"goal":"finite_constraint[T](functional_insert(f, item))","proof":[]}
{"goal":"inserted.contains = functional_insert(f, item)","proof":["function[T0](x0: Set[T0], x1: T0) { Set.new[T0](functional_insert[T0](x0.contains, x1)) = x0.insert(x1) }[T](s.underlying_set, item)","let s0: T satisfy { functional_insert[T](f, item, s0) != s0 ∈ inserted }","function[T0](x0: T0 -> Bool, x1: T0) { x1 ∈ Set.new[T0](x0) = x0(x1) }[T](functional_insert(f, item), s0)","s.underlying_set.contains = f"]}
{"goal":"inserted.is_finite","proof":["function[T0](x0: Set[T0]) { finite_constraint[T0](x0.contains) = x0.is_finite }[T](inserted)","not finite_constraint[T](inserted.contains)","functional_insert(f, item) = inserted.contains"]}
{"goal":"exists(k0: FiniteSet[T]) { FiniteSet.new_option[T](s.underlying_set.insert(item)) = Option.some(k0) }","proof":["let s0[T0]: Set[T0] -> FiniteSet[T0] satisfy { forall(x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) } }","function(x0: FiniteSet[T]) { FiniteSet.new_option[T](s.underlying_set.insert(item)) != Option.some(x0) }(s0(s.underlying_set.insert(item)))","function[T0](x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) }[T](s.underlying_set.insert(item))","function[T0](x0: Set[T0]) { x0.is_finite = FiniteSet.constraint[T0](x0) }[T](inserted)","FiniteSet.constraint[T](inserted)","not FiniteSet.constraint[T](s.underlying_set.insert(item))","FiniteSet.constraint[T](s.underlying_set.insert(item))"]}
{"goal":"finite_constraint[T](f)","proof":["function[T0](x0: Set[T0]) { finite_constraint[T0](x0.contains) = x0.is_finite }[T](s.underlying_set)","s.underlying_set.contains = f","function[T0](x0: FiniteSet[T0]) { x0.underlying_set.is_finite }[T](s)","not finite_constraint[T](s.underlying_set.contains)"]}
{"goal":"finite_constraint[T](functional_remove(f, item))","proof":[]}
{"goal":"removed.contains = functional_remove(f, item)","proof":["function[T0](x0: Set[T0], x1: T0) { Set.new[T0](functional_remove[T0](x0.contains, x1)) = x0.remove(x1) }[T](s.underlying_set, item)","let s0: T satisfy { functional_remove[T](f, item, s0) != s0 ∈ removed }","function[T0](x0: T0 -> Bool, x1: T0) { x1 ∈ Set.new[T0](x0) = x0(x1) }[T](functional_remove(f, item), s0)","s.underlying_set.contains = f"]}
{"goal":"removed.is_finite","proof":["function[T0](x0: Set[T0]) { finite_constraint[T0](x0.contains) = x0.is_finite }[T](removed)","not finite_constraint[T](removed.contains)","functional_remove(f, item) = removed.contains"]}
{"goal":"exists(k0: FiniteSet[T]) { FiniteSet.new_option[T](s.underlying_set.remove(item)) = Option.some(k0) }","proof":["let s0[T0]: Set[T0] -> FiniteSet[T0] satisfy { forall(x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) } }","function(x0: FiniteSet[T]) { FiniteSet.new_option[T](s.underlying_set.remove(item)) != Option.some(x0) }(s0(s.underlying_set.remove(item)))","function[T0](x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) }[T](s.underlying_set.remove(item))","function[T0](x0: Set[T0]) { x0.is_finite = FiniteSet.constraint[T0](x0) }[T](removed)","FiniteSet.constraint[T](removed)","not FiniteSet.constraint[T](s.underlying_set.remove(item))","FiniteSet.constraint[T](s.underlying_set.remove(item))"]}
{"goal":"exists(k0: FiniteSet[T]) { FiniteSet.new_option[T](a.underlying_set.union(b.underlying_set)) = Option.some(k0) }","proof":["let s0[T0]: Set[T0] -> FiniteSet[T0] satisfy { forall(x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) } }","function(x0: FiniteSet[T]) { FiniteSet.new_option[T](a.underlying_set ∪ b.underlying_set) != Option.some(x0) }(s0(a.underlying_set ∪ b.underlying_set))","function[T0](x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) }[T](a.underlying_set ∪ b.underlying_set)","function[T0](x0: Set[T0], x1: Set[T0]) { not x0.is_finite or not x1.is_finite or (x0 ∪ x1).is_finite }[T](a.underlying_set, b.underlying_set)","function[T0](x0: Set[T0]) { x0.is_finite = FiniteSet.constraint[T0](x0) }[T](a.underlying_set ∪ b.underlying_set)","function[T0](x0: FiniteSet[T0]) { x0.underlying_set.is_finite }[T](b)","function[T0](x0: FiniteSet[T0]) { x0.underlying_set.is_finite }[T](a)","not FiniteSet.constraint[T](a.underlying_set ∪ b.underlying_set)","not (a.underlying_set ∪ b.underlying_set).is_finite"]}
{"goal":"exists(k0: FiniteSet[T]) { FiniteSet.new_option[T](a.underlying_set.intersection(b.underlying_set)) = Option.some(k0) }","proof":["let s0[T0]: Set[T0] -> FiniteSet[T0] satisfy { forall(x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) } }","function(x0: FiniteSet[T]) { FiniteSet.new_option[T](a.underlying_set ∩ b.underlying_set) != Option.some(x0) }(s0(a.underlying_set ∩ b.underlying_set))","function[T0](x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) }[T](a.underlying_set ∩ b.underlying_set)","function[T0](x0: Set[T0], x1: Set[T0]) { not x0.is_finite or not x1.is_finite or (x0 ∩ x1).is_finite }[T](a.underlying_set, b.underlying_set)","function[T0](x0: Set[T0]) { x0.is_finite = FiniteSet.constraint[T0](x0) }[T](a.underlying_set ∩ b.underlying_set)","function[T0](x0: FiniteSet[T0]) { x0.underlying_set.is_finite }[T](b)","function[T0](x0: FiniteSet[T0]) { x0.underlying_set.is_finite }[T](a)","not FiniteSet.constraint[T](a.underlying_set ∩ b.underlying_set)","not (a.underlying_set ∩ b.underlying_set).is_finite"]}
{"goal":"exists(k0: FiniteSet[T]) { FiniteSet.new_option[T](a.underlying_set.difference(b.underlying_set)) = Option.some(k0) }","proof":["let s0[T0]: Set[T0] -> FiniteSet[T0] satisfy { forall(x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) } }","function(x0: FiniteSet[T]) { FiniteSet.new_option[T](a.underlying_set ∖ b.underlying_set) != Option.some(x0) }(s0(a.underlying_set ∖ b.underlying_set))","function[T0](x0: Set[T0]) { not FiniteSet.constraint[T0](x0) or Option.some[FiniteSet[T0]](s0(x0)) = FiniteSet.new_option[T0](x0) }[T](a.underlying_set ∖ b.underlying_set)","function[T0](x0: Set[T0], x1: Set[T0]) { not x0.is_finite or (x0 ∖ x1).is_finite }[T](a.underlying_set, b.underlying_set)","function[T0](x0: Set[T0]) { x0.is_finite = FiniteSet.constraint[T0](x0) }[T](a.underlying_set ∖ b.underlying_set)","function[T0](x0: FiniteSet[T0]) { x0.underlying_set.is_finite }[T](a)","not FiniteSet.constraint[T](a.underlying_set ∖ b.underlying_set)","not (a.underlying_set ∖ b.underlying_set).is_finite"]}
