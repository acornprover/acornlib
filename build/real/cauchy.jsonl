{"goal":"Nat.0.suc = Nat.1","proof":[]}
{"goal":"Nat.1.range = List.singleton(Nat.0)","proof":["Nat.0.until(Nat.0.suc) = Nat.0.upto(Nat.0)","Nat.0.upto(Nat.0) = Nat.0.suc.range","Nat.0.until(Nat.0.suc) = List.singleton(Nat.0)"]}
{"goal":"Nat.0 - Nat.0 = Nat.0","proof":["-lib(int.int_base).Int.from_nat(Nat.0) != lib(int.int_base).sub_nat(Nat.0, Nat.0) or Nat.0 + Nat.0 = Nat.0","Nat.0 + Nat.0 != Nat.0 or Nat.0 - Nat.0 = Nat.0","Nat.0 + Nat.0 != Nat.0","-lib(int.int_base).Int.from_nat(Nat.0) = lib(int.int_base).sub_nat(Nat.0, Nat.0)"]}
{"goal":"mapped = List.singleton(a(Nat.0) * b(Nat.0))","proof":["let s0: Nat -> Real satisfy { forall(x0: Nat) { a(x0) * b(Nat.0 - x0) = s0(x0) } }","a(Nat.0) * b(Nat.0 - Nat.0) = s0(Nat.0)","map[Nat, Real](List.singleton(Nat.0), s0) = List.singleton(s0(Nat.0))"]}
{"goal":"sum[Real](mapped) = a(Nat.0) * b(Nat.0)","proof":["let s0: Nat -> Real satisfy { forall(x0: Nat) { a(x0) * b(Nat.0 - x0) = s0(x0) } }","a(Nat.0) * b(Nat.0 - Nat.0) = s0(Nat.0)","sum[Real](map[Nat, Real](Nat.1.range, s0)) = partial[Real](s0, Nat.1)","partial[Real](s0, Nat.1) = s0(Nat.0)"]}
{"goal":"cauchy_product_zero","proof":["let s0: (Nat -> Real, Nat -> Real, Nat, Nat) -> Real satisfy { forall(x0: Nat -> Real, x1: Nat, x2: Nat -> Real, x3: Nat) { x0(x1) * x2(x3 - x1) = s0(x0, x2, x3, x1) } }","sum[Real](map[Nat, Real](Nat.0.suc.range, s0(a, b, Nat.0))) = cauchy_product(a, b, Nat.0)","a(Nat.0) * b(Nat.0 - Nat.0) = s0(a, b, Nat.0, Nat.0)","sum[Real](map[Nat, Real](Nat.0.suc.range, s0(a, b, Nat.0))) = partial[Real](s0(a, b, Nat.0), Nat.0.suc)","partial[Real](s0(a, b, Nat.0), Nat.1) = s0(a, b, Nat.0, Nat.0)"]}
{"goal":"map[T, Real](List.nil[T], f) = List.nil[Real]","proof":["List.nil[T].map(f) = map[T, Real](List.nil[T], f)","List.nil[T].map(f) != List.nil[Real]","List.nil[T] != List.nil[T] or List.nil[T].map(f) = List.nil[Real]"]}
{"goal":"sum[Real](List.nil[Real]) = 0","proof":["List.nil[Real] != List.nil[Real] or sum[Real](List.nil[Real]) = 0"]}
{"goal":"p(List.nil[T])","proof":["sum[Real](map[T, Real](List.nil[T], f)) != 0 or p(List.nil[T])","sum[Real](map[T, Real](List.nil[T], f)) = 0","sum[Real](map[T, Real](List.nil[T], f)) != 0"]}
{"goal":"sum[Real](map[T, Real](tail, f)) = 0","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T]) { f(s0(x0)) != 0 or not p(x0) or sum[Real](map[T, Real](x0, f)) = 0 } and forall(x1: T, x2: List[T]) { 0 = f(x1) or p(x2) } and forall(x3: List[T]) { sum[Real](map[T, Real](x3, f)) != 0 or p(x3) } }","f(s0(tail)) = 0","f(s0(tail)) != 0 or not p(tail) or sum[Real](map[T, Real](tail, f)) = 0","not p(tail) or sum[Real](map[T, Real](tail, f)) = 0"]}
{"goal":"map[T, Real](List.cons(head, tail), f) = List.cons(f(head), map[T, Real](tail, f))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, Real](tail, f)) = map[T, Real](List.cons(head, tail), f)"]}
{"goal":"sum[Real](List.cons(f(head), map[T, Real](tail, f))) = f(head) + sum[Real](map[T, Real](tail, f))","proof":["f(head) + sum[Real](map[T, Real](tail, f)) != sum[Real](map[T, Real](List.cons(head, tail), f))","List.cons(f(head), map[T, Real](tail, f)) != map[T, Real](List.cons(head, tail), f) or f(head) + sum[Real](map[T, Real](tail, f)) = sum[Real](map[T, Real](List.cons(head, tail), f))"]}
{"goal":"f(head) = 0","proof":["f(head) = 0"]}
{"goal":"sum[Real](List.cons(f(head), map[T, Real](tail, f))) = 0 + 0","proof":[]}
{"goal":"sum[Real](List.cons(f(head), map[T, Real](tail, f))) = 0","proof":["sum[Real](List.cons(f(head), map[T, Real](tail, f))) != 0 + 0 or sum[Real](List.cons(f(head), map[T, Real](tail, f))) - 0 = 0","sum[Real](List.cons(f(head), map[T, Real](tail, f))) - 0 != 0 or sum[Real](List.cons(f(head), map[T, Real](tail, f))) = 0","sum[Real](List.cons(f(head), map[T, Real](tail, f))) - 0 = 0","sum[Real](List.cons(f(head), map[T, Real](tail, f))) - 0 != 0"]}
{"goal":"sum[Real](map[T, Real](List.cons(head, tail), f)) = 0","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["let s0: T satisfy { f(s0) != 0 or sum[Real](map[T, Real](List.cons(head, tail), f)) = 0 }","f(s0) = 0","sum[Real](map[T, Real](List.cons(head, tail), f)) != 0 or p(List.cons(head, tail))"]}
{"goal":"sum_map_zero","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T]) { f(s0(x0)) != 0 or not p(x0) or sum[Real](map[T, Real](x0, f)) = 0 } and forall(x1: T, x2: List[T]) { 0 = f(x1) or p(x2) } and forall(x3: List[T]) { sum[Real](map[T, Real](x3, f)) != 0 or p(x3) } }","f(s0(items)) = 0","let (s1: List[T] -> Bool -> T, s2: List[T] -> Bool -> List[T]) satisfy { forall(x4: List[T] -> Bool, x5: List[T]) { not x4(List.nil[T]) or x4(s2(x4)) or x4(x5) } and forall(x6: List[T] -> Bool, x7: List[T]) { not x6(List.cons(s1(x6), s2(x6))) or not x6(List.nil[T]) or x6(x7) } }","not p(s2(p)) or p(List.cons(s1(p), s2(p)))","f(s0(items)) != 0 or not p(items) or sum[Real](map[T, Real](items, f)) = 0","not p(items) or sum[Real](map[T, Real](items, f)) = 0","not p(items)","not p(List.cons(s1(p), s2(p))) or not p(List.nil[T]) or p(items)","not p(List.nil[T]) or p(s2(p)) or p(items)","p(s2(p)) or p(items)","p(s2(p))","not p(List.cons(s1(p), s2(p))) or p(items)","not p(List.cons(s1(p), s2(p)))"]}
