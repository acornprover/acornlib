{"goal":"(x - y).abs <= eps","proof":["function(x0: Real, x1: Real, x2: Real) { (x0 - x1).abs < x2 = x0.is_close(x1, x2) }(x, y, eps)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Real]((x - y).abs, eps)","(x - y).abs < eps","not (x - y).abs < eps"]}
{"goal":"abs_le_abs_add_eps","proof":["function(x0: Real, x1: Real, x2: Real) { x0 + x1 - x2 = x0 - x2 + x1 }(x, y, y)","function[T0: lib(add_ordered_group).AddLeftOrderedGroup](x0: T0, x1: T0, x2: T0) { not T0.lte(x0, x1) or T0.add(x2, x0) <= T0.add(x2, x1) }[Real]((x - y).abs, eps, y.abs)","function[T0](x0: (T0, T0) -> Bool, x1: T0, x2: T0, x3: T0) { not lib(util).is_transitive[T0](x0) or not x0(x1, x2) or not x0(x2, x3) or x0(x1, x3) }[Real](Real.lte, x.abs, y.abs + (x - y).abs, y.abs + eps)","function(x0: Real, x1: Real) { x0 + x1 - x1 = x0 }(x, y)","function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[Real](y.abs, (x - y).abs)","function(x0: Real) { not x0 <= y.abs + eps or not x.abs <= x0 }(y.abs + (x - y).abs)","function(x0: Real) { x0 + (x - y).abs <= x0 + eps }(y.abs)","(x + y - y).abs <= (x - y).abs + y.abs","x.abs <= (x - y).abs + y.abs","not x.abs <= y.abs + (x - y).abs","x.abs <= y.abs + (x - y).abs"]}
{"goal":"lte_lt_trans","proof":["function[T0: lib(add_ordered_group).AddLeftOrderedGroup](x0: T0, x1: T0, x2: T0) { not T0.lt(x0, x1) or not T0.lt(x1, x2) or T0.lt(x0, x2) }[Real](a, b, c)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lte(x0, x1) or T0.lt(x0, x1) or x0 = x1 }[Real](a, b)","function(x0: Real) { not x0 < c or not a < x0 }(b)","not a < b","b = a"]}
{"goal":"mul_le_lt_of_nonneg_pos","proof":["function(x0: Real, x1: Real, x2: Real) { not x0 <= x1 or x0 * x2 <= x1 * x2 or x2.is_negative }(a, b, c)","function(x0: Real, x1: Real, x2: Real) { not x0 < x1 or not x2.is_positive or x2 * x0 < x2 * x1 }(c, d, b)","function(x0: Real) { not x0.is_positive or x0 * c < x0 * d }(b)","function(x0: Real) { a * x0 <= b * x0 or x0.is_negative }(c)","a * c <= b * c","b * c < b * d","not b * c < b * d"]}
{"goal":"diff = a1 * b1 - a1 * b2 + a1 * b2 - a2 * b2","proof":["function(x0: Real, x1: Real, x2: Real) { x0 + x1 - x2 = x0 - x2 + x1 }(a1 * b1, a1 * b2, a1 * b2)","function(x0: Real, x1: Real) { x0 + x1 - x1 = x0 }(a1 * b1, a1 * b2)","a1 * b1 + a1 * b2 - a1 * b2 - a2 * b2 != diff"]}
{"goal":"(a1 * (b1 - b2) + (a1 - a2) * b2).abs <= (a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs","proof":[]}
{"goal":"a1 * (b1 - b2) = a1 * b1 - a1 * b2","proof":["function(x0: Real, x1: Real, x2: Real) { x0 * x1 - x0 * x2 = x0 * (x1 - x2) }(a1, b1, b2)"]}
{"goal":"(a1 - a2) * b2 = a1 * b2 - a2 * b2","proof":["function(x0: Real, x1: Real, x2: Real) { x0 * x1 - x2 * x1 = (x0 - x2) * x1 }(a1, b2, a2)"]}
{"goal":"a1 * (b1 - b2) + (a1 - a2) * b2 = a1 * b1 - a1 * b2 + (a1 * b2 - a2 * b2)","proof":[]}
{"goal":"a1 * b1 - a1 * b2 + (a1 * b2 - a2 * b2) = a1 * b1 - a1 * b2 + a1 * b2 - a2 * b2","proof":["function(x0: Real, x1: Real, x2: Real) { x0 + x1 - x2 = x0 - x2 + x1 }(a1 * b2, a1 * (b1 - b2), a2 * b2)","function(x0: Real, x1: Real) { x0 + x1 = x1 + x0 }(a1 * b2 - a2 * b2, a1 * b1 - a1 * b2)","function(x0: Real, x1: Real) { x0 + x1 = x1 + x0 }(a1 * b2, a1 * b1 - a1 * b2)"]}
{"goal":"a1 * (b1 - b2) + (a1 - a2) * b2 = diff","proof":[]}
{"goal":"diff.abs <= (a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs","proof":["not (a1 * (b1 - b2) + (a1 - a2) * b2).abs <= (a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs"]}
{"goal":"(a1 * (b1 - b2)).abs = a1.abs * (b1 - b2).abs","proof":["function(x0: Real, x1: Real) { x0.abs * x1.abs = (x0 * x1).abs }(a1, b1 - b2)"]}
{"goal":"((a1 - a2) * b2).abs = (a1 - a2).abs * b2.abs","proof":["function(x0: Real, x1: Real) { x0.abs * x1.abs = (x0 * x1).abs }(a1 - a2, b2)"]}
{"goal":"(b1 - b2).abs < b_eps","proof":["function(x0: Real, x1: Real, x2: Real) { (x0 - x1).abs < x2 = x0.is_close(x1, x2) }(b1, b2, b_eps)"]}
{"goal":"a1.abs * (b1 - b2).abs < a_bound * b_eps","proof":["function(x0: Real) { not x0.abs.is_negative }(a1)","function(x0: Real) { not x0.abs.is_negative }(b1 - b2)"]}
{"goal":"(a1 - a2).abs < a_eps","proof":["function(x0: Real, x1: Real, x2: Real) { (x0 - x1).abs < x2 = x0.is_close(x1, x2) }(a1, a2, a_eps)"]}
{"goal":"(a1 - a2).abs * b2.abs < a_eps * b2.abs","proof":["function(x0: Real, x1: Real, x2: Real) { not x0 < x1 or not x2.is_positive or x0 * x2 < x1 * x2 }((a1 - a2).abs, a_eps, b2.abs)"]}
{"goal":"a_eps * b2.abs <= a_eps * b_bound","proof":["function(x0: Real, x1: Real, x2: Real) { not x0 <= x1 or x2 * x0 <= x2 * x1 or x2.is_negative }(b2.abs, b_bound, a_eps)","a_eps.is_negative","function(x0: Real) { not x0.is_negative or not x0.is_positive }(a_eps)"]}
{"goal":"(a1 - a2).abs * b2.abs < a_eps * b_bound","proof":["function(x0: Real, x1: Real, x2: Real) { not x0 < x1 or not x1 <= x2 or x0 < x2 }((a1 - a2).abs * b2.abs, lib(list.list_sum).scalar_mul(a_eps, b2.abs), a_eps * b_bound)","function[T0: lib(semiring.base).Semiring](x0: T0, x1: T0) { T0.mul(x0, x1) = lib(list.list_sum).scalar_mul[T0](x0, x1) }[Real](a_eps, b2.abs)","lib(list.list_sum).scalar_mul(a_eps, b2.abs) <= a_eps * b_bound","(a1 - a2).abs * b2.abs < lib(list.list_sum).scalar_mul(a_eps, b2.abs)","function(x0: Real) { not (a1 - a2).abs * b2.abs < x0 or not x0 <= a_eps * b_bound }(lib(list.list_sum).scalar_mul(a_eps, b2.abs))"]}
{"goal":"not b2.abs.is_negative","proof":["function(x0: Real, x1: Real) { not x0 >= x1 or not x0 < x1 }(b2.abs, Real.0)","function(x0: Real) { not x0.is_negative or x0 < Real.0 }(b2.abs)","function(x0: Real) { x0.abs >= Real.0 }(b2)","b2.abs < Real.0"]}
{"goal":"b2.abs = Real.0","proof":["function(x0: Real) { Real.0 = x0 or x0.is_negative or x0.is_positive }(b2.abs)"]}
{"goal":"(a1 - a2).abs * b2.abs = Real.0","proof":["function(x0: Real) { x0 * Real.0 = Real.0 }((a1 - a2).abs)"]}
{"goal":"Real.0 < a_eps * b_bound","proof":["function(x0: Real, x1: Real, x2: Real) { not x0 < x1 or not x2.is_positive or x2 * x0 < x2 * x1 }(Real.0, b_bound, a_eps)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Real](b_bound, Real.0)","function(x0: Real) { not x0.is_positive or x0 > Real.0 }(b_bound)","function[T0: lib(semiring.base).Semiring](x0: T0) { T0.mul(x0, T0.0) = T0.0 }[Real](a_eps)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.gt(x0, x1) or T0.lt(x1, x0) }[Real](b_bound, Real.0)","b_bound > Real.0","function(x0: Real) { not x0 * Real.0 < a_eps * b_bound }(a_eps)","Real.0 < b_bound","not Real.0 < b_bound"]}
{"goal":"(a1 - a2).abs * b2.abs < a_eps * b_bound","proof":[]}
{"goal":"(a1 * (b1 - b2)).abs < a_bound * b_eps","proof":[]}
{"goal":"((a1 - a2) * b2).abs < a_eps * b_bound","proof":[]}
{"goal":"(a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs < a_bound * b_eps + a_eps * b_bound","proof":["function(x0: Real, x1: Real, x2: Real, x3: Real) { not x0 < x1 or not x2 < x3 or x0 + x2 < x1 + x3 }((a1 * (b1 - b2)).abs, a_bound * b_eps, ((a1 - a2) * b2).abs, a_eps * b_bound)"]}
{"goal":"diff.abs < a_bound * b_eps + a_eps * b_bound","proof":["not (a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs < a_bound * b_eps + a_eps * b_bound"]}
{"goal":"(a1 * b1 - a2 * b2).abs < a_bound * b_eps + a_eps * b_bound","proof":["not diff.abs < a_bound * b_eps + a_eps * b_bound"]}
{"goal":"mul_close_from_close","proof":["function(x0: Real, x1: Real, x2: Real) { (x0 - x1).abs < x2 = x0.is_close(x1, x2) }(a1 * b1, a2 * b2, a_bound * b_eps + a_eps * b_bound)"]}
{"goal":"exists(k0: Real) { limit(a).abs < k0 }","proof":["let s0: (Real, lib(rat.rat_base).Rat) -> lib(rat.rat_base).Rat satisfy { forall(x0: lib(rat.rat_base).Rat, x1: Real) { not x0.is_positive or Real.from_rat(s0(x1, x0)) < x1 } and forall(x2: lib(rat.rat_base).Rat, x3: Real) { not x2.is_positive or x3 < Real.from_rat(s0(x3, x2) + x2) } }","function(x0: Real) { not limit(a).abs < x0 }(Real.from_rat(s0(limit(a).abs, lib(rat.rat_base).Rat.3) + lib(rat.rat_base).Rat.3))","function(x0: lib(rat.rat_base).Rat, x1: Real) { not x0.is_positive or x1 < Real.from_rat(s0(x1, x0) + x0) }(lib(rat.rat_base).Rat.3, limit(a).abs)","function(x0: lib(rat.rat_base).Rat) { not x0.is_positive }(lib(rat.rat_base).Rat.3)"]}
{"goal":"a_bound.is_positive","proof":["function(x0: Real, x1: Real, x2: Real) { not x0 < x1 or not x1 < x2 or x0 < x2 }(limit(a).abs, a_abs_bound, a_abs_bound + Real.1)","function(x0: Real, x1: Real) { not x0.abs < x1 or x0.is_close(Real.0, x1) }(limit(a), a_bound)","function(x0: Real) { x0 < x0 + Real.1 }(a_abs_bound)","function(x0: Real, x1: Real, x2: Real) { not x0.is_close(x1, x2) or x2.is_positive }(limit(a), Real.0, a_bound)","function(x0: Real, x1: Real) { not x0.is_close(x1, a_bound) }(limit(a), Real.0)","function(x0: Real) { not a_abs_bound < x0 or limit(a).abs < x0 }(a_abs_bound + Real.1)","limit(a).abs < a_abs_bound + Real.1","limit(a).abs < a_bound"]}
{"goal":"exists(k0: Real) { limit(b).abs < k0 }","proof":["let s0: (Real, lib(rat.rat_base).Rat) -> lib(rat.rat_base).Rat satisfy { forall(x0: lib(rat.rat_base).Rat, x1: Real) { not x0.is_positive or Real.from_rat(s0(x1, x0)) < x1 } and forall(x2: lib(rat.rat_base).Rat, x3: Real) { not x2.is_positive or x3 < Real.from_rat(s0(x3, x2) + x2) } }","function(x0: Real) { not limit(b).abs < x0 }(Real.from_rat(s0(limit(b).abs, lib(rat.rat_base).Rat.3) + lib(rat.rat_base).Rat.3))","function(x0: lib(rat.rat_base).Rat, x1: Real) { not x0.is_positive or x1 < Real.from_rat(s0(x1, x0) + x0) }(lib(rat.rat_base).Rat.3, limit(b).abs)","function(x0: lib(rat.rat_base).Rat) { not x0.is_positive }(lib(rat.rat_base).Rat.3)"]}
{"goal":"b_bound.is_positive","proof":["function(x0: Real, x1: Real, x2: Real) { not x0 < x1 or not x1 < x2 or x0 < x2 }(limit(b).abs, b_abs_bound, b_abs_bound + Real.1)","function(x0: Real, x1: Real) { not x0.abs < x1 or x0.is_close(Real.0, x1) }(limit(b), b_bound)","function(x0: Real) { x0 < x0 + Real.1 }(b_abs_bound)","function(x0: Real, x1: Real, x2: Real) { not x0.is_close(x1, x2) or x2.is_positive }(limit(b), Real.0, b_bound)","function(x0: Real, x1: Real) { not x0.is_close(x1, b_bound) }(limit(b), Real.0)","function(x0: Real) { not b_abs_bound < x0 or limit(b).abs < x0 }(b_abs_bound + Real.1)","limit(b).abs < b_abs_bound + Real.1","limit(b).abs < b_bound"]}
{"goal":"sum_bound.is_positive","proof":["function(x0: Real, x1: Real, x2: Real) { x0 + x1 != x2 or x2 - x1 = x0 }(a_bound, b_bound, sum_bound)","function(x0: Real, x1: Real) { not (x0 - x1).is_positive or x1 < x0 }(sum_bound, b_bound)","function(x0: Real, x1: Real) { not x0 < x1 or not x0.is_positive or x1.is_positive }(b_bound, sum_bound)","function(x0: Real) { not x0 < sum_bound or not x0.is_positive }(b_bound)","not b_bound < sum_bound","sum_bound - b_bound = a_bound","not (sum_bound - b_bound).is_positive","(sum_bound - b_bound).is_positive"]}
{"goal":"(sum_bound + sum_bound).is_positive","proof":["function(x0: Real, x1: Real, x2: Real) { not x0.is_close(x1, x2) or x1 < x0 + x2 }(sum_bound, sum_bound, sum_bound)","function(x0: Real, x1: Real) { not x0 < x1 or not x0.is_positive or x1.is_positive }(sum_bound, sum_bound + sum_bound)","function(x0: Real, x1: Real) { not x0.is_positive or x1.is_close(x1, x0) }(sum_bound, sum_bound)","function(x0: Real) { x0.is_close(x0, sum_bound) }(sum_bound)","function(x0: Real) { not x0 < sum_bound + sum_bound or not x0.is_positive }(sum_bound)","not sum_bound < sum_bound + sum_bound"]}
{"goal":"Real.1.is_positive","proof":["function(x0: lib(rat.rat_base).Rat) { not x0.is_positive or Real.from_rat(x0).is_positive }(lib(rat.rat_base).Rat.1)","not Real.from_rat(lib(rat.rat_base).Rat.1).is_positive","not lib(rat.rat_base).Rat.1.is_positive"]}
{"goal":"exists(k0: Real) { k0.is_positive and k0 + k0 < Real.1 }","proof":["let s0: Real satisfy { not Real.1.is_positive or s0.is_positive and (not Real.1.is_positive or s0 + s0 < Real.1) }","function(x0: Real) { not x0 + x0 < Real.1 or not x0.is_positive }(s0)","not s0 + s0 < Real.1"]}
{"goal":"exists(k0: Real) { k0.is_positive and k0 * (sum_bound + sum_bound) < eps }","proof":["let s0: Real satisfy { not (sum_bound + sum_bound).is_positive or not eps.is_positive or s0.is_positive and (not (sum_bound + sum_bound).is_positive or not eps.is_positive or s0 * (sum_bound + sum_bound) < eps) }","function(x0: Real) { not x0 * (sum_bound + sum_bound) < eps or not x0.is_positive }(s0)","not s0 * (sum_bound + sum_bound) < eps"]}
{"goal":"small_eps.is_positive","proof":["not eps_candidate.min(eps_half).is_positive","function(x0: Real, x1: Real) { not x0.is_positive or not x1.is_positive or x0.min(x1).is_positive }(eps_candidate, eps_half)"]}
{"goal":"small_eps + small_eps <= eps_half + eps_half","proof":["function[T0: lib(add_ordered_group).AddOrderedGroup](x0: T0, x1: T0, x2: T0, x3: T0) { not T0.lte(x0, x1) or not T0.lte(x2, x3) or T0.add(x0, x2) <= T0.add(x1, x3) }[Real](small_eps, eps_half, small_eps, eps_half)","not small_eps <= eps_half","function(x0: Real, x1: Real) { x0.min(x1) <= x1 }(eps_candidate, eps_half)"]}
{"goal":"small_eps + small_eps < Real.1","proof":["function(x0: Real, x1: Real, x2: Real) { not x0 < x1 or not x2 <= x0 or x2 < x1 }(eps_half + eps_half, Real.1, small_eps + small_eps)","function(x0: Real) { not small_eps + small_eps <= x0 or not x0 < Real.1 }(eps_half + eps_half)"]}
{"goal":"small_eps < Real.1","proof":["function[T0: lib(add_ordered_group).AddLeftOrderedGroup](x0: T0, x1: T0, x2: T0) { not T0.lt(x0, x1) or not T0.lt(x1, x2) or T0.lt(x0, x2) }[Real](small_eps, small_eps + small_eps, Real.1)","function(x0: Real, x1: Real, x2: Real) { not x0.is_close(x1, x2) or x1 < x0 + x2 }(small_eps, small_eps, small_eps)","function(x0: Real, x1: Real) { not x0.is_positive or x1.is_close(x1, x0) }(small_eps, small_eps)","function(x0: Real) { x0.is_close(x0, small_eps) }(small_eps)","function(x0: Real) { not x0 < Real.1 or not small_eps < x0 }(small_eps + small_eps)","not small_eps < small_eps + small_eps"]}
{"goal":"exists(k0: Nat) { tail_bound(a, limit(a), k0, small_eps) }","proof":["let  (s0: (Nat -> Real, Real, Real) -> Nat, s1: (Nat -> Real, Real) -> Real) satisfy { forall(x0: Nat -> Real, x1: Real, x2: Real) { not converges_to(x0, x1) or not x2.is_positive or tail_bound(x0, x1, s0(x0, x1, x2), x2) } and forall(x3: Nat -> Real, x4: Real) { s1(x3, x4).is_positive or converges_to(x3, x4) } and forall(x5: Nat -> Real, x6: Real, x7: Nat) { not tail_bound(x5, x6, x7, s1(x5, x6)) or converges_to(x5, x6) } }","function(x0: Nat) { not tail_bound(a, limit(a), x0, small_eps) }(s0(a, limit(a), small_eps))","function(x0: Nat -> Real, x1: Real, x2: Real) { not converges_to(x0, x1) or not x2.is_positive or tail_bound(x0, x1, s0(x0, x1, x2), x2) }(a, limit(a), small_eps)","not converges_to(a, limit(a))","function(x0: Nat -> Real) { not converges(x0) or converges_to(x0, limit(x0)) }(a)"]}
{"goal":"exists(k0: Nat) { tail_bound(b, limit(b), k0, small_eps) }","proof":["let  (s0: (Nat -> Real, Real, Real) -> Nat, s1: (Nat -> Real, Real) -> Real) satisfy { forall(x0: Nat -> Real, x1: Real, x2: Real) { not converges_to(x0, x1) or not x2.is_positive or tail_bound(x0, x1, s0(x0, x1, x2), x2) } and forall(x3: Nat -> Real, x4: Real) { s1(x3, x4).is_positive or converges_to(x3, x4) } and forall(x5: Nat -> Real, x6: Real, x7: Nat) { not tail_bound(x5, x6, x7, s1(x5, x6)) or converges_to(x5, x6) } }","function(x0: Nat) { not tail_bound(b, limit(b), x0, small_eps) }(s0(b, limit(b), small_eps))","function(x0: Nat -> Real, x1: Real, x2: Real) { not converges_to(x0, x1) or not x2.is_positive or tail_bound(x0, x1, s0(x0, x1, x2), x2) }(b, limit(b), small_eps)","not converges_to(b, limit(b))","function(x0: Nat -> Real) { not converges(x0) or converges_to(x0, limit(x0)) }(b)"]}
{"goal":"exists(k0: Nat) { n1 <= k0 and n2 <= k0 }","proof":["function(x0: Nat) { not n2 <= x0 or not n1 <= x0 }(n1)","function(x0: Nat) { not n2 <= x0 or not n1 <= x0 }(n2)","function[T0: lib(order).LinearOrder](x0: T0, x1: T0) { T0.lte(x0, x1) or T0.lte(x1, x0) }[Nat](n2, n1)","function(x0: Nat) { x0 <= x0 }(n1)","function(x0: Nat) { x0 <= x0 }(n2)","not n1 <= n2","not n2 <= n1","n2 <= n1"]}
{"goal":"n1 <= i","proof":["function[T0](x0: (T0, T0) -> Bool, x1: T0, x2: T0, x3: T0) { not lib(util).is_transitive[T0](x0) or not x0(x1, x2) or not x0(x2, x3) or x0(x1, x3) }[Nat](Nat.lte, n1, n, i)","function(x0: Nat) { not x0 <= i or not n1 <= x0 }(n)"]}
{"goal":"n2 <= i","proof":["function[T0](x0: (T0, T0) -> Bool, x1: T0, x2: T0, x3: T0) { not lib(util).is_transitive[T0](x0) or not x0(x1, x2) or not x0(x2, x3) or x0(x1, x3) }[Nat](Nat.lte, n2, n, i)","function(x0: Nat) { not x0 <= i or not n2 <= x0 }(n)"]}
{"goal":"a(i).is_close(limit(a), small_eps)","proof":["function(x0: Nat, x1: Nat, x2: Nat -> Real, x3: Real, x4: Real) { not x0 <= x1 or not tail_bound(x2, x3, x0, x4) or x2(x1).is_close(x3, x4) }(n1, i, a, limit(a), small_eps)","function(x0: Nat) { not tail_bound(a, limit(a), x0, small_eps) or not x0 <= i }(n1)"]}
{"goal":"b(i).is_close(limit(b), small_eps)","proof":["function(x0: Nat, x1: Nat, x2: Nat -> Real, x3: Real, x4: Real) { not x0 <= x1 or not tail_bound(x2, x3, x0, x4) or x2(x1).is_close(x3, x4) }(n2, i, b, limit(b), small_eps)","function(x0: Nat) { not tail_bound(b, limit(b), x0, small_eps) or not x0 <= i }(n2)"]}
{"goal":"a_abs_bound + small_eps < a_abs_bound + Real.1","proof":["function(x0: Real, x1: Real, x2: Real) { not x0 < x1 or x2 + x0 < x2 + x1 }(small_eps, Real.1, a_abs_bound)"]}
{"goal":"a(i).abs < a_abs_bound + small_eps","proof":["not limit(a).abs + small_eps < a_abs_bound + small_eps","function(x0: Real, x1: Real, x2: Real) { not x0 < x1 or x0 + x2 < x1 + x2 }(limit(a).abs, a_abs_bound, small_eps)"]}
{"goal":"limit(b).abs <= b_bound","proof":["function(x0: Real) { x0 < x0 + Real.1 }(b_abs_bound)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Real](limit(b).abs, b_abs_bound)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Real](limit(b).abs, b_bound)","not limit(b).abs < b_bound","limit(b).abs <= b_abs_bound","not b_abs_bound < b_bound"]}
{"goal":"(a(i) * b(i)).is_close(limit(a) * limit(b), a_bound * small_eps + small_eps * b_bound)","proof":["not a(i).abs <= a_bound","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Real](a(i).abs, a_abs_bound + small_eps)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Real](a(i).abs, a_bound)","a_abs_bound + small_eps < a_bound","not a(i).abs < a_bound","a(i).abs <= a_abs_bound + small_eps","not a(i).abs <= a_abs_bound + small_eps"]}
{"goal":"a_bound * small_eps = small_eps * a_bound","proof":["function(x0: Real, x1: Real) { x0 * x1 = x1 * x0 }(small_eps, a_bound)"]}
{"goal":"small_eps * a_bound + small_eps * b_bound = small_eps * (a_bound + b_bound)","proof":["function(x0: Real, x1: Real, x2: Real) { x0 * x1 + x0 * x2 = x0 * (x1 + x2) }(small_eps, a_bound, b_bound)"]}
{"goal":"a_bound * small_eps + small_eps * b_bound = small_eps * (a_bound + b_bound)","proof":["small_eps * a_bound + small_eps * b_bound != small_eps * (a_bound + b_bound)"]}
{"goal":"a_bound + b_bound = sum_bound","proof":[]}
{"goal":"a_bound * small_eps + small_eps * b_bound = small_eps * sum_bound","proof":["a_bound * small_eps + small_eps * b_bound != small_eps * (a_bound + b_bound)"]}
{"goal":"sum_bound < sum_bound + sum_bound","proof":["function(x0: Real, x1: Real) { not x0.is_positive or x1 < x1 + x0 }(sum_bound, sum_bound)"]}
{"goal":"small_eps * sum_bound < small_eps * (sum_bound + sum_bound)","proof":["function(x0: Real, x1: Real, x2: Real) { not x0 < x1 or not x2.is_positive or x2 * x0 < x2 * x1 }(sum_bound, sum_bound + sum_bound, small_eps)"]}
{"goal":"a_bound * small_eps + small_eps * b_bound < small_eps * (sum_bound + sum_bound)","proof":[]}
{"goal":"small_eps * (sum_bound + sum_bound) < eps","proof":["not small_eps * (sum_bound + sum_bound) <= eps_candidate * (sum_bound + sum_bound)","function(x0: Real, x1: Real, x2: Real) { not x0 <= x1 or x0 * x2 <= x1 * x2 or x2.is_negative }(small_eps, eps_candidate, sum_bound + sum_bound)","function[T0: lib(order).LinearOrder](x0: T0, x1: T0) { T0.min(x0, x1) <= x0 }[Real](eps_candidate, eps_half)","function(x0: Real) { not x0.is_negative or not x0.is_positive }(sum_bound + sum_bound)","not (sum_bound + sum_bound).is_negative","not small_eps <= eps_candidate"]}
{"goal":"a_bound * small_eps + small_eps * b_bound < eps","proof":["not a_bound * small_eps + small_eps * b_bound <= small_eps * (sum_bound + sum_bound)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Real](a_bound * small_eps + small_eps * b_bound, small_eps * (sum_bound + sum_bound))"]}
{"goal":"(a(i) * b(i) - limit(a) * limit(b)).abs < a_bound * small_eps + small_eps * b_bound","proof":["function(x0: Real, x1: Real, x2: Real) { (x0 - x1).abs < x2 = x0.is_close(x1, x2) }(a(i) * b(i), limit(a) * limit(b), a_bound * small_eps + small_eps * b_bound)"]}
{"goal":"(a(i) * b(i) - limit(a) * limit(b)).abs < eps","proof":["not (a(i) * b(i) - limit(a) * limit(b)).abs <= a_bound * small_eps + small_eps * b_bound","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Real]((a(i) * b(i) - limit(a) * limit(b)).abs, a_bound * small_eps + small_eps * b_bound)"]}
{"goal":"q(i).is_close(ql, eps)","proof":["function(x0: Nat) { prod_seq(a, b, x0) = q(x0) }(i)","function(x0: Real, x1: Real, x2: Real) { (x0 - x1).abs < x2 = x0.is_close(x1, x2) }(q(i), ql, eps)","function(x0: Nat -> Real, x1: Nat, x2: Nat -> Real) { x0(x1) * x2(x1) = prod_seq(x0, x2, x1) }(a, i, b)"]}
{"goal":"tail_bound(q, ql, n, eps)","proof":["let s0: (Nat -> Real, Real, Nat, Real) -> Nat satisfy { forall(x0: Nat, x1: Nat, x2: Nat -> Real, x3: Real, x4: Real) { not x0 <= x1 or not tail_bound(x2, x3, x0, x4) or x2(x1).is_close(x3, x4) } and forall(x5: Nat, x6: Nat -> Real, x7: Real, x8: Real) { x5 <= s0(x6, x7, x5, x8) or tail_bound(x6, x7, x5, x8) } and forall(x9: Nat -> Real, x10: Real, x11: Nat, x12: Real) { not x9(s0(x9, x10, x11, x12)).is_close(x10, x12) or tail_bound(x9, x10, x11, x12) } }","function(x0: Nat) { not n <= x0 or q(x0).is_close(ql, eps) }(s0(q, ql, n, eps))","function(x0: Nat -> Real, x1: Real, x2: Nat, x3: Real) { not x0(s0(x0, x1, x2, x3)).is_close(x1, x3) or tail_bound(x0, x1, x2, x3) }(q, ql, n, eps)","function(x0: Nat, x1: Nat -> Real, x2: Real, x3: Real) { x0 <= s0(x1, x2, x0, x3) or tail_bound(x1, x2, x0, x3) }(n, q, ql, eps)","n <= s0(q, ql, n, eps)","not q(s0(q, ql, n, eps)).is_close(ql, eps)","q(s0(q, ql, n, eps)).is_close(ql, eps)"]}
{"goal":"converges_to(q, ql)","proof":["let  (s0: (Nat -> Real, Real, Real) -> Nat, s1: (Nat -> Real, Real) -> Real) satisfy { forall(x0: Nat -> Real, x1: Real, x2: Real) { not converges_to(x0, x1) or not x2.is_positive or tail_bound(x0, x1, s0(x0, x1, x2), x2) } and forall(x3: Nat -> Real, x4: Real) { s1(x3, x4).is_positive or converges_to(x3, x4) } and forall(x5: Nat -> Real, x6: Real, x7: Nat) { not tail_bound(x5, x6, x7, s1(x5, x6)) or converges_to(x5, x6) } }","let s2: Real -> Nat satisfy { forall(x8: Real) { not x8.is_positive or tail_bound(q, ql, s2(x8), x8) } }","function(x0: Real) { not x0.is_positive or tail_bound(q, ql, s2(x0), x0) }(s1(q, ql))","function(x0: Nat -> Real, x1: Real, x2: Nat) { not tail_bound(x0, x1, x2, s1(x0, x1)) or converges_to(x0, x1) }(q, ql, s2(s1(q, ql)))","function(x0: Nat -> Real, x1: Real) { s1(x0, x1).is_positive or converges_to(x0, x1) }(q, ql)","s1(q, ql).is_positive","function(x0: Nat) { not tail_bound(q, ql, x0, s1(q, ql)) }(s2(s1(q, ql)))"]}
{"goal":"limit_prod_seq","proof":["not converges_to(prod_seq(a, b), ql)","prod_seq(a, b) = q"]}
{"goal":"prod_seq_converges","proof":["function(x0: Nat -> Real, x1: Real) { not converges_to(x0, x1) or converges(x0) }(prod_seq(a, b), limit(a) * limit(b))"]}
{"goal":"limit_of_prod","proof":["function(x0: Nat -> Real, x1: Real, x2: Real) { not converges_to(x0, x1) or not converges_to(x0, x2) or x1 = x2 }(prod_seq(a, b), limit(prod_seq(a, b)), limit(a) * limit(b))","function(x0: Nat -> Real) { not converges(x0) or converges_to(x0, limit(x0)) }(prod_seq(a, b))","function(x0: Nat -> Real, x1: Real) { not converges_to(x0, x1) or converges(x0) }(prod_seq(a, b), limit(a) * limit(b))","converges(prod_seq(a, b))","function(x0: Nat -> Real) { not converges_to(x0, limit(a) * limit(b)) or not converges_to(x0, limit(prod_seq(a, b))) }(prod_seq(a, b))","converges_to(prod_seq(a, b), limit(prod_seq(a, b)))","not converges_to(prod_seq(a, b), limit(prod_seq(a, b)))"]}
