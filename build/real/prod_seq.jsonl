{"goal":"(x - y).abs <= eps","proof":["(x - y).abs < eps = x.is_close(y, eps)","not (x - y).abs < eps or (x - y).abs <= eps","(x - y).abs < eps","not (x - y).abs < eps"]}
{"goal":"abs_le_abs_add_eps","proof":["not lib(util).is_transitive[Real](Real.lte) or not x.abs <= y.abs + (x - y).abs or not y.abs + (x - y).abs <= y.abs + eps or x.abs <= y.abs + eps","x + y - y = x - y + y","not (x - y).abs <= eps or y.abs + (x - y).abs <= y.abs + eps","x + y - y = x","(x - y).abs + y.abs = y.abs + (x - y).abs","not y.abs + (x - y).abs <= y.abs + eps or not x.abs <= y.abs + (x - y).abs","y.abs + (x - y).abs <= y.abs + eps","(x + y - y).abs <= (x - y).abs + y.abs","x.abs <= (x - y).abs + y.abs","not x.abs <= y.abs + (x - y).abs","x.abs <= y.abs + (x - y).abs"]}
{"goal":"lte_lt_trans","proof":["not a <= b or not b < c or a < c","not a <= b or not b < c"]}
{"goal":"mul_le_lt_of_nonneg_pos","proof":["not a <= b or a * c <= b * c or c.is_negative","not b.is_positive or not c < d or b * c < b * d","not a * c <= b * c or not b * c < b * d or a * c < b * d","not a * c <= b * c or not b * c < b * d","not b.is_positive or b * c < b * d","a * c <= b * c or c.is_negative","a * c <= b * c","b * c < b * d","not b * c < b * d"]}
{"goal":"diff = a1 * b1 - a1 * b2 + a1 * b2 - a2 * b2","proof":["a1 * b1 + a1 * b2 - a1 * b2 = a1 * b1 - a1 * b2 + a1 * b2","a1 * b1 + a1 * b2 - a1 * b2 = a1 * b1","a1 * b1 + a1 * b2 - a1 * b2 - a2 * b2 != diff"]}
{"goal":"(a1 - a2).abs * b2.abs < a_eps * b_bound","proof":["not b2.abs <= b_bound or not b_bound.is_positive or not a_eps.is_positive or not (a1 - a2).abs < a_eps or b2.abs * (a1 - a2).abs < b_bound * a_eps or b2.abs.is_negative or (a1 - a2).abs.is_negative","(a1 - a2).abs < a_eps = a1.is_close(a2, a_eps)","(a1 - a2).abs * b2.abs = b2.abs * (a1 - a2).abs","b_bound * a_eps = a_eps * b_bound","not (a1 - a2).abs.is_negative","not b2.abs.is_negative","not (a1 - a2).abs * b2.abs < b_bound * a_eps","(a1 - a2).abs < a_eps","not b2.abs * (a1 - a2).abs < b_bound * a_eps"]}
{"goal":"diff.abs <= (a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs","proof":["a1 * b2 - a2 * b2 = (a1 - a2) * b2","a1 * b1 - a1 * b2 = a1 * (b1 - b2)","a1 * b2 + (a1 * b1 - a1 * b2) - a2 * b2 = a1 * b2 - a2 * b2 + (a1 * b1 - a1 * b2)","(a1 * (b1 - b2) + (a1 - a2) * b2).abs <= (a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs = (a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs >= (a1 * (b1 - b2) + (a1 - a2) * b2).abs","diff.abs <= (a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs = (a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs >= diff.abs","(a1 - a2) * b2 + a1 * (b1 - b2) = a1 * (b1 - b2) + (a1 - a2) * b2","a1 * b1 - a1 * b2 + a1 * b2 = a1 * b2 + (a1 * b1 - a1 * b2)","(-(a1 * (b1 - b2) + (a1 - a2) * b2)).abs = (a1 * (b1 - b2) + (a1 - a2) * b2).abs","(-diff).abs = diff.abs"]}
{"goal":"(a1 * b1 - a2 * b2).abs < a_bound * b_eps + a_eps * b_bound","proof":["not diff.abs < a_bound * b_eps + a_eps * b_bound","not (a1 * (b1 - b2)).abs < a_bound * b_eps or not ((a1 - a2) * b2).abs < a_eps * b_bound or (a1 * (b1 - b2)).abs + ((a1 - a2) * b2).abs < a_bound * b_eps + a_eps * b_bound","(b1 - b2).abs < b_eps = b1.is_close(b2, b_eps)","(a1 - a2).abs * b2.abs = ((a1 - a2) * b2).abs","a1.abs * (b1 - b2).abs = (a1 * (b1 - b2)).abs","not (b1 - b2).abs.is_negative","not a1.abs.is_negative","((a1 - a2) * b2).abs < a_eps * b_bound","(b1 - b2).abs < b_eps","not (a1 * (b1 - b2)).abs < a_bound * b_eps","a1.abs * (b1 - b2).abs < a_bound * b_eps","not a1.abs * (b1 - b2).abs < a_bound * b_eps"]}
{"goal":"mul_close_from_close","proof":["(a1 * b1 - a2 * b2).abs < a_bound * b_eps + a_eps * b_bound = (a1 * b1).is_close(a2 * b2, a_bound * b_eps + a_eps * b_bound)"]}
{"goal":"exists(k0: Real) { limit(a).abs < k0 }","proof":["let s0: Nat satisfy { true }","let s1: (Real, lib(rat.rat_base).Rat) -> lib(rat.rat_base).Rat satisfy { forall(x0: lib(rat.rat_base).Rat, x1: Real) { not x0.is_positive or Real.from_rat(s1(x1, x0)) < x1 } and forall(x2: lib(rat.rat_base).Rat, x3: Real) { not x2.is_positive or x3 < Real.from_rat(s1(x3, x2) + x2) } }","not limit(a).abs < Real.from_rat(s1(limit(a).abs, lib(rat).iop(s0)) + lib(rat).iop(s0))","not lib(rat).iop(s0).is_positive or limit(a).abs < Real.from_rat(s1(limit(a).abs, lib(rat).iop(s0)) + lib(rat).iop(s0))","not lib(rat).iop(s0).is_positive","lib(rat).iop(s0).is_positive"]}
{"goal":"a_bound.is_positive","proof":["not limit(a).abs < a_abs_bound or not a_abs_bound < a_abs_bound + Real.1 or limit(a).abs < a_abs_bound + Real.1","not limit(a).abs < a_bound or limit(a).is_close(Real.0, a_bound)","not limit(a).is_close(Real.0, a_bound) or a_bound.is_positive","not limit(a).is_close(Real.0, a_bound)","a_abs_bound < a_abs_bound + Real.1","not a_abs_bound < a_abs_bound + Real.1 or limit(a).abs < a_abs_bound + Real.1","limit(a).abs < a_abs_bound + Real.1","limit(a).abs < a_bound"]}
{"goal":"exists(k0: Real) { limit(b).abs < k0 }","proof":["let s0: Nat satisfy { true }","let s1: (Real, lib(rat.rat_base).Rat) -> lib(rat.rat_base).Rat satisfy { forall(x0: lib(rat.rat_base).Rat, x1: Real) { not x0.is_positive or Real.from_rat(s1(x1, x0)) < x1 } and forall(x2: lib(rat.rat_base).Rat, x3: Real) { not x2.is_positive or x3 < Real.from_rat(s1(x3, x2) + x2) } }","not limit(b).abs < Real.from_rat(s1(limit(b).abs, lib(rat).iop(s0)) + lib(rat).iop(s0))","not lib(rat).iop(s0).is_positive or limit(b).abs < Real.from_rat(s1(limit(b).abs, lib(rat).iop(s0)) + lib(rat).iop(s0))","not lib(rat).iop(s0).is_positive","lib(rat).iop(s0).is_positive"]}
{"goal":"b_bound.is_positive","proof":["not limit(b).abs < b_abs_bound or not b_abs_bound < b_abs_bound + Real.1 or limit(b).abs < b_abs_bound + Real.1","not limit(b).abs < b_bound or limit(b).is_close(Real.0, b_bound)","not limit(b).is_close(Real.0, b_bound) or b_bound.is_positive","not limit(b).is_close(Real.0, b_bound)","b_abs_bound < b_abs_bound + Real.1","not b_abs_bound < b_abs_bound + Real.1 or limit(b).abs < b_abs_bound + Real.1","limit(b).abs < b_abs_bound + Real.1","limit(b).abs < b_bound"]}
{"goal":"sum_bound.is_positive","proof":["a_bound + b_bound != sum_bound or sum_bound - b_bound = a_bound","not b_bound.is_positive or not b_bound < sum_bound or sum_bound.is_positive","not b_bound < sum_bound or not b_bound.is_positive","not b_bound < sum_bound","not (sum_bound - b_bound).is_positive or b_bound < sum_bound","sum_bound - b_bound = a_bound","not (sum_bound - b_bound).is_positive","(sum_bound - b_bound).is_positive"]}
{"goal":"(sum_bound + sum_bound).is_positive","proof":["not sum_bound.is_positive or not sum_bound < sum_bound + sum_bound or (sum_bound + sum_bound).is_positive","not sum_bound.is_positive or sum_bound < sum_bound + sum_bound","not sum_bound < sum_bound + sum_bound or not sum_bound.is_positive","not sum_bound < sum_bound + sum_bound"]}
{"goal":"Real.1.is_positive","proof":["not (eps * Real.1).is_positive or not eps.is_positive or Real.1.is_positive","not (eps * Real.1).is_positive or not eps.is_positive","not (eps * Real.1).is_positive","eps * Real.1 = eps"]}
{"goal":"exists(k0: Real) { k0.is_positive and k0 + k0 < Real.1 }","proof":["let s0: Real satisfy { not Real.1.is_positive or s0.is_positive and (not Real.1.is_positive or s0 + s0 < Real.1) }","not s0 + s0 < Real.1 or not s0.is_positive","not s0 + s0 < Real.1"]}
{"goal":"exists(k0: Real) { k0.is_positive and k0 * (sum_bound + sum_bound) < eps }","proof":["let s0: (Real, Real) -> Real satisfy { forall(x0: Real, x1: Real) { not x0.is_positive or not x1.is_positive or s0(x0, x1).is_positive } and forall(x2: Real, x3: Real) { not x2.is_positive or not x3.is_positive or s0(x2, x3) * x2 < x3 } }","not s0(sum_bound + sum_bound, eps) * (sum_bound + sum_bound) < eps or not s0(sum_bound + sum_bound, eps).is_positive","not (sum_bound + sum_bound).is_positive or not eps.is_positive or s0(sum_bound + sum_bound, eps) * (sum_bound + sum_bound) < eps","not (sum_bound + sum_bound).is_positive or not eps.is_positive or s0(sum_bound + sum_bound, eps).is_positive","not (sum_bound + sum_bound).is_positive or s0(sum_bound + sum_bound, eps).is_positive","s0(sum_bound + sum_bound, eps).is_positive","not (sum_bound + sum_bound).is_positive or s0(sum_bound + sum_bound, eps) * (sum_bound + sum_bound) < eps","not s0(sum_bound + sum_bound, eps) * (sum_bound + sum_bound) < eps","s0(sum_bound + sum_bound, eps) * (sum_bound + sum_bound) < eps"]}
{"goal":"small_eps.is_positive","proof":["not eps_candidate.min(eps_half).is_positive","not eps_candidate.is_positive or not eps_half.is_positive or eps_candidate.min(eps_half).is_positive"]}
{"goal":"small_eps + small_eps <= eps_half + eps_half","proof":["not small_eps <= eps_half or not small_eps <= eps_half or small_eps + small_eps <= eps_half + eps_half","not small_eps <= eps_half","eps_candidate.min(eps_half) <= eps_half"]}
{"goal":"small_eps + small_eps < Real.1","proof":["not small_eps + small_eps <= eps_half + eps_half or not eps_half + eps_half < Real.1 or small_eps + small_eps < Real.1","not small_eps + small_eps <= eps_half + eps_half or not eps_half + eps_half < Real.1"]}
{"goal":"small_eps < Real.1","proof":["not small_eps < small_eps + small_eps or not small_eps + small_eps < Real.1 or small_eps < Real.1","not Real.1 <= small_eps or not Real.1.is_positive or small_eps.is_positive","not small_eps.is_positive or small_eps < small_eps + small_eps","small_eps < Real.1 = Real.1 > small_eps","not Real.1 > small_eps","Real.1 <= small_eps or Real.1 > small_eps","Real.1 <= small_eps","not small_eps + small_eps < Real.1 or not small_eps < small_eps + small_eps","not small_eps < small_eps + small_eps","small_eps.is_positive","not small_eps.is_positive"]}
{"goal":"exists(k0: Nat) { tail_bound(a, limit(a), k0, small_eps) }","proof":["let (s0: (Nat -> Real, Real, Real) -> Nat, s1: (Nat -> Real, Real) -> Real) satisfy { forall(x0: Nat -> Real, x1: Real, x2: Real) { not converges_to(x0, x1) or not x2.is_positive or tail_bound(x0, x1, s0(x0, x1, x2), x2) } and forall(x3: Nat -> Real, x4: Real) { s1(x3, x4).is_positive or converges_to(x3, x4) } and forall(x5: Nat -> Real, x6: Real, x7: Nat) { not tail_bound(x5, x6, x7, s1(x5, x6)) or converges_to(x5, x6) } }","not tail_bound(a, limit(a), s0(a, limit(a), small_eps), small_eps)","not converges_to(a, limit(a)) or not small_eps.is_positive or tail_bound(a, limit(a), s0(a, limit(a), small_eps), small_eps)","not eps_half.is_positive or not eps_candidate.is_positive or eps_half.min(eps_candidate).is_positive","eps_candidate.min(eps_half) = eps_half.min(eps_candidate)","not converges(a) or converges_to(a, limit(a))","not converges_to(a, limit(a)) or not small_eps.is_positive","converges_to(a, limit(a))","not small_eps.is_positive","not eps_half.is_positive or eps_half.min(eps_candidate).is_positive","eps_half.min(eps_candidate).is_positive"]}
{"goal":"exists(k0: Nat) { tail_bound(b, limit(b), k0, small_eps) }","proof":["let (s0: (Nat -> Real, Real, Real) -> Nat, s1: (Nat -> Real, Real) -> Real) satisfy { forall(x0: Nat -> Real, x1: Real, x2: Real) { not converges_to(x0, x1) or not x2.is_positive or tail_bound(x0, x1, s0(x0, x1, x2), x2) } and forall(x3: Nat -> Real, x4: Real) { s1(x3, x4).is_positive or converges_to(x3, x4) } and forall(x5: Nat -> Real, x6: Real, x7: Nat) { not tail_bound(x5, x6, x7, s1(x5, x6)) or converges_to(x5, x6) } }","not tail_bound(b, limit(b), s0(b, limit(b), small_eps), small_eps)","not converges_to(b, limit(b)) or not small_eps.is_positive or tail_bound(b, limit(b), s0(b, limit(b), small_eps), small_eps)","not eps_half.is_positive or not eps_candidate.is_positive or eps_half.min(eps_candidate).is_positive","eps_candidate.min(eps_half) = eps_half.min(eps_candidate)","not converges(b) or converges_to(b, limit(b))","not converges_to(b, limit(b)) or not small_eps.is_positive","converges_to(b, limit(b))","not small_eps.is_positive","not eps_half.is_positive or eps_half.min(eps_candidate).is_positive","eps_half.min(eps_candidate).is_positive"]}
{"goal":"exists(k0: Nat) { n1 <= k0 and n2 <= k0 }","proof":["let s0: Nat satisfy { true }","let s1: (Nat, Nat, Nat) -> Nat satisfy { forall(x0: Nat, x1: Nat, x2: Nat) { x0 <= s1(x0, x1, x2) } and forall(x3: Nat, x4: Nat, x5: Nat) { x3 <= s1(x4, x3, x5) } and forall(x6: Nat, x7: Nat, x8: Nat) { x6 <= s1(x7, x8, x6) } }","not n2 <= s1(n2, s0, n1) or not n1 <= s1(n2, s0, n1)","n1 <= s1(n2, s0, n1)","n2 <= s1(n2, s0, n1)","not n1 <= s1(n2, s0, n1)"]}
{"goal":"a(i).is_close(limit(a), small_eps)","proof":["not tail_bound(a, limit(a), n1, small_eps) or not n1 <= i or a(i).is_close(limit(a), small_eps)","not n1 <= n or not n <= i or n1 <= i","not tail_bound(a, limit(a), n1, small_eps) or not n1 <= i","not n1 <= i","not n1 <= n or n1 <= i"]}
{"goal":"b(i).is_close(limit(b), small_eps)","proof":["not tail_bound(b, limit(b), n2, small_eps) or not n2 <= i or b(i).is_close(limit(b), small_eps)","not n2 <= n or not n <= i or n2 <= i","not tail_bound(b, limit(b), n2, small_eps) or not n2 <= i","not n2 <= i","not n2 <= n or n2 <= i"]}
{"goal":"a_abs_bound + small_eps < a_abs_bound + Real.1","proof":["not small_eps < Real.1 or a_abs_bound + small_eps < a_abs_bound + Real.1"]}
{"goal":"a(i).abs < a_abs_bound + small_eps","proof":["not limit(a).abs + small_eps < a_abs_bound + small_eps","not limit(a).abs < a_abs_bound or limit(a).abs + small_eps < a_abs_bound + small_eps"]}
{"goal":"limit(b).abs <= b_bound","proof":["not limit(b).abs < b_abs_bound or limit(b).abs <= b_abs_bound","not limit(b).abs < b_bound or limit(b).abs <= b_bound","not limit(b).abs < b_bound","b_abs_bound < b_abs_bound + Real.1","limit(b).abs <= b_abs_bound","not b_abs_bound < b_bound"]}
{"goal":"(a(i) * b(i)).is_close(limit(a) * limit(b), a_bound * small_eps + small_eps * b_bound)","proof":["not a(i).abs <= a_bound","a_abs_bound + small_eps < a_bound","not a(i).abs < a_abs_bound + small_eps or a(i).abs <= a_abs_bound + small_eps","not a(i).abs < a_bound or a(i).abs <= a_bound","not a(i).abs < a_bound","a(i).abs <= a_abs_bound + small_eps","not a(i).abs <= a_abs_bound + small_eps"]}
{"goal":"a_bound * small_eps + small_eps * b_bound < small_eps * (sum_bound + sum_bound)","proof":["not small_eps.is_positive or not sum_bound < sum_bound + sum_bound or sum_bound * small_eps < (sum_bound + sum_bound) * small_eps","a_bound * small_eps + b_bound * small_eps = (a_bound + b_bound) * small_eps","not sum_bound.is_positive or sum_bound < sum_bound + sum_bound","small_eps * b_bound = b_bound * small_eps","not a_bound * small_eps + b_bound * small_eps < small_eps * (sum_bound + sum_bound)","small_eps * (sum_bound + sum_bound) = (sum_bound + sum_bound) * small_eps","not (a_bound + b_bound) * small_eps < small_eps * (sum_bound + sum_bound)","not sum_bound * small_eps < small_eps * (sum_bound + sum_bound)","not sum_bound * small_eps < (sum_bound + sum_bound) * small_eps","sum_bound < sum_bound + sum_bound"]}
{"goal":"small_eps * (sum_bound + sum_bound) < eps","proof":["not small_eps * (sum_bound + sum_bound) <= eps_candidate * (sum_bound + sum_bound)","not small_eps <= eps_candidate or small_eps * (sum_bound + sum_bound) <= eps_candidate * (sum_bound + sum_bound) or (sum_bound + sum_bound).is_negative","eps_candidate.min(eps_half) <= eps_candidate","not (sum_bound + sum_bound).is_negative or not (sum_bound + sum_bound).is_positive","not (sum_bound + sum_bound).is_negative","not small_eps <= eps_candidate"]}
{"goal":"a_bound * small_eps + small_eps * b_bound < eps","proof":["small_eps * sum_bound + small_eps * sum_bound = small_eps * (sum_bound + sum_bound)","not small_eps * (sum_bound + sum_bound) <= eps or not a_bound * small_eps + small_eps * b_bound < small_eps * (sum_bound + sum_bound) or a_bound * small_eps + small_eps * b_bound < eps","not small_eps * (sum_bound + sum_bound) < eps or small_eps * (sum_bound + sum_bound) <= eps","small_eps * (sum_bound + sum_bound) < eps","a_bound * small_eps + small_eps * b_bound < small_eps * (sum_bound + sum_bound)","not a_bound * small_eps + small_eps * b_bound < small_eps * (sum_bound + sum_bound) or not small_eps * (sum_bound + sum_bound) <= eps","small_eps * (sum_bound + sum_bound) <= eps","not small_eps * (sum_bound + sum_bound) <= eps"]}
{"goal":"(a(i) * b(i) - limit(a) * limit(b)).abs < eps","proof":["(a(i) * b(i) - limit(a) * limit(b)).abs < lib(list.list_sum).scalar_mul(a_bound, small_eps) + small_eps * b_bound = (a(i) * b(i)).is_close(limit(a) * limit(b), lib(list.list_sum).scalar_mul(a_bound, small_eps) + small_eps * b_bound)","not (a(i) * b(i) - limit(a) * limit(b)).abs < lib(list.list_sum).scalar_mul(a_bound, small_eps) + small_eps * b_bound or not lib(list.list_sum).scalar_mul(a_bound, small_eps) + small_eps * b_bound < eps or (a(i) * b(i) - limit(a) * limit(b)).abs < eps","a_bound * small_eps = lib(list.list_sum).scalar_mul(a_bound, small_eps)","lib(list.list_sum).scalar_mul(a_bound, small_eps) + small_eps * b_bound < eps","(a(i) * b(i)).is_close(limit(a) * limit(b), lib(list.list_sum).scalar_mul(a_bound, small_eps) + small_eps * b_bound)","not (a(i) * b(i) - limit(a) * limit(b)).abs < lib(list.list_sum).scalar_mul(a_bound, small_eps) + small_eps * b_bound or not lib(list.list_sum).scalar_mul(a_bound, small_eps) + small_eps * b_bound < eps","(a(i) * b(i) - limit(a) * limit(b)).abs < lib(list.list_sum).scalar_mul(a_bound, small_eps) + small_eps * b_bound","not (a(i) * b(i) - limit(a) * limit(b)).abs < lib(list.list_sum).scalar_mul(a_bound, small_eps) + small_eps * b_bound"]}
{"goal":"q(i).is_close(ql, eps)","proof":["prod_seq(a, b, i) = q(i)","(a(i) * b(i) - limit(a) * limit(b)).abs < eps = (a(i) * b(i)).is_close(limit(a) * limit(b), eps)","a(i) * b(i) = prod_seq(a, b, i)"]}
{"goal":"converges_to(q, ql)","proof":["let s0: Real -> Nat satisfy { forall(x0: Real, x1: Nat) { not s0(x0) <= x1 or not x0.is_positive or q(x1).is_close(ql, x0) } }","let (s1: (Nat -> Real, Real, Real) -> Nat, s2: (Nat -> Real, Real) -> Real) satisfy { forall(x2: Nat -> Real, x3: Real, x4: Real) { not converges_to(x2, x3) or not x4.is_positive or tail_bound(x2, x3, s1(x2, x3, x4), x4) } and forall(x5: Nat -> Real, x6: Real) { s2(x5, x6).is_positive or converges_to(x5, x6) } and forall(x7: Nat -> Real, x8: Real, x9: Nat) { not tail_bound(x7, x8, x9, s2(x7, x8)) or converges_to(x7, x8) } }","let s3: (Nat -> Real, Real, Nat, Real) -> Nat satisfy { forall(x10: Nat -> Real, x11: Real, x12: Nat, x13: Real, x14: Nat) { not tail_bound(x10, x11, x12, x13) or not x12 <= x14 or x10(x14).is_close(x11, x13) } and forall(x15: Nat, x16: Nat -> Real, x17: Real, x18: Real) { x15 <= s3(x16, x17, x15, x18) or tail_bound(x16, x17, x15, x18) } and forall(x19: Nat -> Real, x20: Real, x21: Nat, x22: Real) { not x19(s3(x19, x20, x21, x22)).is_close(x20, x22) or tail_bound(x19, x20, x21, x22) } }","not s0(s2(q, ql)) <= s3(q, ql, s0(s2(q, ql)), s2(q, ql)) or not s2(q, ql).is_positive or q(s3(q, ql, s0(s2(q, ql)), s2(q, ql))).is_close(ql, s2(q, ql))","not q(s3(q, ql, s0(s2(q, ql)), s2(q, ql))).is_close(ql, s2(q, ql)) or tail_bound(q, ql, s0(s2(q, ql)), s2(q, ql))","s0(s2(q, ql)) <= s3(q, ql, s0(s2(q, ql)), s2(q, ql)) or tail_bound(q, ql, s0(s2(q, ql)), s2(q, ql))","not tail_bound(q, ql, s0(s2(q, ql)), s2(q, ql)) or converges_to(q, ql)","s2(q, ql).is_positive or converges_to(q, ql)","s2(q, ql).is_positive","not tail_bound(q, ql, s0(s2(q, ql)), s2(q, ql))","s0(s2(q, ql)) <= s3(q, ql, s0(s2(q, ql)), s2(q, ql))","not q(s3(q, ql, s0(s2(q, ql)), s2(q, ql))).is_close(ql, s2(q, ql))","not s0(s2(q, ql)) <= s3(q, ql, s0(s2(q, ql)), s2(q, ql)) or q(s3(q, ql, s0(s2(q, ql)), s2(q, ql))).is_close(ql, s2(q, ql))"]}
{"goal":"limit_prod_seq","proof":[]}
{"goal":"prod_seq_converges","proof":["not converges_to(prod_seq(a, b), limit(a) * limit(b)) or converges(prod_seq(a, b))"]}
{"goal":"limit_of_prod","proof":["not converges_to(prod_seq(a, b), limit(a) * limit(b)) or not converges_to(prod_seq(a, b), limit(prod_seq(a, b))) or limit(a) * limit(b) = limit(prod_seq(a, b))","not converges(prod_seq(a, b)) or converges_to(prod_seq(a, b), limit(prod_seq(a, b)))","not converges_to(prod_seq(a, b), limit(a) * limit(b)) or converges(prod_seq(a, b))","converges(prod_seq(a, b))","not converges_to(prod_seq(a, b), limit(a) * limit(b)) or not converges_to(prod_seq(a, b), limit(prod_seq(a, b)))","converges_to(prod_seq(a, b), limit(prod_seq(a, b)))","not converges_to(prod_seq(a, b), limit(prod_seq(a, b)))"]}
