{"goal":"sum[A](map[Nat, A](1.range, f)) = partial[A](f, 1)","proof":["sum[A](map[Nat, A](1.range, f)) = partial[A](f, 1)"]}
{"goal":"List.nil[Nat] + List.singleton(0) = List.nil[Nat].append(0)","proof":["List.nil[Nat] + List.singleton(0) = List.nil[Nat].append(0)"]}
{"goal":"List.cons(f(0), List.nil[A]) = List.singleton(f(0))","proof":["List.cons(f(0), List.nil[A]) = List.singleton(f(0))"]}
{"goal":"f(0) + A.0 = f(0)","proof":["f(0) + A.0 = A.0 + f(0)","A.0 + f(0) != f(0)","A.0 + f(0) = f(0)"]}
{"goal":"List.nil[Nat] + List.singleton(0) = List.singleton(0)","proof":["List.nil[Nat] != List.nil[Nat] or List.nil[Nat] + List.singleton(0) = List.singleton(0)"]}
{"goal":"0.range.append(0) = 0.suc.range","proof":["0.suc != 0.suc or 0.range.append(0) = 0.suc.range"]}
{"goal":"f(0) + sum[A](List.nil[A]) = sum[A](List.cons(f(0), List.nil[A]))","proof":["f(0) + sum[A](List.nil[A]) != sum[A](List.singleton(f(0)))","List.cons(f(0), List.nil[A]) != List.singleton(f(0)) or f(0) + sum[A](List.nil[A]) = sum[A](List.singleton(f(0)))"]}
{"goal":"List.cons(0, List.nil[Nat]) = List.singleton(0)","proof":["List.cons(0, List.nil[Nat]) = List.singleton(0)"]}
{"goal":"map[Nat, A](List.nil[Nat], f) = List.nil[A]","proof":["List.nil[Nat] != List.nil[Nat] or map[Nat, A](List.nil[Nat], f) = List.nil[A]"]}
{"goal":"List.cons(f(0), map[Nat, A](List.nil[Nat], f)) = map[Nat, A](List.cons(0, List.nil[Nat]), f)","proof":["List.cons(0, List.nil[Nat]) != List.cons(0, List.nil[Nat]) or List.cons(f(0), map[Nat, A](List.nil[Nat], f)) = map[Nat, A](List.cons(0, List.nil[Nat]), f)"]}
{"goal":"map[Nat, A](List.singleton(0), f) = List.singleton(f(0))","proof":[]}
{"goal":"partial_one","proof":["lib(util).flip(A.add, f(0), A.0) = A.0 + f(0)","lib(util).flip(A.add, f(0), sum[A](List.nil[A])) = sum[A](List.nil[A]) + f(0)","lib(util).flip(List.append[Nat], 0, 0.range) = 0.range.append(0)","lib(util).flip(List.append[Nat], 0, List.nil[Nat]) = List.nil[Nat].append(0)","lib(util).flip[List[Nat], Nat -> A, List[A]](map[Nat, A], f, 1.range) = map[Nat, A](1.range, f)","lib(util).flip[List[Nat], Nat -> A, List[A]](map[Nat, A], f, List.cons(0, List.nil[Nat])) = map[Nat, A](List.cons(0, List.nil[Nat]), f)","List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0","f(0) + A.0 = A.0 + f(0)","f(0) + sum[A](List.nil[A]) = sum[A](List.nil[A]) + f(0)","0 + 1 = 0.suc","Nat.zero != Nat.zero or Nat.zero.range = List.nil[Nat]","0 + 1 = 1","Nat.zero.range = List.nil[Nat]","sum[A](List.nil[A]) = A.0"]}
{"goal":"p(List.nil[T])","proof":["sum[A](map[T, A](List.nil[T], f)) + sum[A](map[T, A](List.nil[T], g)) != sum[A](map[T, A](List.nil[T], add_fn[T, A](f, g))) or p(List.nil[T])","List.nil[T] != List.nil[T] or map[T, A](List.nil[T], add_fn[T, A](f, g)) = List.nil[A]","List.nil[T] != List.nil[T] or map[T, A](List.nil[T], f) = List.nil[A]","List.nil[T] != List.nil[T] or map[T, A](List.nil[T], g) = List.nil[A]","List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0","A.0 + sum[A](List.nil[A]) = sum[A](List.nil[A])","sum[A](List.nil[A]) = A.0","map[T, A](List.nil[T], add_fn[T, A](f, g)) = List.nil[A]","map[T, A](List.nil[T], f) = List.nil[A]","map[T, A](List.nil[T], g) = List.nil[A]","sum[A](map[T, A](List.nil[T], f)) + sum[A](map[T, A](List.nil[T], g)) != sum[A](map[T, A](List.nil[T], add_fn[T, A](f, g)))","sum[A](List.nil[A]) + sum[A](map[T, A](List.nil[T], g)) != sum[A](map[T, A](List.nil[T], add_fn[T, A](f, g)))","sum[A](List.nil[A]) + sum[A](map[T, A](List.nil[T], g)) != sum[A](List.nil[A])","sum[A](List.nil[A]) + sum[A](List.nil[A]) != sum[A](List.nil[A])"]}
{"goal":"f(head) + (g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))) = f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","proof":["f(head) + (g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))) = f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))"]}
{"goal":"f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))) = f(head) + g(head) + sum[A](map[T, A](tail, add_fn[T, A](f, g)))","proof":["not p(tail) or sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) = sum[A](map[T, A](tail, add_fn[T, A](f, g)))","sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) != sum[A](map[T, A](tail, add_fn[T, A](f, g)))","sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) = sum[A](map[T, A](tail, add_fn[T, A](f, g)))"]}
{"goal":"map[T, A](List.cons(head, tail), f) = List.cons(f(head), map[T, A](tail, f))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, A](tail, f)) = map[T, A](List.cons(head, tail), f)"]}
{"goal":"map[T, A](List.cons(head, tail), g) = List.cons(g(head), map[T, A](tail, g))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(g(head), map[T, A](tail, g)) = map[T, A](List.cons(head, tail), g)"]}
{"goal":"map[T, A](List.cons(head, tail), add_fn[T, A](f, g)) = List.cons(add_fn[T, A](f, g, head), map[T, A](tail, add_fn[T, A](f, g)))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(add_fn[T, A](f, g, head), map[T, A](tail, add_fn[T, A](f, g))) = map[T, A](List.cons(head, tail), add_fn[T, A](f, g))"]}
{"goal":"f(head) + g(head) = add_fn[T, A](f, g, head)","proof":["f(head) + g(head) = add_fn[T, A](f, g, head)"]}
{"goal":"sum[A](List.cons(f(head), map[T, A](tail, f))) = f(head) + sum[A](map[T, A](tail, f))","proof":["f(head) + sum[A](map[T, A](tail, f)) != sum[A](map[T, A](List.cons(head, tail), f))","List.cons(f(head), map[T, A](tail, f)) != map[T, A](List.cons(head, tail), f) or f(head) + sum[A](map[T, A](tail, f)) = sum[A](map[T, A](List.cons(head, tail), f))"]}
{"goal":"sum[A](List.cons(g(head), map[T, A](tail, g))) = g(head) + sum[A](map[T, A](tail, g))","proof":["g(head) + sum[A](map[T, A](tail, g)) != sum[A](map[T, A](List.cons(head, tail), g))","List.cons(g(head), map[T, A](tail, g)) != map[T, A](List.cons(head, tail), g) or g(head) + sum[A](map[T, A](tail, g)) = sum[A](map[T, A](List.cons(head, tail), g))"]}
{"goal":"sum[A](List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g)))) = f(head) + g(head) + sum[A](map[T, A](tail, add_fn[T, A](f, g)))","proof":["List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g))) != List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g))) or sum[A](List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g)))) = f(head) + g(head) + sum[A](map[T, A](tail, add_fn[T, A](f, g)))"]}
{"goal":"sum[A](map[T, A](tail, f)) + g(head) = g(head) + sum[A](map[T, A](tail, f))","proof":["g(head) + sum[A](map[T, A](tail, f)) = sum[A](map[T, A](tail, f)) + g(head)"]}
{"goal":"f(head) + sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) = f(head) + (sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))))","proof":["f(head) + (sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g)))) = f(head) + sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g)))"]}
{"goal":"g(head) + sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) = g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","proof":["g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))) = g(head) + sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))"]}
{"goal":"sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) = sum[A](map[T, A](tail, f)) + g(head) + sum[A](map[T, A](tail, g))","proof":["sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) = sum[A](map[T, A](tail, f)) + g(head) + sum[A](map[T, A](tail, g))"]}
{"goal":"p(List.cons(head, tail))","proof":["sum[A](map[T, A](List.cons(head, tail), f)) + sum[A](map[T, A](List.cons(head, tail), g)) != sum[A](map[T, A](List.cons(head, tail), add_fn[T, A](f, g))) or p(List.cons(head, tail))","f(head) + (g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))) = f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","sum[A](map[T, A](List.cons(head, tail), f)) + sum[A](map[T, A](List.cons(head, tail), g)) != sum[A](map[T, A](List.cons(head, tail), add_fn[T, A](f, g)))"]}
{"goal":"map_sum_add","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","not p(list) or sum[A](map[T, A](list, f)) + sum[A](map[T, A](list, g)) = sum[A](map[T, A](list, add_fn[T, A](f, g)))","not p(list)","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p)) or p(list)","p(s1(p))","not p(List.cons[T](s0(p), s1(p))) or p(list)","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"partial_add","proof":["sum[A](map[Nat, A](n.range, add_fn[Nat, A](f, g))) = partial[A](add_fn[Nat, A](f, g), n)","sum[A](map[Nat, A](n.range, f)) = partial[A](f, n)","sum[A](map[Nat, A](n.range, g)) = partial[A](g, n)","sum[A](map[Nat, A](n.range, f)) + sum[A](map[Nat, A](n.range, g)) = sum[A](map[Nat, A](n.range, add_fn[Nat, A](f, g)))"]}
{"goal":"p(List.nil[S])","proof":["sum[S](map[S, S](List.nil[S], scalar_mul(c))) != c * sum[S](List.nil[S]) or p(List.nil[S])","List.nil[S] != List.nil[S] or map[S, S](List.nil[S], scalar_mul(c)) = List.nil[S]","List.nil[S] != List.nil[S] or sum[S](List.nil[S]) = S.0","c * S.0 = S.0","sum[S](List.nil[S]) = S.0","map[S, S](List.nil[S], scalar_mul(c)) = List.nil[S]","sum[S](map[S, S](List.nil[S], scalar_mul(c))) != c * sum[S](List.nil[S])","c * sum[S](List.nil[S]) != sum[S](List.nil[S])","c * sum[S](List.nil[S]) != S.0"]}
{"goal":"c * sum[S](List.cons(head, tail)) = sum[S](map[S, S](List.cons(head, tail), scalar_mul(c)))","proof":["not p(tail) or sum[S](map[S, S](tail, scalar_mul(c))) = c * sum[S](tail)","c * head + c * sum[S](tail) = c * (head + sum[S](tail))","List.cons(head, tail) != List.cons(head, tail) or List.cons(scalar_mul(c, head), tail.map(scalar_mul(c))) = List.cons(head, tail).map(scalar_mul(c))","List.cons(head, tail) != List.cons(head, tail) or sum[S](List.cons(head, tail)) = head + sum[S](tail)","List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c))) != List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c))) or sum[S](List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c)))) = scalar_mul(c, head) + sum[S](map[S, S](tail, scalar_mul(c)))","map[S, S](List.cons(head, tail), scalar_mul(c)) = List.cons(head, tail).map(scalar_mul(c))","scalar_mul(c, head) = c * head","map[S, S] = List.map[S, S]","sum[S](List.cons(head, tail)) = head + sum[S](tail)","sum[S](List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c)))) = scalar_mul(c, head) + sum[S](map[S, S](tail, scalar_mul(c)))","List.cons(scalar_mul(c, head), tail.map(scalar_mul(c))) = List.cons(head, tail).map(scalar_mul(c))","sum[S](map[S, S](tail, scalar_mul(c))) = c * sum[S](tail)"]}
{"goal":"sum_scalar_mul","proof":["let  (s0: S, s1: List[S]) satisfy { forall(x0: List[S]) { not p(List.nil[S]) or p(s1) or p(x0) } and forall(x1: List[S]) { not p(List.cons[S](s0, s1)) or not p(List.nil[S]) or p(x1) } }","not p(List.nil[S]) or p(s1) or p(s1)","p(s1) or p(s1)","not p(List.cons(s0, s1)) or not p(List.nil[S]) or p(list)","not p(List.cons(s0, s1)) or p(list)","sum[S](map[S, S](List.cons(s0, s1), scalar_mul(c))) != c * sum[S](List.cons(s0, s1)) or p(List.cons(s0, s1))","not p(list) or sum[S](map[S, S](list, scalar_mul(c))) = c * sum[S](list)","not p(s1) or sum[S](map[S, S](List.cons(s0, s1), scalar_mul(c))) = c * sum[S](List.cons(s0, s1))","p(s1)","not p(list)","not p(List.cons(s0, s1))","sum[S](map[S, S](List.cons(s0, s1), scalar_mul(c))) = c * sum[S](List.cons(s0, s1))"]}
{"goal":"p(List.nil[A])","proof":["sum[A](List.nil[A]) + sum[A](right) != sum[A](List.nil[A] + right) or p(List.nil[A])","List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0","List.nil[A] + right = right","A.0 + sum[A](right) = sum[A](right)","sum[A](List.nil[A]) = A.0","sum[A](List.nil[A]) + sum[A](right) != sum[A](List.nil[A] + right)","sum[A](List.nil[A]) + sum[A](right) != sum[A](right)"]}
{"goal":"p(List.cons(head, tail))","proof":["sum[A](List.cons(head, tail)) + sum[A](right) != sum[A](List.cons(head, tail) + right) or p(List.cons(head, tail))","not p(tail) or sum[A](tail) + sum[A](right) = sum[A](tail + right)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + right = List.cons(head, tail + right)","List.cons(head, tail + right) != List.cons(head, tail + right) or sum[A](List.cons(head, tail + right)) = head + sum[A](tail + right)","List.cons(head, tail) != List.cons(head, tail) or sum[A](List.cons(head, tail)) = head + sum[A](tail)","head + (sum[A](tail) + sum[A](right)) = head + sum[A](tail) + sum[A](right)","sum[A](List.cons(head, tail + right)) = head + sum[A](tail + right)","sum[A](List.cons(head, tail)) = head + sum[A](tail)","List.cons(head, tail) + right = List.cons(head, tail + right)","sum[A](List.cons(head, tail)) + sum[A](right) != sum[A](List.cons(head, tail) + right)","sum[A](tail) + sum[A](right) = sum[A](tail + right)"]}
{"goal":"sum_add","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not p(s1(p)) or p(List.cons[A](s0(p), s1(p)))","not p(left) or sum[A](left) + sum[A](right) = sum[A](left + right)","not p(left)","not p(List.cons[A](s0(p), s1(p))) or not p(List.nil[A]) or p(left)","not p(List.nil[A]) or p(s1(p)) or p(left)","p(s1(p)) or p(left)","p(s1(p))","not p(List.cons[A](s0(p), s1(p))) or p(left)","not p(List.cons[A](s0(p), s1(p)))"]}
{"goal":"p(List.nil[T])","proof":["map[T, U](List.nil[T], f) + map[T, U](right, f) != map[T, U](List.nil[T] + right, f) or p(List.nil[T])","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","map[T, U](List.nil[T], f) != List.nil[U] or map[T, U](List.nil[T], f) + map[T, U](right, f) = map[T, U](right, f)","List.nil[T] + right = right","map[T, U](List.nil[T], f) = List.nil[U]","map[T, U](List.nil[T], f) + map[T, U](right, f) != map[T, U](List.nil[T] + right, f)","map[T, U](List.nil[T], f) + map[T, U](right, f) != map[T, U](right, f)"]}
{"goal":"p(tail) implies map[T, U](tail, f) + map[T, U](right, f) = map[T, U](tail + right, f)","proof":["not p(tail) or map[T, U](tail, f) + map[T, U](right, f) = map[T, U](tail + right, f)"]}
{"goal":"List.cons(head, tail) + right = List.cons(head, tail + right)","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + right = List.cons(head, tail + right)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) + map[T, U](right, f) = List.cons(f(head), map[T, U](tail, f) + map[T, U](right, f))","proof":["List.cons(f(head), map[T, U](tail, f)) != List.cons(f(head), map[T, U](tail, f)) or List.cons(f(head), map[T, U](tail, f)) + map[T, U](right, f) = List.cons(f(head), map[T, U](tail, f) + map[T, U](right, f))"]}
{"goal":"List.cons(f(head), map[T, U](tail + right, f)) = map[T, U](List.cons(head, tail + right), f)","proof":["List.cons(head, tail + right) != List.cons(head, tail + right) or List.cons(f(head), map[T, U](tail + right, f)) = map[T, U](List.cons(head, tail + right), f)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"p(List.cons(head, tail))","proof":["map[T, U](List.cons(head, tail), f) + map[T, U](right, f) != map[T, U](List.cons(head, tail) + right, f) or p(List.cons(head, tail))","map[T, U](List.cons(head, tail), f) + map[T, U](right, f) != map[T, U](List.cons(head, tail) + right, f)"]}
{"goal":"map_add","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","not p(left) or map[T, U](left, f) + map[T, U](right, f) = map[T, U](left + right, f)","not p(left)","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(left)","not p(List.nil[T]) or p(s1(p)) or p(left)","p(s1(p)) or p(left)","p(s1(p))","not p(List.cons[T](s0(p), s1(p))) or p(left)","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"map[T, U](initial, f) + map[T, U](List.singleton(last), f) = map[T, U](initial + List.singleton(last), f)","proof":["map[T, U](initial, f) + map[T, U](List.singleton(last), f) = map[T, U](initial + List.singleton(last), f)"]}
{"goal":"map[T, U](initial, f) + List.singleton(f(last)) = map[T, U](initial, f).append(f(last))","proof":["map[T, U](initial, f) + List.singleton(f(last)) = map[T, U](initial, f).append(f(last))"]}
{"goal":"initial + List.singleton(last) = initial.append(last)","proof":["initial + List.singleton(last) = initial.append(last)"]}
{"goal":"List.cons(f(last), List.nil[U]) = List.singleton(f(last))","proof":["List.cons(f(last), List.nil[U]) = List.singleton(f(last))"]}
{"goal":"List.cons(last, List.nil[T]) = List.singleton(last)","proof":["List.cons(last, List.nil[T]) = List.singleton(last)"]}
{"goal":"map[T, U](List.nil[T], f) = List.nil[U]","proof":["List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]"]}
{"goal":"List.cons(f(last), map[T, U](List.nil[T], f)) = map[T, U](List.cons(last, List.nil[T]), f)","proof":["List.cons(last, List.nil[T]) != List.cons(last, List.nil[T]) or List.cons(f(last), map[T, U](List.nil[T], f)) = map[T, U](List.cons(last, List.nil[T]), f)"]}
{"goal":"map_append","proof":[]}
{"goal":"sum_append","proof":["sum[A](initial) + sum[A](List.singleton(last)) = sum[A](initial + List.singleton(last))","List.cons(last, List.nil[A]) != List.cons(last, List.nil[A]) or sum[A](List.cons(last, List.nil[A])) = last + sum[A](List.nil[A])","initial + List.singleton(last) = initial.append(last)","List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0","List.cons(last, List.nil[A]) = List.singleton(last)","last + A.0 = last","sum[A](List.nil[A]) = A.0","sum[A](List.cons(last, List.nil[A])) = last + sum[A](List.nil[A])","sum[A](initial + List.singleton(last)) != sum[A](initial) + last","sum[A](initial) + sum[A](List.singleton(last)) != sum[A](initial) + last","sum[A](List.singleton(last)) != last"]}
{"goal":"p(List.nil[T])","proof":["List.nil[T] + b + c != List.nil[T] + (b + c) or p(List.nil[T])","List.nil[T] + (b + c) = b + c","List.nil[T] + b = b","List.nil[T] + b + c != List.nil[T] + (b + c)"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail) + b + c != List.cons(head, tail) + (b + c) or p(List.cons(head, tail))","not p(tail) or tail + (b + c) = tail + b + c","List.cons(head, tail + b) != List.cons(head, tail + b) or List.cons(head, tail + b) + c = List.cons(head, tail + b + c)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + (b + c) = List.cons(head, tail + (b + c))","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + b = List.cons(head, tail + b)","List.cons(head, tail + b) + c = List.cons(head, tail + b + c)","List.cons(head, tail) + (b + c) = List.cons(head, tail + (b + c))","List.cons(head, tail) + b = List.cons(head, tail + b)","List.cons(head, tail) + b + c != List.cons(head, tail) + (b + c)","tail + (b + c) = tail + b + c"]}
{"goal":"add_assoc","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","not p(a) or a + (b + c) = a + b + c","not p(a)","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(a)","not p(List.nil[T]) or p(s1(p)) or p(a)","p(s1(p)) or p(a)","p(s1(p))","not p(List.cons[T](s0(p), s1(p))) or p(a)","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"map_singleton","proof":["map[T, U](List.nil[T], f).append(f(x)) = map[T, U](List.nil[T].append(x), f)","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","List.nil[T] + List.singleton(x) = List.nil[T].append(x)","List.nil[U] + List.singleton(f(x)) = List.nil[U].append(f(x))","List.nil[T] + List.singleton(x) = List.singleton(x)","List.nil[U] + List.singleton(f(x)) = List.singleton(f(x))","map[T, U](List.nil[T], f) = List.nil[U]"]}
{"goal":"exists(k0: T, k1: List[T]) { List.cons(k0, k1) = list or List.nil[T] = list }","proof":["let [T0] (s0: List[T0] -> T0, s1: List[T0] -> List[T0]) satisfy { forall(x0: List[T0]) { List.cons[T0](s0(x0), s1(x0)) = x0 or List.nil[T0] = x0 } }","List.cons[T](s0(list), s1(list)) != list","List.cons[T](s0(list), s1(list)) = list or List.nil[T] = list"]}
{"goal":"tail.length.suc != 0","proof":["tail.length.suc != 0"]}
{"goal":"length_zero_imp_nil","proof":["List.cons(head, tail) != list or tail.length.suc = list.length","tail.length.suc != list.length","tail.length.suc = list.length"]}
{"goal":"a.length + b.length = (a + b).length","proof":["a.length + b.length = (a + b).length"]}
{"goal":"a.length + b.length != 0 or b.length = 0","proof":["a.length + b.length != 0 or b.length = 0"]}
{"goal":"a.length + b.length != 0 or a.length = 0","proof":["a.length + b.length != 0 or a.length = 0"]}
{"goal":"a.length != 0 or List.nil[T] = a","proof":["a.length != 0 or List.nil[T] = a"]}
{"goal":"b.length != 0 or List.nil[T] = b","proof":["b.length != 0 or List.nil[T] = b"]}
{"goal":"add_to_nil","proof":["List.nil[T] != List.nil[T] or List.nil[T].length = 0","a + List.nil[T] = a","a.length + b.length = List.nil[T].length","List.nil[T].length = 0","a.length + b.length = 0","b.length = 0","List.nil[T] = b","List.nil[T] != a"]}
{"goal":"append_not_nil","proof":["a + List.singleton(t) = a.append(t)","a + List.singleton(t) != List.nil[T] or List.singleton(t) = List.nil[T]","List.cons(t, List.nil[T]) = List.singleton(t)","List.cons(t, List.nil[T]) != List.nil[T]","a + List.singleton(t) = List.nil[T]","List.singleton(t) = List.nil[T]"]}
{"goal":"p(List.nil[T])","proof":["map[T, V](List.nil[T], compose[T, U, V](g, f)) != map[U, V](map[T, U](List.nil[T], f), g) or p(List.nil[T])","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","List.nil[T] != List.nil[T] or map[T, V](List.nil[T], compose[T, U, V](g, f)) = List.nil[V]","map[T, U](List.nil[T], f) != List.nil[U] or map[U, V](map[T, U](List.nil[T], f), g) = List.nil[V]","map[T, U](List.nil[T], f) = List.nil[U]","map[T, V](List.nil[T], compose[T, U, V](g, f)) = List.nil[V]","map[T, V](List.nil[T], compose[T, U, V](g, f)) != map[U, V](map[T, U](List.nil[T], f), g)","map[U, V](map[T, U](List.nil[T], f), g) != List.nil[V]"]}
{"goal":"compose[T, U, V](g, f, head) = g(f(head))","proof":["compose[T, U, V](g, f, head) = g(f(head))"]}
{"goal":"List.cons(g(f(head)), map[U, V](map[T, U](tail, f), g)) = map[U, V](List.cons(f(head), map[T, U](tail, f)), g)","proof":["List.cons(f(head), map[T, U](tail, f)) != List.cons(f(head), map[T, U](tail, f)) or List.cons(g(f(head)), map[U, V](map[T, U](tail, f), g)) = map[U, V](List.cons(f(head), map[T, U](tail, f)), g)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"List.cons(compose[T, U, V](g, f, head), map[T, V](tail, compose[T, U, V](g, f))) = map[T, V](List.cons(head, tail), compose[T, U, V](g, f))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(compose[T, U, V](g, f, head), map[T, V](tail, compose[T, U, V](g, f))) = map[T, V](List.cons(head, tail), compose[T, U, V](g, f))"]}
{"goal":"p(List.cons(head, tail))","proof":["map[T, V](List.cons(head, tail), compose[T, U, V](g, f)) != map[U, V](map[T, U](List.cons(head, tail), f), g) or p(List.cons(head, tail))","not p(tail) or map[T, V](tail, compose[T, U, V](g, f)) = map[U, V](map[T, U](tail, f), g)","lib(util).flip(List.cons[V], map[T, V](tail, compose[T, U, V](g, f)), compose[T, U, V](g, f, head)) = List.cons(compose[T, U, V](g, f, head), map[T, V](tail, compose[T, U, V](g, f)))","lib(util).flip(List.cons[V], map[U, V](map[T, U](tail, f), g), g(f(head))) = List.cons(g(f(head)), map[U, V](map[T, U](tail, f), g))","map[T, V](List.cons(head, tail), compose[T, U, V](g, f)) != map[U, V](map[T, U](List.cons(head, tail), f), g)","map[T, V](tail, compose[T, U, V](g, f)) = map[U, V](map[T, U](tail, f), g)"]}
{"goal":"map_map","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","not p(items) or map[T, V](items, compose[T, U, V](g, f)) = map[U, V](map[T, U](items, f), g)","not p(items)","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(items)","not p(List.nil[T]) or p(s1(p)) or p(items)","p(s1(p)) or p(items)","p(s1(p))","not p(List.cons[T](s0(p), s1(p))) or p(items)","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"map[S, S](map[Nat, S](n.range, f), scalar_mul(c)) = map[Nat, S](n.range, compose[Nat, S, S](scalar_mul(c), f))","proof":["map[Nat, S](n.range, compose[Nat, S, S](scalar_mul(c), f)) = map[S, S](map[Nat, S](n.range, f), scalar_mul(c))"]}
{"goal":"sum[S](map[S, S](map[Nat, S](n.range, f), scalar_mul(c))) = c * sum[S](map[Nat, S](n.range, f))","proof":["sum[S](map[S, S](map[Nat, S](n.range, f), scalar_mul(c))) = c * sum[S](map[Nat, S](n.range, f))"]}
{"goal":"sum[S](map[Nat, S](n.range, f)) = partial[S](f, n)","proof":["sum[S](map[Nat, S](n.range, f)) = partial[S](f, n)"]}
{"goal":"sum[S](map[Nat, S](n.range, mul_fn[Nat, S](c, f))) = partial[S](mul_fn[Nat, S](c, f), n)","proof":["sum[S](map[Nat, S](n.range, mul_fn[Nat, S](c, f))) = partial[S](mul_fn[Nat, S](c, f), n)"]}
{"goal":"compose[Nat, S, S](scalar_mul(c), f) = mul_fn[Nat, S](c, f)","proof":["let s0: Nat satisfy { compose[Nat, S, S](scalar_mul[S](c), f, s0) != mul_fn[Nat, S](c, f, s0) }","mul_fn(c, f, s0) = c * f(s0)","compose[Nat, S, S](scalar_mul(c), f, s0) = scalar_mul(c, f(s0))","mul_fn(c, f, s0) != scalar_mul(c, f(s0))","scalar_mul(c, f(s0)) = c * f(s0)"]}
{"goal":"partial_scalar_mul","proof":[]}
{"goal":"sum[A](map[Nat, A](0.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), 0)","proof":["sum[A](map[Nat, A](0.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), 0)"]}
{"goal":"partial[A](f, 1) = f(0)","proof":["partial[A](f, 1) = f(0)"]}
{"goal":"partial[A](f, 0.suc) + A.0 = partial[A](f, 0.suc)","proof":["partial[A](f, 0.suc) + A.0 = A.0 + partial[A](f, 0.suc)","A.0 + partial[A](f, 0.suc) != partial[A](f, 0.suc)","A.0 + partial[A](f, 0.suc) = partial[A](f, 0.suc)"]}
{"goal":"map[Nat, A](List.nil[Nat], compose[Nat, Nat, A](f, Nat.suc)) = List.nil[A]","proof":["List.nil[Nat] != List.nil[Nat] or map[Nat, A](List.nil[Nat], compose[Nat, Nat, A](f, Nat.suc)) = List.nil[A]"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) = partial[A](f, 0.suc)","proof":["lib(util).flip(A.add, f(0), partial[A](compose[Nat, Nat, A](f, Nat.suc), 0)) = partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) + f(0)","lib(util).flip(A.add, partial[A](f, 0.suc), A.0) = A.0 + partial[A](f, 0.suc)","lib(util).flip[List[Nat], Nat -> A, List[A]](map[Nat, A], compose[Nat, Nat, A](f, Nat.suc), 0.range) = map[Nat, A](0.range, compose[Nat, Nat, A](f, Nat.suc))","lib(util).flip[List[Nat], Nat -> A, List[A]](map[Nat, A], compose[Nat, Nat, A](f, Nat.suc), List.nil[Nat]) = map[Nat, A](List.nil[Nat], compose[Nat, Nat, A](f, Nat.suc))","lib(util).flip[Nat -> A, Nat, A](partial[A], 0.suc, f) = partial[A](f, 0.suc)","lib(util).flip[Nat -> A, Nat, A](partial[A], 1, f) = partial[A](f, 1)","List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) = partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) + f(0)","partial[A](f, 0.suc) + A.0 = A.0 + partial[A](f, 0.suc)","0 + 1 = 0.suc","Nat.zero != Nat.zero or Nat.zero.range = List.nil[Nat]","0 + 1 = 1","Nat.zero.range = List.nil[Nat]","sum[A](List.nil[A]) = A.0"]}
{"goal":"map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(compose[Nat, Nat, A](f, Nat.suc, k)) = map[Nat, A](k.range.append(k), compose[Nat, Nat, A](f, Nat.suc))","proof":["map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(compose[Nat, Nat, A](f, Nat.suc, k)) = map[Nat, A](k.range.append(k), compose[Nat, Nat, A](f, Nat.suc))"]}
{"goal":"sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k)","proof":["sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k)"]}
{"goal":"sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(f(k.suc))) = sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) + f(k.suc)","proof":["sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(f(k.suc))) = sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) + f(k.suc)"]}
{"goal":"compose[Nat, Nat, A](f, Nat.suc, k) = f(k.suc)","proof":["compose[Nat, Nat, A](f, Nat.suc, k) = f(k.suc)"]}
{"goal":"k.range.append(k) = k.suc.range","proof":["k.suc != k.suc or k.range.append(k) = k.suc.range"]}
{"goal":"sum[A](map[Nat, A](k.suc.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc)","proof":[]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc) = partial[A](f, k.suc) + f(k.suc)","proof":["not p(k) or f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) = partial[A](f, k.suc)","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) != partial[A](f, k.suc)","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) = partial[A](f, k.suc)"]}
{"goal":"map[Nat, A](k.suc.range, f).append(f(k.suc)) = map[Nat, A](k.suc.range.append(k.suc), f)","proof":["map[Nat, A](k.suc.range, f).append(f(k.suc)) = map[Nat, A](k.suc.range.append(k.suc), f)"]}
{"goal":"sum[A](map[Nat, A](k.suc.range, f)) = partial[A](f, k.suc)","proof":["sum[A](map[Nat, A](k.suc.range, f)) = partial[A](f, k.suc)"]}
{"goal":"sum[A](map[Nat, A](k.suc.range, f).append(f(k.suc))) = sum[A](map[Nat, A](k.suc.range, f)) + f(k.suc)","proof":["sum[A](map[Nat, A](k.suc.range, f).append(f(k.suc))) = sum[A](map[Nat, A](k.suc.range, f)) + f(k.suc)"]}
{"goal":"k.suc.range.append(k.suc) = k.suc.suc.range","proof":["k.suc.suc != k.suc.suc or k.suc.range.append(k.suc) = k.suc.suc.range"]}
{"goal":"sum[A](map[Nat, A](k.suc.suc.range, f)) = partial[A](f, k.suc) + f(k.suc)","proof":[]}
{"goal":"p(k.suc)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc) != partial[A](f, k.suc.suc) or p(k.suc)","f(0) + (partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc)) = f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc)","sum[A](map[Nat, A](k.suc.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc)","sum[A](map[Nat, A](k.suc.suc.range, f)) = partial[A](f, k.suc.suc)","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc) != partial[A](f, k.suc.suc)"]}
{"goal":"partial_shift_suc","proof":["let s0: Nat satisfy { forall(x0: Nat) { not p(Nat.zero) or p(s0) or p(x0) } and forall(x1: Nat) { not p(s0.suc) or not p(Nat.zero) or p(x1) } }","not p(s0) or p(s0.suc)","not p(Nat.zero) or p(s0) or p(n)","not p(s0.suc) or not p(Nat.zero) or p(n)","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) != partial[A](f, 0.suc) or p(0)","not p(n) or f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n) = partial[A](f, n.suc)","not p(n)","not p(Nat.zero) or p(s0)","not p(s0.suc) or not p(Nat.zero)","p(0)","p(Nat.zero)","p(s0)","not p(s0.suc)","p(s0.suc)"]}
{"goal":"n.range.append(n) = n.suc.range","proof":["n.suc != n.suc or n.range.append(n) = n.suc.range"]}
{"goal":"map[Nat, A](n.range, f).append(f(n)) = map[Nat, A](n.range.append(n), f)","proof":["map[Nat, A](n.range, f).append(f(n)) = map[Nat, A](n.range.append(n), f)"]}
{"goal":"sum[A](map[Nat, A](n.range, f).append(f(n))) = sum[A](map[Nat, A](n.range, f)) + f(n)","proof":["sum[A](map[Nat, A](n.range, f).append(f(n))) = sum[A](map[Nat, A](n.range, f)) + f(n)"]}
{"goal":"sum[A](map[Nat, A](n.range, f)) = partial[A](f, n)","proof":["sum[A](map[Nat, A](n.range, f)) = partial[A](f, n)"]}
{"goal":"sum[A](map[Nat, A](n.suc.range, f)) = partial[A](f, n.suc)","proof":["sum[A](map[Nat, A](n.suc.range, f)) = partial[A](f, n.suc)"]}
{"goal":"partial_split_last","proof":[]}
{"goal":"sum[A](map[Nat, A](0.range, f)) = partial[A](f, 0)","proof":["sum[A](map[Nat, A](0.range, f)) = partial[A](f, 0)"]}
{"goal":"sum[A](map[Nat, A](0.range, g)) = partial[A](g, 0)","proof":["sum[A](map[Nat, A](0.range, g)) = partial[A](g, 0)"]}
{"goal":"map[Nat, A](List.nil[Nat], f) = List.nil[A]","proof":["List.nil[Nat] != List.nil[Nat] or map[Nat, A](List.nil[Nat], f) = List.nil[A]"]}
{"goal":"map[Nat, A](List.nil[Nat], g) = List.nil[A]","proof":["List.nil[Nat] != List.nil[Nat] or map[Nat, A](List.nil[Nat], g) = List.nil[A]"]}
{"goal":"p(0)","proof":["partial[A](g, 0) != partial[A](f, 0) or p(0)","lib(util).flip[List[Nat], Nat -> A, List[A]](map[Nat, A], f, 0.range) = map[Nat, A](0.range, f)","lib(util).flip[List[Nat], Nat -> A, List[A]](map[Nat, A], f, List.nil[Nat]) = map[Nat, A](List.nil[Nat], f)","lib(util).flip[List[Nat], Nat -> A, List[A]](map[Nat, A], g, 0.range) = map[Nat, A](0.range, g)","lib(util).flip[List[Nat], Nat -> A, List[A]](map[Nat, A], g, List.nil[Nat]) = map[Nat, A](List.nil[Nat], g)","Nat.zero != Nat.zero or Nat.zero.range = List.nil[Nat]","Nat.zero.range = List.nil[Nat]","partial[A](g, 0) != partial[A](f, 0)"]}
{"goal":"partial[A](f, m.suc) = partial[A](g, m) + f(m)","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { not p(x0) or partial[A](g, x0) = partial[A](f, x0) or s0(x0) < x0 } and forall(x1: Nat) { g(s0(x1)) != f(s0(x1)) or not p(x1) or partial[A](g, x1) = partial[A](f, x1) } and forall(x2: Nat, x3: Nat) { not x2 < x3 or p(x3) or g(x2) = f(x2) } and forall(x4: Nat) { partial[A](g, x4) != partial[A](f, x4) or p(x4) } }","not s0(m) < m.suc or g(s0(m)) = f(s0(m))","not p(m) or partial[A](g, m) = partial[A](f, m) or s0(m) < m","g(s0(m)) != f(s0(m)) or not p(m) or partial[A](g, m) = partial[A](f, m)","partial[A](f, m) + f(m) = partial[A](f, m.suc)","not s0(m) < m or s0(m) < m.suc","partial[A](g, m) + f(m) != partial[A](f, m) + f(m)","partial[A](g, m) != partial[A](f, m)","s0(m) < m","g(s0(m)) != f(s0(m))","s0(m) < m.suc","not s0(m) < m.suc"]}
{"goal":"partial[A](f, m.suc) = partial[A](g, m.suc)","proof":["not m < m.suc or g(m) = f(m)","partial[A](g, m) + g(m) = partial[A](g, m.suc)","m < m.suc","g(m) = f(m)"]}
{"goal":"p(n)","proof":["let s0: Nat satisfy { forall(x0: Nat) { not p(Nat.zero) or p(s0) or p(x0) } and forall(x1: Nat) { not p(s0.suc) or not p(Nat.zero) or p(x1) } }","not p(Nat.zero) or p(s0) or p(n)","not p(Nat.zero) or p(s0)","not p(s0.suc) or not p(Nat.zero) or p(n)","partial[A](g, s0.suc) != partial[A](f, s0.suc) or p(s0.suc)","let s1: Nat -> Nat satisfy { forall(x2: Nat) { not p(x2) or partial[A](g, x2.suc) = partial[A](f, x2.suc) or s1(x2) < x2.suc } and forall(x3: Nat) { g(s1(x3)) != f(s1(x3)) or not p(x3) or partial[A](g, x3.suc) = partial[A](f, x3.suc) } }","not s1(s0) < s0.suc or p(s0.suc) or g(s1(s0)) = f(s1(s0))","not p(s0.suc) or not p(Nat.zero)","g(s1(s0)) != f(s1(s0)) or not p(s0) or partial[A](g, s0.suc) = partial[A](f, s0.suc)","not p(s0) or partial[A](g, s0.suc) = partial[A](f, s0.suc) or s1(s0) < s0.suc","p(Nat.zero)","p(s0)","not p(s0.suc)","not s1(s0) < s0.suc or g(s1(s0)) = f(s1(s0))","partial[A](g, s0.suc) != partial[A](f, s0.suc)","s1(s0) < s0.suc","g(s1(s0)) != f(s1(s0))","g(s1(s0)) = f(s1(s0))"]}
{"goal":"partial_pointwise_eq","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { not p(x0) or partial[A](g, x0) = partial[A](f, x0) or s0(x0) < x0 } and forall(x1: Nat) { g(s0(x1)) != f(s0(x1)) or not p(x1) or partial[A](g, x1) = partial[A](f, x1) } and forall(x2: Nat, x3: Nat) { not x2 < x3 or p(x3) or g(x2) = f(x2) } and forall(x4: Nat) { partial[A](g, x4) != partial[A](f, x4) or p(x4) } }","not s0(n) < n or g(s0(n)) = f(s0(n))","not p(n) or partial[A](g, n) = partial[A](f, n) or s0(n) < n","g(s0(n)) != f(s0(n)) or not p(n) or partial[A](g, n) = partial[A](f, n)","s0(n) < n","g(s0(n)) != f(s0(n))","g(s0(n)) = f(s0(n))"]}
{"goal":"partial[A](g, 1) = g(0)","proof":["partial[A](g, 1) = g(0)"]}
{"goal":"reverse_index[A](g, 0, 0) = g(0 - 0)","proof":["reverse_index[A](g, 0, 0) = g(0 - 0)"]}
{"goal":"0 - 0 = 0","proof":["0 + 0 - 0 = 0","0 + 0 = 0"]}
{"goal":"reverse_index[A](g, 0, 0) = g(0)","proof":["reverse_index[A](g, 0, 0) != g(0 - 0)"]}
{"goal":"partial[A](reverse_index[A](g, 0), 1) = reverse_index[A](g, 0, 0)","proof":["partial[A](reverse_index[A](g, 0), 1) = reverse_index[A](g, 0, 0)"]}
{"goal":"partial[A](g, 1) = partial[A](reverse_index[A](g, 0), 1)","proof":[]}
{"goal":"p(0)","proof":["partial[A](reverse_index[A](g, 0), 0.suc) != partial[A](g, 0.suc) or p(0)","partial[A](reverse_index[A](g, 0), 0.suc) != partial[A](g, 0.suc)"]}
{"goal":"partial[A](g, m.suc.suc) = partial[A](g, m.suc) + g(m.suc)","proof":["partial[A](g, m.suc) + g(m.suc) = partial[A](g, m.suc.suc)"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc.suc) = partial[A](reverse_index[A](g, m.suc), m.suc) + reverse_index[A](g, m.suc, m.suc)","proof":["partial[A](reverse_index[A](g, m.suc), m.suc) + reverse_index[A](g, m.suc, m.suc) = partial[A](reverse_index[A](g, m.suc), m.suc.suc)"]}
{"goal":"reverse_index[A](g, m.suc, m.suc) = g(m.suc - m.suc)","proof":["reverse_index[A](g, m.suc, m.suc) = g(m.suc - m.suc)"]}
{"goal":"m.suc - m.suc = 0","proof":["0 + m.suc - m.suc = 0","0 + m.suc = m.suc"]}
{"goal":"reverse_index[A](g, m.suc, m.suc) = g(0)","proof":["reverse_index[A](g, m.suc, m.suc) != g(m.suc - m.suc)"]}
{"goal":"m.suc > 0","proof":["0 < 0 + m.suc","m.suc > 0 = 0 < m.suc","not 0 < m.suc","0 + m.suc = m.suc"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc) = reverse_index[A](g, m.suc, 0) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m.suc - 1)","proof":["reverse_index[A](g, m.suc, 0) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m.suc - 1) = partial[A](reverse_index[A](g, m.suc), (m.suc - 1).suc)","partial[A](reverse_index[A](g, m.suc), (m.suc - 1).suc) != partial[A](reverse_index[A](g, m.suc), m.suc)","(m.suc - 1).suc != m.suc","m.suc - 1 != m","m + 1 - 1 = m","m + 1 = m.suc"]}
{"goal":"reverse_index[A](g, m.suc, 0) = g(m.suc - 0)","proof":["reverse_index[A](g, m.suc, 0) = g(m.suc - 0)"]}
{"goal":"m.suc - 0 = m.suc","proof":["m.suc + 0 - 0 = m.suc","m.suc + 0 = m.suc"]}
{"goal":"reverse_index[A](g, m.suc, 0) = g(m.suc)","proof":["reverse_index[A](g, m.suc, 0) != g(m.suc - 0)"]}
{"goal":"m.suc - 1 = m","proof":["m + 1 - 1 = m","m + 1 = m.suc"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc) = g(m.suc) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m)","proof":["reverse_index[A](g, m.suc, 0) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m.suc), m.suc)"]}
{"goal":"compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, i) = reverse_index[A](g, m.suc, i.suc)","proof":["compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, i) = reverse_index[A](g, m.suc, i.suc)"]}
{"goal":"reverse_index[A](g, m.suc, i.suc) = g(m.suc - i.suc)","proof":["reverse_index[A](g, m.suc, i.suc) = g(m.suc - i.suc)"]}
{"goal":"i <= m","proof":["let s0: (Nat, Nat) -> Nat satisfy { forall(x0: Nat, x1: Nat) { not x0 < x1 or x0 + s0(x0, x1) = x1 } and forall(x2: Nat, x3: Nat) { not x2 < x3 or 0 != s0(x2, x3) } }","not i < m or i + s0(i, m) = m","i + s0(i, m) != m or i <= m","i + s0(i, m) != m"]}
{"goal":"m - i + i = m","proof":["not i <= m or m - i + i = m"]}
{"goal":"m - i + i.suc = (m - i + i).suc","proof":["i.suc != i.suc or (m - i + i).suc = m - i + i.suc"]}
{"goal":"m.suc - i.suc = m - i","proof":["m - i + i.suc != m.suc or m.suc - i.suc = m - i","m - i + i.suc = m.suc","m - i + i.suc != m.suc"]}
{"goal":"reverse_index[A](g, m, i) = g(m - i)","proof":["reverse_index[A](g, m, i) = g(m - i)"]}
{"goal":"compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, i) = reverse_index[A](g, m, i)","proof":[]}
{"goal":"partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m), m)","proof":["let s0: Nat satisfy { partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m), m) or s0 < m and (compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, s0) != reverse_index[A](g, m, s0) or partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m), m)) }","not s0 < m or compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, s0) = reverse_index[A](g, m, s0)"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc) = g(m.suc) + partial[A](reverse_index[A](g, m), m)","proof":["g(m.suc) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) != partial[A](reverse_index[A](g, m.suc), m.suc)"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) = partial[A](reverse_index[A](g, m), m) + reverse_index[A](g, m, m)","proof":["partial[A](reverse_index[A](g, m), m) + reverse_index[A](g, m, m) = partial[A](reverse_index[A](g, m), m.suc)"]}
{"goal":"reverse_index[A](g, m, m) = g(m - m)","proof":["reverse_index[A](g, m, m) = g(m - m)"]}
{"goal":"m - m = 0","proof":["0 + m - m = 0","0 + m = m"]}
{"goal":"reverse_index[A](g, m, m) = g(0)","proof":["reverse_index[A](g, m, m) != g(m - m)"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) = partial[A](reverse_index[A](g, m), m) + g(0)","proof":["partial[A](reverse_index[A](g, m), m) + reverse_index[A](g, m, m) != partial[A](reverse_index[A](g, m), m.suc)"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) + g(m.suc) = g(m.suc) + partial[A](reverse_index[A](g, m), m.suc)","proof":["g(m.suc) + partial[A](reverse_index[A](g, m), m.suc) = partial[A](reverse_index[A](g, m), m.suc) + g(m.suc)"]}
{"goal":"g(m.suc) + partial[A](reverse_index[A](g, m), m) + g(0) = g(m.suc) + (partial[A](reverse_index[A](g, m), m) + g(0))","proof":["g(m.suc) + (partial[A](reverse_index[A](g, m), m) + g(0)) = g(m.suc) + partial[A](reverse_index[A](g, m), m) + g(0)"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) + g(m.suc) = partial[A](reverse_index[A](g, m.suc), m.suc) + g(0)","proof":[]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) = partial[A](g, m.suc)","proof":["not p(m) or partial[A](reverse_index[A](g, m), m.suc) = partial[A](g, m.suc)"]}
{"goal":"p(m.suc)","proof":["partial[A](reverse_index[A](g, m.suc), m.suc.suc) != partial[A](g, m.suc.suc) or p(m.suc)","partial[A](reverse_index[A](g, m.suc), m.suc.suc) != partial[A](g, m.suc.suc)"]}
{"goal":"partial_reverse","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not p(s0(p)) or p(s0(p).suc)","not p(n) or partial[A](reverse_index[A](g, n), n.suc) = partial[A](g, n.suc)","not p(n)","not p(s0(p).suc) or not p(0) or p(n)","not p(0) or p(s0(p)) or p(n)","p(s0(p)) or p(n)","p(s0(p))","not p(s0(p).suc)","p(s0(p).suc)"]}
{"goal":"partial_drop_first","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1) = partial[A](f, (n - 1).suc)","partial[A](f, (n - 1).suc) != partial[A](f, n)","(n - 1).suc != n","not 1 <= n or n - 1 + 1 = n","not 0 < n or 0.suc <= n","n > 0 = 0 < n","0 < n","n - 1 + 1 = (n - 1).suc","0.suc <= n","n - 1 + 1 != n","1 <= n","not 1 <= n"]}
{"goal":"exists(k0: Nat) { k0.suc = n }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { s0(x0).suc = x0 or 0 = x0 } }","s0(n).suc != n","not 2 <= n or 2 < n or 2 = n","n >= 2 = 2 <= n","2 <= n","s0(n).suc = n or 0 = n","0 = n","not 2 < 0","2 != n","2 < n"]}
{"goal":"n_minus_1.suc >= 2","proof":["not n >= 2"]}
{"goal":"n_minus_1 >= 1","proof":["not 1.suc <= n_minus_1.suc or 1 <= n_minus_1","n_minus_1 >= 1 = 1 <= n_minus_1","n_minus_1.suc >= 2 = 2 <= n_minus_1.suc","not 1 <= n_minus_1","2 <= n_minus_1.suc","not 1.suc <= n_minus_1.suc","1.suc <= n_minus_1.suc"]}
{"goal":"exists(k0: Nat) { k0.suc = n_minus_1 }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { s0(x0).suc = x0 or 0 = x0 } }","s0(n_minus_1).suc != n_minus_1","not n_minus_1 ∈ n_minus_1.suc.range or not n_minus_1 >= n_minus_1.suc","s0(n_minus_1).suc = n_minus_1 or 0 = n_minus_1","0 = n_minus_1","n_minus_1 ∈ n_minus_1.suc.range","n_minus_1 >= 0.suc","n_minus_1 >= n_minus_1.suc"]}
{"goal":"n_minus_2 + 1 = n_minus_2.suc","proof":["n_minus_2 + 1 = 1 + n_minus_2","1 + n_minus_2 != n_minus_2.suc","1 + n_minus_2 = n_minus_2.suc"]}
{"goal":"n_minus_2 + 2 = n","proof":["(n_minus_2 + 1).suc = n_minus_2 + 1.suc","1 + 1 = 1.suc"]}
{"goal":"n - 2 = n_minus_2","proof":["n_minus_2 + 2 != n or n - 2 = n_minus_2"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) = partial[A](f, (n - 2).suc)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) = partial[A](f, (n - 2).suc)"]}
{"goal":"partial[A](f, n_minus_1) + f(n_minus_1) = partial[A](f, n_minus_1.suc)","proof":["partial[A](f, n_minus_1) + f(n_minus_1) = partial[A](f, n_minus_1.suc)"]}
{"goal":"n_minus_1.suc - 1 = n_minus_1","proof":["n_minus_1 + 1 - 1 = n_minus_1","n_minus_1 + 1 = n_minus_1.suc"]}
{"goal":"partial[A](f, n) = f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1)","proof":[]}
{"goal":"partial_split_first_last","proof":[]}
{"goal":"p(List.nil[T])","proof":["map[T, U](List.nil[T], f).length != List.nil[T].length or p(List.nil[T])","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","List.nil[T] != List.nil[T] or List.nil[T].length = 0","List.nil[U] != List.nil[U] or List.nil[U].length = 0","List.nil[T].length = 0","List.nil[U].length = 0","map[T, U](List.nil[T], f) = List.nil[U]","map[T, U](List.nil[T], f).length != List.nil[T].length","List.nil[U].length != List.nil[T].length"]}
{"goal":"map[T, U](List.cons(head, tail), f).length = List.cons(head, tail).length","proof":["not p(tail) or map[T, U](tail, f).length = tail.length","List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), tail.map(f)) = List.cons(head, tail).map(f)","List.cons(f(head), map[T, U](tail, f)) != List.cons(f(head), map[T, U](tail, f)) or List.cons(f(head), map[T, U](tail, f)).length = map[T, U](tail, f).length.suc","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","map[T, U](List.cons(head, tail), f) = List.cons(head, tail).map(f)","map[T, U] = List.map[T, U]","List.cons(f(head), map[T, U](tail, f)).length = map[T, U](tail, f).length.suc","List.cons(head, tail).length = tail.length.suc","List.cons(f(head), tail.map(f)) = List.cons(head, tail).map(f)","map[T, U](tail, f).length = tail.length"]}
{"goal":"map_length","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(s1)","p(s1) or p(s1)","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(list)","not p(List.cons(s0, s1)) or p(list)","map[T, U](List.cons(s0, s1), f).length != List.cons(s0, s1).length or p(List.cons(s0, s1))","not p(list) or map[T, U](list, f).length = list.length","not p(s1) or map[T, U](List.cons(s0, s1), f).length = List.cons(s0, s1).length","p(s1)","not p(list)","not p(List.cons(s0, s1))","map[T, U](List.cons(s0, s1), f).length = List.cons(s0, s1).length"]}
{"goal":"p(List.nil[T])","proof":["item ∈ map[T, U](List.nil[T], f) or p(List.nil[T])","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","not item ∈ List.nil[U] or List.nil[U] != List.nil[U]","not item ∈ List.nil[U]","item ∈ map[T, U](List.nil[T], f)","map[T, U](List.nil[T], f) = List.nil[U]"]}
{"goal":"p(List.cons(head, tail))","proof":["not head ∈ List.cons(head, tail) or f(head) != item or p(List.cons(head, tail))","List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","not item ∈ map[T, U](List.cons(head, tail), f) or List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f) or item ∈ map[T, U](tail, f) or f(head) = item","List.cons(head, tail) != List.cons(head, tail) or head != head or head ∈ List.cons(head, tail)","not head ∈ List.cons(head, tail) or f(head) != item","head != head or head ∈ List.cons(head, tail)","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","head ∈ List.cons(head, tail)","f(head) != item","List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f) or item ∈ map[T, U](tail, f) or f(head) = item"]}
{"goal":"List.nil[T] + tail = tail","proof":["List.nil[T] != List.nil[T] or List.nil[T] + tail = tail"]}
{"goal":"List.cons(head, List.nil[T]) + tail = List.cons(head, List.nil[T] + tail)","proof":["List.cons(head, List.nil[T]) != List.cons(head, List.nil[T]) or List.cons(head, List.nil[T]) + tail = List.cons(head, List.nil[T] + tail)"]}
{"goal":"List.cons(head, List.nil[T]) + tail = List.cons(head, tail)","proof":["List.cons(head, List.nil[T]) + tail != List.cons(head, List.nil[T] + tail)"]}
{"goal":"tail.contains(x) implies (List.cons(head, List.nil[T]) + tail).contains(x)","proof":["not x ∈ tail or x ∈ List.cons(head, List.nil[T]) + tail"]}
{"goal":"p(List.cons(head, List.nil[T]) + tail)","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T]) { not item ∈ map[T, U](x0, f) or not p(x0) or s0(x0) ∈ x0 } and forall(x1: List[T]) { not item ∈ map[T, U](x1, f) or not p(x1) or f(s0(x1)) = item } and forall(x2: List[T]) { item ∈ map[T, U](x2, f) or p(x2) } and forall(x3: List[T], x4: T) { not x4 ∈ x3 or item != f(x4) or p(x3) } }","not s0(tail) ∈ List.cons(head, List.nil[T]) + tail or f(s0(tail)) != item or p(List.cons(head, List.nil[T]) + tail)","item ∈ map[T, U](List.cons(head, List.nil[T]) + tail, f) or p(List.cons(head, List.nil[T]) + tail)","not p(List.cons(head, tail))","not item ∈ map[T, U](tail, f) or not p(tail) or f(s0(tail)) = item","not s0(tail) ∈ tail or s0(tail) ∈ List.cons(head, List.nil[T]) + tail","not item ∈ map[T, U](tail, f) or not p(tail) or s0(tail) ∈ tail","not s0(tail) ∈ List.cons(head, List.nil[T]) + tail or f(s0(tail)) != item","item ∈ map[T, U](List.cons(head, List.nil[T]) + tail, f)","item ∈ map[T, U](List.cons(head, tail), f)","item ∈ map[T, U](tail, f)","f(s0(tail)) = item","s0(tail) ∈ tail","not s0(tail) ∈ List.cons(head, List.nil[T]) + tail","s0(tail) ∈ List.cons(head, List.nil[T]) + tail"]}
{"goal":"p(List.cons(head, tail))","proof":[]}
{"goal":"map_contains","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T]) { not item ∈ map[T, U](x0, f) or not p(x0) or s0(x0) ∈ x0 } and forall(x1: List[T]) { not item ∈ map[T, U](x1, f) or not p(x1) or f(s0(x1)) = item } and forall(x2: List[T]) { item ∈ map[T, U](x2, f) or p(x2) } and forall(x3: List[T], x4: T) { not x4 ∈ x3 or item != f(x4) or p(x3) } }","not s0(list) ∈ list or f(s0(list)) != item","let  (s1: T, s2: List[T]) satisfy { forall(x5: List[T]) { not p(List.nil[T]) or p(s2) or p(x5) } and forall(x6: List[T]) { not p(List.cons[T](s1, s2)) or not p(List.nil[T]) or p(x6) } }","not p(List.nil[T]) or p(s2) or p(s2)","p(s2) or p(s2)","not p(List.cons(s1, s2)) or not p(List.nil[T]) or p(list)","not p(List.cons(s1, s2)) or p(list)","not p(s2) or p(List.cons(s1, s2))","not item ∈ map[T, U](list, f) or not p(list) or f(s0(list)) = item","not item ∈ map[T, U](list, f) or not p(list) or s0(list) ∈ list","p(s2)","not p(list) or f(s0(list)) = item","p(List.cons(s1, s2))","p(list)","s0(list) ∈ list","f(s0(list)) = item","f(s0(list)) != item"]}
{"goal":"p(List.nil[T])","proof":["not map[T, U](List.nil[T], f).is_unique or p(List.nil[T])","List.nil[T] != List.nil[T] or map[T, U](List.nil[T], f) = List.nil[U]","List.nil[U] != List.nil[U] or List.nil[U].unique = List.nil[U]","List.nil[U].unique != List.nil[U] or List.nil[U].is_unique","not map[T, U](List.nil[T], f).is_unique","List.nil[U].unique = List.nil[U]","map[T, U](List.nil[T], f) = List.nil[U]","not List.nil[U].is_unique"]}
{"goal":"not map[T, U](tail, f).is_unique","proof":["tail_map.is_unique","let s0: List[U] -> U satisfy { forall(x0: List[U]) { not has_duplicate(x0) or x0.count(s0(x0)) > 1 } and forall(x1: List[U], x2: U) { not x1.count(x2) > 1 or has_duplicate(x1) } }","not has_duplicate(tail_map) or tail_map.count(s0(tail_map)) > 1","not tail_map.is_unique or tail_map.count(s0(tail_map)) <= 1","not 1 < tail_map.count(s0(tail_map)) or not tail_map.count(s0(tail_map)) <= 1","tail_map.count(s0(tail_map)) > 1 = 1 < tail_map.count(s0(tail_map))","tail_map.count(s0(tail_map)) <= 1","tail_map.count(s0(tail_map)) > 1","1 < tail_map.count(s0(tail_map))"]}
{"goal":"tail_map.is_unique","proof":["let s0[T0]: List[T0] -> T0 satisfy { forall(x0: List[T0]) { x0.count(s0(x0)) > 1 or x0.is_unique } }","not tail_map.count(s0(tail_map)) > 1 or has_duplicate(tail_map)","tail_map.count(s0(tail_map)) > 1 or tail_map.is_unique","tail_map.count(s0(tail_map)) > 1"]}
{"goal":"tail_map.unique = tail_map","proof":["not tail_map.is_unique or tail_map.unique = tail_map"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"map[T, U](List.cons(head, tail), f).unique != map[T, U](List.cons(head, tail), f)","proof":["map[T, U](List.cons(head, tail), f).unique != map[T, U](List.cons(head, tail), f) or map[T, U](List.cons(head, tail), f).is_unique"]}
{"goal":"tail_map.contains(dup)","proof":["List.cons(dup, tail_map) != List.cons(dup, tail_map) or List.cons(dup, tail_map).unique = List.cons(dup, tail_map.unique) or dup ∈ tail_map","List.cons(dup, tail_map) != List.cons(dup, tail_map) or List.cons(dup, tail_map).unique = List.cons(dup, tail_map.unique)","List.cons(dup, tail_map).unique = List.cons(dup, tail_map.unique)"]}
{"goal":"map[T, U](tail, f).contains(dup)","proof":[]}
{"goal":"exists(k0: T) { tail.contains(k0) and f(k0) = dup }","proof":["let s0[T0, T1]: (List[T0], T0 -> T1, T1) -> T0 satisfy { forall(x0: List[T0], x1: T0 -> T1, x2: T1) { not x2 ∈ map[T0, T1](x0, x1) or s0(x0, x1, x2) ∈ x0 } and forall(x3: List[T0], x4: T0 -> T1, x5: T1) { not x5 ∈ map[T0, T1](x3, x4) or x4(s0(x3, x4, x5)) = x5 } }","not s0(tail, f, dup) ∈ tail or f(s0(tail, f, dup)) != dup","not dup ∈ map[T, U](tail, f) or s0(tail, f, dup) ∈ tail","not dup ∈ map[T, U](tail, f) or f(s0(tail, f, dup)) = dup","f(s0(tail, f, dup)) = dup","s0(tail, f, dup) ∈ tail","not s0(tail, f, dup) ∈ tail"]}
{"goal":"tail.is_unique","proof":["not List.cons(head, tail).is_unique or tail.is_unique"]}
{"goal":"tail.unique = tail","proof":["not tail.is_unique or tail.unique = tail"]}
{"goal":"List.cons(head, tail).unique = List.cons(head, tail)","proof":["not List.cons(head, tail).is_unique or List.cons(head, tail).unique = List.cons(head, tail)"]}
{"goal":"x != head","proof":["head ∈ tail","not head ∈ tail or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).unique = tail.unique","lib(util).flip[List[T], T -> U, List[U]](map[T, U], f, List.cons(head, tail)) = map[T, U](List.cons(head, tail), f)","lib(util).flip[List[T], T -> U, List[U]](map[T, U], f, tail) = map[T, U](tail, f)","not head ∈ tail or List.cons(head, tail).unique = tail.unique","List.cons(head, tail).unique = tail.unique"]}
{"goal":"f(x) = f(head)","proof":["f(head) != dup"]}
{"goal":"p(List.cons(head, tail))","proof":["f(x) != f(head) or p(List.cons(head, tail)) or x = head","f(x) != f(head) or x = head"]}
{"goal":"p(List.cons(head, tail))","proof":["let  (s0: List[T] -> T, s1: List[T] -> T) satisfy { forall(x0: List[T]) { not x0.is_unique or s1(x0) != s0(x0) or not p(x0) or map[T, U](x0, f).is_unique } and forall(x1: List[T]) { not x1.is_unique or not p(x1) or map[T, U](x1, f).is_unique or f(s1(x1)) = f(s0(x1)) } and forall(x2: List[T]) { x2.is_unique or p(x2) } and forall(x3: List[T]) { not map[T, U](x3, f).is_unique or p(x3) } and forall(x4: T, x5: T, x6: List[T]) { f(x4) != f(x5) or p(x6) or x4 = x5 } }","f(s1(tail)) != f(s0(tail)) or p(List.cons(head, tail)) or s1(tail) = s0(tail)","f(s1(tail)) != f(s0(tail)) or s1(tail) = s0(tail)","not tail.is_unique or s1(tail) != s0(tail) or not p(tail) or map[T, U](tail, f).is_unique","not tail.is_unique or not p(tail) or map[T, U](tail, f).is_unique or f(s1(tail)) = f(s0(tail))","not List.cons(head, tail).is_unique or tail.is_unique","not tail.is_unique or s1(tail) != s0(tail)","tail.is_unique","s1(tail) != s0(tail)","f(s1(tail)) = f(s0(tail))","f(s1(tail)) != f(s0(tail))"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).is_unique or p(List.cons(head, tail))","not map[T, U](List.cons(head, tail), f).is_unique or p(List.cons(head, tail))","List.cons(head, tail).is_unique","not map[T, U](List.cons(head, tail), f).is_unique","map[T, U](List.cons(head, tail), f).is_unique"]}
{"goal":"pigeonhole_unique_map","proof":["let  (s0: List[T] -> T, s1: List[T] -> T) satisfy { forall(x0: List[T]) { not x0.is_unique or s1(x0) != s0(x0) or not p(x0) or map[T, U](x0, f).is_unique } and forall(x1: List[T]) { not x1.is_unique or not p(x1) or map[T, U](x1, f).is_unique or f(s1(x1)) = f(s0(x1)) } and forall(x2: List[T]) { x2.is_unique or p(x2) } and forall(x3: List[T]) { not map[T, U](x3, f).is_unique or p(x3) } and forall(x4: T, x5: T, x6: List[T]) { f(x4) != f(x5) or p(x6) or x4 = x5 } }","f(s1(items)) != f(s0(items)) or s1(items) = s0(items)","let [T0] (s2: (List[T0] -> Bool) -> T0, s3: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x7: List[T0] -> Bool, x8: List[T0]) { not x7(List.nil[T0]) or x7(s3(x7)) or x7(x8) } and forall(x9: List[T0] -> Bool, x10: List[T0]) { not x9(List.cons[T0](s2(x9), s3(x9))) or not x9(List.nil[T0]) or x9(x10) } }","not p(s3(p)) or p(List.cons[T](s2(p), s3(p)))","not items.is_unique or s1(items) != s0(items) or not p(items) or map[T, U](items, f).is_unique","not items.is_unique or not p(items) or map[T, U](items, f).is_unique or f(s1(items)) = f(s0(items))","not p(List.cons[T](s2(p), s3(p))) or not p(List.nil[T]) or p(items)","not p(List.nil[T]) or p(s3(p)) or p(s3(p))","p(s3(p)) or p(s3(p))","p(s3(p))","s1(items) != s0(items) or not p(items)","not p(items) or f(s1(items)) = f(s0(items))","not p(List.cons[T](s2(p), s3(p))) or p(items)","p(List.cons[T](s2(p), s3(p)))","p(items)","s1(items) != s0(items)","f(s1(items)) = f(s0(items))","f(s1(items)) != f(s0(items))"]}
{"goal":"not map[T, U](items, f).is_unique","proof":["map[T, U](items, f).length = items.length","items.length > map[T, U](items, f).unique.length = map[T, U](items, f).unique.length < items.length","not map[T, U](items, f).is_unique or map[T, U](items, f).unique = map[T, U](items, f)","not map[T, U](items, f).unique.length < items.length or map[T, U](items, f).unique.length != items.length","map[T, U](items, f).unique.length < items.length","map[T, U](items, f).unique = map[T, U](items, f)","map[T, U](items, f).unique.length != items.length","map[T, U](items, f).length != items.length"]}
{"goal":"pigeonhole_map","proof":["let [T0, T1] (s0: (List[T0], T0 -> T1) -> T0, s1: (List[T0], T0 -> T1) -> T0) satisfy { forall(x0: List[T0], x1: T0 -> T1) { not x0.is_unique or s1(x0, x1) != s0(x0, x1) or map[T0, T1](x0, x1).is_unique } and forall(x2: List[T0], x3: T0 -> T1) { not x2.is_unique or map[T0, T1](x2, x3).is_unique or x3(s1(x2, x3)) = x3(s0(x2, x3)) } }","f(s1(items, f)) != f(s0(items, f)) or s1(items, f) = s0(items, f)","not items.is_unique or s1(items, f) != s0(items, f) or map[T, U](items, f).is_unique","not items.is_unique or map[T, U](items, f).is_unique or f(s1(items, f)) = f(s0(items, f))","s1(items, f) != s0(items, f)","f(s1(items, f)) = f(s0(items, f))","f(s1(items, f)) != f(s0(items, f))"]}
{"goal":"tail_cancels_cons","proof":["List.cons(a, b) != List.cons(a, b) or List.cons(a, b).tail = b","List.cons(a, b) != List.cons(a, b)"]}
{"goal":"alt_drop_zero","proof":["Nat.zero != n or a.drop(n) = a","Nat.zero != n","0 != Nat.zero"]}
{"goal":"drop_zero","proof":["0 != 0 or a.drop(0) = a"]}
{"goal":"drop_one","proof":["0.suc != 0.suc or a.tail.drop(0) = a.drop(0.suc)","a.tail.drop(0) = a.tail","a.drop(0.suc) != a.tail","a.tail.drop(0) = a.drop(0.suc)"]}
{"goal":"p(List.nil[T])","proof":["(List.nil[T] + b).drop(List.nil[T].length) != b or p(List.nil[T])","List.nil[T].length != 0 or b.drop(List.nil[T].length) = b","List.nil[T] != List.nil[T] or List.nil[T].length = 0","List.nil[T] + b = b","List.nil[T].length = 0","(List.nil[T] + b).drop(List.nil[T].length) != b","b.drop(List.nil[T].length) != b"]}
{"goal":"List.cons(head, tail) + b = List.cons(head, tail + b)","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + b = List.cons(head, tail + b)"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","List.cons(head, tail) != List.cons(head, tail)"]}
{"goal":"List.cons(head, tail + b).tail = tail + b","proof":["List.cons(head, tail) + b != List.cons(head, tail + b) or (List.cons(head, tail) + b).tail = tail + b","(List.cons(head, tail) + b).tail != tail + b","(List.cons(head, tail) + b).tail = tail + b"]}
{"goal":"List.cons(head, tail + b).tail.drop(tail.length) = List.cons(head, tail + b).drop(tail.length.suc)","proof":["tail.length.suc != tail.length.suc or List.cons(head, tail + b).tail.drop(tail.length) = List.cons(head, tail + b).drop(tail.length.suc)"]}
{"goal":"p(List.cons(head, tail))","proof":["(List.cons(head, tail) + b).drop(List.cons(head, tail).length) != b or p(List.cons(head, tail))","not p(tail) or (tail + b).drop(tail.length) = b","(List.cons(head, tail) + b).drop(List.cons(head, tail).length) != b","(tail + b).drop(tail.length) = b"]}
{"goal":"drop_cancels_add","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","not p(a) or (a + b).drop(a.length) = b","not p(a)","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(a)","not p(List.nil[T]) or p(s1(p)) or p(a)","p(s1(p)) or p(a)","p(s1(p))","not p(List.cons[T](s0(p), s1(p))) or p(a)","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"f(0)","proof":["let  (s0: Nat -> List[T], s1: Nat -> Nat) satisfy { forall(x0: Nat, x1: List[T], x2: Nat) { not f(x0) or x1.drop(x0).drop(x2) = x1.drop(x0 + x2) } and forall(x3: Nat) { s0(x3).drop(x3).drop(s1(x3)) != s0(x3).drop(x3 + s1(x3)) or f(x3) } }","s0(0).drop(0).drop(s1(0)) != s0(0).drop(0 + s1(0)) or f(0)","s0(0).drop(0) = s0(0)","0 + s1(0) = s1(0)","s0(0).drop(0).drop(s1(0)) != s0(0).drop(0 + s1(0))"]}
{"goal":"l.drop(x.suc).drop(k) = l.drop(x.suc + k)","proof":["not f(x) or l.tail.drop(x).drop(k) = l.tail.drop(x + k)","(x + k).suc != (x + k).suc or l.tail.drop(x + k) = l.drop((x + k).suc)","x.suc != x.suc or l.tail.drop(x) = l.drop(x.suc)","(x + k).suc = x.suc + k","l.tail.drop(x + k) = l.drop((x + k).suc)","l.tail.drop(x) = l.drop(x.suc)","l.tail.drop(x).drop(k) = l.tail.drop(x + k)"]}
{"goal":"f(x.suc)","proof":["let  (s0: Nat -> List[T], s1: Nat -> Nat) satisfy { forall(x0: Nat, x1: List[T], x2: Nat) { not f(x0) or x1.drop(x0).drop(x2) = x1.drop(x0 + x2) } and forall(x3: Nat) { s0(x3).drop(x3).drop(s1(x3)) != s0(x3).drop(x3 + s1(x3)) or f(x3) } }","s0(x.suc).drop(x.suc).drop(s1(x.suc)) = s0(x.suc).drop(x.suc + s1(x.suc))","s0(x.suc).drop(x.suc).drop(s1(x.suc)) != s0(x.suc).drop(x.suc + s1(x.suc)) or f(x.suc)"]}
{"goal":"drop_twice","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not f(s0(f)) or f(s0(f).suc)","not f(m) or a.drop(m).drop(n) = a.drop(m + n)","not f(m)","not f(s0(f).suc) or not f(0) or f(m)","not f(0) or f(s0(f)) or f(m)","f(s0(f)) or f(m)","f(s0(f))","not f(s0(f).suc)","f(s0(f).suc)"]}
{"goal":"not tail.length < 0","proof":["not tail.length <= 0 or tail.length = 0","not tail.length < 0 or tail.length <= 0","not tail.length < 0 or tail.length != 0","tail.length != 0","tail.length <= 0","not tail.length <= 0"]}
{"goal":"List.cons(head, tail).drop_last(0) = List.cons(head, tail.drop_last(0)) or tail.length < 0","proof":["List.cons(head, tail) != List.cons(head, tail) or tail.length < 0 or List.cons(head, tail).drop_last(0) = List.cons(head, tail.drop_last(0))"]}
{"goal":"q(List.cons(head, tail))","proof":["List.cons(head, tail).drop_last(0) != List.cons(head, tail) or q(List.cons(head, tail))","not q(tail) or tail.drop_last(0) = tail","List.cons(head, tail).drop_last(0) != List.cons(head, tail)","tail.drop_last(0) = tail"]}
{"goal":"drop_last_zero","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not q(s1(q)) or q(List.cons[T](s0(q), s1(q)))","List.nil[T].drop_last(0) != List.nil[T] or q(List.nil[T])","not q(a) or a.drop_last(0) = a","not q(a)","not q(List.cons[T](s0(q), s1(q))) or not q(List.nil[T]) or q(a)","List.nil[T] != List.nil[T] or List.nil[T].drop_last(0) = List.nil[T]","not q(List.nil[T]) or q(s1(q)) or q(a)","List.nil[T].drop_last(0) = List.nil[T]","q(List.nil[T])","q(s1(q))","not q(List.cons[T](s0(q), s1(q)))"]}
{"goal":"r(List.cons(head, tail))","proof":["List.cons(head, tail).drop_last(List.cons(head, tail).length) != List.nil[T] or r(List.cons(head, tail))","not tail.length < tail.length.suc or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).drop_last(tail.length.suc) = List.nil[T]","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","tail.length < tail.length.suc","List.cons(head, tail).length = tail.length.suc","not tail.length < tail.length.suc or List.cons(head, tail).drop_last(tail.length.suc) = List.nil[T]","List.cons(head, tail).drop_last(List.cons(head, tail).length) != List.nil[T]","List.cons(head, tail).drop_last(tail.length.suc) != List.nil[T]"]}
{"goal":"drop_last_all","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not r(s1(r)) or r(List.cons[T](s0(r), s1(r)))","List.nil[T].drop_last(List.nil[T].length) != List.nil[T] or r(List.nil[T])","not r(l) or l.drop_last(l.length) = List.nil[T]","not r(l)","not r(List.cons[T](s0(r), s1(r))) or not r(List.nil[T]) or r(l)","List.nil[T] != List.nil[T] or List.nil[T].drop_last(List.nil[T].length) = List.nil[T]","not r(List.nil[T]) or r(s1(r)) or r(l)","List.nil[T].drop_last(List.nil[T].length) = List.nil[T]","r(List.nil[T])","r(s1(r))","not r(List.cons[T](s0(r), s1(r)))"]}
{"goal":"tail.length + b.length = (tail + b).length","proof":["tail.length + b.length = (tail + b).length"]}
{"goal":"tail.length + b.length = b.length + tail.length","proof":["tail.length + b.length = b.length + tail.length"]}
{"goal":"b.length <= b.length + tail.length","proof":["tail.length + b.length != b.length + tail.length or b.length <= tail.length + b.length","not b.length <= tail.length + b.length","b.length <= tail.length + b.length"]}
{"goal":"not b.length <= b.length + tail.length or not b.length + tail.length < b.length","proof":["not b.length + tail.length < b.length or not b.length <= b.length + tail.length"]}
{"goal":"List.cons(head, tail + b).drop_last(b.length) = List.cons(head, (tail + b).drop_last(b.length))","proof":["List.cons(head, tail + b) != List.cons(head, tail + b) or (tail + b).length < b.length or List.cons(head, tail + b).drop_last(b.length) = List.cons(head, (tail + b).drop_last(b.length))","(tail + b).length < b.length"]}
{"goal":"p(List.cons(head, tail))","proof":["(List.cons(head, tail) + b).drop_last(b.length) != List.cons(head, tail) or p(List.cons(head, tail))","not p(tail) or (tail + b).drop_last(b.length) = tail","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + b = List.cons(head, tail + b)","lib(util).flip(List.cons[T], (tail + b).drop_last(b.length), head) = List.cons(head, (tail + b).drop_last(b.length))","lib(util).flip(List.cons[T], tail, head) = List.cons(head, tail)","List.cons(head, tail) + b = List.cons(head, tail + b)","(List.cons(head, tail) + b).drop_last(b.length) != List.cons(head, tail)","(tail + b).drop_last(b.length) = tail"]}
{"goal":"drop_last_cancels_add","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","(List.nil[T] + b).drop_last(b.length) != List.nil[T] or p(List.nil[T])","not p(a) or (a + b).drop_last(b.length) = a","not p(a)","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(a)","not p(List.nil[T]) or p(s1(p)) or p(a)","List.nil[T] + b = b","(List.nil[T] + b).drop_last(b.length) = List.nil[T]","p(List.nil[T])","p(s1(p))","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"zero_until","proof":["n.range.drop(0) = 0.until(n)"]}
{"goal":"until_self","proof":["n.range.drop(n) = n.until(n)","n.range + List.nil[Nat] = n.range","n.range.length = n"]}
{"goal":"until_suc","proof":["n.suc != n.suc or n.range.append(n) = n.suc.range","n.range + List.singleton(n) = n.range.append(n)","lib(util).flip(List.drop[Nat], n, n.suc.range) = n.suc.range.drop(n)","lib(util).flip(List.drop[Nat], n.range.length, n.range + List.singleton(n)) = (n.range + List.singleton(n)).drop(n.range.length)","n.suc.range.drop(n) = n.until(n.suc)","n.range.length = n","n.range.append(n) = n.suc.range"]}
{"goal":"zero_upto","proof":["0.until(n.suc) = 0.upto(n)","0.until(n.suc) = n.suc.range"]}
{"goal":"upto_self","proof":["n.until(n.suc) = List.singleton(n)","n.until(n.suc) = n.upto(n)"]}
{"goal":"exists(k0: Nat) { a + k0 = b }","proof":["let s0: (Nat, Nat) -> Nat satisfy { forall(x0: Nat, x1: Nat) { not x0 <= x1 or x0 + s0(x0, x1) = x1 } and forall(x2: Nat, x3: Nat, x4: Nat) { x2 + x3 != x4 or x2 <= x4 } }","a + s0(a, b) != b","not a <= b or a + s0(a, b) = b"]}
{"goal":"f(0)","proof":["a.range + a.until(a + 0) != (a + 0).range or f(0)","a.range + List.nil[Nat] = a.range","a + 0 = a","a.range + a.until(a + 0) != (a + 0).range","a.range + a.until(a + 0) != a.range","a.range + a.until(a) != a.range"]}
{"goal":"a + x.suc = (a + x).suc","proof":["x.suc != x.suc or (a + x).suc = a + x.suc"]}
{"goal":"a.range + a.until(a + x) + List.singleton(a + x) = (a.range + a.until(a + x)).append(a + x)","proof":["a.range + a.until(a + x) + List.singleton(a + x) = (a.range + a.until(a + x)).append(a + x)"]}
{"goal":"(a + x.suc).range.drop(a) = a.until(a + x.suc)","proof":["(a + x.suc).range.drop(a) = a.until(a + x.suc)"]}
{"goal":"a.range.length = a","proof":["a.range.length = a"]}
{"goal":"(a + x).range.append(a + x) = (a + x).suc.range","proof":["(a + x).range.append(a + x) != (a + x.suc).range","(a + x).suc != a + x.suc or (a + x).range.append(a + x) = (a + x.suc).range"]}
{"goal":"a.range + a.until(a + x) = (a + x).range","proof":["not f(x) or a.range + a.until(a + x) = (a + x).range"]}
{"goal":"f(x.suc)","proof":["a.range + a.until(a + x.suc) != (a + x.suc).range or f(x.suc)","a.range + (a.until(a + x) + List.singleton(a + x)) = a.range + a.until(a + x) + List.singleton(a + x)","a.range + a.until(a + x.suc) != (a + x.suc).range"]}
{"goal":"f(k)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not f(s0(f)) or f(s0(f).suc)","not f(s0(f).suc) or not f(0) or f(k)","not f(s0(f).suc)","not f(0) or f(s0(f)) or f(k)","not f(s0(f))","f(s0(f))"]}
{"goal":"range_add_until","proof":["not f(k) or a.range + a.until(a + k) = (a + k).range","a.range + a.until(b) != (a + k).range","a.range + a.until(a + k) = (a + k).range","a.range + a.until(a + k) != (a + k).range"]}
{"goal":"m >= max_list(tail)","proof":["head.max(max_list(tail)) >= max_list(tail)","not head.max(k) >= max_list(tail)"]}
{"goal":"tail.contains(x) implies x <= m","proof":["not x ∈ tail or not f(tail) or x <= max_list(tail)","not lib(util).is_transitive[Nat](Nat.lte) or not x <= max_list(tail) or not max_list(tail) <= m or x <= m","m >= max_list(tail) = max_list(tail) <= m","max_list(tail) <= m","not x <= max_list(tail) or not max_list(tail) <= m","x <= max_list(tail)","not x <= max_list(tail)"]}
{"goal":"List.cons(head, tail).contains(x) implies x <= m","proof":["not x ∈ List.cons(head, tail) or List.cons(head, tail) != List.cons(head, tail) or x ∈ tail or x = head","m >= x = x <= m","not m >= x","head.max(k) >= head","not x ∈ List.cons(head, tail) or x ∈ tail or x = head","x = head","not m >= head"]}
{"goal":"head.max(max_list(tail)) = max_list(List.cons(head, tail))","proof":["List.cons(head, tail) != List.cons(head, tail) or max_list(List.cons(head, tail)) = head.max(max_list(tail))"]}
{"goal":"m = max_list(List.cons(head, tail))","proof":[]}
{"goal":"f(List.cons(head, tail))","proof":["let s0: List[Nat] -> Nat satisfy { forall(x0: List[Nat], x1: Nat) { not x1 ∈ x0 or not f(x0) or x1 <= max_list(x0) } and forall(x2: List[Nat]) { s0(x2) ∈ x2 or f(x2) } and forall(x3: List[Nat]) { not s0(x3) <= max_list(x3) or f(x3) } }","s0(List.cons(head, tail)) ∈ List.cons(head, tail) or f(List.cons(head, tail))","not s0(List.cons(head, tail)) <= max_list(List.cons(head, tail)) or f(List.cons(head, tail))","not s0(List.cons(head, tail)) ∈ List.cons(head, tail) or s0(List.cons(head, tail)) <= m","s0(List.cons(head, tail)) ∈ List.cons(head, tail)","not s0(List.cons(head, tail)) <= max_list(List.cons(head, tail))","s0(List.cons(head, tail)) <= m","not s0(List.cons(head, tail)) <= m"]}
{"goal":"f(list)","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not f(s1(f)) or f(List.cons[Nat](s0(f), s1(f)))","let s2: List[Nat] -> Nat satisfy { forall(x4: List[Nat], x5: Nat) { not x5 ∈ x4 or not f(x4) or x5 <= max_list(x4) } and forall(x6: List[Nat]) { s2(x6) ∈ x6 or f(x6) } and forall(x7: List[Nat]) { not s2(x7) <= max_list(x7) or f(x7) } }","s2(List.nil[Nat]) ∈ List.nil[Nat] or f(List.nil[Nat])","not f(List.cons[Nat](s0(f), s1(f))) or not f(List.nil[Nat]) or f(list)","not f(List.nil[Nat]) or f(s1(f)) or f(list)","not s2(List.nil[Nat]) ∈ List.nil[Nat] or List.nil[Nat] != List.nil[Nat]","not f(List.nil[Nat]) or f(s1(f))","not s2(List.nil[Nat]) ∈ List.nil[Nat]","f(List.nil[Nat])","f(s1(f))","not f(List.cons[Nat](s0(f), s1(f)))"]}
{"goal":"list_has_max","proof":["let s0: Nat satisfy { s0 ∈ list and not s0 <= n }","not s0 ∈ list or not f(list) or s0 <= max_list(list)","not lib(util).is_transitive[Nat](Nat.lte) or not s0 <= max_list(list) or not max_list(list) <= n or s0 <= n","s0 <= max_list(list)","not s0 <= max_list(list) or not max_list(list) <= n"]}
{"goal":"no_list_contains_nat","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { x0 < s0(x0) } and forall(x1: Nat) { s0(x1).is_prime } }","s0(max_list(list)) ∈ list","not max_list(list) <= max_list(list) or not s0(max_list(list)) ∈ list or s0(max_list(list)) <= max_list(list)","not max_list(list) < s0(max_list(list)) or not s0(max_list(list)) <= max_list(list)","max_list(list) < s0(max_list(list))","max_list(list) <= max_list(list)","not max_list(list) <= max_list(list) or s0(max_list(list)) <= max_list(list)","s0(max_list(list)) <= max_list(list)","not max_list(list) < s0(max_list(list))"]}
{"goal":"p(List.cons(head, tail))","proof":["not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length or p(List.cons(head, tail))","List.cons(head, tail) != List.cons(head, tail) or head != item or List.cons(head, tail).find_first_idx(item) = 0","List.cons(head, tail).length < 0 or 0 < List.cons(head, tail).length or List.cons(head, tail).length = 0","List.cons(head, tail).length != 0 or List.cons(head, tail) = List.nil[T]","not item ∈ List.cons(head, tail) or List.cons(head, tail) != List.nil[T]","not List.cons(head, tail).length < 0","List.cons(head, tail) != List.nil[T]","not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).find_first_idx(item) = 0","List.cons(head, tail).find_first_idx(item) = 0","not 0 < List.cons(head, tail).length","List.cons(head, tail).length != 0","List.cons(head, tail).length = 0"]}
{"goal":"tail.contains(item)","proof":["not item ∈ List.cons(head, tail) or List.cons(head, tail) != List.cons(head, tail) or item ∈ tail or head = item","not item ∈ List.cons(head, tail) or item ∈ tail or head = item"]}
{"goal":"tail.find_first_idx(item) < tail.length","proof":["not item ∈ tail or not p(tail) or tail.find_first_idx(item) < tail.length"]}
{"goal":"1 + tail.find_first_idx(item) = tail.find_first_idx(item).suc","proof":["1 + tail.find_first_idx(item) = tail.find_first_idx(item).suc"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","List.cons(head, tail) != List.cons(head, tail)"]}
{"goal":"not tail.length <= tail.find_first_idx(item) or not tail.find_first_idx(item) < tail.length","proof":["not tail.find_first_idx(item) < tail.length or not tail.length <= tail.find_first_idx(item)"]}
{"goal":"tail.length.suc <= tail.find_first_idx(item).suc or tail.find_first_idx(item).suc < tail.length.suc","proof":["tail.find_first_idx(item).suc < tail.length.suc or tail.length.suc <= tail.find_first_idx(item).suc"]}
{"goal":"not tail.length.suc <= tail.find_first_idx(item).suc or tail.length <= tail.find_first_idx(item)","proof":["not tail.length.suc <= tail.find_first_idx(item).suc or tail.length <= tail.find_first_idx(item)"]}
{"goal":"p(List.cons(head, tail))","proof":["not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length or p(List.cons(head, tail))","List.cons(head, tail) != List.cons(head, tail) or 1 + tail.find_first_idx(item) = List.cons(head, tail).find_first_idx(item) or head = item","List.cons(head, tail).length > List.cons(head, tail).find_first_idx(item) = List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length","tail.length.suc > tail.find_first_idx(item).suc = tail.find_first_idx(item).suc < tail.length.suc","not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length","List.cons(head, tail) != List.cons(head, tail) or 1 + tail.find_first_idx(item) = List.cons(head, tail).find_first_idx(item)","1 + tail.find_first_idx(item) = List.cons(head, tail).find_first_idx(item)"]}
{"goal":"find_first_idx_contains","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","item ∈ List.cons[T](s0(p), s1(p)) or p(List.cons[T](s0(p), s1(p)))","item ∈ List.nil[T] or p(List.nil[T])","not item ∈ List.cons[T](s0(p), s1(p)) or not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","not item ∈ list or not p(list) or list.find_first_idx(item) < list.length","not p(list)","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","not item ∈ List.nil[T] or List.nil[T] != List.nil[T]","not item ∈ List.nil[T]","p(List.nil[T])","p(s1(p))","not p(List.cons[T](s0(p), s1(p)))","item ∈ List.cons[T](s0(p), s1(p))","not item ∈ List.cons[T](s0(p), s1(p))"]}
{"goal":"List.cons(head, tail).find_first_idx(item) = 0","proof":["List.cons(head, tail) != List.cons(head, tail) or head != item or List.cons(head, tail).find_first_idx(item) = 0","List.cons(head, tail) != List.cons(head, tail) or head != item"]}
{"goal":"List.cons(head, tail).get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != List.cons(head, tail) or 0 > 0 or List.cons(head, tail).get_idx(0) = Option.some(head)","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","not 0 - 1 - s0 < 0","0 > 0 or List.cons(head, tail).get_idx(0) = Option.some(head)","0 > 0"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item) or p(List.cons(head, tail))","List.cons(head, tail).get_idx(0) = Option.some(item)","List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item)","List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) = Option.some(item)"]}
{"goal":"1 + idx = idx.suc","proof":["1 + idx = idx.suc"]}
{"goal":"idx.suc != 0","proof":["0 < 0 + idx.suc","0 + idx.suc = idx.suc","not 0 < idx.suc or idx.suc != 0","not 0 < idx.suc"]}
{"goal":"not idx.suc < 0","proof":["not idx.suc <= 0 or idx.suc = 0","not idx.suc < 0 or idx.suc <= 0","not idx.suc <= 0","idx.suc <= 0"]}
{"goal":"idx.suc > 0 = 0 < idx.suc","proof":["idx.suc > 0 = 0 < idx.suc"]}
{"goal":"0 < idx.suc or idx.suc < 0 or idx.suc = 0","proof":["idx.suc < 0 or 0 < idx.suc or idx.suc = 0"]}
{"goal":"idx.suc > 0","proof":[]}
{"goal":"idx.suc - 1 = idx","proof":["idx + 1 != idx.suc or idx.suc - 1 = idx","idx + 1 = 1 + idx","idx + 1 != idx.suc","idx + 1 = idx.suc"]}
{"goal":"tail.get_idx(idx.suc - 1) = List.cons(head, tail).get_idx(idx.suc)","proof":["not idx.suc > 0 or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).get_idx(idx.suc) = tail.get_idx(idx.suc - 1)","List.cons(head, tail) != List.cons(head, tail)"]}
{"goal":"List.cons(head, tail).get_idx(1 + idx) = tail.get_idx(idx)","proof":[]}
{"goal":"tail.contains(item)","proof":["not item ∈ List.cons(head, tail) or List.cons(head, tail) != List.cons(head, tail) or item ∈ tail or head = item","not item ∈ List.cons(head, tail) or item ∈ tail or head = item"]}
{"goal":"List.cons(head, tail).find_first_idx(item) = 1 + tail.find_first_idx(item)","proof":["List.cons(head, tail) != List.cons(head, tail) or 1 + tail.find_first_idx(item) = List.cons(head, tail).find_first_idx(item) or head = item","List.cons(head, tail) != List.cons(head, tail) or head = item"]}
{"goal":"tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","proof":["not item ∈ tail or not p(tail) or tail.get_idx(tail.find_first_idx(item)) = Option.some(item)"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item) or p(List.cons(head, tail))","List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item)"]}
{"goal":"find_first_idx_get_idx","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","item ∈ List.cons[T](s0(p), s1(p)) or p(List.cons[T](s0(p), s1(p)))","item ∈ List.nil[T] or p(List.nil[T])","not item ∈ List.cons[T](s0(p), s1(p)) or not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","not item ∈ list or not p(list) or list.get_idx(list.find_first_idx(item)) = Option.some(item)","not p(list)","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","not item ∈ List.nil[T] or List.nil[T] != List.nil[T]","not item ∈ List.nil[T]","p(List.nil[T])","p(s1(p))","not p(List.cons[T](s0(p), s1(p)))","item ∈ List.cons[T](s0(p), s1(p))","not item ∈ List.cons[T](s0(p), s1(p))"]}
{"goal":"p(List.nil[T])","proof":["i + 1 < List.nil[T].length or p(List.nil[T])","List.nil[T] != List.nil[T] or List.nil[T].length = 0","not i + 1 < 0","List.nil[T].length = 0","i + 1 < List.nil[T].length"]}
{"goal":"i + 1 = i.suc","proof":["i + 1 = 1 + i","1 + i != i.suc","1 + i = i.suc"]}
{"goal":"i.suc != 0","proof":["0 < 0 + i.suc","0 + i.suc = i.suc","not 0 < i.suc or i.suc != 0","not 0 < i.suc"]}
{"goal":"not i.suc < 0","proof":["not i.suc <= 0 or i.suc = 0","not i.suc < 0 or i.suc <= 0","not i.suc <= 0","i.suc <= 0"]}
{"goal":"i + 1 - 1 = i","proof":["i.suc - 1 != i","i + 1 != i.suc or i.suc - 1 = i"]}
{"goal":"i + 1 > 0 = 0 < i + 1","proof":["i + 1 > 0 = 0 < i + 1"]}
{"goal":"not i + 1 > 0 or List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i + 1 - 1)","proof":["not i + 1 > 0 or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i + 1 - 1)","List.cons(head, tail) != List.cons(head, tail)"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i)","proof":["i.suc < 0 or 0 < i.suc or i.suc = 0","i + 1 - 1 = i","i + 1 = i.suc","i + 1 > 0 = 0 < i.suc","0 < i.suc","List.cons(head, tail).get_idx(i + 1) != tail.get_idx(i + 1 - 1)","i + 1 > 0","not i + 1 > 0"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(i + 1) != List.cons(head, tail).tail.get_idx(i) or p(List.cons(head, tail))","List.cons(head, tail).tail = tail","List.cons(head, tail).get_idx(i + 1) != List.cons(head, tail).tail.get_idx(i)"]}
{"goal":"get_idx_succ_implies_tail","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","i + 1 < List.cons[T](s0(p), s1(p)).length or p(List.cons[T](s0(p), s1(p)))","not i + 1 < List.cons[T](s0(p), s1(p)).length or not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","not i + 1 < list.length or not p(list) or list.get_idx(i + 1) = list.tail.get_idx(i)","not p(list)","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p)) or p(list)","p(s1(p))","not p(List.cons[T](s0(p), s1(p))) or p(list)","not p(List.cons[T](s0(p), s1(p)))","i + 1 < List.cons[T](s0(p), s1(p)).length","not i + 1 < List.cons[T](s0(p), s1(p)).length"]}
{"goal":"p(List.nil[T])","proof":["List.nil[T].count(item) > 1 or p(List.nil[T])","List.nil[T] != List.nil[T] or List.nil[T].count(item) = 0","0 > 1 = 1 < 0","not 1 < 0","List.nil[T].count(item) > 1","List.nil[T].count(item) = 0","0 > 1"]}
{"goal":"tail.contains(item)","proof":["List.cons(item, tail) != List.cons(item, tail) or item != item or 1 + tail.count(item) = List.cons(item, tail).count(item)","tail.count(item) = 0 or item ∈ tail","List.cons(head, tail).count(item) > 1 = 1 < List.cons(head, tail).count(item)","let s0: Nat satisfy { true }","1 + s0 = s0.suc","not 1 < List.cons(head, tail).count(item) or List.cons(head, tail).count(item) != 1","tail.count(item) = 0","1 < List.cons(head, tail).count(item)","1.add = Nat.suc","item != item or 1 + tail.count(item) = List.cons(item, tail).count(item)","List.cons(head, tail).count(item) != 1","1 + tail.count(item) = List.cons(item, tail).count(item)"]}
{"goal":"idx + 1 < tail.length + 1","proof":["not idx < tail.length or 1 + idx < 1 + tail.length","not item ∈ tail or tail.find_first_idx(item) < tail.length","tail.length + 1 = 1 + tail.length","not idx + 1 < 1 + tail.length","idx + 1 = 1 + idx","not 1 + idx < 1 + tail.length","not idx < tail.length","tail.find_first_idx(item) < tail.length","not tail.find_first_idx(item) < tail.length"]}
{"goal":"idx + 1 > 0","proof":["0 < 0 + idx.suc","idx + 1 = 1 + idx","not 1 + idx > 0","idx.suc > 0 = 0 < idx.suc","1 + idx = idx.suc","not idx.suc > 0","not 0 < idx.suc","0 + idx.suc = idx.suc"]}
{"goal":"idx + 1 - 1 = idx","proof":["idx + 1 != idx + 1 or idx + 1 - 1 = idx"]}
{"goal":"List.cons(head, tail).get_idx(idx + 1) = tail.get_idx(idx)","proof":["not idx + 1 > 0 or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).get_idx(idx + 1) = tail.get_idx(idx + 1 - 1)","idx + 1 - 1 = idx","not idx + 1 > 0 or List.cons(head, tail).get_idx(idx + 1) = tail.get_idx(idx + 1 - 1)","List.cons(head, tail).get_idx(idx + 1) != tail.get_idx(idx + 1 - 1)"]}
{"goal":"i < j","proof":["not 0 < j","j > 0","j > 0 = 0 < j"]}
{"goal":"List.cons(head, tail).get_idx(i) = Option.some(head)","proof":["List.cons(item, tail).get_idx(i) != Option.some(head)","List.cons(item, tail) != List.cons(item, tail) or i > 0 or List.cons(item, tail).get_idx(i) = Option.some(item)","i > 0 = 0 < i","not 0 < i or 0 != i","List.cons(item, tail).get_idx(i) != Option.some(item)","not i > 0 or 0 < i","not 0 < i","i > 0 or List.cons(item, tail).get_idx(i) = Option.some(item)","not i > 0","i > 0"]}
{"goal":"tail.length + 1 = tail.length.suc","proof":["tail.length + 1 = 1 + tail.length","1 + tail.length != tail.length.suc","1 + tail.length = tail.length.suc"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","List.cons(head, tail) != List.cons(head, tail)"]}
{"goal":"not tail.contains(item) or tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","proof":["not item ∈ tail or tail.get_idx(tail.find_first_idx(item)) = Option.some(item)"]}
{"goal":"j < List.cons(head, tail).length","proof":[]}
{"goal":"List.cons(head, tail).get_idx(j) = Option.some(item)","proof":[]}
{"goal":"0 < j","proof":["not i < j"]}
{"goal":"p(List.cons(head, tail))","proof":["not j < List.cons(head, tail).length or List.cons(head, tail).get_idx(i) != Option.some(item) or List.cons(head, tail).get_idx(j) != Option.some(item) or not i < j or p(List.cons(head, tail))","List.cons(head, tail).get_idx(i) = Option.some(item)","List.cons(head, tail).get_idx(i) != Option.some(item) or not i < j"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < tail.length and tail.get_idx(k0) = Option.some(item) and tail.get_idx(k1) = Option.some(item) }","proof":["let  (s0: List[T] -> Nat, s1: List[T] -> Nat) satisfy { forall(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s0(x0) < s1(x0) } and forall(x1: List[T]) { not x1.count(item) > 1 or not p(x1) or s1(x1) < x1.length } and forall(x2: List[T]) { not x2.count(item) > 1 or not p(x2) or x2.get_idx(s0(x2)) = Option.some[T](item) } and forall(x3: List[T]) { not x3.count(item) > 1 or not p(x3) or x3.get_idx(s1(x3)) = Option.some[T](item) } and forall(x4: List[T]) { x4.count(item) > 1 or p(x4) } and forall(x5: Nat, x6: List[T], x7: Nat) { not x5 < x6.length or Option.some[T](item) != x6.get_idx(x7) or Option.some[T](item) != x6.get_idx(x5) or not x7 < x5 or p(x6) } }","not s1(tail) < tail.length or tail.get_idx(s0(tail)) != Option.some(item) or tail.get_idx(s1(tail)) != Option.some(item) or not s0(tail) < s1(tail)","not tail.count(item) > 1 or not p(tail) or s0(tail) < s1(tail)","not tail.count(item) > 1 or not p(tail) or s1(tail) < tail.length","not tail.count(item) > 1 or not p(tail) or tail.get_idx(s1(tail)) = Option.some(item)","not tail.count(item) > 1 or not p(tail) or tail.get_idx(s0(tail)) = Option.some(item)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).count(item) = tail.count(item) or head = item","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).count(item) = tail.count(item)","not tail.count(item) > 1 or s0(tail) < s1(tail)","not tail.count(item) > 1 or s1(tail) < tail.length","not tail.count(item) > 1 or tail.get_idx(s1(tail)) = Option.some(item)","List.cons(head, tail).count(item) = tail.count(item)","tail.count(item) > 1","s0(tail) < s1(tail)","s1(tail) < tail.length","tail.get_idx(s1(tail)) = Option.some(item)","tail.get_idx(s0(tail)) = Option.some(item)","tail.get_idx(s0(tail)) != Option.some(item)"]}
{"goal":"i + 1 > 0","proof":["0 < 0 + i.suc","i + 1 = 1 + i","not 1 + i > 0","i.suc > 0 = 0 < i.suc","1 + i = i.suc","not i.suc > 0","not 0 < i.suc","0 + i.suc = i.suc"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i)","proof":["not i + 1 > 0 or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i + 1 - 1)","i + 1 - 1 = i","not i + 1 > 0 or List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i + 1 - 1)","List.cons(head, tail).get_idx(i + 1) != tail.get_idx(i + 1 - 1)"]}
{"goal":"j + 1 > 0","proof":["0 < 0 + j.suc","j + 1 = 1 + j","not 1 + j > 0","j.suc > 0 = 0 < j.suc","1 + j = j.suc","not j.suc > 0","not 0 < j.suc","0 + j.suc = j.suc"]}
{"goal":"List.cons(head, tail).get_idx(j + 1) = tail.get_idx(j)","proof":["not j + 1 > 0 or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).get_idx(j + 1) = tail.get_idx(j + 1 - 1)","j + 1 - 1 = j","not j + 1 > 0 or List.cons(head, tail).get_idx(j + 1) = tail.get_idx(j + 1 - 1)","List.cons(head, tail).get_idx(j + 1) != tail.get_idx(j + 1 - 1)"]}
{"goal":"i + 1 < j + 1","proof":["not i < j or 1 + i < 1 + j","i + 1 = 1 + i","not 1 + i < j + 1","j + 1 = 1 + j","not 1 + i < 1 + j"]}
{"goal":"j + 1 = j.suc","proof":["j + 1 = 1 + j","1 + j != j.suc","1 + j = j.suc"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","List.cons(head, tail) != List.cons(head, tail)"]}
{"goal":"tail.length.suc <= j.suc or j.suc < tail.length.suc","proof":["j.suc < tail.length.suc or tail.length.suc <= j.suc"]}
{"goal":"not tail.length <= j or not j < tail.length","proof":["not j < tail.length or not tail.length <= j"]}
{"goal":"not tail.length.suc <= j.suc or tail.length <= j","proof":["not tail.length.suc <= j.suc or tail.length <= j"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = Option.some(item)","proof":["List.cons(head, tail).get_idx(i + 1) != tail.get_idx(i)"]}
{"goal":"List.cons(head, tail).get_idx(j + 1) = Option.some(item)","proof":["List.cons(head, tail).get_idx(j + 1) != tail.get_idx(j)"]}
{"goal":"j + 1 < List.cons(head, tail).length","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["not j + 1 < List.cons(head, tail).length or List.cons(head, tail).get_idx(i + 1) != Option.some(item) or List.cons(head, tail).get_idx(j + 1) != Option.some(item) or not i + 1 < j + 1 or p(List.cons(head, tail))","not i + 1 < j + 1 or List.cons(head, tail).get_idx(i + 1) != Option.some(item)"]}
{"goal":"p(list)","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","List.cons[T](s0(p), s1(p)).count(item) > 1 or p(List.cons[T](s0(p), s1(p)))","not List.cons[T](s0(p), s1(p)).count(item) > 1 or not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","p(s1(p))","not p(List.cons[T](s0(p), s1(p)))","List.cons[T](s0(p), s1(p)).count(item) > 1","not List.cons[T](s0(p), s1(p)).count(item) > 1"]}
{"goal":"duplicate_implies_duplicate_idx","proof":["let  (s0: List[T] -> Nat, s1: List[T] -> Nat) satisfy { forall(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s0(x0) < s1(x0) } and forall(x1: List[T]) { not x1.count(item) > 1 or not p(x1) or s1(x1) < x1.length } and forall(x2: List[T]) { not x2.count(item) > 1 or not p(x2) or x2.get_idx(s0(x2)) = Option.some[T](item) } and forall(x3: List[T]) { not x3.count(item) > 1 or not p(x3) or x3.get_idx(s1(x3)) = Option.some[T](item) } and forall(x4: List[T]) { x4.count(item) > 1 or p(x4) } and forall(x5: Nat, x6: List[T], x7: Nat) { not x5 < x6.length or Option.some[T](item) != x6.get_idx(x7) or Option.some[T](item) != x6.get_idx(x5) or not x7 < x5 or p(x6) } }","not s1(list) < list.length or list.get_idx(s0(list)) != Option.some(item) or list.get_idx(s1(list)) != Option.some(item) or not s0(list) < s1(list)","not list.count(item) > 1 or not p(list) or s0(list) < s1(list)","not list.count(item) > 1 or not p(list) or s1(list) < list.length","not list.count(item) > 1 or not p(list) or list.get_idx(s1(list)) = Option.some(item)","not list.count(item) > 1 or not p(list) or list.get_idx(s0(list)) = Option.some(item)","s0(list) < s1(list)","s1(list) < list.length","list.get_idx(s0(list)) = Option.some(item)","list.get_idx(s1(list)) = Option.some(item)","list.get_idx(s1(list)) != Option.some(item)"]}
{"goal":"list.unique.length < list.length implies exists(k0: T) { list.count(k0) > 1 }","proof":["let s0[T0]: List[T0] -> T0 satisfy { forall(x0: List[T0]) { not x0.unique.length < x0.length or x0.count(s0(x0)) > 1 } }","not list.count(s0(list)) > 1","not list.unique.length < list.length or list.count(s0(list)) > 1"]}
{"goal":"exists(k0: T) { list.count(k0) > 1 }","proof":["let s0: T satisfy { not list.unique.length < list.length or list.count(s0) > 1 }","not list.count(s0) > 1"]}
{"goal":"list.count(item) > 1 implies exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < list.length and list.get_idx(k0) = Option.some(item) and list.get_idx(k1) = Option.some(item) }","proof":["let [T0] (s0: (List[T0], T0) -> Nat, s1: (List[T0], T0) -> Nat) satisfy { forall(x0: List[T0], x1: T0) { not x0.count(x1) > 1 or s0(x0, x1) < s1(x0, x1) } and forall(x2: List[T0], x3: T0) { not x2.count(x3) > 1 or s1(x2, x3) < x2.length } and forall(x4: List[T0], x5: T0) { not x4.count(x5) > 1 or x4.get_idx(s0(x4, x5)) = Option.some[T0](x5) } and forall(x6: List[T0], x7: T0) { not x6.count(x7) > 1 or x6.get_idx(s1(x6, x7)) = Option.some[T0](x7) } }","not s1(list, item) < list.length or list.get_idx(s0(list, item)) != Option.some(item) or list.get_idx(s1(list, item)) != Option.some(item) or not s0(list, item) < s1(list, item)","not list.count(item) > 1 or s1(list, item) < list.length","not list.count(item) > 1 or list.get_idx(s1(list, item)) = Option.some(item)","not list.count(item) > 1 or list.get_idx(s0(list, item)) = Option.some(item)","not list.count(item) > 1 or s0(list, item) < s1(list, item)","s1(list, item) < list.length","s0(list, item) < s1(list, item)","list.get_idx(s0(list, item)) = Option.some(item)","list.get_idx(s1(list, item)) = Option.some(item)","list.get_idx(s1(list, item)) != Option.some(item)"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < list.length and list.get_idx(k0) = Option.some(item) and list.get_idx(k1) = Option.some(item) }","proof":["let  (s0: Nat, s1: Nat) satisfy { not list.count(item) > 1 or s0 < s1 and (not list.count(item) > 1 or s1 < list.length) and (not list.count(item) > 1 or list.get_idx(s0) = Option.some[T](item)) and (not list.count(item) > 1 or list.get_idx(s1) = Option.some[T](item)) }","not s1 < list.length or list.get_idx(s0) != Option.some(item) or list.get_idx(s1) != Option.some(item) or not s0 < s1","list.get_idx(s0) != Option.some(item)"]}
{"goal":"list.get_idx(i) = list.get_idx(j)","proof":["list.get_idx(i) != Option.some(item)"]}
{"goal":"index_pigeonhole","proof":["let s0: T satisfy { not list.unique.length < list.length or list.count(s0) > 1 }","let [T0] (s1: (List[T0], T0) -> Nat, s2: (List[T0], T0) -> Nat) satisfy { forall(x0: List[T0], x1: T0) { not x0.count(x1) > 1 or s1(x0, x1) < s2(x0, x1) } and forall(x2: List[T0], x3: T0) { not x2.count(x3) > 1 or s2(x2, x3) < x2.length } and forall(x4: List[T0], x5: T0) { not x4.count(x5) > 1 or x4.get_idx(s1(x4, x5)) = Option.some[T0](x5) } and forall(x6: List[T0], x7: T0) { not x6.count(x7) > 1 or x6.get_idx(s2(x6, x7)) = Option.some[T0](x7) } }","not s2(list, s0) < list.length or list.get_idx(s2(list, s0)) != list.get_idx(s1(list, s0)) or not s1(list, s0) < s2(list, s0)","not list.count(s0) > 1 or s2(list, s0) < list.length","not list.count(s0) > 1 or list.get_idx(s2(list, s0)) = Option.some(s0)","not list.count(s0) > 1 or list.get_idx(s1(list, s0)) = Option.some(s0)","not list.count(s0) > 1 or s1(list, s0) < s2(list, s0)","s2(list, s0) < list.length","s1(list, s0) < s2(list, s0)","list.get_idx(s1(list, s0)) = Option.some(s0)","list.get_idx(s2(list, s0)) = Option.some(s0)","list.get_idx(s2(list, s0)) != list.get_idx(s1(list, s0))","list.get_idx(s2(list, s0)) = list.get_idx(s1(list, s0))"]}
{"goal":"pl(0, l)","proof":["0 < l.length or pl(0, l)","List.nil[T] != l or l.length = 0","not 0 < l.length or l.length != 0","0 < l.length","l.length = 0","l.length != 0"]}
{"goal":"List.cons(head, tail) = l","proof":[]}
{"goal":"l.get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != l or 0 > 0 or l.get_idx(0) = Option.some(head)","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","not 0 - 1 - s0 < 0","List.cons(head, tail) != l or 0 > 0","0 > 0"]}
{"goal":"pl(0, l)","proof":["l.get_idx(0) != Option.some(head) or pl(0, l)"]}
{"goal":"pl(0, l)","proof":["pl(0, l)"]}
{"goal":"p(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pl(x0, x1) } and forall(x2: Nat) { not pl(x2, s0(x2)) or p(x2) } }","pl(0, s0(0))","not pl(0, s0(0)) or p(0)"]}
{"goal":"i + 1 < l.length","proof":["i + 1 < l.length or l.length <= i + 1","i + 1 >= l.length = l.length <= i + 1","l.length <= i + 1","not l.length <= i + 1"]}
{"goal":"exists(k0: T) { tail.get_idx(i) = Option.some(k0) }","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pl(x0, x1) or Option.some[T](s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { x2 < x3.length or pl(x2, x3) } and forall(x4: List[T], x5: Nat, x6: T) { x4.get_idx(x5) != Option.some[T](x6) or pl(x5, x4) } }","Option.some(s0(i, tail)) != tail.get_idx(i)","not p(i) or pl(i, tail)","not i < tail.length or not pl(i, tail) or Option.some(s0(i, tail)) = tail.get_idx(i)","List.cons(head, tail) != l or tail.length.suc = l.length","not i.suc < tail.length.suc or i < tail.length","i + 1 = i.suc","i.suc < l.length","pl(i, tail)","not i < tail.length","tail.length.suc = l.length","not i.suc < tail.length.suc","i.suc < tail.length.suc"]}
{"goal":"not i + 1 < l.length or l.get_idx(i + 1) = l.tail.get_idx(i)","proof":["not i + 1 < l.length or l.get_idx(i + 1) = l.tail.get_idx(i)"]}
{"goal":"List.cons(head, tail) != l or l.tail = tail","proof":["List.cons(head, tail) != l or l.tail = tail"]}
{"goal":"pl(i + 1, l)","proof":["l.get_idx(i + 1) != Option.some(x) or pl(i + 1, l)","l.get_idx(i + 1) = tail.get_idx(i)","l.get_idx(i + 1) != Option.some(x)"]}
{"goal":"i + 1 < l.length or pl(i + 1, l)","proof":["i + 1 < l.length or pl(i + 1, l)"]}
{"goal":"l.length <= i + 1 = i + 1 >= l.length","proof":["i + 1 >= l.length = l.length <= i + 1"]}
{"goal":"not l.length <= i + 1 or not i + 1 < l.length","proof":["i + 1 >= l.length","not i + 1 ∈ l.length.range or not i + 1 >= l.length","not i + 1 < l.length or i + 1 ∈ l.length.range","not i + 1 ∈ l.length.range","i + 1 ∈ l.length.range"]}
{"goal":"i + 1 = 1 + i","proof":["i + 1 = 1 + i"]}
{"goal":"1 + i = i.suc","proof":["1 + i = i.suc"]}
{"goal":"i.suc - 0 = i.suc","proof":["i.suc + 0 - 0 = i.suc","i.suc + 0 = i.suc"]}
{"goal":"not i + 1 < l.length or i + 1 != l.length","proof":["l.length < l.length","not l.length < l.length or not l.length < l.length"]}
{"goal":"pl(i + 1, l)","proof":["not i + 1 >= l.length","List.nil[T] = l","List.nil[T] != l or l.length = 0","not i + 1 < 0","l.length = 0"]}
{"goal":"pl(i + 1, l)","proof":["pl(i + 1, l)"]}
{"goal":"p(i + 1)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pl(x0, x1) } and forall(x2: Nat) { not pl(x2, s0(x2)) or p(x2) } }","not pl(i + 1, s0(i + 1)) or p(i + 1)","pl(i + 1, s0(i + 1))"]}
{"goal":"p(idx)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not p(s0(p)) or p(s0(p) + 1)","not p(s0(p).suc) or not p(0) or p(idx)","not p(s0(p).suc)","not p(0) or p(s0(p)) or p(idx)","p(s0(p))","s0(p) + 1 = s0(p).suc","p(s0(p) + 1)","not p(s0(p) + 1)"]}
{"goal":"pl(idx, list)","proof":["not p(idx) or pl(idx, list)"]}
{"goal":"get_idx_always_some","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pl(x0, x1) or Option.some[T](s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { x2 < x3.length or pl(x2, x3) } and forall(x4: List[T], x5: Nat, x6: T) { x4.get_idx(x5) != Option.some[T](x6) or pl(x5, x4) } }","Option.some(s0(idx, list)) != list.get_idx(idx)","not idx < list.length or not pl(idx, list) or Option.some(s0(idx, list)) = list.get_idx(idx)"]}
{"goal":"pf(0, l)","proof":["0 < l.length or pf(0, l)","List.nil[T] != l or l.length = 0","not 0 < l.length or l.length != 0","0 < l.length","l.length = 0","l.length != 0"]}
{"goal":"map[T, U](l, f).get_idx(0) = Option.some(f(head))","proof":["List.cons(f(head), tail.map(f)) != l.map(f) or 0 > 0 or l.map(f).get_idx(0) = Option.some(f(head))","List.cons(head, tail) != l or List.cons(f(head), tail.map(f)) = l.map(f)","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","map[T, U](l, f) = l.map(f)","l.map(f).get_idx(0) != Option.some(f(head))","not 0 - 1 - s0 < 0","List.cons(f(head), tail.map(f)) != l.map(f) or 0 > 0","List.cons(f(head), tail.map(f)) = l.map(f)","0 > 0"]}
{"goal":"pf(0, l)","proof":["map[T, U](l, f).get_idx(0) != Option.some(f(head)) or l.get_idx(0) != Option.some(head) or pf(0, l)","not head ∈ l or l.get_idx(l.find_first_idx(head)) = Option.some(head)","List.cons(head, tail) != l or head != head or l.find_first_idx(head) = 0","List.cons(head, tail) != l or head != head or head ∈ l","l.get_idx(0) != Option.some(head)","List.cons(head, tail) != l or head ∈ l","List.cons(head, tail) != l or l.find_first_idx(head) = 0","head ∈ l","l.find_first_idx(head) = 0","l.get_idx(l.find_first_idx(head)) = Option.some(head)","l.get_idx(l.find_first_idx(head)) != Option.some(head)"]}
{"goal":"pf(0, l)","proof":["pf(0, l)"]}
{"goal":"p(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pf(x0, x1) } and forall(x2: Nat) { not pf(x2, s0(x2)) or p(x2) } }","pf(0, s0(0))","not pf(0, s0(0)) or p(0)"]}
{"goal":"pf(i + 1, l)","proof":["i + 1 < l.length or pf(i + 1, l)","not i + 1 < l.length or not l.length <= i + 1","i + 1 >= l.length = l.length <= i + 1","l.length <= i + 1","i + 1 < l.length","not i + 1 < l.length"]}
{"goal":"i + 1 = i.suc","proof":["i + 1 = 1 + i","1 + i != i.suc","1 + i = i.suc"]}
{"goal":"i.suc != 0","proof":["0 < 0 + i.suc","0 + i.suc = i.suc","not 0 < i.suc or i.suc != 0","not 0 < i.suc"]}
{"goal":"i + 1 > 0","proof":["0 < i.suc or i.suc <= 0","not i.suc <= 0 or i.suc = 0","i + 1 > 0 = 0 < i + 1","not 0 < i + 1","not 0 < i.suc","not i.suc <= 0","i.suc <= 0"]}
{"goal":"i + 1 - 1 = i","proof":["i.suc - 1 != i","i + 1 != i.suc or i.suc - 1 = i"]}
{"goal":"tail.get_idx(i + 1 - 1) = l.get_idx(i + 1)","proof":["not i + 1 > 0 or List.cons(head, tail) != l or tail.get_idx(i + 1 - 1) = l.get_idx(i + 1)","List.cons(head, tail) != l"]}
{"goal":"l.get_idx(i + 1) = tail.get_idx(i)","proof":["tail.get_idx(i + 1 - 1) != l.get_idx(i + 1)"]}
{"goal":"i < tail.length","proof":["List.cons(head, tail) != l or tail.length.suc = l.length","not i.suc < tail.length.suc or i < tail.length","i.suc < tail.length.suc or tail.length.suc <= i.suc","i + 1 >= l.length = l.length <= i + 1","i + 1 = i.suc","not l.length <= i + 1","not i.suc < tail.length.suc","not l.length <= i.suc","tail.length.suc = l.length","tail.length.suc <= i.suc","not tail.length.suc <= i.suc"]}
{"goal":"pf(i, tail)","proof":["not p(i) or pf(i, tail)"]}
{"goal":"exists(k0: T) { tail.get_idx(i) = Option.some(k0) and map[T, U](tail, f).get_idx(i) = Option.some(f(k0)) }","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or Option.some[T](s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { not x2 < x3.length or not pf(x2, x3) or map[T, U](x3, f).get_idx(x2) = Option.some[U](f(s0(x2, x3))) } and forall(x4: Nat, x5: List[T]) { x4 < x5.length or pf(x4, x5) } and forall(x6: List[T], x7: Nat, x8: T) { map[T, U](x6, f).get_idx(x7) != Option.some[U](f(x8)) or x6.get_idx(x7) != Option.some[T](x8) or pf(x7, x6) } }","map[T, U](tail, f).get_idx(i) != Option.some(f(s0(i, tail))) or Option.some(s0(i, tail)) != tail.get_idx(i)","not i < tail.length or not pf(i, tail) or Option.some(s0(i, tail)) = tail.get_idx(i)","not i < tail.length or not pf(i, tail) or map[T, U](tail, f).get_idx(i) = Option.some(f(s0(i, tail)))","Option.some(s0(i, tail)) = tail.get_idx(i)","map[T, U](tail, f).get_idx(i) = Option.some(f(s0(i, tail)))","map[T, U](tail, f).get_idx(i) != Option.some(f(s0(i, tail)))"]}
{"goal":"map[T, U](List.cons(head, tail), f).get_idx(i + 1) = map[T, U](tail, f).get_idx(i + 1 - 1)","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","not i + 1 > 0 or List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f) or map[T, U](List.cons(head, tail), f).get_idx(i + 1) = map[T, U](tail, f).get_idx(i + 1 - 1)","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f)"]}
{"goal":"i + 1 - 1 = i","proof":[]}
{"goal":"l.get_idx(i + 1) = Option.some(x)","proof":["l.get_idx(i + 1) != tail.get_idx(i)"]}
{"goal":"map[T, U](l, f).get_idx(i + 1) = Option.some(f(x))","proof":[]}
{"goal":"pf(i + 1, l)","proof":["map[T, U](l, f).get_idx(i + 1) != Option.some(f(x)) or l.get_idx(i + 1) != Option.some(x) or pf(i + 1, l)"]}
{"goal":"pf(i + 1, l)","proof":["i + 1 < l.length or pf(i + 1, l)","List.nil[T] != l or l.length = 0","l.length = 0","not i + 1 < 0","i + 1 < l.length"]}
{"goal":"p(i) implies p(i.suc)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pf(x0, x1) } and forall(x2: Nat) { not pf(x2, s0(x2)) or p(x2) } }","not pf(i + 1, s0(i + 1)) or p(i + 1)","not p(i) or pf(i + 1, s0(i + 1))","i + 1 = i.suc","not p(i + 1)","pf(i + 1, s0(i + 1))"]}
{"goal":"p(idx)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not p(s0(p)) or p(s0(p).suc)","not p(s0(p).suc) or not p(0) or p(idx)","not p(s0(p).suc)","not p(0) or p(s0(p)) or p(idx)","not p(s0(p))","p(s0(p))"]}
{"goal":"pf(idx, a)","proof":["not p(idx) or pf(idx, a)"]}
{"goal":"map_under_idx","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or Option.some[T](s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { not x2 < x3.length or not pf(x2, x3) or map[T, U](x3, f).get_idx(x2) = Option.some[U](f(s0(x2, x3))) } and forall(x4: Nat, x5: List[T]) { x4 < x5.length or pf(x4, x5) } and forall(x6: List[T], x7: Nat, x8: T) { map[T, U](x6, f).get_idx(x7) != Option.some[U](f(x8)) or x6.get_idx(x7) != Option.some[T](x8) or pf(x7, x6) } }","map[T, U](a, f).get_idx(idx) != Option.some(f(s0(idx, a))) or Option.some(s0(idx, a)) != a.get_idx(idx)","not idx < a.length or not pf(idx, a) or Option.some(s0(idx, a)) = a.get_idx(idx)","not idx < a.length or not pf(idx, a) or map[T, U](a, f).get_idx(idx) = Option.some(f(s0(idx, a)))","Option.some(s0(idx, a)) = a.get_idx(idx)","map[T, U](a, f).get_idx(idx) = Option.some(f(s0(idx, a)))","map[T, U](a, f).get_idx(idx) != Option.some(f(s0(idx, a)))"]}
{"goal":"fp(0, l)","proof":["0 < l.length or fp(0, l)","List.nil[T] != l or l.length = 0","not 0 < l.length or l.length != 0","0 < l.length","l.length = 0","l.length != 0"]}
{"goal":"(l + b).get_idx(0) = Option.some(head)","proof":["List.cons(head, tail + b) != l + b or 0 > 0 or (l + b).get_idx(0) = Option.some(head)","List.cons(head, tail) != l or List.cons(head, tail + b) = l + b","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","not 0 - 1 - s0 < 0","List.cons(head, tail + b) != l + b or 0 > 0","List.cons(head, tail + b) = l + b","0 > 0"]}
{"goal":"fp(0, l)","proof":["(l + b).get_idx(0) != l.get_idx(0) or fp(0, l)","not head ∈ l or l.get_idx(l.find_first_idx(head)) = Option.some(head)","List.cons(head, tail) != l or head != head or l.find_first_idx(head) = 0","List.cons(head, tail) != l or head != head or head ∈ l","List.cons(head, tail) != l or head ∈ l","List.cons(head, tail) != l or l.find_first_idx(head) = 0","head ∈ l","(l + b).get_idx(0) != l.get_idx(0)","l.get_idx(0) != Option.some(head)","l.find_first_idx(head) = 0","l.get_idx(l.find_first_idx(head)) = Option.some(head)","l.get_idx(l.find_first_idx(head)) != Option.some(head)"]}
{"goal":"fp(0, l)","proof":["fp(0, l)"]}
{"goal":"f(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not f(x0) or fp(x0, x1) } and forall(x2: Nat) { not fp(x2, s0(x2)) or f(x2) } }","fp(0, s0(0))","not fp(0, s0(0)) or f(0)"]}
{"goal":"i + 1 = i.suc","proof":["i + 1 = 1 + i","1 + i != i.suc","1 + i = i.suc"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["tail.length.suc != l.length","List.cons(head, tail) != l or tail.length.suc = l.length"]}
{"goal":"i < tail.length","proof":["not i.suc < tail.length.suc or i < tail.length","not i.suc < tail.length.suc"]}
{"goal":"l.tail = tail","proof":["List.cons(head, tail) != l or l.tail = tail"]}
{"goal":"fp(i, tail)","proof":["not f(i) or fp(i, tail)"]}
{"goal":"(tail + b).get_idx(i) = tail.get_idx(i)","proof":["not i < tail.length or not fp(i, tail) or (tail + b).get_idx(i) = tail.get_idx(i)"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = (tail + b).get_idx(i)","proof":["l.get_idx(i + 1) != (tail + b).get_idx(i)","not i + 1 < l.length or l.get_idx(i + 1) = l.tail.get_idx(i)","l.get_idx(i + 1) != tail.get_idx(i)","l.get_idx(i + 1) = l.tail.get_idx(i)","l.get_idx(i + 1) != l.tail.get_idx(i)"]}
{"goal":"i + 1 > 0","proof":["0 < 0 + i.suc","i + 1 > 0 = 0 < i + 1","not 0 < i + 1","not 0 < i.suc","0 + i.suc = i.suc"]}
{"goal":"List.cons(head, tail + b).get_idx(i + 1) = (tail + b).get_idx(i)","proof":["not i + 1 > 0 or List.cons(head, tail + b) != List.cons(head, tail + b) or List.cons(head, tail + b).get_idx(i + 1) = (tail + b).get_idx(i + 1 - 1)","i + 1 - 1 = i","not i + 1 > 0 or List.cons(head, tail + b).get_idx(i + 1) = (tail + b).get_idx(i + 1 - 1)","List.cons(head, tail + b).get_idx(i + 1) != (tail + b).get_idx(i + 1 - 1)"]}
{"goal":"fp(i + 1, l)","proof":["(l + b).get_idx(i + 1) != l.get_idx(i + 1) or fp(i + 1, l)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail) + b = List.cons(head, tail + b)","List.cons(head, tail) + b = List.cons(head, tail + b)","(l + b).get_idx(i + 1) != l.get_idx(i + 1)"]}
{"goal":"fp(i + 1, l)","proof":["List.nil[T] != l or l.length = 0","l.length = 0","not i + 1 < 0"]}
{"goal":"fp(i + 1, l)","proof":["i + 1 < l.length or fp(i + 1, l)","not i + 1 < l.length or fp(i + 1, l)","i + 1 < l.length","not i + 1 < l.length"]}
{"goal":"f(i + 1)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not f(x0) or fp(x0, x1) } and forall(x2: Nat) { not fp(x2, s0(x2)) or f(x2) } }","not fp(i + 1, s0(i + 1)) or f(i + 1)","fp(i + 1, s0(i + 1))"]}
{"goal":"f(n)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not f(s0(f)) or f(s0(f) + 1)","not f(s0(f).suc) or not f(0) or f(n)","not f(s0(f).suc)","not f(0) or f(s0(f)) or f(n)","f(s0(f))","s0(f) + 1 = s0(f).suc","f(s0(f) + 1)","not f(s0(f) + 1)"]}
{"goal":"fp(n, a)","proof":["not f(n) or fp(n, a)"]}
{"goal":"append_add_idx_left","proof":["not n < a.length or not fp(n, a) or (a + b).get_idx(n) = a.get_idx(n)"]}
{"goal":"List.cons(a, List.nil[T]) = List.singleton(a)","proof":["List.cons(a, List.nil[T]) = List.singleton(a)"]}
{"goal":"List.nil[T] + List.singleton(a) = List.singleton(a)","proof":["List.nil[T] != List.nil[T] or List.nil[T] + List.singleton(a) = List.singleton(a)"]}
{"goal":"List.nil[T].length = 0","proof":["List.nil[T] != List.nil[T] or List.nil[T].length = 0"]}
{"goal":"List.singleton(a).get_idx(0) = Option.some(a)","proof":["List.cons(a, List.nil[T]) != List.singleton(a) or 0 > 0 or List.singleton(a).get_idx(0) = Option.some(a)","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","List.cons(a, List.nil[T]) = List.singleton(a)","not 0 - 1 - s0 < 0","List.cons(a, List.nil[T]) != List.singleton(a) or 0 > 0","0 > 0"]}
{"goal":"f(List.nil[T])","proof":["(List.nil[T] + List.singleton(a)).get_idx(List.nil[T].length) != Option.some(a) or f(List.nil[T])","(List.nil[T] + List.singleton(a)).get_idx(List.nil[T].length) != Option.some(a)"]}
{"goal":"l.length = tail.length.suc","proof":["List.cons(head, tail) != l or tail.length.suc = l.length"]}
{"goal":"tail.length.suc - 1 = tail.length","proof":["tail.length + 1 - 1 = tail.length","tail.length + 1 = tail.length.suc"]}
{"goal":"l.length - 1 = tail.length","proof":["tail.length.suc - 1 != tail.length"]}
{"goal":"(tail + sa).get_idx(tail.length) = Option.some(a)","proof":["not f(tail) or (tail + List.singleton(a)).get_idx(tail.length) = Option.some(a)","(tail + List.singleton(a)).get_idx(tail.length) != Option.some(a)","(tail + List.singleton(a)).get_idx(tail.length) = Option.some(a)"]}
{"goal":"(l + sa).get_idx(l.length) = (tail + sa).get_idx(l.length - 1)","proof":["List.cons(head, tail) != l or List.cons(head, tail + sa) = l + sa","not l.length > 0 or List.cons(head, tail + sa) != l + sa or (tail + sa).get_idx(l.length - 1) = (l + sa).get_idx(l.length)","not head ∈ l or l.find_first_idx(head) < l.length","List.cons(head, tail) != l or head != head or l.find_first_idx(head) = 0","List.cons(head, tail) != l or head != head or head ∈ l","l.length > 0 = 0 < l.length","List.cons(head, tail) != l or head ∈ l","List.cons(head, tail) != l or l.find_first_idx(head) = 0","head ∈ l","not l.length > 0 or List.cons(head, tail + sa) != l + sa","l.find_first_idx(head) = 0","List.cons(head, tail + sa) = l + sa","not l.length > 0","not 0 < l.length","l.find_first_idx(head) < l.length","not l.find_first_idx(head) < l.length"]}
{"goal":"f(List.cons(head, tail))","proof":["(List.cons(head, tail) + List.singleton(a)).get_idx(List.cons(head, tail).length) != Option.some(a) or f(List.cons(head, tail))","(List.cons(head, tail) + List.singleton(a)).get_idx(List.cons(head, tail).length) != Option.some(a)"]}
{"goal":"append_add_singleton_right","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not f(s1(f)) or f(List.cons[T](s0(f), s1(f)))","not f(list) or (list + List.singleton(a)).get_idx(list.length) = Option.some(a)","not f(list)","not f(List.cons[T](s0(f), s1(f))) or not f(List.nil[T]) or f(list)","not f(List.nil[T]) or f(s1(f)) or f(list)","f(s1(f)) or f(list)","f(s1(f))","not f(List.cons[T](s0(f), s1(f))) or f(list)","not f(List.cons[T](s0(f), s1(f)))"]}
{"goal":"f(0)","proof":["idx < 0 or f(0)","not idx < 0"]}
{"goal":"(m.range + List.singleton(m)).get_idx(idx) = m.range.get_idx(idx)","proof":["not idx < m.range.length or (m.range + List.singleton(m)).get_idx(idx) = m.range.get_idx(idx)","m.range.length = m","not idx < m.range.length","idx < m.range.length"]}
{"goal":"f(m + 1)","proof":["(m + 1).range.get_idx(idx) != Option.some(idx) or f(m + 1)","not idx < m or not f(m) or m.range.get_idx(idx) = Option.some(idx)","m.suc != m.suc or m.range.append(m) = m.suc.range","m.range + List.singleton(m) = m.range.append(m)","m + 1 = 1 + m","1 + m = m.suc","m.range.append(m) = m.suc.range","(m + 1).range.get_idx(idx) != Option.some(idx)","m.range.get_idx(idx) = Option.some(idx)"]}
{"goal":"(m.range + List.singleton(m)).get_idx(m) = Option.some(m)","proof":["(m.range + List.singleton(m)).get_idx(m.range.length) = Option.some(m)","m.range.length = m"]}
{"goal":"f(m + 1)","proof":["(m + 1).range.get_idx(idx) != Option.some(idx) or f(m + 1)","not idx < m.suc or idx < m or m = idx","m.suc != m.suc or m.range.append(m) = m.suc.range","m.range + List.singleton(m) = m.range.append(m)","m + 1 = 1 + m","1 + m = m.suc","m + 1 = m.suc","idx < m.suc","m = idx","m.range.append(m) = m.suc.range","(m + 1).range.get_idx(idx) != Option.some(idx)"]}
{"goal":"idx < m + 1 or f(m + 1)","proof":["idx < m + 1 or f(m + 1)"]}
{"goal":"f(m + 1)","proof":[]}
{"goal":"f(n)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not f(s0(f)) or f(s0(f) + 1)","not f(s0(f).suc) or not f(0) or f(n)","not f(s0(f).suc)","not f(0) or f(s0(f)) or f(n)","f(s0(f))","s0(f) + 1 = s0(f).suc","f(s0(f) + 1)","not f(s0(f) + 1)"]}
{"goal":"range_idx_eq_idx","proof":["not idx < n or not f(n) or n.range.get_idx(idx) = Option.some(idx)"]}
{"goal":"map_range","proof":["let s0: Nat satisfy { not idx < n.range.length or n.range.get_idx(idx) = Option.some(s0) and (not idx < n.range.length or map[Nat, T](n.range, f).get_idx(idx) = Option.some[T](f(s0))) }","not idx < n or n.range.get_idx(idx) = Option.some(idx)","Option.some(s0) != Option.some(idx) or s0 = idx","n.range.length = n","idx < n.range.length","n.range.get_idx(idx) = Option.some(idx)","n.range.get_idx(idx) = Option.some(s0)","Option.some(s0) = Option.some(idx)","map[Nat, T](n.range, f).get_idx(idx) = Option.some(f(s0))","Option.some(f(s0)) != Option.some(f(idx))","f(s0) != f(idx)","s0 = idx","s0 != idx"]}
{"goal":"f_out.length = n.range.length","proof":["map[Nat, T](n.range, f).length = n.range.length","map[Nat, T](n.range, f).length != n.range.length"]}
{"goal":"n.range.length = n","proof":["n.range.length = n"]}
{"goal":"f_out.length = n","proof":["n.range.length != f_out.length"]}
{"goal":"f_out.unique.length < f_out.length","proof":[]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < f_out.length and f_out.get_idx(k0) = f_out.get_idx(k1) }","proof":["let [T0] (s0: List[T0] -> Nat, s1: List[T0] -> Nat) satisfy { forall(x0: List[T0]) { not x0.unique.length < x0.length or s0(x0) < s1(x0) } and forall(x1: List[T0]) { not x1.unique.length < x1.length or s1(x1) < x1.length } and forall(x2: List[T0]) { not x2.unique.length < x2.length or x2.get_idx(s1(x2)) = x2.get_idx(s0(x2)) } }","not s1(f_out) < f_out.length or f_out.get_idx(s1(f_out)) != f_out.get_idx(s0(f_out)) or not s0(f_out) < s1(f_out)","not f_out.unique.length < f_out.length or s1(f_out) < f_out.length","not f_out.unique.length < f_out.length or s0(f_out) < s1(f_out)","not f_out.unique.length < f_out.length or f_out.get_idx(s1(f_out)) = f_out.get_idx(s0(f_out))","s0(f_out) < s1(f_out)","s1(f_out) < f_out.length","f_out.get_idx(s1(f_out)) = f_out.get_idx(s0(f_out))","f_out.get_idx(s1(f_out)) != f_out.get_idx(s0(f_out))"]}
{"goal":"j < n","proof":["not j < f_out.length"]}
{"goal":"map[Nat, T](n.range, f).get_idx(i) = Option.some(f(i))","proof":["not i < n or map[Nat, T](n.range, f).get_idx(i) = Option.some(f(i))","not i < n","not i < j or not j <= n or i < n","not j < n or j <= n","j <= n","not j <= n or i < n"]}
{"goal":"map[Nat, T](n.range, f).get_idx(j) = Option.some(f(j))","proof":["not j < n or map[Nat, T](n.range, f).get_idx(j) = Option.some(f(j))"]}
{"goal":"Option.some(f(j)) = Option.some(f(i)) implies f(j) = f(i)","proof":["Option.some(f(j)) != Option.some(f(i)) or f(j) = f(i)"]}
{"goal":"f(i) = f(j)","proof":[]}
{"goal":"range_pigeonhole","proof":["not j < n or not i < j or f(j) != f(i)","not i < j"]}
{"goal":"exists(k0: Nat) { k0.suc = i }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { s0(x0).suc = x0 or 0 = x0 } }","s0(i).suc != i","s0(i).suc = i or 0 = i"]}
{"goal":"i > 0","proof":["0 < i or i <= 0","not i <= 0 or 0 = i","i > 0 = 0 < i","not 0 < i","not i <= 0","i <= 0"]}
{"goal":"i_pred.suc - 1 = i_pred","proof":["i_pred + 1 - 1 = i_pred","i_pred + 1 = i_pred.suc"]}
{"goal":"i - 1 = i_pred","proof":["i_pred.suc - 1 != i_pred"]}
{"goal":"List.cons(head, tail).get_idx(i) = tail.get_idx(i_pred)","proof":["not i > 0 or List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).get_idx(i) = tail.get_idx(i - 1)","List.cons(head, tail).get_idx(i) != tail.get_idx(i - 1)","not i > 0 or List.cons(head, tail).get_idx(i) = tail.get_idx(i - 1)"]}
{"goal":"List.cons(head, tail).get_idx(i) = Option.none[T]","proof":["not i_pred >= tail.length or not p(tail) or tail.get_idx(i_pred) = Option.none[T]","tail.get_idx(i_pred) != Option.none[T]","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","not tail.length.suc <= i_pred.suc or tail.length <= i_pred","i >= tail.length.suc = tail.length.suc <= i","i_pred >= tail.length = tail.length <= i_pred","not i_pred >= tail.length","not tail.length <= i_pred","List.cons(head, tail).length = tail.length.suc","i >= tail.length.suc","tail.length.suc <= i","not tail.length.suc <= i_pred.suc","tail.length.suc <= i_pred.suc"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).length = tail.length.suc","List.cons(head, tail) != List.cons(head, tail)"]}
{"goal":"tail.length.suc != 0","proof":["tail.length.suc != 0"]}
{"goal":"not tail.length.suc <= 0 or tail.length.suc = 0","proof":["not tail.length.suc <= 0 or tail.length.suc = 0"]}
{"goal":"List.cons(head, tail).get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != List.cons(head, tail) or 0 > 0 or List.cons(head, tail).get_idx(0) = Option.some(head)","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","not 0 - 1 - s0 < 0","0 > 0 or List.cons(head, tail).get_idx(0) = Option.some(head)","0 > 0"]}
{"goal":"List.cons(head, tail).get_idx(0) != Option.none[T]","proof":["Option.some(head) = Option.none[T]","Option.some(head) != Option.none[T]"]}
{"goal":"i >= List.cons(head, tail).length implies List.cons(head, tail).get_idx(i) = Option.none[T]","proof":["not i >= List.cons(head, tail).length or List.cons(head, tail).get_idx(i) = Option.none[T] or 0 = i","0 = i","i >= List.cons(head, tail).length = List.cons(head, tail).length <= i"]}
{"goal":"p(List.cons(head, tail))","proof":["let s0: List[T] -> Nat satisfy { forall(x0: Nat, x1: List[T]) { not x0 >= x1.length or not p(x1) or x1.get_idx(x0) = Option.none[T] } and forall(x2: List[T]) { s0(x2) >= x2.length or p(x2) } and forall(x3: List[T]) { x3.get_idx(s0(x3)) != Option.none[T] or p(x3) } }","List.cons(head, tail).get_idx(s0(List.cons(head, tail))) != Option.none[T] or p(List.cons(head, tail))","s0(List.cons(head, tail)) >= List.cons(head, tail).length or p(List.cons(head, tail))","not s0(List.cons(head, tail)) >= List.cons(head, tail).length or List.cons(head, tail).get_idx(s0(List.cons(head, tail))) = Option.none[T]","s0(List.cons(head, tail)) >= List.cons(head, tail).length","List.cons(head, tail).get_idx(s0(List.cons(head, tail))) != Option.none[T]","List.cons(head, tail).get_idx(s0(List.cons(head, tail))) = Option.none[T]"]}
{"goal":"get_idx_out_of_bounds","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","not p(s1(p)) or p(List.cons[T](s0(p), s1(p)))","let s2: List[T] -> Nat satisfy { forall(x4: Nat, x5: List[T]) { not x4 >= x5.length or not p(x5) or x5.get_idx(x4) = Option.none[T] } and forall(x6: List[T]) { s2(x6) >= x6.length or p(x6) } and forall(x7: List[T]) { x7.get_idx(s2(x7)) != Option.none[T] or p(x7) } }","List.nil[T].get_idx(s2(List.nil[T])) != Option.none[T] or p(List.nil[T])","not idx >= list.length or not p(list) or list.get_idx(idx) = Option.none[T]","not p(list)","not p(List.cons[T](s0(p), s1(p))) or not p(List.nil[T]) or p(list)","List.nil[T] != List.nil[T] or List.nil[T].get_idx(s2(List.nil[T])) = Option.none[T]","not p(List.nil[T]) or p(s1(p)) or p(list)","List.nil[T].get_idx(s2(List.nil[T])) = Option.none[T]","p(List.nil[T])","p(s1(p))","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"exists(k0: T, k1: List[T]) { lb = List.cons(k0, k1) }","proof":["let [T0] (s0: List[T0] -> T0, s1: List[T0] -> List[T0]) satisfy { forall(x0: List[T0]) { List.cons[T0](s0(x0), s1(x0)) = x0 or List.nil[T0] = x0 } }","List.cons[T](s0(lb), s1(lb)) != lb","List.cons[T](s0(lb), s1(lb)) = lb or List.nil[T] = lb"]}
{"goal":"lb.get_idx(0) = Option.some(hb)","proof":["List.cons(hb, tb) != lb or 0 > 0 or lb.get_idx(0) = Option.some(hb)","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","not 0 - 1 - s0 < 0","List.cons(hb, tb) != lb or 0 > 0","0 > 0"]}
{"goal":"List.nil[T].get_idx(0) != lb.get_idx(0)","proof":["List.nil[T].get_idx(0) = Option.some(hb)","List.nil[T] != List.nil[T] or List.nil[T].get_idx(0) = Option.none[T]","Option.some(hb) != Option.none[T]","List.nil[T].get_idx(0) = Option.none[T]"]}
{"goal":"differ[T](List.nil[T], lb, n)","proof":["not 0 < n or differ[T](List.nil[T], lb, n) or List.nil[T].get_idx(0) = lb.get_idx(0)","lb.length < 0 or 0 < lb.length or lb.length = 0","not 0 <= n or 0 < n or 0 = n","lb.length != 0 or List.nil[T] = lb","List.nil[T] != List.nil[T] or List.nil[T].length = 0","not n < lb.length or not lb.length <= n","not lb.length < 0","List.nil[T].length = 0","0 <= n","lb.length != 0","not n < lb.length","not 0 < n or List.nil[T].get_idx(0) = lb.get_idx(0)","not 0 < n","0 = n","0 < lb.length","not 0 < lb.length"]}
{"goal":"p(List.nil[T])","proof":["let s0: List[T] -> List[T] satisfy { forall(x0: List[T], x1: List[T]) { not x0.length <= n or not x1.length <= n or not p(x0) or differ[T](x0, x1, n) or x0 = x1 } and forall(x2: List[T]) { s0(x2) != x2 or p(x2) } and forall(x3: List[T]) { x3.length <= n or p(x3) } and forall(x4: List[T]) { s0(x4).length <= n or p(x4) } and forall(x5: List[T]) { not differ[T](x5, s0(x5), n) or p(x5) } }","s0(List.nil[T]) != List.nil[T] or p(List.nil[T])","not differ[T](List.nil[T], s0(List.nil[T]), n) or p(List.nil[T])","List.nil[T].length <= n or p(List.nil[T])","s0(List.nil[T]).length <= n or p(List.nil[T])","not List.nil[T].length <= n or not s0(List.nil[T]).length <= n or differ[T](List.nil[T], s0(List.nil[T]), n) or s0(List.nil[T]) = List.nil[T]","s0(List.nil[T]) != List.nil[T]","List.nil[T].length <= n","s0(List.nil[T]).length <= n","not differ[T](List.nil[T], s0(List.nil[T]), n)","differ[T](List.nil[T], s0(List.nil[T]), n)"]}
{"goal":"List.cons(ha, ta).get_idx(0) = Option.some(ha)","proof":["List.cons(ha, ta) != List.cons(ha, ta) or 0 > 0 or List.cons(ha, ta).get_idx(0) = Option.some(ha)","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","not 0 - 1 - s0 < 0","0 > 0 or List.cons(ha, ta).get_idx(0) = Option.some(ha)","0 > 0"]}
{"goal":"List.cons(ha, ta).get_idx(0) != lb.get_idx(0)","proof":["lb.get_idx(0) = Option.some(ha)","List.nil[T] != lb or lb.get_idx(0) = Option.none[T]","Option.some(ha) != Option.none[T]","lb.get_idx(0) = Option.none[T]"]}
{"goal":"not n < 0","proof":["not n <= 0 or 0 = n","not n < 0 or n <= 0","n <= 0","not n < 0 or 0 != n","0 = n","0 != n"]}
{"goal":"n < 0 or 0 < n or n = 0","proof":["n < 0 or 0 < n or 0 = n"]}
{"goal":"List.nil[T] != lb or lb.get_idx(0) = Option.none[T]","proof":["List.nil[T] != lb or lb.get_idx(0) = Option.none[T]"]}
{"goal":"List.cons(ha, ta).length <= n = n >= List.cons(ha, ta).length","proof":["n >= List.cons(ha, ta).length = List.cons(ha, ta).length <= n"]}
{"goal":"not n >= List.cons(ha, ta).length or List.cons(ha, ta).get_idx(n) = Option.none[T]","proof":["not n >= List.cons(ha, ta).length or List.cons(ha, ta).get_idx(n) = Option.none[T]"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["not 0 < n or differ[T](List.cons(ha, ta), lb, n) or List.cons(ha, ta).get_idx(0) = lb.get_idx(0)","n >= List.cons(ha, ta).length","List.cons(ha, ta).get_idx(0) != Option.none[T]","List.cons(ha, ta).get_idx(n) = Option.none[T]","not 0 < n or List.cons(ha, ta).get_idx(0) = lb.get_idx(0)","not 0 < n","0 = n"]}
{"goal":"exists(k0: T, k1: List[T]) { lb = List.cons(k0, k1) }","proof":["let [T0] (s0: List[T0] -> T0, s1: List[T0] -> List[T0]) satisfy { forall(x0: List[T0]) { List.cons[T0](s0(x0), s1(x0)) = x0 or List.nil[T0] = x0 } }","List.cons[T](s0(lb), s1(lb)) != lb","List.cons[T](s0(lb), s1(lb)) = lb or List.nil[T] = lb"]}
{"goal":"List.cons(ha, ta).get_idx(0) = Option.some(ha)","proof":["List.cons(ha, ta) != List.cons(ha, ta) or 0 > 0 or List.cons(ha, ta).get_idx(0) = Option.some(ha)","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","not 0 - 1 - s0 < 0","0 > 0 or List.cons(ha, ta).get_idx(0) = Option.some(ha)","0 > 0"]}
{"goal":"List.cons(hb, tb).get_idx(0) = Option.some(hb)","proof":["List.cons(hb, tb) != List.cons(hb, tb) or 0 > 0 or List.cons(hb, tb).get_idx(0) = Option.some(hb)","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","not 0 - 1 - s0 < 0","0 > 0 or List.cons(hb, tb).get_idx(0) = Option.some(hb)","0 > 0"]}
{"goal":"tb.length < n","proof":["List.cons(hb, tb) != lb or tb.length.suc = lb.length","not tb.length < tb.length.suc or not tb.length.suc <= n or tb.length < n","tb.length < tb.length.suc","not tb.length < tb.length.suc or not tb.length.suc <= n","not tb.length.suc <= n","tb.length.suc = lb.length"]}
{"goal":"differ[T](ta, tb, n)","proof":["not ta.length <= n or not tb.length <= n or not p(ta) or differ[T](ta, tb, n) or tb = ta","List.cons(ha, ta) != List.cons(ha, ta) or List.cons(ha, ta).length = ta.length.suc","not n < ta.length or n < ta.length.suc","not n < List.cons(ha, ta).length or not List.cons(ha, ta).length <= n","n < ta.length or ta.length <= n","not tb.length < n or tb.length <= n","List.cons(ha, ta).length = ta.length.suc","tb.length <= n","not ta.length <= n or tb = ta","List.cons(hb, tb) != List.cons(ha, ta)","not n < List.cons(ha, ta).length","List.cons(ha, tb) != List.cons(ha, ta)","tb != ta","not ta.length <= n","not n < ta.length.suc","n < ta.length","not n < ta.length"]}
{"goal":"exists(k0: Nat) { k0 < n and ta.get_idx(k0) != tb.get_idx(k0) }","proof":["let s0[T0]: (List[T0], List[T0], Nat) -> Nat satisfy { forall(x0: List[T0], x1: List[T0], x2: Nat) { not differ[T0](x0, x1, x2) or s0(x0, x1, x2) < x2 } and forall(x3: List[T0], x4: List[T0], x5: Nat) { x3.get_idx(s0(x3, x4, x5)) != x4.get_idx(s0(x3, x4, x5)) or not differ[T0](x3, x4, x5) } and forall(x6: Nat, x7: Nat, x8: List[T0], x9: List[T0]) { not x6 < x7 or differ[T0](x8, x9, x7) or x8.get_idx(x6) = x9.get_idx(x6) } }","not s0(ta, tb, n) < n or tb.get_idx(s0(ta, tb, n)) = ta.get_idx(s0(ta, tb, n))","tb.get_idx(s0(ta, tb, n)) != ta.get_idx(s0(ta, tb, n)) or not differ[T](ta, tb, n)","not differ[T](ta, tb, n) or s0(ta, tb, n) < n","s0(ta, tb, n) < n","tb.get_idx(s0(ta, tb, n)) != ta.get_idx(s0(ta, tb, n))","tb.get_idx(s0(ta, tb, n)) = ta.get_idx(s0(ta, tb, n))"]}
{"goal":"exists(k0: Nat) { k0.suc = n }","proof":["i.suc != n","not i < n or i.suc < n or i.suc = n","i.suc < n","not i.suc ∈ n.range or not i.suc >= n","not i.suc < n or i.suc ∈ n.range","not i.suc ∈ n.range","i.suc ∈ n.range"]}
{"goal":"i = ip","proof":["not i < n or i.suc < n or i.suc = n","not i.suc < n or not n <= i.suc","i.suc >= n = n <= i.suc","n <= i.suc","ip.suc != i.suc or ip = i","ip.suc != i.suc","i.suc != n","not i.suc < n","i.suc < n"]}
{"goal":"ta.length <= ip","proof":["List.cons(ha, ta) != List.cons(ha, ta) or List.cons(ha, ta).length = ta.length.suc","not ta.length.suc <= ip.suc or ta.length <= ip","not ta.length.suc <= ip.suc","not ta.length.suc <= n","List.cons(ha, ta).length = ta.length.suc"]}
{"goal":"tb.length <= ip","proof":["not tb.length.suc <= ip.suc or tb.length <= ip","not tb.length < n or tb.length.suc <= n","not tb.length.suc <= ip.suc","tb.length.suc <= n","not tb.length.suc <= n"]}
{"goal":"ta.length <= ip = ip >= ta.length","proof":["ip >= ta.length = ta.length <= ip"]}
{"goal":"tb.length <= ip = ip >= tb.length","proof":["ip >= tb.length = tb.length <= ip"]}
{"goal":"not ip >= ta.length or ta.get_idx(ip) = Option.none[T]","proof":["i >= ta.length","ta.get_idx(i) != Option.none[T]","not i >= ta.length or ta.get_idx(i) = Option.none[T]"]}
{"goal":"not ip >= tb.length or tb.get_idx(ip) = Option.none[T]","proof":["i >= tb.length","tb.get_idx(i) != Option.none[T]","not i >= tb.length or tb.get_idx(i) = Option.none[T]"]}
{"goal":"false","proof":["ip >= ta.length","ip >= tb.length","tb.get_idx(ip) = Option.none[T]","ta.get_idx(ip) = Option.none[T]"]}
{"goal":"i.suc > 0","proof":["0 < 0 + i.suc","i.suc > 0 = 0 < i.suc","not 0 < i.suc","0 + i.suc = i.suc"]}
{"goal":"List.cons(ha, ta).get_idx(i.suc) = ta.get_idx(i)","proof":["not i.suc > 0 or List.cons(ha, ta) != List.cons(ha, ta) or List.cons(ha, ta).get_idx(i.suc) = ta.get_idx(i.suc - 1)","i.suc - 1 = i","List.cons(ha, ta).get_idx(i.suc) != ta.get_idx(i.suc - 1)","not i.suc > 0 or List.cons(ha, ta).get_idx(i.suc) = ta.get_idx(i.suc - 1)"]}
{"goal":"List.cons(hb, tb).get_idx(i.suc) = tb.get_idx(i)","proof":["not i.suc > 0 or List.cons(hb, tb) != List.cons(hb, tb) or List.cons(hb, tb).get_idx(i.suc) = tb.get_idx(i.suc - 1)","i.suc - 1 = i","List.cons(hb, tb).get_idx(i.suc) != tb.get_idx(i.suc - 1)","not i.suc > 0 or List.cons(hb, tb).get_idx(i.suc) = tb.get_idx(i.suc - 1)"]}
{"goal":"i.suc < n","proof":["i.suc < n or n <= i.suc","n <= i.suc","i.suc >= n = n <= i.suc"]}
{"goal":"List.cons(ha, ta).get_idx(i.suc) != lb.get_idx(i.suc)","proof":[]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["not i.suc < n or differ[T](List.cons(ha, ta), lb, n) or List.cons(ha, ta).get_idx(i.suc) = lb.get_idx(i.suc)","not i.suc < n or List.cons(ha, ta).get_idx(i.suc) = lb.get_idx(i.suc)"]}
{"goal":"0 < n","proof":["not 0 < lb.length or not lb.length <= n or 0 < n","lb.length < 0 or 0 < lb.length or lb.length = 0","lb.length != 0 or List.nil[T] = lb","not lb.length < 0","not 0 < lb.length or not lb.length <= n","not 0 < lb.length","lb.length != 0","lb.length = 0"]}
{"goal":"List.cons(ha, ta).get_idx(0) = Option.some(ha)","proof":[]}
{"goal":"lb.get_idx(0) = Option.some(hb)","proof":["List.cons(hb, tb).get_idx(0) != Option.some(hb)"]}
{"goal":"ha != hb","proof":[]}
{"goal":"List.cons(ha, ta).get_idx(0) != lb.get_idx(0)","proof":["List.cons(ha, ta).get_idx(0) = Option.some(hb)","Option.some(hb) = Option.some(ha)","Option.some(hb) != Option.some(ha) or hb = ha"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["not 0 < n or differ[T](List.cons(ha, ta), lb, n) or List.cons(ha, ta).get_idx(0) = lb.get_idx(0)","not 0 < n or List.cons(ha, ta).get_idx(0) = lb.get_idx(0)"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":[]}
{"goal":"p(a)","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(a)","p(s1) or p(a)","p(s1)","let s2: List[T] -> List[T] satisfy { forall(x2: List[T], x3: List[T]) { not x2.length <= n or not x3.length <= n or not p(x2) or differ[T](x2, x3, n) or x2 = x3 } and forall(x4: List[T]) { s2(x4) != x4 or p(x4) } and forall(x5: List[T]) { x5.length <= n or p(x5) } and forall(x6: List[T]) { s2(x6).length <= n or p(x6) } and forall(x7: List[T]) { not differ[T](x7, s2(x7), n) or p(x7) } }","s2(List.cons(s0, s1)) != List.cons(s0, s1) or p(List.cons(s0, s1))","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(a)","not p(List.cons(s0, s1)) or p(a)","not differ[T](List.cons(s0, s1), s2(List.cons(s0, s1)), n) or p(List.cons(s0, s1))","List.cons(s0, s1).length <= n or p(List.cons(s0, s1))","s2(List.cons(s0, s1)).length <= n or p(List.cons(s0, s1))","not p(List.cons(s0, s1))","not List.cons(s0, s1).length <= n or not s2(List.cons(s0, s1)).length <= n or not p(s1) or differ[T](List.cons(s0, s1), s2(List.cons(s0, s1)), n) or s2(List.cons(s0, s1)) = List.cons(s0, s1)","List.cons(s0, s1).length <= n","s2(List.cons(s0, s1)) != List.cons(s0, s1)","s2(List.cons(s0, s1)).length <= n","not differ[T](List.cons(s0, s1), s2(List.cons(s0, s1)), n)","differ[T](List.cons(s0, s1), s2(List.cons(s0, s1)), n)"]}
{"goal":"differ[T](a, b, n)","proof":["not a.length <= n or not b.length <= n or not p(a) or differ[T](a, b, n) or b = a"]}
{"goal":"lists_differ_at_index","proof":["not a.length <= n"]}
{"goal":"partial_zero","proof":["sum[A](map[Nat, A](0.range, f)) = partial[A](f, 0)","List.nil[Nat] != List.nil[Nat] or map[Nat, A](List.nil[Nat], f) = List.nil[A]","map[Nat, A](List.nil[Nat], f) != List.nil[A] or sum[A](map[Nat, A](List.nil[Nat], f)) = A.0","Nat.zero != Nat.zero or Nat.zero.range = List.nil[Nat]","Nat.zero.range = List.nil[Nat]","map[Nat, A](List.nil[Nat], f) = List.nil[A]","sum[A](map[Nat, A](0.range, f)) != A.0","sum[A](map[Nat, A](Nat.zero.range, f)) != A.0","sum[A](map[Nat, A](List.nil[Nat], f)) != A.0"]}
{"goal":"differ[T](a, b, a.length)","proof":["a.length <= a.length","not b.length <= a.length"]}
{"goal":"a = b","proof":["let s0[T0]: (List[T0], List[T0], Nat) -> Nat satisfy { forall(x0: List[T0], x1: List[T0], x2: Nat) { not differ[T0](x0, x1, x2) or s0(x0, x1, x2) < x2 } and forall(x3: List[T0], x4: List[T0], x5: Nat) { x3.get_idx(s0(x3, x4, x5)) != x4.get_idx(s0(x3, x4, x5)) or not differ[T0](x3, x4, x5) } and forall(x6: Nat, x7: Nat, x8: List[T0], x9: List[T0]) { not x6 < x7 or differ[T0](x8, x9, x7) or x8.get_idx(x6) = x9.get_idx(x6) } }","not s0(a, b, a.length) < a.length or b.get_idx(s0(a, b, a.length)) = a.get_idx(s0(a, b, a.length))","b.get_idx(s0(a, b, a.length)) != a.get_idx(s0(a, b, a.length)) or not differ[T](a, b, a.length)","not differ[T](a, b, a.length) or s0(a, b, a.length) < a.length","s0(a, b, a.length) < a.length","b.get_idx(s0(a, b, a.length)) != a.get_idx(s0(a, b, a.length))","b.get_idx(s0(a, b, a.length)) = a.get_idx(s0(a, b, a.length))"]}
{"goal":"list_extensionality","proof":["let s0: Nat satisfy { b.length != a.length or s0 < a.length or b = a and (b.get_idx(s0) != a.get_idx(s0) or b.length != a.length or b = a) }","not s0 < a.length or b.get_idx(s0) = a.get_idx(s0)","s0 < a.length","b.get_idx(s0) != a.get_idx(s0)","b.get_idx(s0) = a.get_idx(s0)"]}
