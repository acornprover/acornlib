{"goal":"sum[A](map[Nat, A](1.range, f)) = partial[A](f, 1)","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](1, f)"]}
{"goal":"List.nil[Nat] + List.singleton(0) = List.nil[Nat].append(0)","proof":["function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[Nat](List.nil[Nat], 0)"]}
{"goal":"List.cons(f(0), List.nil[A]) = List.singleton(f(0))","proof":["function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[A](f(0))"]}
{"goal":"f(0) + A.0 = f(0)","proof":["function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[A](A.0, f(0))","A.0 + f(0) != f(0)","function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.0 + x0 = x0 }[A](f(0))"]}
{"goal":"List.nil[Nat] + List.singleton(0) = List.singleton(0)","proof":["function[T0](x0: List[T0], x1: List[T0]) { List.nil[T0] != x0 or x0 + x1 = x1 }[Nat](List.nil[Nat], List.singleton(0))"]}
{"goal":"0.range.append(0) = 0.suc.range","proof":["function(x0: Nat, x1: Nat) { x0.suc != x1 or x0.range.append(x0) = x1.range }(0, 0.suc)"]}
{"goal":"f(0) + sum[A](List.nil[A]) = sum[A](List.cons(f(0), List.nil[A]))","proof":["f(0) + sum[A](List.nil[A]) != sum[A](List.singleton(f(0)))","function[T0: AddCommMonoid](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or T0.add(x0, sum[T0](x1)) = sum[T0](x2) }[A](f(0), List.nil[A], List.singleton(f(0)))"]}
{"goal":"List.cons(0, List.nil[Nat]) = List.singleton(0)","proof":["function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[Nat](0)"]}
{"goal":"map[Nat, A](List.nil[Nat], f) = List.nil[A]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[Nat, A](List.nil[Nat], f)"]}
{"goal":"List.cons(f(0), map[Nat, A](List.nil[Nat], f)) = map[Nat, A](List.cons(0, List.nil[Nat]), f)","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[Nat, A](0, List.nil[Nat], List.cons(0, List.nil[Nat]), f)"]}
{"goal":"map[Nat, A](List.singleton(0), f) = List.singleton(f(0))","proof":[]}
{"goal":"partial_one","proof":["function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[A, A, A](A.add, f(0), A.0)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[A, A, A](A.add, f(0), sum[A](List.nil[A]))","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat -> A, List[A]](map[Nat, A], f, List.cons(0, List.nil[Nat]))","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat, List[Nat]](List.append[Nat], 0, List.nil[Nat])","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat, List[Nat]](List.append[Nat], 0, 0.range)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat -> A, List[A]](map[Nat, A], f, 1.range)","function[T0: AddCommMonoid](x0: List[T0]) { List.nil[T0] != x0 or T0.0 = sum[T0](x0) }[A](List.nil[A])","function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[A](f(0), A.0)","function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[A](f(0), sum[A](List.nil[A]))","function(x0: Nat) { x0 + 1 = x0.suc }(0)","function(x0: Nat) { Nat.zero != x0 or List.nil[Nat] = x0.range }(Nat.zero)","function(x0: Nat) { 0 + x0 = x0 }(1 * 1)","Nat.zero.range = List.nil[Nat]","function[T0: AddCommMonoid] { sum[T0](List.nil[T0]) = T0.0 }[A]"]}
{"goal":"map[T, A](List.nil[T], f) = List.nil[A]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, A](List.nil[T], f)"]}
{"goal":"map[T, A](List.nil[T], g) = List.nil[A]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, A](List.nil[T], g)"]}
{"goal":"map[T, A](List.nil[T], add_fn[T, A](f, g)) = List.nil[A]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, A](List.nil[T], add_fn[T, A](f, g))"]}
{"goal":"sum[A](List.nil[A]) = A.0","proof":["function[T0: AddCommMonoid](x0: List[T0]) { List.nil[T0] != x0 or T0.0 = sum[T0](x0) }[A](List.nil[A])"]}
{"goal":"A.0 + sum[A](List.nil[A]) = sum[A](List.nil[A])","proof":["function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.0 + x0 = x0 }[A](sum[A](List.nil[A]))"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { sum[A](map[T, A](x0, f)) + sum[A](map[T, A](x0, g)) != sum[A](map[T, A](x0, add_fn[T, A](f, g))) or p(x0) }(List.nil[T])","sum[A](map[T, A](List.nil[T], f)) + sum[A](map[T, A](List.nil[T], g)) != sum[A](map[T, A](List.nil[T], add_fn[T, A](f, g)))"]}
{"goal":"f(head) + (g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))) = f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","proof":["function[T0: lib(add_semigroup).AddSemigroup](x0: T0, x1: T0, x2: T0) { T0.add(x0, x1) + x2 = T0.add(x0, T0.add(x1, x2)) }[A](f(head), g(head), sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))"]}
{"goal":"f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))) = f(head) + g(head) + sum[A](map[T, A](tail, add_fn[T, A](f, g)))","proof":["function(x0: List[T]) { not p(x0) or sum[A](map[T, A](x0, f)) + sum[A](map[T, A](x0, g)) = sum[A](map[T, A](x0, add_fn[T, A](f, g))) }(tail)","sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) != sum[A](map[T, A](tail, add_fn[T, A](f, g)))","sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) = sum[A](map[T, A](tail, add_fn[T, A](f, g)))"]}
{"goal":"map[T, A](List.cons(head, tail), f) = List.cons(f(head), map[T, A](tail, f))","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, A](head, tail, List.cons(head, tail), f)"]}
{"goal":"map[T, A](List.cons(head, tail), g) = List.cons(g(head), map[T, A](tail, g))","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, A](head, tail, List.cons(head, tail), g)"]}
{"goal":"map[T, A](List.cons(head, tail), add_fn[T, A](f, g)) = List.cons(add_fn[T, A](f, g, head), map[T, A](tail, add_fn[T, A](f, g)))","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, A](head, tail, List.cons(head, tail), add_fn[T, A](f, g))"]}
{"goal":"f(head) + g(head) = add_fn[T, A](f, g, head)","proof":["function[T0, T1: lib(add_semigroup).AddSemigroup](x0: T0 -> T1, x1: T0 -> T1, x2: T0) { add_fn[T0, T1](x0, x1, x2) = T1.add(x0(x2), x1(x2)) }[T, A](f, g, head)"]}
{"goal":"sum[A](List.cons(f(head), map[T, A](tail, f))) = f(head) + sum[A](map[T, A](tail, f))","proof":["f(head) + sum[A](map[T, A](tail, f)) != sum[A](map[T, A](List.cons(head, tail), f))","function[T0: AddCommMonoid](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or T0.add(x0, sum[T0](x1)) = sum[T0](x2) }[A](f(head), map[T, A](tail, f), map[T, A](List.cons(head, tail), f))"]}
{"goal":"sum[A](List.cons(g(head), map[T, A](tail, g))) = g(head) + sum[A](map[T, A](tail, g))","proof":["g(head) + sum[A](map[T, A](tail, g)) != sum[A](map[T, A](List.cons(head, tail), g))","function[T0: AddCommMonoid](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or T0.add(x0, sum[T0](x1)) = sum[T0](x2) }[A](g(head), map[T, A](tail, g), map[T, A](List.cons(head, tail), g))"]}
{"goal":"sum[A](List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g)))) = f(head) + g(head) + sum[A](map[T, A](tail, add_fn[T, A](f, g)))","proof":["function[T0: AddCommMonoid](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or T0.add(x0, sum[T0](x1)) = sum[T0](x2) }[A](f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g)), List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g))))"]}
{"goal":"sum[A](map[T, A](tail, f)) + g(head) = g(head) + sum[A](map[T, A](tail, f))","proof":["function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[A](g(head), sum[A](map[T, A](tail, f)))"]}
{"goal":"f(head) + sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) = f(head) + (sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))))","proof":["function[T0: lib(add_semigroup).AddSemigroup](x0: T0, x1: T0, x2: T0) { T0.add(x0, x1) + x2 = T0.add(x0, T0.add(x1, x2)) }[A](f(head), sum[A](map[T, A](tail, f)), g(head) + sum[A](map[T, A](tail, g)))"]}
{"goal":"g(head) + sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) = g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","proof":["function[T0: lib(add_semigroup).AddSemigroup](x0: T0, x1: T0, x2: T0) { T0.add(x0, x1) + x2 = T0.add(x0, T0.add(x1, x2)) }[A](g(head), sum[A](map[T, A](tail, f)), sum[A](map[T, A](tail, g)))"]}
{"goal":"sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) = sum[A](map[T, A](tail, f)) + g(head) + sum[A](map[T, A](tail, g))","proof":["function[T0: lib(add_semigroup).AddSemigroup](x0: T0, x1: T0, x2: T0) { T0.add(x0, x1) + x2 = T0.add(x0, T0.add(x1, x2)) }[A](sum[A](map[T, A](tail, f)), g(head), sum[A](map[T, A](tail, g)))"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { sum[A](map[T, A](x0, f)) + sum[A](map[T, A](x0, g)) != sum[A](map[T, A](x0, add_fn[T, A](f, g))) or p(x0) }(List.cons(head, tail))","function[T0: lib(add_semigroup).AddSemigroup](x0: T0, x1: T0, x2: T0) { T0.add(x0, x1) + x2 = T0.add(x0, T0.add(x1, x2)) }[A](f(head), g(head), sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","sum[A](map[T, A](List.cons(head, tail), f)) + sum[A](map[T, A](List.cons(head, tail), g)) != sum[A](map[T, A](List.cons(head, tail), add_fn[T, A](f, g)))"]}
{"goal":"map_sum_add","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1(p), s0(p))","function(x0: List[T]) { not p(x0) or sum[A](map[T, A](x0, f)) + sum[A](map[T, A](x0, g)) = sum[A](map[T, A](x0, add_fn[T, A](f, g))) }(list)","not p(list)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](p, list)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](p, list)","function(x0: List[T]) { p(s1(p)) or p(x0) }(list)","p(s1(p))","function(x0: List[T]) { not p(List.cons[T](s0(p), s1(p))) or p(x0) }(list)","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"partial_add","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](n, add_fn[Nat, A](f, g))","function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](n, g)","function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](n, f)","function[T0, T1: AddCommMonoid](x0: List[T0], x1: T0 -> T1, x2: T0 -> T1) { sum[T1](map[T0, T1](x0, x1)) + sum[T1](map[T0, T1](x0, x2)) = sum[T1](map[T0, T1](x0, add_fn[T0, T1](x1, x2))) }[Nat, A](n.range, f, g)"]}
{"goal":"p(List.nil[S])","proof":["function(x0: List[S]) { sum[S](map[S, S](x0, scalar_mul(c))) != c * sum[S](x0) or p(x0) }(List.nil[S])","function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[S, S](List.nil[S], scalar_mul(c))","function[T0: AddCommMonoid](x0: List[T0]) { List.nil[T0] != x0 or T0.0 = sum[T0](x0) }[S](map[S, S](List.nil[S], scalar_mul(c)))","function[T0: AddCommMonoid](x0: List[T0]) { List.nil[T0] != x0 or T0.0 = sum[T0](x0) }[S](List.nil[S])","function[T0: Semiring](x0: T0) { T0.mul(x0, T0.0) = T0.0 }[S](c)","function[T0: AddCommMonoid] { sum[T0](List.nil[T0]) = T0.0 }[S]","sum[S](map[S, S](List.nil[S], scalar_mul(c))) != c * sum[S](List.nil[S])","sum[S](map[S, S](List.nil[S], scalar_mul(c))) != c * S.0","sum[S](map[S, S](List.nil[S], scalar_mul(c))) != S.0","map[S, S](List.nil[S], scalar_mul(c)) != List.nil[S]"]}
{"goal":"c * head + c * sum[S](tail) = c * (head + sum[S](tail))","proof":["function[T0: Semiring](x0: T0, x1: T0, x2: T0) { T0.mul(x0, x1) + T0.mul(x0, x2) = T0.mul(x0, T0.add(x1, x2)) }[S](c, head, sum[S](tail))"]}
{"goal":"sum[S](List.cons(head, tail)) = head + sum[S](tail)","proof":["function[T0: AddCommMonoid](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or T0.add(x0, sum[T0](x1)) = sum[T0](x2) }[S](head, tail, List.cons(head, tail))"]}
{"goal":"c * head = scalar_mul(c, head)","proof":["function[T0: Semiring](x0: T0, x1: T0) { T0.mul(x0, x1) = scalar_mul[T0](x0, x1) }[S](c, head)"]}
{"goal":"List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c))) = map[S, S](List.cons(head, tail), scalar_mul(c))","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[S, S](head, tail, List.cons(head, tail), scalar_mul(c))"]}
{"goal":"sum[S](List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c)))) = scalar_mul(c, head) + sum[S](map[S, S](tail, scalar_mul(c)))","proof":["function[T0: AddCommMonoid](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or T0.add(x0, sum[T0](x1)) = sum[T0](x2) }[S](scalar_mul(c, head), map[S, S](tail, scalar_mul(c)), List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c))))"]}
{"goal":"c * sum[S](List.cons(head, tail)) = sum[S](map[S, S](List.cons(head, tail), scalar_mul(c)))","proof":["function(x0: List[S]) { not p(x0) or sum[S](map[S, S](x0, scalar_mul(c))) = c * sum[S](x0) }(tail)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[S, S, S](S.add, c * head, c * sum[S](tail))","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[S, S, S](S.add, scalar_mul(c, head), sum[S](map[S, S](tail, scalar_mul(c))))","function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[S](c * head, c * sum[S](tail))","function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[S](scalar_mul(c, head), sum[S](map[S, S](tail, scalar_mul(c))))","sum[S](map[S, S](tail, scalar_mul(c))) = c * sum[S](tail)"]}
{"goal":"sum_scalar_mul","proof":["let  (s0: S, s1: List[S]) satisfy { forall(x0: List[S]) { not p(List.nil[S]) or p(s1) or p(x0) } and forall(x1: List[S]) { not p(List.cons[S](s0, s1)) or not p(List.nil[S]) or p(x1) } }","function(x0: List[S]) { not p(List.nil[S]) or p(s1) or p(x0) }(s1)","function(x0: List[S]) { p(s1) or p(x0) }(s1)","function(x0: List[S]) { not p(List.cons(s0, s1)) or not p(List.nil[S]) or p(x0) }(list)","function(x0: List[S]) { not p(List.cons(s0, s1)) or p(x0) }(list)","function(x0: List[S]) { sum[S](map[S, S](x0, scalar_mul(c))) != c * sum[S](x0) or p(x0) }(List.cons(s0, s1))","function(x0: List[S]) { not p(x0) or sum[S](map[S, S](x0, scalar_mul(c))) = c * sum[S](x0) }(list)","function(x0: List[S], x1: S) { not p(x0) or sum[S](map[S, S](List.cons(x1, x0), scalar_mul(c))) = c * sum[S](List.cons(x1, x0)) }(s1, s0)","p(s1)","not p(list)","not p(List.cons(s0, s1))","function(x0: S) { sum[S](map[S, S](List.cons(x0, s1), scalar_mul(c))) = c * sum[S](List.cons(x0, s1)) }(s0)"]}
{"goal":"p(List.nil[A])","proof":["function(x0: List[A]) { sum[A](x0) + sum[A](right) != sum[A](x0 + right) or p(x0) }(List.nil[A])","function[T0: AddCommMonoid](x0: List[T0]) { List.nil[T0] != x0 or T0.0 = sum[T0](x0) }[A](List.nil[A])","function[T0](x0: List[T0]) { List.nil[T0] + x0 = x0 }[A](right)","function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.0 + x0 = x0 }[A](sum[A](right))","function[T0: AddCommMonoid] { sum[T0](List.nil[T0]) = T0.0 }[A]","sum[A](List.nil[A]) + sum[A](right) != sum[A](List.nil[A] + right)","sum[A](List.nil[A]) + sum[A](right) != sum[A](right)"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[A]) { sum[A](x0) + sum[A](right) != sum[A](x0 + right) or p(x0) }(List.cons(head, tail))","function(x0: List[A]) { not p(x0) or sum[A](x0) + sum[A](right) = sum[A](x0 + right) }(tail)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[A](head, tail, List.cons(head, tail), right)","function[T0: AddCommMonoid](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or T0.add(x0, sum[T0](x1)) = sum[T0](x2) }[A](head, tail + right, List.cons(head, tail + right))","function[T0: AddCommMonoid](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or T0.add(x0, sum[T0](x1)) = sum[T0](x2) }[A](head, tail, List.cons(head, tail))","function[T0: lib(add_semigroup).AddSemigroup](x0: T0, x1: T0, x2: T0) { T0.add(x0, x1) + x2 = T0.add(x0, T0.add(x1, x2)) }[A](head, sum[A](tail), sum[A](right))","function[T0: AddCommMonoid](x0: T0, x1: List[T0]) { sum[T0](List.cons[T0](x0, x1)) = T0.add(x0, sum[T0](x1)) }[A](head, tail + right)","function[T0: AddCommMonoid](x0: T0, x1: List[T0]) { sum[T0](List.cons[T0](x0, x1)) = T0.add(x0, sum[T0](x1)) }[A](head, tail)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) + x2 = List.cons[T0](x0, x1 + x2) }[A](head, tail, right)","sum[A](List.cons(head, tail)) + sum[A](right) != sum[A](List.cons(head, tail) + right)","sum[A](tail) + sum[A](right) = sum[A](tail + right)"]}
{"goal":"sum_add","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[A], x1: A) { not p(x0) or p(List.cons(x1, x0)) }(s1(p), s0(p))","function(x0: List[A]) { not p(x0) or sum[A](x0) + sum[A](right) = sum[A](x0 + right) }(left)","not p(left)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[A](p, left)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[A](p, left)","function(x0: List[A]) { p(s1(p)) or p(x0) }(left)","p(s1(p))","function(x0: List[A]) { not p(List.cons[A](s0(p), s1(p))) or p(x0) }(left)","not p(List.cons[A](s0(p), s1(p)))"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { map[T, U](x0, f) + map[T, U](right, f) != map[T, U](x0 + right, f) or p(x0) }(List.nil[T])","function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, U](List.nil[T], f)","function[T0](x0: List[T0], x1: List[T0]) { List.nil[T0] != x0 or x0 + x1 = x1 }[U](map[T, U](List.nil[T], f), map[T, U](right, f))","function[T0](x0: List[T0]) { List.nil[T0] + x0 = x0 }[T](right)","map[T, U](List.nil[T], f) + map[T, U](right, f) != map[T, U](List.nil[T] + right, f)","map[T, U](List.nil[T], f) + map[T, U](right, f) != map[T, U](right, f)","map[T, U](List.nil[T], f) != List.nil[U]"]}
{"goal":"p(tail) implies map[T, U](tail, f) + map[T, U](right, f) = map[T, U](tail + right, f)","proof":["function(x0: List[T]) { not p(x0) or map[T, U](x0, f) + map[T, U](right, f) = map[T, U](x0 + right, f) }(tail)"]}
{"goal":"List.cons(head, tail) + right = List.cons(head, tail + right)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, List.cons(head, tail), right)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) + map[T, U](right, f) = List.cons(f(head), map[T, U](tail, f) + map[T, U](right, f))","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[U](f(head), map[T, U](tail, f), List.cons(f(head), map[T, U](tail, f)), map[T, U](right, f))"]}
{"goal":"List.cons(f(head), map[T, U](tail + right, f)) = map[T, U](List.cons(head, tail + right), f)","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, U](head, tail + right, List.cons(head, tail + right), f)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, U](head, tail, List.cons(head, tail), f)"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { map[T, U](x0, f) + map[T, U](right, f) != map[T, U](x0 + right, f) or p(x0) }(List.cons(head, tail))","map[T, U](List.cons(head, tail), f) + map[T, U](right, f) != map[T, U](List.cons(head, tail) + right, f)"]}
{"goal":"map_add","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1(p), s0(p))","function(x0: List[T]) { not p(x0) or map[T, U](x0, f) + map[T, U](right, f) = map[T, U](x0 + right, f) }(left)","not p(left)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](p, left)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](p, left)","function(x0: List[T]) { p(s1(p)) or p(x0) }(left)","p(s1(p))","function(x0: List[T]) { not p(List.cons[T](s0(p), s1(p))) or p(x0) }(left)","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"map[T, U](initial, f) + map[T, U](List.singleton(last), f) = map[T, U](initial + List.singleton(last), f)","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1, x2: List[T0]) { map[T0, T1](x0, x1) + map[T0, T1](x2, x1) = map[T0, T1](x0 + x2, x1) }[T, U](initial, f, List.singleton(last))"]}
{"goal":"map[T, U](initial, f) + List.singleton(f(last)) = map[T, U](initial, f).append(f(last))","proof":["function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[U](map[T, U](initial, f), f(last))"]}
{"goal":"initial + List.singleton(last) = initial.append(last)","proof":["function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[T](initial, last)"]}
{"goal":"List.cons(f(last), List.nil[U]) = List.singleton(f(last))","proof":["function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[U](f(last))"]}
{"goal":"List.cons(last, List.nil[T]) = List.singleton(last)","proof":["function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[T](last)"]}
{"goal":"map[T, U](List.nil[T], f) = List.nil[U]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, U](List.nil[T], f)"]}
{"goal":"List.cons(f(last), map[T, U](List.nil[T], f)) = map[T, U](List.cons(last, List.nil[T]), f)","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, U](last, List.nil[T], List.cons(last, List.nil[T]), f)"]}
{"goal":"map_append","proof":[]}
{"goal":"sum_append","proof":["function[T0: AddCommMonoid](x0: List[T0], x1: List[T0]) { sum[T0](x0) + sum[T0](x1) = sum[T0](x0 + x1) }[A](initial, List.singleton(last))","function[T0: AddCommMonoid](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or T0.add(x0, sum[T0](x1)) = sum[T0](x2) }[A](last, List.nil[A], List.cons(last, List.nil[A]))","function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[A](initial, last)","function[T0: AddCommMonoid](x0: List[T0]) { List.nil[T0] != x0 or T0.0 = sum[T0](x0) }[A](List.nil[A])","function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[A](last)","function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.add(x0, T0.0) = x0 }[A](last)","function[T0: AddCommMonoid] { sum[T0](List.nil[T0]) = T0.0 }[A]","function[T0: AddCommMonoid](x0: T0, x1: List[T0]) { sum[T0](List.cons[T0](x0, x1)) = T0.add(x0, sum[T0](x1)) }[A](last, List.nil[A])","sum[A](initial + List.singleton(last)) != sum[A](initial) + last","sum[A](initial) + sum[A](List.singleton(last)) != sum[A](initial) + last","sum[A](List.singleton(last)) != last"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { x0 + b + c != x0 + (b + c) or p(x0) }(List.nil[T])","function[T0](x0: List[T0]) { List.nil[T0] + x0 = x0 }[T](b + c)","function[T0](x0: List[T0]) { List.nil[T0] + x0 = x0 }[T](b)","List.nil[T] + b + c != List.nil[T] + (b + c)"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { x0 + b + c != x0 + (b + c) or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { not p(x0) or x0 + b + c = x0 + (b + c) }(tail)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, List.cons(head, tail), b + c)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail + b, List.cons(head, tail + b), c)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, List.cons(head, tail), b)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) + x2 = List.cons[T0](x0, x1 + x2) }[T](head, tail, b + c)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) + x2 = List.cons[T0](x0, x1 + x2) }[T](head, tail + b, c)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) + x2 = List.cons[T0](x0, x1 + x2) }[T](head, tail, b)","List.cons(head, tail) + b + c != List.cons(head, tail) + (b + c)","tail + (b + c) = tail + b + c"]}
{"goal":"add_assoc","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1(p), s0(p))","function(x0: List[T]) { not p(x0) or x0 + b + c = x0 + (b + c) }(a)","not p(a)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](p, a)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](p, a)","function(x0: List[T]) { p(s1(p)) or p(x0) }(a)","p(s1(p))","function(x0: List[T]) { not p(List.cons[T](s0(p), s1(p))) or p(x0) }(a)","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"map[T, U](List.nil[T], f) = List.nil[U]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, U](List.nil[T], f)"]}
{"goal":"List.nil[T] + List.singleton(x) = List.nil[T].append(x)","proof":["function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[T](List.nil[T], x)"]}
{"goal":"List.nil[U] + List.singleton(f(x)) = List.nil[U].append(f(x))","proof":["function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[U](List.nil[U], f(x))"]}
{"goal":"List.nil[T] + List.singleton(x) = List.singleton(x)","proof":["function[T0](x0: List[T0], x1: List[T0]) { List.nil[T0] != x0 or x0 + x1 = x1 }[T](List.nil[T], List.singleton(x))"]}
{"goal":"List.nil[U] + List.singleton(f(x)) = List.singleton(f(x))","proof":["function[T0](x0: List[T0], x1: List[T0]) { List.nil[T0] != x0 or x0 + x1 = x1 }[U](List.nil[U], List.singleton(f(x)))"]}
{"goal":"map[T, U](List.nil[T], f).append(f(x)) = map[T, U](List.nil[T].append(x), f)","proof":["function[T0, T1](x0: List[T0], x1: T0, x2: T0 -> T1) { map[T0, T1](x0.append(x1), x2) = map[T0, T1](x0, x2).append(x2(x1)) }[T, U](List.nil[T], x, f)"]}
{"goal":"map_singleton","proof":[]}
{"goal":"exists(k0: T, k1: List[T]) { List.cons(k0, k1) = list or List.nil[T] = list }","proof":["let [T0] (s0: List[T0] -> T0, s1: List[T0] -> List[T0]) satisfy { forall(x0: List[T0]) { List.cons[T0](s0(x0), s1(x0)) = x0 or List.nil[T0] = x0 } }","function(x0: T, x1: List[T]) { List.cons(x0, x1) != list }(s0(list), s1(list))","function[T0](x0: List[T0]) { List.cons[T0](s0(x0), s1(x0)) = x0 or List.nil[T0] = x0 }[T](list)"]}
{"goal":"tail.length.suc != 0","proof":["function(x0: Nat) { 0 != x0.suc }(tail.length)"]}
{"goal":"length_zero_imp_nil","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, list)","tail.length.suc != list.length","tail.length.suc = list.length"]}
{"goal":"a.length + b.length = (a + b).length","proof":["function[T0](x0: List[T0], x1: List[T0]) { x0.length + x1.length = (x0 + x1).length }[T](a, b)"]}
{"goal":"a.length + b.length != 0 or b.length = 0","proof":["function(x0: Nat, x1: Nat) { 0 != x0 + x1 or 0 = x1 }(a.length, b.length)"]}
{"goal":"a.length + b.length != 0 or a.length = 0","proof":["function(x0: Nat, x1: Nat) { 0 != x0 + x1 or 0 = x0 }(a.length, b.length)"]}
{"goal":"a.length != 0 or List.nil[T] = a","proof":["function[T0](x0: List[T0]) { 0 != x0.length or List.nil[T0] = x0 }[T](a)"]}
{"goal":"b.length != 0 or List.nil[T] = b","proof":["function[T0](x0: List[T0]) { 0 != x0.length or List.nil[T0] = x0 }[T](b)"]}
{"goal":"add_to_nil","proof":["function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](List.nil[T])","function[T0](x0: List[T0]) { x0 + List.nil[T0] = x0 }[T](a)","a.length + b.length = List.nil[T].length","function[T0] { 0 = List.nil[T0].length }[T]","a.length + b.length = 0","b.length = 0","List.nil[T] = b","List.nil[T] != a"]}
{"goal":"append_not_nil","proof":["function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[T](a, t)","function[T0](x0: List[T0], x1: List[T0]) { x0 + x1 != List.nil[T0] or List.nil[T0] = x1 }[T](a, List.singleton(t))","function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[T](t)","function[T0](x0: T0, x1: List[T0]) { List.nil[T0] != List.cons[T0](x0, x1) }[T](t, List.nil[T])","a + List.singleton(t) = List.nil[T]","List.singleton(t) = List.nil[T]"]}
{"goal":"map[T, U](List.nil[T], f) = List.nil[U]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, U](List.nil[T], f)"]}
{"goal":"map[T, V](List.nil[T], compose[T, U, V](g, f)) = List.nil[V]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, V](List.nil[T], compose[T, U, V](g, f))"]}
{"goal":"map[U, V](List.nil[U], g) = List.nil[V]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[U, V](List.nil[U], g)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { map[T, V](x0, compose[T, U, V](g, f)) != map[U, V](map[T, U](x0, f), g) or p(x0) }(List.nil[T])","map[T, V](List.nil[T], compose[T, U, V](g, f)) != map[U, V](map[T, U](List.nil[T], f), g)"]}
{"goal":"compose[T, U, V](g, f, head) = g(f(head))","proof":["function[T0, T1, T2](x0: T1 -> T2, x1: T0 -> T1, x2: T0) { compose[T0, T1, T2](x0, x1, x2) = x0(x1(x2)) }[T, U, V](g, f, head)"]}
{"goal":"List.cons(g(f(head)), map[U, V](map[T, U](tail, f), g)) = map[U, V](List.cons(f(head), map[T, U](tail, f)), g)","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[U, V](f(head), map[T, U](tail, f), List.cons(f(head), map[T, U](tail, f)), g)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, U](head, tail, List.cons(head, tail), f)"]}
{"goal":"List.cons(compose[T, U, V](g, f, head), map[T, V](tail, compose[T, U, V](g, f))) = map[T, V](List.cons(head, tail), compose[T, U, V](g, f))","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, V](head, tail, List.cons(head, tail), compose[T, U, V](g, f))"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { map[T, V](x0, compose[T, U, V](g, f)) != map[U, V](map[T, U](x0, f), g) or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { not p(x0) or map[T, V](x0, compose[T, U, V](g, f)) = map[U, V](map[T, U](x0, f), g) }(tail)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[V, List[V], List[V]](List.cons[V], map[U, V](map[T, U](tail, f), g), g(f(head)))","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[V, List[V], List[V]](List.cons[V], map[T, V](tail, compose[T, U, V](g, f)), compose[T, U, V](g, f, head))","map[T, V](List.cons(head, tail), compose[T, U, V](g, f)) != map[U, V](map[T, U](List.cons(head, tail), f), g)","map[T, V](tail, compose[T, U, V](g, f)) = map[U, V](map[T, U](tail, f), g)"]}
{"goal":"map_map","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1(p), s0(p))","function(x0: List[T]) { not p(x0) or map[T, V](x0, compose[T, U, V](g, f)) = map[U, V](map[T, U](x0, f), g) }(items)","not p(items)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](p, items)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](p, items)","function(x0: List[T]) { p(s1(p)) or p(x0) }(items)","p(s1(p))","function(x0: List[T]) { not p(List.cons[T](s0(p), s1(p))) or p(x0) }(items)","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"map[S, S](map[Nat, S](n.range, f), scalar_mul(c)) = map[Nat, S](n.range, compose[Nat, S, S](scalar_mul(c), f))","proof":["function[T0, T1, T2](x0: List[T0], x1: T1 -> T2, x2: T0 -> T1) { map[T0, T2](x0, compose[T0, T1, T2](x1, x2)) = map[T1, T2](map[T0, T1](x0, x2), x1) }[Nat, S, S](n.range, scalar_mul(c), f)"]}
{"goal":"sum[S](map[S, S](map[Nat, S](n.range, f), scalar_mul(c))) = c * sum[S](map[Nat, S](n.range, f))","proof":["function[T0: Semiring](x0: List[T0], x1: T0) { sum[T0](map[T0, T0](x0, scalar_mul[T0](x1))) = T0.mul(x1, sum[T0](x0)) }[S](map[Nat, S](n.range, f), c)"]}
{"goal":"sum[S](map[Nat, S](n.range, f)) = partial[S](f, n)","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[S](n, f)"]}
{"goal":"sum[S](map[Nat, S](n.range, mul_fn[Nat, S](c, f))) = partial[S](mul_fn[Nat, S](c, f), n)","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[S](n, mul_fn[Nat, S](c, f))"]}
{"goal":"compose[Nat, S, S](scalar_mul(c), f) = mul_fn[Nat, S](c, f)","proof":["let s0: Nat satisfy { compose[Nat, S, S](scalar_mul[S](c), f, s0) != mul_fn[Nat, S](c, f, s0) }","function[T0, T1: lib(semigroup).Semigroup](x0: T1, x1: T0 -> T1, x2: T0) { mul_fn[T0, T1](x0, x1, x2) = T1.mul(x0, x1(x2)) }[Nat, S](c, f, s0)","compose[Nat, S, S](scalar_mul(c), f, s0) != c * f(s0)","function[T0, T1, T2](x0: T1 -> T2, x1: T0 -> T1, x2: T0) { compose[T0, T1, T2](x0, x1, x2) = x0(x1(x2)) }[Nat, S, S](scalar_mul(c), f, s0)","function[T0: Semiring](x0: T0, x1: T0) { T0.mul(x0, x1) = scalar_mul[T0](x0, x1) }[S](c, f(s0))"]}
{"goal":"partial_scalar_mul","proof":["function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat -> S, List[S]](map[Nat, S], compose[Nat, S, S](scalar_mul(c), f), n.range)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat -> S, List[S]](map[Nat, S], mul_fn[Nat, S](c, f), n.range)","compose[Nat, S, S](scalar_mul(c), f) = mul_fn[Nat, S](c, f)"]}
{"goal":"sum[A](map[Nat, A](0.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), 0)","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](0, compose[Nat, Nat, A](f, Nat.suc))"]}
{"goal":"partial[A](f, 1) = f(0)","proof":["function[T0: AddCommMonoid](x0: Nat -> T0) { partial[T0](x0, 1) = x0(0) }[A](f)"]}
{"goal":"partial[A](f, 0.suc) + A.0 = partial[A](f, 0.suc)","proof":["function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[A](partial[A](f, 0.suc), A.0)","function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.0 + x0 = x0 }[A](partial[A](f, 0.suc))"]}
{"goal":"map[Nat, A](List.nil[Nat], compose[Nat, Nat, A](f, Nat.suc)) = List.nil[A]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[Nat, A](List.nil[Nat], compose[Nat, Nat, A](f, Nat.suc))"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) = partial[A](f, 0.suc)","proof":["function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[Nat -> A, Nat, A](partial[A], 0.suc, f)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[Nat -> A, Nat, A](partial[A], 1, f)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat -> A, List[A]](map[Nat, A], compose[Nat, Nat, A](f, Nat.suc), List.nil[Nat])","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat -> A, List[A]](map[Nat, A], compose[Nat, Nat, A](f, Nat.suc), 0.range)","function[T0: AddCommMonoid](x0: List[T0]) { List.nil[T0] != x0 or T0.0 = sum[T0](x0) }[A](List.nil[A])","function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[A](A.0, partial[A](f, 0.suc))","function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[A](f(0), partial[A](compose[Nat, Nat, A](f, Nat.suc), 0))","function(x0: Nat) { x0 + 1 = x0.suc }(0)","function(x0: Nat) { Nat.zero != x0 or List.nil[Nat] = x0.range }(Nat.zero)","function(x0: Nat) { 0 + x0 = x0 }(1 * 1)","Nat.zero.range = List.nil[Nat]","function[T0: AddCommMonoid] { sum[T0](List.nil[T0]) = T0.0 }[A]"]}
{"goal":"map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(compose[Nat, Nat, A](f, Nat.suc, k)) = map[Nat, A](k.range.append(k), compose[Nat, Nat, A](f, Nat.suc))","proof":["function[T0, T1](x0: List[T0], x1: T0, x2: T0 -> T1) { map[T0, T1](x0.append(x1), x2) = map[T0, T1](x0, x2).append(x2(x1)) }[Nat, A](k.range, k, compose[Nat, Nat, A](f, Nat.suc))"]}
{"goal":"sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k)","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](k, compose[Nat, Nat, A](f, Nat.suc))"]}
{"goal":"sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(f(k.suc))) = sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) + f(k.suc)","proof":["function[T0: AddCommMonoid](x0: List[T0], x1: T0) { sum[T0](x0.append(x1)) = sum[T0](x0) + x1 }[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)), f(k.suc))"]}
{"goal":"compose[Nat, Nat, A](f, Nat.suc, k) = f(k.suc)","proof":["function[T0, T1, T2](x0: T1 -> T2, x1: T0 -> T1, x2: T0) { compose[T0, T1, T2](x0, x1, x2) = x0(x1(x2)) }[Nat, Nat, A](f, Nat.suc, k)"]}
{"goal":"k.range.append(k) = k.suc.range","proof":["function(x0: Nat, x1: Nat) { x0.suc != x1 or x0.range.append(x0) = x1.range }(k, k.suc)"]}
{"goal":"sum[A](map[Nat, A](k.suc.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc)","proof":[]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc) = partial[A](f, k.suc) + f(k.suc)","proof":["function(x0: Nat) { not p(x0) or f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), x0) = partial[A](f, x0.suc) }(k)","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) != partial[A](f, k.suc)","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) = partial[A](f, k.suc)"]}
{"goal":"map[Nat, A](k.suc.range, f).append(f(k.suc)) = map[Nat, A](k.suc.range.append(k.suc), f)","proof":["function[T0, T1](x0: List[T0], x1: T0, x2: T0 -> T1) { map[T0, T1](x0.append(x1), x2) = map[T0, T1](x0, x2).append(x2(x1)) }[Nat, A](k.suc.range, k.suc, f)"]}
{"goal":"sum[A](map[Nat, A](k.suc.range, f)) = partial[A](f, k.suc)","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](k.suc, f)"]}
{"goal":"sum[A](map[Nat, A](k.suc.range, f).append(f(k.suc))) = sum[A](map[Nat, A](k.suc.range, f)) + f(k.suc)","proof":["function[T0: AddCommMonoid](x0: List[T0], x1: T0) { sum[T0](x0.append(x1)) = sum[T0](x0) + x1 }[A](map[Nat, A](k.suc.range, f), f(k.suc))"]}
{"goal":"k.suc.range.append(k.suc) = k.suc.suc.range","proof":["function(x0: Nat, x1: Nat) { x0.suc != x1 or x0.range.append(x0) = x1.range }(k.suc, k.suc.suc)"]}
{"goal":"sum[A](map[Nat, A](k.suc.suc.range, f)) = partial[A](f, k.suc) + f(k.suc)","proof":[]}
{"goal":"p(k.suc)","proof":["function(x0: Nat) { f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), x0) != partial[A](f, x0.suc) or p(x0) }(k.suc)","function[T0: lib(add_semigroup).AddSemigroup](x0: T0, x1: T0, x2: T0) { T0.add(x0, x1) + x2 = T0.add(x0, T0.add(x1, x2)) }[A](f(0), partial[A](compose[Nat, Nat, A](f, Nat.suc), k), f(k.suc))","function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](k.suc.suc, f)","function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](k.suc, compose[Nat, Nat, A](f, Nat.suc))","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc) != partial[A](f, k.suc.suc)"]}
{"goal":"partial_shift_suc","proof":["let s0: Nat satisfy { forall(x0: Nat) { not p(Nat.zero) or p(s0) or p(x0) } and forall(x1: Nat) { not p(s0.suc) or not p(Nat.zero) or p(x1) } }","function(x0: Nat) { not p(x0) or p(x0.suc) }(s0)","function(x0: Nat) { not p(Nat.zero) or p(s0) or p(x0) }(n)","function(x0: Nat) { not p(s0.suc) or not p(Nat.zero) or p(x0) }(n)","function(x0: Nat) { f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), x0) != partial[A](f, x0.suc) or p(x0) }(0)","function(x0: Nat) { not p(x0) or f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), x0) = partial[A](f, x0.suc) }(n)","not p(n)","not p(Nat.zero) or p(s0)","not p(s0.suc) or not p(Nat.zero)","p(0)","p(Nat.zero)","p(s0)","not p(s0.suc)","p(s0.suc)"]}
{"goal":"n.range.append(n) = n.suc.range","proof":["function(x0: Nat, x1: Nat) { x0.suc != x1 or x0.range.append(x0) = x1.range }(n, n.suc)"]}
{"goal":"map[Nat, A](n.range, f).append(f(n)) = map[Nat, A](n.range.append(n), f)","proof":["function[T0, T1](x0: List[T0], x1: T0, x2: T0 -> T1) { map[T0, T1](x0.append(x1), x2) = map[T0, T1](x0, x2).append(x2(x1)) }[Nat, A](n.range, n, f)"]}
{"goal":"sum[A](map[Nat, A](n.range, f).append(f(n))) = sum[A](map[Nat, A](n.range, f)) + f(n)","proof":["function[T0: AddCommMonoid](x0: List[T0], x1: T0) { sum[T0](x0.append(x1)) = sum[T0](x0) + x1 }[A](map[Nat, A](n.range, f), f(n))"]}
{"goal":"sum[A](map[Nat, A](n.range, f)) = partial[A](f, n)","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](n, f)"]}
{"goal":"sum[A](map[Nat, A](n.suc.range, f)) = partial[A](f, n.suc)","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](n.suc, f)"]}
{"goal":"partial_split_last","proof":[]}
{"goal":"sum[A](map[Nat, A](0.range, f)) = partial[A](f, 0)","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](0, f)"]}
{"goal":"sum[A](map[Nat, A](0.range, g)) = partial[A](g, 0)","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](0, g)"]}
{"goal":"map[Nat, A](List.nil[Nat], f) = List.nil[A]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[Nat, A](List.nil[Nat], f)"]}
{"goal":"map[Nat, A](List.nil[Nat], g) = List.nil[A]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[Nat, A](List.nil[Nat], g)"]}
{"goal":"p(0)","proof":["function(x0: Nat) { partial[A](g, x0) != partial[A](f, x0) or p(x0) }(0)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat -> A, List[A]](map[Nat, A], f, 0.range)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat -> A, List[A]](map[Nat, A], f, List.nil[Nat])","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat -> A, List[A]](map[Nat, A], g, List.nil[Nat])","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat -> A, List[A]](map[Nat, A], g, 0.range)","function(x0: Nat) { Nat.zero != x0 or List.nil[Nat] = x0.range }(Nat.zero)","Nat.zero.range = List.nil[Nat]","partial[A](g, 0) != partial[A](f, 0)"]}
{"goal":"partial[A](f, m.suc) = partial[A](g, m) + f(m)","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { not p(x0) or s0(x0) < x0 or partial[A](g, x0) = partial[A](f, x0) } and forall(x1: Nat) { g(s0(x1)) != f(s0(x1)) or not p(x1) or partial[A](g, x1) = partial[A](f, x1) } and forall(x2: Nat, x3: Nat) { not x2 < x3 or p(x3) or g(x2) = f(x2) } and forall(x4: Nat) { partial[A](g, x4) != partial[A](f, x4) or p(x4) } }","function(x0: Nat) { not x0 < m.suc or g(x0) = f(x0) }(s0(m))","function(x0: Nat) { not p(x0) or s0(x0) < x0 or partial[A](g, x0) = partial[A](f, x0) }(m)","function(x0: Nat) { g(s0(x0)) != f(s0(x0)) or not p(x0) or partial[A](g, x0) = partial[A](f, x0) }(m)","function[T0: AddCommMonoid](x0: Nat -> T0, x1: Nat) { partial[T0](x0, x1.suc) = partial[T0](x0, x1) + x0(x1) }[A](f, m)","function(x0: Nat, x1: Nat) { not x0 < x1 or x0 < x1.suc }(s0(m), m)","partial[A](g, m) + f(m) != partial[A](f, m) + f(m)","partial[A](g, m) != partial[A](f, m)","s0(m) < m","g(s0(m)) != f(s0(m))","s0(m) < m.suc","not s0(m) < m.suc"]}
{"goal":"partial[A](f, m.suc) = partial[A](g, m.suc)","proof":["function(x0: Nat) { not x0 < m.suc or g(x0) = f(x0) }(m)","function[T0: AddCommMonoid](x0: Nat -> T0, x1: Nat) { partial[T0](x0, x1.suc) = partial[T0](x0, x1) + x0(x1) }[A](g, m)","function(x0: Nat) { x0 < x0.suc }(m)","g(m) = f(m)"]}
{"goal":"p(n)","proof":["let s0: Nat satisfy { forall(x0: Nat) { not p(Nat.zero) or p(s0) or p(x0) } and forall(x1: Nat) { not p(s0.suc) or not p(Nat.zero) or p(x1) } }","function(x0: Nat) { not p(Nat.zero) or p(s0) or p(x0) }(n)","not p(Nat.zero) or p(s0)","function(x0: Nat) { not p(s0.suc) or not p(Nat.zero) or p(x0) }(n)","function(x0: Nat) { partial[A](g, x0) != partial[A](f, x0) or p(x0) }(s0.suc)","let s1: Nat -> Nat satisfy { forall(x2: Nat) { not p(x2) or s1(x2) < x2.suc or partial[A](g, x2.suc) = partial[A](f, x2.suc) } and forall(x3: Nat) { g(s1(x3)) != f(s1(x3)) or not p(x3) or partial[A](g, x3.suc) = partial[A](f, x3.suc) } }","function(x0: Nat, x1: Nat) { not x0 < x1 or p(x1) or g(x0) = f(x0) }(s1(s0), s0.suc)","not p(s0.suc) or not p(Nat.zero)","function(x0: Nat) { g(s1(x0)) != f(s1(x0)) or not p(x0) or partial[A](g, x0.suc) = partial[A](f, x0.suc) }(s0)","function(x0: Nat) { not p(x0) or s1(x0) < x0.suc or partial[A](g, x0.suc) = partial[A](f, x0.suc) }(s0)","p(Nat.zero)","p(s0)","not p(s0.suc)","function(x0: Nat) { not x0 < s0.suc or g(x0) = f(x0) }(s1(s0))","partial[A](g, s0.suc) != partial[A](f, s0.suc)","s1(s0) < s0.suc","g(s1(s0)) != f(s1(s0))","g(s1(s0)) = f(s1(s0))"]}
{"goal":"partial_pointwise_eq","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { not p(x0) or s0(x0) < x0 or partial[A](g, x0) = partial[A](f, x0) } and forall(x1: Nat) { g(s0(x1)) != f(s0(x1)) or not p(x1) or partial[A](g, x1) = partial[A](f, x1) } and forall(x2: Nat, x3: Nat) { not x2 < x3 or p(x3) or g(x2) = f(x2) } and forall(x4: Nat) { partial[A](g, x4) != partial[A](f, x4) or p(x4) } }","function(x0: Nat) { not x0 < n or g(x0) = f(x0) }(s0(n))","function(x0: Nat) { not p(x0) or s0(x0) < x0 or partial[A](g, x0) = partial[A](f, x0) }(n)","function(x0: Nat) { g(s0(x0)) != f(s0(x0)) or not p(x0) or partial[A](g, x0) = partial[A](f, x0) }(n)","s0(n) < n","g(s0(n)) != f(s0(n))","g(s0(n)) = f(s0(n))"]}
{"goal":"partial[A](g, 1) = g(0)","proof":["function[T0: AddCommMonoid](x0: Nat -> T0) { partial[T0](x0, 1) = x0(0) }[A](g)"]}
{"goal":"reverse_index[A](g, 0, 0) = g(0 - 0)","proof":["function[T0](x0: Nat -> T0, x1: Nat, x2: Nat) { x0(x1 - x2) = reverse_index[T0](x0, x1, x2) }[A](g, 0, 0)"]}
{"goal":"0 - 0 = 0","proof":["function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(0, 0)","function(x0: Nat) { 0 + x0 = x0 }(0)"]}
{"goal":"reverse_index[A](g, 0, 0) = g(0)","proof":["reverse_index[A](g, 0, 0) != g(0 - 0)"]}
{"goal":"partial[A](reverse_index[A](g, 0), 1) = reverse_index[A](g, 0, 0)","proof":["function[T0: AddCommMonoid](x0: Nat -> T0) { partial[T0](x0, 1) = x0(0) }[A](reverse_index[A](g, 0))"]}
{"goal":"partial[A](g, 1) = partial[A](reverse_index[A](g, 0), 1)","proof":[]}
{"goal":"p(0)","proof":["function(x0: Nat) { partial[A](reverse_index[A](g, x0), x0.suc) != partial[A](g, x0.suc) or p(x0) }(0)","partial[A](reverse_index[A](g, 0), 0.suc) != partial[A](g, 0.suc)"]}
{"goal":"partial[A](g, m.suc.suc) = partial[A](g, m.suc) + g(m.suc)","proof":["function[T0: AddCommMonoid](x0: Nat -> T0, x1: Nat) { partial[T0](x0, x1.suc) = partial[T0](x0, x1) + x0(x1) }[A](g, m.suc)"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc.suc) = partial[A](reverse_index[A](g, m.suc), m.suc) + reverse_index[A](g, m.suc, m.suc)","proof":["function[T0: AddCommMonoid](x0: Nat -> T0, x1: Nat) { partial[T0](x0, x1.suc) = partial[T0](x0, x1) + x0(x1) }[A](reverse_index[A](g, m.suc), m.suc)"]}
{"goal":"reverse_index[A](g, m.suc, m.suc) = g(m.suc - m.suc)","proof":["function[T0](x0: Nat -> T0, x1: Nat, x2: Nat) { x0(x1 - x2) = reverse_index[T0](x0, x1, x2) }[A](g, m.suc, m.suc)"]}
{"goal":"m.suc - m.suc = 0","proof":["function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(0, m.suc)","function(x0: Nat) { 0 + x0 = x0 }(m.suc)"]}
{"goal":"reverse_index[A](g, m.suc, m.suc) = g(0)","proof":["reverse_index[A](g, m.suc, m.suc) != g(m.suc - m.suc)"]}
{"goal":"m.suc > 0","proof":["function(x0: Nat, x1: Nat) { x0 < x0 + x1.suc }(0, m)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](m.suc, 0)","not 0 < m.suc","function(x0: Nat) { 0 + x0 = x0 }(m.suc)"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc) = reverse_index[A](g, m.suc, 0) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m.suc - 1)","proof":["function[T0: AddCommMonoid](x0: Nat -> T0, x1: Nat) { T0.add(x0(0), partial[T0](compose[Nat, Nat, T0](x0, Nat.suc), x1)) = partial[T0](x0, x1.suc) }[A](reverse_index[A](g, m.suc), m.suc - 1)","partial[A](reverse_index[A](g, m.suc), (m.suc - 1).suc) != partial[A](reverse_index[A](g, m.suc), m.suc)","(m.suc - 1).suc != m.suc","m.suc - 1 != m","function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(m, 1)","function(x0: Nat) { x0 + 1 = x0.suc }(m)"]}
{"goal":"reverse_index[A](g, m.suc, 0) = g(m.suc - 0)","proof":["function[T0](x0: Nat -> T0, x1: Nat, x2: Nat) { x0(x1 - x2) = reverse_index[T0](x0, x1, x2) }[A](g, m.suc, 0)"]}
{"goal":"m.suc - 0 = m.suc","proof":["function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(m.suc, 0)","function(x0: Nat) { x0 + 0 = x0 }(m.suc)"]}
{"goal":"reverse_index[A](g, m.suc, 0) = g(m.suc)","proof":["reverse_index[A](g, m.suc, 0) != g(m.suc - 0)"]}
{"goal":"m.suc - 1 = m","proof":["function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(m, 1)","function(x0: Nat) { x0 + 1 = x0.suc }(m)"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc) = g(m.suc) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m)","proof":["function[T0: AddCommMonoid](x0: Nat -> T0, x1: Nat) { T0.add(x0(0), partial[T0](compose[Nat, Nat, T0](x0, Nat.suc), x1)) = partial[T0](x0, x1.suc) }[A](reverse_index[A](g, m.suc), m)"]}
{"goal":"compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, i) = reverse_index[A](g, m.suc, i.suc)","proof":["function[T0, T1, T2](x0: T1 -> T2, x1: T0 -> T1, x2: T0) { compose[T0, T1, T2](x0, x1, x2) = x0(x1(x2)) }[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, i)"]}
{"goal":"reverse_index[A](g, m.suc, i.suc) = g(m.suc - i.suc)","proof":["function[T0](x0: Nat -> T0, x1: Nat, x2: Nat) { x0(x1 - x2) = reverse_index[T0](x0, x1, x2) }[A](g, m.suc, i.suc)"]}
{"goal":"i <= m","proof":["let s0: (Nat, Nat) -> Nat satisfy { forall(x0: Nat, x1: Nat) { not x0 < x1 or x0 + s0(x0, x1) = x1 } and forall(x2: Nat, x3: Nat) { 0 != s0(x2, x3) or not x2 < x3 } }","function(x0: Nat, x1: Nat) { not x0 < x1 or x0 + s0(x0, x1) = x1 }(i, m)","function(x0: Nat, x1: Nat, x2: Nat) { x0 + x1 != x2 or x0 <= x2 }(i, s0(i, m), m)","function(x0: Nat) { i + x0 != m }(s0(i, m))"]}
{"goal":"m - i + i = m","proof":["function(x0: Nat, x1: Nat) { not x0 <= x1 or x1 - x0 + x0 = x1 }(i, m)"]}
{"goal":"m - i + i.suc = (m - i + i).suc","proof":["function(x0: Nat, x1: Nat, x2: Nat) { x0.suc != x1 or (x2 + x0).suc = x2 + x1 }(i, i.suc, m - i)"]}
{"goal":"m.suc - i.suc = m - i","proof":["function(x0: Nat, x1: Nat, x2: Nat) { x0 + x1 != x2 or x2 - x1 = x0 }(m - i, i.suc, m.suc)","m - i + i.suc = m.suc","m - i + i.suc != m.suc"]}
{"goal":"reverse_index[A](g, m, i) = g(m - i)","proof":["function[T0](x0: Nat -> T0, x1: Nat, x2: Nat) { x0(x1 - x2) = reverse_index[T0](x0, x1, x2) }[A](g, m, i)"]}
{"goal":"compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, i) = reverse_index[A](g, m, i)","proof":[]}
{"goal":"partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m), m)","proof":["let s0: Nat satisfy { partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m), m) or s0 < m and (compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, s0) != reverse_index[A](g, m, s0) or partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m), m)) }","function(x0: Nat) { not x0 < m or compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, x0) = reverse_index[A](g, m, x0) }(s0)"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc) = g(m.suc) + partial[A](reverse_index[A](g, m), m)","proof":["g(m.suc) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) != partial[A](reverse_index[A](g, m.suc), m.suc)"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) = partial[A](reverse_index[A](g, m), m) + reverse_index[A](g, m, m)","proof":["function[T0: AddCommMonoid](x0: Nat -> T0, x1: Nat) { partial[T0](x0, x1.suc) = partial[T0](x0, x1) + x0(x1) }[A](reverse_index[A](g, m), m)"]}
{"goal":"reverse_index[A](g, m, m) = g(m - m)","proof":["function[T0](x0: Nat -> T0, x1: Nat, x2: Nat) { x0(x1 - x2) = reverse_index[T0](x0, x1, x2) }[A](g, m, m)"]}
{"goal":"m - m = 0","proof":["function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(0, m)","function(x0: Nat) { 0 + x0 = x0 }(m)"]}
{"goal":"reverse_index[A](g, m, m) = g(0)","proof":["reverse_index[A](g, m, m) != g(m - m)"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) = partial[A](reverse_index[A](g, m), m) + g(0)","proof":["partial[A](reverse_index[A](g, m), m) + reverse_index[A](g, m, m) != partial[A](reverse_index[A](g, m), m.suc)"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) + g(m.suc) = g(m.suc) + partial[A](reverse_index[A](g, m), m.suc)","proof":["function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[A](g(m.suc), partial[A](reverse_index[A](g, m), m.suc))"]}
{"goal":"g(m.suc) + partial[A](reverse_index[A](g, m), m) + g(0) = g(m.suc) + (partial[A](reverse_index[A](g, m), m) + g(0))","proof":["function[T0: lib(add_semigroup).AddSemigroup](x0: T0, x1: T0, x2: T0) { T0.add(x0, x1) + x2 = T0.add(x0, T0.add(x1, x2)) }[A](g(m.suc), partial[A](reverse_index[A](g, m), m), g(0))"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) + g(m.suc) = partial[A](reverse_index[A](g, m.suc), m.suc) + g(0)","proof":[]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) = partial[A](g, m.suc)","proof":["function(x0: Nat) { not p(x0) or partial[A](reverse_index[A](g, x0), x0.suc) = partial[A](g, x0.suc) }(m)"]}
{"goal":"p(m.suc)","proof":["function(x0: Nat) { partial[A](reverse_index[A](g, x0), x0.suc) != partial[A](g, x0.suc) or p(x0) }(m.suc)","partial[A](reverse_index[A](g, m.suc), m.suc.suc) != partial[A](g, m.suc.suc)"]}
{"goal":"partial_reverse","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(0) or not x2(s0(x2).suc) or x2(x3) } }","function(x0: Nat) { not p(x0) or p(x0.suc) }(s0(p))","function(x0: Nat) { not p(x0) or partial[A](reverse_index[A](g, x0), x0.suc) = partial[A](g, x0.suc) }(n)","not p(n)","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or not x0(s0(x0).suc) or x0(x1) }(p, n)","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) }(p, n)","function(x0: Nat) { p(s0(p)) or p(x0) }(n)","p(s0(p))","not p(s0(p).suc)","p(s0(p).suc)"]}
{"goal":"partial_drop_first","proof":["function[T0: AddCommMonoid](x0: Nat -> T0, x1: Nat) { T0.add(x0(0), partial[T0](compose[Nat, Nat, T0](x0, Nat.suc), x1)) = partial[T0](x0, x1.suc) }[A](f, n - 1)","partial[A](f, (n - 1).suc) != partial[A](f, n)","(n - 1).suc != n","function(x0: Nat, x1: Nat) { not x0 <= x1 or x1 - x0 + x0 = x1 }(1, n)","function(x0: Nat, x1: Nat) { not x0 < x1 or x0.suc <= x1 }(0, n)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](n, 0)","0 < n","function(x0: Nat) { x0 + 1 = x0.suc }(n - 1)","0.suc <= n","n - 1 + 1 != n","1 <= n","not 1 <= n"]}
{"goal":"exists(k0: Nat) { k0.suc = n }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { 0 = x0 or s0(x0).suc = x0 } }","function(x0: Nat) { x0.suc != n }(s0(n))","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lte(x0, x1) or T0.lt(x0, x1) or x0 = x1 }[Nat](2, n)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](n, 2)","2 <= n","function(x0: Nat) { 0 = x0 or s0(x0).suc = x0 }(n)","0 = n","function(x0: Nat) { not x0 < 0 }(2)","2 != n","2 < n"]}
{"goal":"n_minus_1.suc >= 2","proof":["not n >= 2"]}
{"goal":"n_minus_1 >= 1","proof":["function(x0: Nat, x1: Nat) { not x0.suc <= x1.suc or x0 <= x1 }(1, n_minus_1)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](n_minus_1.suc, 2)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](n_minus_1, 1)","not 1 <= n_minus_1","2 <= n_minus_1.suc","not 1.suc <= n_minus_1.suc","1.suc <= n_minus_1.suc"]}
{"goal":"exists(k0: Nat) { k0.suc = n_minus_1 }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { 0 = x0 or s0(x0).suc = x0 } }","function(x0: Nat) { x0.suc != n_minus_1 }(s0(n_minus_1))","function(x0: Nat, x1: Nat) { not x1  x0.range or not x1 >= x0 }(n_minus_1.suc, n_minus_1)","function(x0: Nat) { 0 = x0 or s0(x0).suc = x0 }(n_minus_1)","0 = n_minus_1","function(x0: Nat) { x0  x0.suc.range }(n_minus_1)","n_minus_1 >= 0.suc","n_minus_1 >= n_minus_1.suc"]}
{"goal":"n_minus_2 + 1 = n_minus_2.suc","proof":["function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(1, n_minus_2)","1 + n_minus_2 != n_minus_2.suc","function(x0: Nat) { 1 + x0 = x0.suc }(n_minus_2)"]}
{"goal":"n_minus_2 + 2 = n","proof":["function(x0: Nat, x1: Nat) { (x0 + x1).suc = x0 + x1.suc }(n_minus_2, 1)","function(x0: Nat) { 1 + x0 = x0.suc }(1)"]}
{"goal":"n - 2 = n_minus_2","proof":["function(x0: Nat, x1: Nat, x2: Nat) { x0 + x1 != x2 or x2 - x1 = x0 }(n_minus_2, 2, n)"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) = partial[A](f, (n - 2).suc)","proof":["function[T0: AddCommMonoid](x0: Nat -> T0, x1: Nat) { T0.add(x0(0), partial[T0](compose[Nat, Nat, T0](x0, Nat.suc), x1)) = partial[T0](x0, x1.suc) }[A](f, n - 2)"]}
{"goal":"partial[A](f, n_minus_1) + f(n_minus_1) = partial[A](f, n_minus_1.suc)","proof":["function[T0: AddCommMonoid](x0: Nat -> T0, x1: Nat) { partial[T0](x0, x1.suc) = partial[T0](x0, x1) + x0(x1) }[A](f, n_minus_1)"]}
{"goal":"n_minus_1.suc - 1 = n_minus_1","proof":["function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(n_minus_1, 1)","function(x0: Nat) { x0 + 1 = x0.suc }(n_minus_1)"]}
{"goal":"partial[A](f, n) = f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1)","proof":[]}
{"goal":"partial_split_first_last","proof":[]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { map[T, U](x0, f).length != x0.length or p(x0) }(List.nil[T])","function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, U](List.nil[T], f)","function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[U](map[T, U](List.nil[T], f))","function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](List.nil[T])","function[T0] { 0 = List.nil[T0].length }[T]","map[T, U](List.nil[T], f).length != List.nil[T].length","map[T, U](List.nil[T], f).length != 0","map[T, U](List.nil[T], f) != List.nil[U]"]}
{"goal":"map[T, U](tail, f).length = tail.length","proof":["function(x0: List[T]) { not p(x0) or map[T, U](x0, f).length = x0.length }(tail)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, U](head, tail, List.cons(head, tail), f)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)).length = map[T, U](tail, f).length.suc","proof":["map[T, U](List.cons(head, tail), f).length != map[T, U](tail, f).length.suc","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[U](f(head), map[T, U](tail, f), map[T, U](List.cons(head, tail), f))"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, List.cons(head, tail))","function(x0: T) { List.cons(head, tail) != List.cons(x0, tail) }(head)"]}
{"goal":"map[T, U](List.cons(head, tail), f).length = List.cons(head, tail).length","proof":[]}
{"goal":"map_length","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list)","function(x0: List[T]) { map[T, U](x0, f).length != x0.length or p(x0) }(List.cons(s0, s1))","function(x0: List[T]) { not p(x0) or map[T, U](x0, f).length = x0.length }(list)","function(x0: List[T], x1: T) { not p(x0) or map[T, U](List.cons(x1, x0), f).length = List.cons(x1, x0).length }(s1, s0)","p(s1)","not p(list)","not p(List.cons(s0, s1))","function(x0: T) { map[T, U](List.cons(x0, s1), f).length = List.cons(x0, s1).length }(s0)"]}
{"goal":"map[T, U](List.nil[T], f) = List.nil[U]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, U](List.nil[T], f)"]}
{"goal":"not List.nil[U].contains(item)","proof":["function[T0](x0: List[T0], x1: T0) { not x1  x0 or List.nil[T0] != x0 }[U](List.nil[U], item)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { item  map[T, U](x0, f) or p(x0) }(List.nil[T])","not item  map[T, U](List.nil[T], f)","item  map[T, U](List.nil[T], f)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, U](head, tail, List.cons(head, tail), f)"]}
{"goal":"f(head) = item","proof":["function[T0](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not x1  x0 or List.cons[T0](x2, x3) != x0 or x1  x3 or x1 = x2 }[U](map[T, U](List.cons(head, tail), f), item, f(head), tail.map(f))","function[T0, T1](x0: List[T0], x1: T0 -> T1) { map[T0, T1](x0, x1) = x0.map(x1) }[T, U](tail, f)","not item  tail.map(f)","List.cons(f(head), tail.map(f)) = map[T, U](List.cons(head, tail), f)","function(x0: List[U], x1: List[U]) { List.cons(f(head), x0) != x1 or not item  x1 or item  x0 }(tail.map(f), map[T, U](List.cons(head, tail), f))"]}
{"goal":"List.cons(head, tail).contains(head)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or x3  x2 }[T](head, tail, List.cons(head, tail), head)","function(x0: T, x1: List[T]) { List.cons(head, tail) != List.cons(x0, x1) or head != x0 }(head, tail)"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T], x1: T) { not x1  x0 or item != f(x1) or p(x0) }(List.cons(head, tail), head)"]}
{"goal":"List.nil[T] + tail = tail","proof":["function[T0](x0: List[T0], x1: List[T0]) { List.nil[T0] != x0 or x0 + x1 = x1 }[T](List.nil[T], tail)"]}
{"goal":"List.cons(head, List.nil[T]) + tail = List.cons(head, List.nil[T] + tail)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, List.nil[T], List.cons(head, List.nil[T]), tail)"]}
{"goal":"List.cons(head, List.nil[T]) + tail = List.cons(head, tail)","proof":["List.cons(head, List.nil[T]) + tail != List.cons(head, List.nil[T] + tail)"]}
{"goal":"tail.contains(x) implies (List.cons(head, List.nil[T]) + tail).contains(x)","proof":["function[T0](x0: List[T0], x1: T0, x2: List[T0]) { not x1  x0 or x1  x2 + x0 }[T](tail, x, List.cons(head, List.nil[T]))"]}
{"goal":"p(List.cons(head, List.nil[T]) + tail)","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T]) { not item  map[T, U](x0, f) or not p(x0) or s0(x0)  x0 } and forall(x1: List[T]) { not item  map[T, U](x1, f) or not p(x1) or f(s0(x1)) = item } and forall(x2: List[T]) { item  map[T, U](x2, f) or p(x2) } and forall(x3: List[T], x4: T) { not x4  x3 or item != f(x4) or p(x3) } }","function(x0: List[T], x1: T) { not x1  x0 or item != f(x1) or p(x0) }(List.cons(head, List.nil[T]) + tail, s0(tail))","function(x0: List[T]) { item  map[T, U](x0, f) or p(x0) }(List.cons(head, List.nil[T]) + tail)","not p(List.cons(head, tail))","function(x0: List[T]) { not item  map[T, U](x0, f) or not p(x0) or f(s0(x0)) = item }(tail)","function(x0: T) { not x0  tail or x0  List.cons(head, List.nil[T]) + tail }(s0(tail))","function(x0: List[T]) { not item  map[T, U](x0, f) or not p(x0) or s0(x0)  x0 }(tail)","function(x0: T) { not x0  List.cons(head, List.nil[T]) + tail or item != f(x0) }(s0(tail))","item  map[T, U](List.cons(head, List.nil[T]) + tail, f)","item  map[T, U](List.cons(head, tail), f)","item  map[T, U](tail, f)","f(s0(tail)) = item","s0(tail)  tail","not s0(tail)  List.cons(head, List.nil[T]) + tail","s0(tail)  List.cons(head, List.nil[T]) + tail"]}
{"goal":"p(List.cons(head, tail))","proof":[]}
{"goal":"map_contains","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T]) { not item  map[T, U](x0, f) or not p(x0) or s0(x0)  x0 } and forall(x1: List[T]) { not item  map[T, U](x1, f) or not p(x1) or f(s0(x1)) = item } and forall(x2: List[T]) { item  map[T, U](x2, f) or p(x2) } and forall(x3: List[T], x4: T) { not x4  x3 or item != f(x4) or p(x3) } }","function(x0: T) { not x0  list or item != f(x0) }(s0(list))","let  (s1: T, s2: List[T]) satisfy { forall(x5: List[T]) { not p(List.nil[T]) or p(s2) or p(x5) } and forall(x6: List[T]) { not p(List.cons[T](s1, s2)) or not p(List.nil[T]) or p(x6) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s2) or p(x0) }(s2)","function(x0: List[T]) { p(s2) or p(x0) }(s2)","function(x0: List[T]) { not p(List.cons(s1, s2)) or not p(List.nil[T]) or p(x0) }(list)","function(x0: List[T]) { not p(List.cons(s1, s2)) or p(x0) }(list)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s2, s1)","function(x0: List[T]) { not item  map[T, U](x0, f) or not p(x0) or f(s0(x0)) = item }(list)","function(x0: List[T]) { not item  map[T, U](x0, f) or not p(x0) or s0(x0)  x0 }(list)","p(s2)","not p(list) or f(s0(list)) = item","function(x0: T) { p(List.cons(x0, s2)) }(s1)","function(x0: List[T]) { p(x0) }(list)","s0(list)  list","f(s0(list)) = item","f(s0(list)) != item"]}
{"goal":"map[T, U](List.nil[T], f) = List.nil[U]","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[T, U](List.nil[T], f)"]}
{"goal":"List.nil[U].unique = List.nil[U]","proof":["function[T0](x0: List[T0]) { List.nil[T0] != x0 or x0.unique = List.nil[T0] }[U](List.nil[U])"]}
{"goal":"List.nil[U].is_unique","proof":["function[T0](x0: List[T0]) { x0.unique != x0 or x0.is_unique }[U](List.nil[U])"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { not map[T, U](x0, f).is_unique or p(x0) }(List.nil[T])","map[T, U](List.nil[T], f).is_unique","not map[T, U](List.nil[T], f).is_unique"]}
{"goal":"not map[T, U](tail, f).is_unique","proof":["tail_map.is_unique","let s0: List[U] -> U satisfy { forall(x0: List[U]) { not has_duplicate(x0) or x0.count(s0(x0)) > 1 } and forall(x1: List[U], x2: U) { not x1.count(x2) > 1 or has_duplicate(x1) } }","function(x0: List[U]) { not has_duplicate(x0) or x0.count(s0(x0)) > 1 }(tail_map)","function[T0](x0: List[T0], x1: T0) { not x0.is_unique or x0.count(x1) <= 1 }[U](tail_map, s0(tail_map))","function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 <= x0 }(1, tail_map.count(s0(tail_map)))","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](tail_map.count(s0(tail_map)), 1)","function(x0: U) { tail_map.count(x0) <= 1 }(s0(tail_map))","tail_map.count(s0(tail_map)) > 1","1 < tail_map.count(s0(tail_map))"]}
{"goal":"tail_map.is_unique","proof":["let s0[T0]: List[T0] -> T0 satisfy { forall(x0: List[T0]) { x0.count(s0(x0)) > 1 or x0.is_unique } }","function(x0: List[U], x1: U) { not x0.count(x1) > 1 or has_duplicate(x0) }(tail_map, s0(tail_map))","function[T0](x0: List[T0]) { x0.count(s0(x0)) > 1 or x0.is_unique }[U](tail_map)","tail_map.count(s0(tail_map)) > 1"]}
{"goal":"tail_map.unique = tail_map","proof":["function[T0](x0: List[T0]) { not x0.is_unique or x0.unique = x0 }[U](tail_map)"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, U](head, tail, List.cons(head, tail), f)"]}
{"goal":"map[T, U](List.cons(head, tail), f).unique != map[T, U](List.cons(head, tail), f)","proof":["function[T0](x0: List[T0]) { x0.unique != x0 or x0.is_unique }[U](map[T, U](List.cons(head, tail), f))"]}
{"goal":"tail_map.contains(dup)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1.unique) = x2.unique or x0  x1 }[U](dup, tail_map, List.cons(dup, tail_map))","function(x0: List[U]) { List.cons(dup, tail_map) != x0 or List.cons(dup, tail_map.unique) = x0.unique }(List.cons(dup, tail_map))","List.cons(dup, tail_map).unique = List.cons(dup, tail_map.unique)"]}
{"goal":"map[T, U](tail, f).contains(dup)","proof":[]}
{"goal":"exists(k0: T) { tail.contains(k0) and f(k0) = dup }","proof":["let s0[T0, T1]: (List[T0], T0 -> T1, T1) -> T0 satisfy { forall(x0: List[T0], x1: T0 -> T1, x2: T1) { not x2  map[T0, T1](x0, x1) or s0(x0, x1, x2)  x0 } and forall(x3: List[T0], x4: T0 -> T1, x5: T1) { not x5  map[T0, T1](x3, x4) or x4(s0(x3, x4, x5)) = x5 } }","function(x0: T) { not x0  tail or dup != f(x0) }(s0(tail, f, dup))","function[T0, T1](x0: List[T0], x1: T0 -> T1, x2: T1) { not x2  map[T0, T1](x0, x1) or s0(x0, x1, x2)  x0 }[T, U](tail, f, dup)","function[T0, T1](x0: List[T0], x1: T0 -> T1, x2: T1) { not x2  map[T0, T1](x0, x1) or x1(s0(x0, x1, x2)) = x2 }[T, U](tail, f, dup)","f(s0(tail, f, dup)) = dup","s0(tail, f, dup)  tail","not s0(tail, f, dup)  tail"]}
{"goal":"tail.is_unique","proof":["function[T0](x0: T0, x1: List[T0]) { not List.cons[T0](x0, x1).is_unique or x1.is_unique }[T](head, tail)"]}
{"goal":"tail.unique = tail","proof":["function[T0](x0: List[T0]) { not x0.is_unique or x0.unique = x0 }[T](tail)"]}
{"goal":"List.cons(head, tail).unique = List.cons(head, tail)","proof":["function[T0](x0: List[T0]) { not x0.is_unique or x0.unique = x0 }[T](List.cons(head, tail))"]}
{"goal":"x != head","proof":["head  tail","function[T0](x0: List[T0], x1: T0, x2: List[T0]) { not x1  x0 or List.cons[T0](x1, x0) != x2 or x0.unique = x2.unique }[T](tail, head, List.cons(head, tail))","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[T], T -> U, List[U]](map[T, U], f, tail)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[T], T -> U, List[U]](map[T, U], f, List.cons(head, tail))","function[T0](x0: List[T0], x1: T0) { not x1  x0 or List.cons[T0](x1, x0).unique = x0.unique }[T](tail, head)","List.cons(head, tail).unique = tail.unique"]}
{"goal":"f(x) = f(head)","proof":["f(head) != dup"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: T, x1: T, x2: List[T]) { f(x0) != f(x1) or p(x2) or x0 = x1 }(head, x, List.cons(head, tail))","function(x0: T, x1: T) { f(x0) != f(x1) or x0 = x1 }(head, x)"]}
{"goal":"p(List.cons(head, tail))","proof":["let  (s0: List[T] -> T, s1: List[T] -> T) satisfy { forall(x0: List[T]) { not x0.is_unique or s1(x0) != s0(x0) or not p(x0) or map[T, U](x0, f).is_unique } and forall(x1: List[T]) { not x1.is_unique or not p(x1) or map[T, U](x1, f).is_unique or f(s1(x1)) = f(s0(x1)) } and forall(x2: List[T]) { x2.is_unique or p(x2) } and forall(x3: List[T]) { not map[T, U](x3, f).is_unique or p(x3) } and forall(x4: T, x5: T, x6: List[T]) { f(x4) != f(x5) or p(x6) or x4 = x5 } }","function(x0: T, x1: T, x2: List[T]) { f(x0) != f(x1) or p(x2) or x0 = x1 }(s0(tail), s1(tail), List.cons(head, tail))","function(x0: T, x1: T) { f(x0) != f(x1) or x0 = x1 }(s0(tail), s1(tail))","function(x0: List[T]) { not x0.is_unique or s1(x0) != s0(x0) or not p(x0) or map[T, U](x0, f).is_unique }(tail)","function(x0: List[T]) { not x0.is_unique or not p(x0) or map[T, U](x0, f).is_unique or f(s1(x0)) = f(s0(x0)) }(tail)","function[T0](x0: T0, x1: List[T0]) { not List.cons[T0](x0, x1).is_unique or x1.is_unique }[T](head, tail)","not tail.is_unique or s1(tail) != s0(tail)","tail.is_unique","s1(tail) != s0(tail)","f(s1(tail)) = f(s0(tail))","f(s1(tail)) != f(s0(tail))"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { x0.is_unique or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { not map[T, U](x0, f).is_unique or p(x0) }(List.cons(head, tail))","List.cons(head, tail).is_unique","not map[T, U](List.cons(head, tail), f).is_unique","map[T, U](List.cons(head, tail), f).is_unique"]}
{"goal":"p(items)","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(items)","function(x0: List[T]) { p(s1) or p(x0) }(items)","p(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(items)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(items)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1, s0)","not p(List.cons(s0, s1))"]}
{"goal":"pigeonhole_unique_map","proof":["let  (s0: List[T] -> T, s1: List[T] -> T) satisfy { forall(x0: List[T]) { not x0.is_unique or s1(x0) != s0(x0) or not p(x0) or map[T, U](x0, f).is_unique } and forall(x1: List[T]) { not x1.is_unique or not p(x1) or map[T, U](x1, f).is_unique or f(s1(x1)) = f(s0(x1)) } and forall(x2: List[T]) { x2.is_unique or p(x2) } and forall(x3: List[T]) { not map[T, U](x3, f).is_unique or p(x3) } and forall(x4: T, x5: T, x6: List[T]) { f(x4) != f(x5) or p(x6) or x4 = x5 } }","function(x0: T, x1: T) { f(x0) != f(x1) or x0 = x1 }(s0(items), s1(items))","function(x0: List[T]) { not x0.is_unique or s1(x0) != s0(x0) or not p(x0) or map[T, U](x0, f).is_unique }(items)","function(x0: List[T]) { not x0.is_unique or not p(x0) or map[T, U](x0, f).is_unique or f(s1(x0)) = f(s0(x0)) }(items)","s1(items) != s0(items)","f(s1(items)) = f(s0(items))","f(s1(items)) != f(s0(items))"]}
{"goal":"not map[T, U](items, f).is_unique","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { map[T0, T1](x0, x1).length = x0.length }[T, U](items, f)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](items.length, map[T, U](items, f).unique.length)","function[T0](x0: List[T0]) { not x0.is_unique or x0.unique = x0 }[U](map[T, U](items, f))","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](map[T, U](items, f).unique.length, items.length)","map[T, U](items, f).unique.length < items.length","map[T, U](items, f).unique = map[T, U](items, f)","map[T, U](items, f).unique.length != items.length","map[T, U](items, f).length != items.length"]}
{"goal":"pigeonhole_map","proof":["let [T0, T1] (s0: (List[T0], T0 -> T1) -> T0, s1: (List[T0], T0 -> T1) -> T0) satisfy { forall(x0: List[T0], x1: T0 -> T1) { s1(x0, x1) != s0(x0, x1) or not x0.is_unique or map[T0, T1](x0, x1).is_unique } and forall(x2: List[T0], x3: T0 -> T1) { not x2.is_unique or map[T0, T1](x2, x3).is_unique or x3(s1(x2, x3)) = x3(s0(x2, x3)) } }","function(x0: T, x1: T) { f(x0) != f(x1) or x0 = x1 }(s0(items, f), s1(items, f))","function[T0, T1](x0: List[T0], x1: T0 -> T1) { s1(x0, x1) != s0(x0, x1) or not x0.is_unique or map[T0, T1](x0, x1).is_unique }[T, U](items, f)","function[T0, T1](x0: List[T0], x1: T0 -> T1) { not x0.is_unique or map[T0, T1](x0, x1).is_unique or x1(s1(x0, x1)) = x1(s0(x0, x1)) }[T, U](items, f)","s1(items, f) != s0(items, f)","f(s1(items, f)) = f(s0(items, f))","f(s1(items, f)) != f(s0(items, f))"]}
{"goal":"tail_cancels_cons","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x2.tail = x1 }[T](a, b, List.cons(a, b))","function(x0: T) { List.cons(a, b) != List.cons(x0, b) }(a)"]}
{"goal":"alt_drop_zero","proof":["function[T0](x0: Nat, x1: List[T0]) { Nat.zero != x0 or x1.drop(x0) = x1 }[T](n, a)","Nat.zero != n","0 != Nat.zero"]}
{"goal":"drop_zero","proof":["function[T0](x0: Nat, x1: List[T0]) { 0 != x0 or x1.drop(x0) = x1 }[T](0, a)"]}
{"goal":"drop_one","proof":["function[T0](x0: Nat, x1: Nat, x2: List[T0]) { x0.suc != x1 or x2.tail.drop(x0) = x2.drop(x1) }[T](Nat.zero, Nat.zero.suc, a)","function[T0](x0: Nat, x1: List[T0]) { Nat.zero != x0 or x1.drop(x0) = x1 }[T](Nat.zero, a.tail)","function[T0](x0: List[T0]) { x0.drop(Nat.zero) = x0 }[T](a.tail)","a.drop(0.suc) != a.tail","a.drop(Nat.zero.suc) != a.tail","function[T0](x0: List[T0], x1: Nat) { x0.drop(x1.suc) = x0.tail.drop(x1) }[T](a, Nat.zero)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { (x0 + b).drop(x0.length) != b or p(x0) }(List.nil[T])","function[T0](x0: Nat, x1: List[T0]) { 0 != x0 or x1.drop(x0) = x1 }[T](List.nil[T].length, b)","function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](List.nil[T])","function[T0](x0: List[T0]) { List.nil[T0] + x0 = x0 }[T](b)","function[T0] { 0 = List.nil[T0].length }[T]","(List.nil[T] + b).drop(List.nil[T].length) != b","b.drop(List.nil[T].length) != b"]}
{"goal":"List.cons(head, tail) + b = List.cons(head, tail + b)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, List.cons(head, tail), b)"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, List.cons(head, tail))","function(x0: T) { List.cons(head, tail) != List.cons(x0, tail) }(head)"]}
{"goal":"List.cons(head, tail + b).tail = tail + b","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x2.tail = x1 }[T](head, tail + b, List.cons(head, tail) + b)","(List.cons(head, tail) + b).tail != tail + b","(List.cons(head, tail) + b).tail = tail + b"]}
{"goal":"List.cons(head, tail + b).tail.drop(tail.length) = List.cons(head, tail + b).drop(tail.length.suc)","proof":["function[T0](x0: Nat, x1: Nat, x2: List[T0]) { x0.suc != x1 or x2.tail.drop(x0) = x2.drop(x1) }[T](tail.length, tail.length.suc, List.cons(head, tail + b))"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { (x0 + b).drop(x0.length) != b or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { not p(x0) or (x0 + b).drop(x0.length) = b }(tail)","(List.cons(head, tail) + b).drop(List.cons(head, tail).length) != b","(tail + b).drop(tail.length) = b"]}
{"goal":"drop_cancels_add","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1(p), s0(p))","function(x0: List[T]) { not p(x0) or (x0 + b).drop(x0.length) = b }(a)","not p(a)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](p, a)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](p, a)","function(x0: List[T]) { p(s1(p)) or p(x0) }(a)","p(s1(p))","function(x0: List[T]) { not p(List.cons[T](s0(p), s1(p))) or p(x0) }(a)","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"f(0)","proof":["let  (s0: Nat -> List[T], s1: Nat -> Nat) satisfy { forall(x0: Nat, x1: List[T], x2: Nat) { not f(x0) or x1.drop(x0 + x2) = x1.drop(x0).drop(x2) } and forall(x3: Nat) { s0(x3).drop(x3 + s1(x3)) != s0(x3).drop(x3).drop(s1(x3)) or f(x3) } }","function(x0: Nat) { s0(x0).drop(x0 + s1(x0)) != s0(x0).drop(x0).drop(s1(x0)) or f(x0) }(0)","function[T0](x0: List[T0]) { x0.drop(0) = x0 }[T](s0(0))","function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.0 + x0 = x0 }[Nat](s1(0))","s0(0).drop(0 + s1(0)) != s0(0).drop(0).drop(s1(0))"]}
{"goal":"l.drop(x.suc).drop(k) = l.drop(x.suc + k)","proof":["function(x0: Nat, x1: List[T], x2: Nat) { not f(x0) or x1.drop(x0 + x2) = x1.drop(x0).drop(x2) }(x, l.tail, k)","function[T0](x0: Nat, x1: Nat, x2: List[T0]) { x0.suc != x1 or x2.tail.drop(x0) = x2.drop(x1) }[T](x, x.suc, l)","function[T0](x0: Nat, x1: Nat, x2: List[T0]) { x0.suc != x1 or x2.tail.drop(x0) = x2.drop(x1) }[T](x + k, (x + k).suc, l)","function(x0: Nat, x1: Nat) { (x0 + x1).suc = x0.suc + x1 }(x, k)","function[T0](x0: List[T0], x1: Nat) { x0.drop(x1.suc) = x0.tail.drop(x1) }[T](l, x)","function[T0](x0: List[T0], x1: Nat) { x0.drop(x1.suc) = x0.tail.drop(x1) }[T](l, x + k)","function(x0: List[T], x1: Nat) { x0.drop(x + x1) = x0.drop(x).drop(x1) }(l.tail, k)"]}
{"goal":"f(x.suc)","proof":["let  (s0: Nat -> List[T], s1: Nat -> Nat) satisfy { forall(x0: Nat, x1: List[T], x2: Nat) { not f(x0) or x1.drop(x0 + x2) = x1.drop(x0).drop(x2) } and forall(x3: Nat) { s0(x3).drop(x3 + s1(x3)) != s0(x3).drop(x3).drop(s1(x3)) or f(x3) } }","function(x0: List[T], x1: Nat) { x0.drop(x.suc + x1) = x0.drop(x.suc).drop(x1) }(s0(x.suc), s1(x.suc))","function(x0: Nat) { s0(x0).drop(x0 + s1(x0)) != s0(x0).drop(x0).drop(s1(x0)) or f(x0) }(x.suc)"]}
{"goal":"drop_twice","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(0) or not x2(s0(x2).suc) or x2(x3) } }","function(x0: Nat) { not f(x0) or f(x0.suc) }(s0(f))","function(x0: Nat, x1: List[T], x2: Nat) { not f(x0) or x1.drop(x0 + x2) = x1.drop(x0).drop(x2) }(m, a, n)","not f(m)","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or not x0(s0(x0).suc) or x0(x1) }(f, m)","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) }(f, m)","function(x0: Nat) { f(s0(f)) or f(x0) }(m)","f(s0(f))","not f(s0(f).suc)","f(s0(f).suc)"]}
{"goal":"not tail.length < 0","proof":["function(x0: Nat) { not x0 <= 0 or 0 = x0 }(tail.length)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Nat](tail.length, 0)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](tail.length, 0)","tail.length != 0","tail.length <= 0","not tail.length <= 0"]}
{"goal":"List.cons(head, tail).drop_last(0) = List.cons(head, tail.drop_last(0)) or tail.length < 0","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x1.length < x3 or List.cons[T0](x0, x1.drop_last(x3)) = x2.drop_last(x3) }[T](head, tail, List.cons(head, tail), 0)"]}
{"goal":"q(List.cons(head, tail))","proof":["function(x0: List[T]) { x0.drop_last(0) != x0 or q(x0) }(List.cons(head, tail))","function(x0: List[T]) { not q(x0) or x0.drop_last(0) = x0 }(tail)","List.cons(head, tail).drop_last(0) != List.cons(head, tail)","tail.drop_last(0) = tail"]}
{"goal":"drop_last_zero","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T], x1: T) { not q(x0) or q(List.cons(x1, x0)) }(s1(q), s0(q))","function(x0: List[T]) { x0.drop_last(0) != x0 or q(x0) }(List.nil[T])","function(x0: List[T]) { not q(x0) or x0.drop_last(0) = x0 }(a)","not q(a)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](q, a)","function[T0](x0: List[T0], x1: Nat) { List.nil[T0] != x0 or x0.drop_last(x1) = List.nil[T0] }[T](List.nil[T], 0)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](q, a)","function[T0](x0: Nat) { List.nil[T0].drop_last(x0) = List.nil[T0] }[T](0)","q(List.nil[T])","q(s1(q))","not q(List.cons[T](s0(q), s1(q)))"]}
{"goal":"r(List.cons(head, tail))","proof":["function(x0: List[T]) { x0.drop_last(x0.length) != List.nil[T] or r(x0) }(List.cons(head, tail))","function[T0](x0: List[T0], x1: Nat, x2: T0, x3: List[T0]) { not x0.length < x1 or List.cons[T0](x2, x0) != x3 or x3.drop_last(x1) = List.nil[T0] }[T](tail, tail.length.suc, head, List.cons(head, tail))","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, List.cons(head, tail))","function(x0: Nat) { x0 < x0.suc }(tail.length)","function[T0](x0: List[T0], x1: T0) { x0.length.suc = List.cons[T0](x1, x0).length }[T](tail, head)","function[T0](x0: List[T0], x1: Nat, x2: T0) { not x0.length < x1 or List.cons[T0](x2, x0).drop_last(x1) = List.nil[T0] }[T](tail, tail.length.suc, head)","List.cons(head, tail).drop_last(List.cons(head, tail).length) != List.nil[T]","List.cons(head, tail).drop_last(tail.length.suc) != List.nil[T]"]}
{"goal":"drop_last_all","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T], x1: T) { not r(x0) or r(List.cons(x1, x0)) }(s1(r), s0(r))","function(x0: List[T]) { x0.drop_last(x0.length) != List.nil[T] or r(x0) }(List.nil[T])","function(x0: List[T]) { not r(x0) or x0.drop_last(x0.length) = List.nil[T] }(l)","not r(l)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](r, l)","function[T0](x0: List[T0], x1: Nat) { List.nil[T0] != x0 or x0.drop_last(x1) = List.nil[T0] }[T](List.nil[T], List.nil[T].length)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](r, l)","function[T0](x0: Nat) { List.nil[T0].drop_last(x0) = List.nil[T0] }[T](List.nil[T].length)","r(List.nil[T])","r(s1(r))","not r(List.cons[T](s0(r), s1(r)))"]}
{"goal":"tail.length + b.length = (tail + b).length","proof":["function[T0](x0: List[T0], x1: List[T0]) { x0.length + x1.length = (x0 + x1).length }[T](tail, b)"]}
{"goal":"tail.length + b.length = b.length + tail.length","proof":["function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(tail.length, b.length)"]}
{"goal":"b.length <= b.length + tail.length","proof":["function(x0: Nat, x1: Nat, x2: Nat) { x0 + x1 != x2 or x0 <= x2 }(b.length, tail.length, tail.length + b.length)","not b.length <= tail.length + b.length","b.length <= tail.length + b.length"]}
{"goal":"not b.length <= b.length + tail.length or not b.length + tail.length < b.length","proof":["function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 <= x0 }(b.length + tail.length, b.length)"]}
{"goal":"List.cons(head, tail + b).drop_last(b.length) = List.cons(head, (tail + b).drop_last(b.length))","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x1.length < x3 or List.cons[T0](x0, x1.drop_last(x3)) = x2.drop_last(x3) }[T](head, tail + b, List.cons(head, tail + b), b.length)","(tail + b).length < b.length"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { (x0 + b).drop_last(b.length) != x0 or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { not p(x0) or (x0 + b).drop_last(b.length) = x0 }(tail)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, List.cons(head, tail), b)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[T, List[T], List[T]](List.cons[T], tail, head)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[T, List[T], List[T]](List.cons[T], (tail + b).drop_last(b.length), head)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) + x2 = List.cons[T0](x0, x1 + x2) }[T](head, tail, b)","(List.cons(head, tail) + b).drop_last(b.length) != List.cons(head, tail)","(tail + b).drop_last(b.length) = tail"]}
{"goal":"drop_last_cancels_add","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1(p), s0(p))","function(x0: List[T]) { (x0 + b).drop_last(b.length) != x0 or p(x0) }(List.nil[T])","function(x0: List[T]) { not p(x0) or (x0 + b).drop_last(b.length) = x0 }(a)","not p(a)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](p, a)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](p, a)","function[T0](x0: List[T0]) { List.nil[T0] + x0 = x0 }[T](b)","(List.nil[T] + b).drop_last(b.length) = List.nil[T]","p(List.nil[T])","p(s1(p))","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"zero_until","proof":["function(x0: Nat, x1: Nat) { x0.range.drop(x1) = x1.until(x0) }(n, 0)"]}
{"goal":"until_self","proof":["function(x0: Nat, x1: Nat) { x0.range.drop(x1) = x1.until(x0) }(n, n)","function[T0](x0: List[T0]) { x0 + List.nil[T0] = x0 }[Nat](n.range)","function(x0: Nat) { x0.range.length = x0 }(n)"]}
{"goal":"until_suc","proof":["function(x0: Nat, x1: Nat) { x0.suc != x1 or x0.range.append(x0) = x1.range }(n, n.suc)","function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[Nat](n.range, n)","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat, List[Nat]](List.drop[Nat], n.range.length, n.range + List.singleton(n))","function[T0, T1, T2](x0: (T0, T1) -> T2, x1: T1, x2: T0) { lib(util).flip[T0, T1, T2](x0, x1, x2) = x0(x2, x1) }[List[Nat], Nat, List[Nat]](List.drop[Nat], n, n.suc.range)","function(x0: Nat, x1: Nat) { x0.range.drop(x1) = x1.until(x0) }(n.suc, n)","function(x0: Nat) { x0.range.length = x0 }(n)","function(x0: Nat) { x0.range.append(x0) = x0.suc.range }(n)"]}
{"goal":"zero_upto","proof":["function(x0: Nat, x1: Nat) { x0.until(x1.suc) = x0.upto(x1) }(0, n)","function(x0: Nat) { 0.until(x0) = x0.range }(n.suc)"]}
{"goal":"upto_self","proof":["function(x0: Nat) { x0.until(x0.suc) = List.singleton(x0) }(n)","function(x0: Nat, x1: Nat) { x0.until(x1.suc) = x0.upto(x1) }(n, n)"]}
{"goal":"exists(k0: Nat) { a + k0 = b }","proof":["let s0: (Nat, Nat) -> Nat satisfy { forall(x0: Nat, x1: Nat) { not x0 <= x1 or x0 + s0(x0, x1) = x1 } and forall(x2: Nat, x3: Nat, x4: Nat) { x2 + x3 != x4 or x2 <= x4 } }","function(x0: Nat) { a + x0 != b }(s0(a, b))","function(x0: Nat, x1: Nat) { not x0 <= x1 or x0 + s0(x0, x1) = x1 }(a, b)"]}
{"goal":"f(0)","proof":["function(x0: Nat) { a.range + a.until(a + x0) != (a + x0).range or f(x0) }(0)","function[T0](x0: List[T0]) { x0 + List.nil[T0] = x0 }[Nat](a.range)","function(x0: Nat) { x0 + 0 = x0 }(a)","a.range + a.until(a + 0) != (a + 0).range","a.range + a.until(a + 0) != a.range","a.range + a.until(a) != a.range"]}
{"goal":"a + x.suc = (a + x).suc","proof":["function(x0: Nat, x1: Nat, x2: Nat) { x0.suc != x1 or (x2 + x0).suc = x2 + x1 }(x, x.suc, a)"]}
{"goal":"a.range + a.until(a + x) + List.singleton(a + x) = (a.range + a.until(a + x)).append(a + x)","proof":["function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[Nat](a.range + a.until(a + x), a + x)"]}
{"goal":"(a + x.suc).range.drop(a) = a.until(a + x.suc)","proof":["function(x0: Nat, x1: Nat) { x0.range.drop(x1) = x1.until(x0) }(a + x.suc, a)"]}
{"goal":"a.range.length = a","proof":["function(x0: Nat) { x0.range.length = x0 }(a)"]}
{"goal":"(a + x).range.append(a + x) = (a + x).suc.range","proof":["(a + x).range.append(a + x) != (a + x.suc).range","function(x0: Nat, x1: Nat) { x0.suc != x1 or x0.range.append(x0) = x1.range }(a + x, a + x.suc)"]}
{"goal":"a.range + a.until(a + x) = (a + x).range","proof":["function(x0: Nat) { not f(x0) or a.range + a.until(a + x0) = (a + x0).range }(x)"]}
{"goal":"f(x.suc)","proof":["function(x0: Nat) { a.range + a.until(a + x0) != (a + x0).range or f(x0) }(x.suc)","function[T0](x0: List[T0], x1: List[T0], x2: List[T0]) { x0 + x1 + x2 = x0 + (x1 + x2) }[Nat](a.range, a.until(a + x), List.singleton(a + x))","a.range + a.until(a + x.suc) != (a + x.suc).range"]}
{"goal":"f(k)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(0) or not x2(s0(x2).suc) or x2(x3) } }","function(x0: Nat) { not f(x0) or f(x0.suc) }(s0(f))","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or not x0(s0(x0).suc) or x0(x1) }(f, k)","not f(s0(f).suc)","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) }(f, k)","not f(s0(f))","f(s0(f))"]}
{"goal":"range_add_until","proof":["function(x0: Nat) { not f(x0) or a.range + a.until(a + x0) = (a + x0).range }(k)","a.range + a.until(b) != (a + k).range","a.range + a.until(a + k) = (a + k).range","a.range + a.until(a + k) != (a + k).range"]}
{"goal":"not List.nil[Nat].contains(0)","proof":["function[T0](x0: List[T0], x1: T0) { not x1  x0 or List.nil[T0] != x0 }[Nat](List.nil[Nat], 0)"]}
{"goal":"f(List.nil[Nat])","proof":["let s0: List[Nat] -> Nat satisfy { forall(x0: List[Nat], x1: Nat) { not x1  x0 or not f(x0) or x1 <= max_list(x0) } and forall(x2: List[Nat]) { s0(x2)  x2 or f(x2) } and forall(x3: List[Nat]) { not s0(x3) <= max_list(x3) or f(x3) } }","function(x0: List[Nat]) { s0(x0)  x0 or f(x0) }(List.nil[Nat])","function[T0](x0: List[T0], x1: T0) { not x1  x0 or List.nil[T0] != x0 }[Nat](List.nil[Nat], s0(List.nil[Nat]))","s0(List.nil[Nat])  List.nil[Nat]"]}
{"goal":"m >= max_list(tail)","proof":["function[T0: lib(order).LinearOrder](x0: T0, x1: T0) { T0.max(x0, x1) >= x1 }[Nat](head, max_list(tail))","not head.max(k) >= max_list(tail)"]}
{"goal":"tail.contains(x) implies x <= m","proof":["function(x0: List[Nat], x1: Nat) { not x1  x0 or not f(x0) or x1 <= max_list(x0) }(tail, x)","function[T0](x0: (T0, T0) -> Bool, x1: T0, x2: T0, x3: T0) { not lib(util).is_transitive[T0](x0) or not x0(x1, x2) or not x0(x2, x3) or x0(x1, x3) }[Nat](Nat.lte, x, max_list(tail), m)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](m, max_list(tail))","max_list(tail) <= m","function(x0: Nat) { not x <= x0 or not x0 <= m }(max_list(tail))","x <= max_list(tail)","not x <= max_list(tail)"]}
{"goal":"List.cons(head, tail).contains(x) implies x <= m","proof":["function[T0](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not x1  x0 or List.cons[T0](x2, x3) != x0 or x1  x3 or x1 = x2 }[Nat](List.cons(head, tail), x, head, tail)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](m, x)","not m >= x","function[T0: lib(order).LinearOrder](x0: T0, x1: T0) { T0.max(x0, x1) >= x0 }[Nat](head, k)","function[T0](x0: T0, x1: List[T0], x2: T0) { not x2  List.cons[T0](x0, x1) or x2  x1 or x0 = x2 }[Nat](head, tail, x)","x = head","not m >= head"]}
{"goal":"head.max(max_list(tail)) = max_list(List.cons(head, tail))","proof":["function(x0: Nat, x1: List[Nat], x2: List[Nat]) { List.cons(x0, x1) != x2 or x0.max(max_list(x1)) = max_list(x2) }(head, tail, List.cons(head, tail))"]}
{"goal":"m = max_list(List.cons(head, tail))","proof":[]}
{"goal":"f(List.cons(head, tail))","proof":["let s0: List[Nat] -> Nat satisfy { forall(x0: List[Nat], x1: Nat) { not x1  x0 or not f(x0) or x1 <= max_list(x0) } and forall(x2: List[Nat]) { s0(x2)  x2 or f(x2) } and forall(x3: List[Nat]) { not s0(x3) <= max_list(x3) or f(x3) } }","function(x0: List[Nat]) { s0(x0)  x0 or f(x0) }(List.cons(head, tail))","function(x0: List[Nat]) { not s0(x0) <= max_list(x0) or f(x0) }(List.cons(head, tail))","function(x0: Nat) { not x0  List.cons(head, tail) or x0 <= m }(s0(List.cons(head, tail)))","s0(List.cons(head, tail))  List.cons(head, tail)","not s0(List.cons(head, tail)) <= max_list(List.cons(head, tail))","s0(List.cons(head, tail)) <= m","not s0(List.cons(head, tail)) <= m"]}
{"goal":"f(list)","proof":["let  (s0: Nat, s1: List[Nat]) satisfy { forall(x0: List[Nat]) { not f(List.nil[Nat]) or f(s1) or f(x0) } and forall(x1: List[Nat]) { not f(List.cons(s0, s1)) or not f(List.nil[Nat]) or f(x1) } }","function(x0: List[Nat]) { not f(List.nil[Nat]) or f(s1) or f(x0) }(list)","function(x0: List[Nat]) { f(s1) or f(x0) }(list)","f(s1)","function(x0: List[Nat]) { not f(List.cons(s0, s1)) or not f(List.nil[Nat]) or f(x0) }(list)","function(x0: List[Nat]) { not f(List.cons(s0, s1)) or f(x0) }(list)","function(x0: List[Nat], x1: Nat) { not f(x0) or f(List.cons(x1, x0)) }(s1, s0)","not f(List.cons(s0, s1))"]}
{"goal":"list_has_max","proof":["let s0: Nat satisfy { s0  list and not s0 <= n }","function(x0: List[Nat], x1: Nat) { not x1  x0 or not f(x0) or x1 <= max_list(x0) }(list, s0)","function[T0](x0: (T0, T0) -> Bool, x1: T0, x2: T0, x3: T0) { not lib(util).is_transitive[T0](x0) or not x0(x1, x2) or not x0(x2, x3) or x0(x1, x3) }[Nat](Nat.lte, s0, max_list(list), n)","s0 <= max_list(list)","function(x0: Nat) { not s0 <= x0 or not x0 <= n }(max_list(list))"]}
{"goal":"no_list_contains_nat","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { x0 < s0(x0) } and forall(x1: Nat) { s0(x1).is_prime } }","function(x0: Nat) { x0  list }(s0(max_list(list)))","function(x0: List[Nat], x1: Nat, x2: Nat) { not max_list(x0) <= x1 or not x2  x0 or x2 <= x1 }(list, max_list(list), s0(max_list(list)))","function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 <= x0 }(max_list(list), s0(max_list(list)))","function(x0: Nat) { x0 < s0(x0) }(max_list(list))","function(x0: Nat) { x0 <= x0 }(max_list(list))","function(x0: Nat, x1: Nat) { not max_list(list) <= x0 or x1 <= x0 }(max_list(list), s0(max_list(list)))","function(x0: Nat) { x0 <= max_list(list) }(s0(max_list(list)))","function(x0: Nat) { not max_list(list) < x0 }(s0(max_list(list)))"]}
{"goal":"not List.nil[T].contains(item)","proof":["function[T0](x0: List[T0], x1: T0) { not x1  x0 or List.nil[T0] != x0 }[T](List.nil[T], item)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { item  x0 or p(x0) }(List.nil[T])"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { not x0.find_first_idx(item) < x0.length or p(x0) }(List.cons(head, tail))","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or 0 = x2.find_first_idx(x3) }[T](head, tail, List.cons(head, tail), item)","function(x0: Nat, x1: Nat) { x0 < x1 or x1 < x0 or x0 = x1 }(List.cons(head, tail).length, 0)","function[T0](x0: List[T0]) { 0 != x0.length or List.nil[T0] = x0 }[T](List.cons(head, tail))","function[T0](x0: List[T0], x1: T0) { not x1  x0 or List.nil[T0] != x0 }[T](List.cons(head, tail), item)","function(x0: Nat) { not x0 < 0 }(List.cons(head, tail).length)","List.cons(head, tail) != List.nil[T]","not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length","function(x0: List[T], x1: List[T]) { List.cons(head, x0) != x1 or x1.find_first_idx(item) = 0 }(tail, List.cons(head, tail))","function(x0: List[T]) { List.cons(head, x0).find_first_idx(item) = 0 }(tail)","not 0 < List.cons(head, tail).length","List.cons(head, tail).length != 0","List.cons(head, tail).length = 0"]}
{"goal":"tail.contains(item)","proof":["function[T0](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not x1  x0 or List.cons[T0](x2, x3) != x0 or x1  x3 or x1 = x2 }[T](List.cons(head, tail), item, head, tail)","function[T0](x0: T0, x1: List[T0], x2: T0) { not x2  List.cons[T0](x0, x1) or x2  x1 or x0 = x2 }[T](head, tail, item)"]}
{"goal":"tail.find_first_idx(item) < tail.length","proof":["function(x0: List[T]) { not item  x0 or not p(x0) or x0.find_first_idx(item) < x0.length }(tail)"]}
{"goal":"1 + tail.find_first_idx(item) = tail.find_first_idx(item).suc","proof":["function(x0: Nat) { 1 + x0 = x0.suc }(tail.find_first_idx(item))"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, List.cons(head, tail))","function(x0: T) { List.cons(head, tail) != List.cons(x0, tail) }(head)"]}
{"goal":"not tail.length <= tail.find_first_idx(item) or not tail.find_first_idx(item) < tail.length","proof":["function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 <= x0 }(tail.find_first_idx(item), tail.length)"]}
{"goal":"tail.length.suc <= tail.find_first_idx(item).suc or tail.find_first_idx(item).suc < tail.length.suc","proof":["function(x0: Nat, x1: Nat) { x0 < x1 or x1 <= x0 }(tail.find_first_idx(item).suc, tail.length.suc)"]}
{"goal":"not tail.length.suc <= tail.find_first_idx(item).suc or tail.length <= tail.find_first_idx(item)","proof":["function(x0: Nat, x1: Nat) { not x0.suc <= x1.suc or x0 <= x1 }(tail.length, tail.find_first_idx(item))"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { not x0.find_first_idx(item) < x0.length or p(x0) }(List.cons(head, tail))","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or 1 + x1.find_first_idx(x3) = x2.find_first_idx(x3) or x0 = x3 }[T](head, tail, List.cons(head, tail), item)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](tail.length.suc, tail.find_first_idx(item).suc)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](List.cons(head, tail).length, List.cons(head, tail).find_first_idx(item))","not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length","function(x0: List[T], x1: List[T]) { List.cons(head, x0) != x1 or 1 + x0.find_first_idx(item) = x1.find_first_idx(item) }(tail, List.cons(head, tail))","function(x0: List[T]) { 1 + x0.find_first_idx(item) = List.cons(head, x0).find_first_idx(item) }(tail)"]}
{"goal":"p(list)","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(list)","function(x0: List[T]) { p(s1) or p(x0) }(list)","p(s1)","function(x0: List[T]) { item  x0 or p(x0) }(List.cons(s0, s1))","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list)","not p(List.cons(s0, s1))","function(x0: T, x1: List[T]) { not item  List.cons(x0, x1) or not p(x1) or p(List.cons(x0, x1)) }(s0, s1)","item  List.cons(s0, s1)","not item  List.cons(s0, s1)"]}
{"goal":"find_first_idx_contains","proof":["function(x0: List[T]) { not item  x0 or not p(x0) or x0.find_first_idx(item) < x0.length }(list)"]}
{"goal":"not List.nil[T].contains(item)","proof":["function[T0](x0: List[T0], x1: T0) { not x1  x0 or List.nil[T0] != x0 }[T](List.nil[T], item)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { item  x0 or p(x0) }(List.nil[T])"]}
{"goal":"List.cons(head, tail).find_first_idx(item) = 0","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or 0 = x2.find_first_idx(x3) }[T](head, tail, List.cons(head, tail), item)","function(x0: T, x1: List[T]) { List.cons(head, tail) != List.cons(x0, x1) or item != x0 }(head, tail)"]}
{"goal":"List.cons(head, tail).get_idx(0) = Option.some(head)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[T](head, tail, List.cons(head, tail), 0)","let s0: Nat satisfy { true }","function(x0: Nat, x1: Nat) { not x0 > 0 or x0 - 1 - x1 < x0 }(0, s0)","function(x0: Nat) { not x0 < 0 }(0 - 1 - s0)","function[T1](x0: Nat, x1: T1, x2: List[T1]) { x0 > 0 or List.cons[T1](x1, x2).get_idx(x0) = Option.some[T1](x1) }[T](0, head, tail)","0 > 0"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { x0.get_idx(x0.find_first_idx(item)) != Option.some(item) or p(x0) }(List.cons(head, tail))","List.cons(head, tail).get_idx(0) = Option.some(item)","List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item)","List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) = Option.some(item)"]}
{"goal":"1 + idx = idx.suc","proof":["function(x0: Nat) { 1 + x0 = x0.suc }(idx)"]}
{"goal":"idx.suc != 0","proof":["function(x0: Nat, x1: Nat) { x0 < x0 + x1.suc }(0, idx)","function(x0: Nat) { 0 + x0 = x0 }(idx.suc)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](0, idx.suc)","not 0 < idx.suc"]}
{"goal":"not idx.suc < 0","proof":["function(x0: Nat) { not x0 <= 0 or 0 = x0 }(idx.suc)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Nat](idx.suc, 0)","not idx.suc <= 0","idx.suc <= 0"]}
{"goal":"idx.suc > 0 = 0 < idx.suc","proof":["function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](idx.suc, 0)"]}
{"goal":"0 < idx.suc or idx.suc < 0 or idx.suc = 0","proof":["function(x0: Nat, x1: Nat) { x0 < x1 or x1 < x0 or x0 = x1 }(0, idx.suc)"]}
{"goal":"idx.suc > 0","proof":[]}
{"goal":"idx.suc - 1 = idx","proof":["function(x0: Nat, x1: Nat, x2: Nat) { x0 + x1 != x2 or x2 - x1 = x0 }(idx, 1, idx.suc)","function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(idx, 1)","idx + 1 != idx.suc","idx + 1 = idx.suc"]}
{"goal":"tail.get_idx(idx.suc - 1) = List.cons(head, tail).get_idx(idx.suc)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](idx.suc, head, tail, List.cons(head, tail))","function(x0: T) { List.cons(head, tail) != List.cons(x0, tail) }(head)"]}
{"goal":"List.cons(head, tail).get_idx(1 + idx) = tail.get_idx(idx)","proof":[]}
{"goal":"tail.contains(item)","proof":["function[T0](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not x1  x0 or List.cons[T0](x2, x3) != x0 or x1  x3 or x1 = x2 }[T](List.cons(head, tail), item, head, tail)","function[T0](x0: T0, x1: List[T0], x2: T0) { not x2  List.cons[T0](x0, x1) or x2  x1 or x0 = x2 }[T](head, tail, item)"]}
{"goal":"List.cons(head, tail).find_first_idx(item) = 1 + tail.find_first_idx(item)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or 1 + x1.find_first_idx(x3) = x2.find_first_idx(x3) or x0 = x3 }[T](head, tail, List.cons(head, tail), item)","function(x0: T) { List.cons(head, tail) != List.cons(x0, tail) or item = x0 }(head)"]}
{"goal":"tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","proof":["function(x0: List[T]) { not item  x0 or not p(x0) or x0.get_idx(x0.find_first_idx(item)) = Option.some(item) }(tail)"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { x0.get_idx(x0.find_first_idx(item)) != Option.some(item) or p(x0) }(List.cons(head, tail))","List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item)"]}
{"goal":"p(list)","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(list)","function(x0: List[T]) { p(s1) or p(x0) }(list)","p(s1)","function(x0: List[T]) { item  x0 or p(x0) }(List.cons(s0, s1))","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list)","not p(List.cons(s0, s1))","function(x0: T, x1: List[T]) { not item  List.cons(x0, x1) or not p(x1) or p(List.cons(x0, x1)) }(s0, s1)","item  List.cons(s0, s1)","not item  List.cons(s0, s1)"]}
{"goal":"find_first_idx_get_idx","proof":["function(x0: List[T]) { not item  x0 or not p(x0) or x0.get_idx(x0.find_first_idx(item)) = Option.some(item) }(list)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { i + 1 < x0.length or p(x0) }(List.nil[T])","function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](List.nil[T])","function(x0: Nat) { not x0 < 0 }(i + 1)","function[T0] { 0 = List.nil[T0].length }[T]","i + 1 < List.nil[T].length"]}
{"goal":"i + 1 = i.suc","proof":["function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(1, i)","1 + i != i.suc","function(x0: Nat) { 1 + x0 = x0.suc }(i)"]}
{"goal":"i.suc != 0","proof":["function(x0: Nat, x1: Nat) { x0 < x0 + x1.suc }(0, i)","function(x0: Nat) { 0 + x0 = x0 }(i.suc)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](0, i.suc)","not 0 < i.suc"]}
{"goal":"not i.suc < 0","proof":["function(x0: Nat) { not x0 <= 0 or 0 = x0 }(i.suc)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Nat](i.suc, 0)","not i.suc <= 0","i.suc <= 0"]}
{"goal":"i + 1 - 1 = i","proof":["i.suc - 1 != i","function(x0: Nat, x1: Nat, x2: Nat) { x0 + x1 != x2 or x2 - x1 = x0 }(i, 1, i.suc)"]}
{"goal":"i + 1 > 0 = 0 < i + 1","proof":["function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](i + 1, 0)"]}
{"goal":"not i + 1 > 0 or List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i + 1 - 1)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](i + 1, head, tail, List.cons(head, tail))","function(x0: T) { List.cons(head, tail) != List.cons(x0, tail) }(head)"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i)","proof":["function(x0: Nat, x1: Nat) { x0 < x1 or x1 < x0 or x0 = x1 }(0, i.suc)","function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(i, 1)","function(x0: Nat) { x0 + 1 = x0.suc }(i)","i + 1 > 0 = 0 < i.suc","0 < i.suc","function(x0: Nat) { List.cons(head, tail).get_idx(i + 1) != tail.get_idx(i + x0 - x0) }(1)","i + 1 > 0","not i + 1 > 0"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { x0.get_idx(i + 1) != x0.tail.get_idx(i) or p(x0) }(List.cons(head, tail))","function[T0](x0: T0, x1: List[T0]) { List.cons[T0](x0, x1).tail = x1 }[T](head, tail)","List.cons(head, tail).get_idx(i + 1) != List.cons(head, tail).tail.get_idx(i)"]}
{"goal":"get_idx_succ_implies_tail","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T]) { i + 1 < x0.length or p(x0) }(List.cons[T](s0(p), s1(p)))","function(x0: T, x1: List[T]) { not i + 1 < List.cons(x0, x1).length or not p(x1) or p(List.cons(x0, x1)) }(s0(p), s1(p))","function(x0: List[T]) { not i + 1 < x0.length or not p(x0) or x0.get_idx(i + 1) = x0.tail.get_idx(i) }(list)","not p(list)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](p, list)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](p, list)","function(x0: List[T]) { p(s1(p)) or p(x0) }(list)","p(s1(p))","function(x0: List[T]) { not p(List.cons[T](s0(p), s1(p))) or p(x0) }(list)","not p(List.cons[T](s0(p), s1(p)))","i + 1 < List.cons[T](s0(p), s1(p)).length","not i + 1 < List.cons[T](s0(p), s1(p)).length"]}
{"goal":"List.nil[T].count(item) = 0","proof":["function[T0](x0: List[T0], x1: T0) { List.nil[T0] != x0 or 0 = x0.count(x1) }[T](List.nil[T], item)"]}
{"goal":"not 1 < 0","proof":["function(x0: Nat) { not x0 <= 0 or 0 = x0 }(1)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Nat](1, 0)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](1, 0)","0 != 1","1 <= 0","not 1 <= 0"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { x0.count(item) > 1 or p(x0) }(List.nil[T])","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](0, 1)","List.nil[T].count(item) > 1"]}
{"goal":"1 + tail.count(item) = List.cons(item, tail).count(item)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or 1 + x1.count(x3) = x2.count(x3) }[T](item, tail, List.cons(item, tail), item)","function(x0: T) { List.cons(item, tail) != List.cons(x0, tail) or item != x0 }(item)"]}
{"goal":"List.cons(head, tail).count(item) > 1 = 1 < List.cons(head, tail).count(item)","proof":["function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](List.cons(head, tail).count(item), 1)"]}
{"goal":"not 1 < List.cons(head, tail).count(item) or List.cons(head, tail).count(item) != 1","proof":["1 < 1","function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 < x0 }(1, 1)"]}
{"goal":"1 + tail.count(item) = tail.count(item).suc","proof":["function(x0: Nat) { 1 + x0 = x0.suc }(tail.count(item))"]}
{"goal":"tail.count(item) = 0 or tail.contains(item)","proof":["function[T0](x0: List[T0], x1: T0) { 0 = x0.count(x1) or x1  x0 }[T](tail, item)"]}
{"goal":"tail.contains(item)","proof":["List.cons(item, tail).count(item) = 1 + 0","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](List.cons(head, tail).count(item), 1)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](1, List.cons(item, tail).count(item))","function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.add(x0, T0.0) = x0 }[Nat](1)","List.cons(item, tail).count(item) = 1","1 < List.cons(head, tail).count(item)","not 1 < List.cons(item, tail).count(item)","1 < List.cons(item, tail).count(item)"]}
{"goal":"idx + 1 < tail.length + 1","proof":["function[T0](x0: List[T0], x1: T0) { not x1  x0 or x0.find_first_idx(x1) < x0.length }[T](tail, item)","function(x0: Nat, x1: Nat) { not x0.suc <= x1.suc or x0 <= x1 }(tail.length, idx)","function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 <= x0 }(idx, tail.length)","function(x0: Nat, x1: Nat) { x0 < x1 or x1 <= x0 }(idx.suc, tail.length.suc)","function(x0: Nat) { x0 + 1 = x0.suc }(idx)","function(x0: Nat) { x0 + 1 = x0.suc }(tail.length)","not idx + 1 < tail.length.suc","not idx.suc < tail.length.suc","tail.length.suc <= idx.suc","tail.find_first_idx(item) < tail.length","idx < tail.length","tail.length <= idx","not tail.length <= idx"]}
{"goal":"idx + 1 > 0","proof":["function(x0: Nat, x1: Nat) { x0 < x0 + x1.suc }(0, idx)","function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(1, idx)","not 1 + idx > 0","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](idx.suc, 0)","function(x0: Nat) { 1 + x0 = x0.suc }(idx)","not idx.suc > 0","not 0 < idx.suc","function(x0: Nat) { 0 + x0 = x0 }(idx.suc)"]}
{"goal":"idx + 1 - 1 = idx","proof":["function(x0: Nat, x1: Nat, x2: Nat) { x0 + x1 != x2 or x2 - x1 = x0 }(idx, 1, idx + 1)"]}
{"goal":"List.cons(head, tail).get_idx(idx + 1) = tail.get_idx(idx)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](idx + 1, head, tail, List.cons(head, tail))","function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(idx, 1)","function[T1](x0: Nat, x1: List[T1], x2: T1) { not x0 > 0 or x1.get_idx(x0 - 1) = List.cons[T1](x2, x1).get_idx(x0) }[T](idx + 1, tail, head)","function(x0: Nat) { List.cons(head, tail).get_idx(idx + 1) != tail.get_idx(idx + x0 - x0) }(1)"]}
{"goal":"i < j","proof":["not 0 < j","j > 0","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](j, 0)"]}
{"goal":"List.cons(head, tail).get_idx(i) = Option.some(head)","proof":["List.cons(item, tail).get_idx(i) != Option.some(head)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[T](item, tail, List.cons(item, tail), i)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](i, 0)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](0, i)","List.cons(item, tail).get_idx(i) != Option.some(item)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.gt(x0, x1) or T0.lt(x1, x0) }[Nat](i, 0)","not 0 < i","function[T1](x0: Nat, x1: T1, x2: List[T1]) { x0 > 0 or List.cons[T1](x1, x2).get_idx(x0) = Option.some[T1](x1) }[T](i, item, tail)","not i > 0","i > 0"]}
{"goal":"tail.length + 1 = tail.length.suc","proof":["function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[Nat](tail.length, 1)","function(x0: Nat) { 1 + x0 = x0.suc }(tail.length)"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, List.cons(head, tail))","function(x0: T) { List.cons(head, tail) != List.cons(x0, tail) }(head)"]}
{"goal":"not tail.contains(item) or tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","proof":["function[T0](x0: List[T0], x1: T0) { not x1  x0 or x0.get_idx(x0.find_first_idx(x1)) = Option.some[T0](x1) }[T](tail, item)"]}
{"goal":"j < List.cons(head, tail).length","proof":[]}
{"goal":"List.cons(head, tail).get_idx(j) = Option.some(item)","proof":[]}
{"goal":"0 < j","proof":["not i < j"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: Nat, x1: List[T], x2: Nat) { not x0 < x1.length or Option.some(item) != x1.get_idx(x2) or Option.some(item) != x1.get_idx(x0) or not x2 < x0 or p(x1) }(j, List.cons(head, tail), i)","List.cons(head, tail).get_idx(i) = Option.some(item)","function(x0: Nat) { List.cons(head, tail).get_idx(x0) != Option.some(item) or not x0 < j }(i)"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < tail.length and tail.get_idx(k0) = Option.some(item) and tail.get_idx(k1) = Option.some(item) }","proof":["let  (s0: List[T] -> Nat, s1: List[T] -> Nat) satisfy { forall(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s0(x0) < s1(x0) } and forall(x1: List[T]) { not x1.count(item) > 1 or not p(x1) or s1(x1) < x1.length } and forall(x2: List[T]) { not x2.count(item) > 1 or not p(x2) or x2.get_idx(s0(x2)) = Option.some[T](item) } and forall(x3: List[T]) { not x3.count(item) > 1 or not p(x3) or x3.get_idx(s1(x3)) = Option.some[T](item) } and forall(x4: List[T]) { x4.count(item) > 1 or p(x4) } and forall(x5: Nat, x6: List[T], x7: Nat) { not x5 < x6.length or Option.some[T](item) != x6.get_idx(x7) or Option.some[T](item) != x6.get_idx(x5) or not x7 < x5 or p(x6) } }","function(x0: Nat, x1: Nat) { not x0 < tail.length or tail.get_idx(x1) != Option.some(item) or tail.get_idx(x0) != Option.some(item) or not x1 < x0 }(s1(tail), s0(tail))","function(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s0(x0) < s1(x0) }(tail)","function(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s1(x0) < x0.length }(tail)","function(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or x0.get_idx(s1(x0)) = Option.some(item) }(tail)","function(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or x0.get_idx(s0(x0)) = Option.some(item) }(tail)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x1.count(x3) = x2.count(x3) or x0 = x3 }[T](head, tail, List.cons(head, tail), item)","function(x0: List[T], x1: List[T]) { List.cons(head, x0) != x1 or x0.count(item) = x1.count(item) }(tail, List.cons(head, tail))","not tail.count(item) > 1 or s0(tail) < s1(tail)","not tail.count(item) > 1 or s1(tail) < tail.length","not tail.count(item) > 1 or tail.get_idx(s1(tail)) = Option.some(item)","function(x0: List[T]) { List.cons(head, x0).count(item) = x0.count(item) }(tail)","tail.count(item) > 1","s0(tail) < s1(tail)","s1(tail) < tail.length","tail.get_idx(s1(tail)) = Option.some(item)","tail.get_idx(s0(tail)) = Option.some(item)","tail.get_idx(s0(tail)) != Option.some(item)"]}
{"goal":"i + 1 > 0","proof":["function(x0: Nat, x1: Nat) { x0 < x0 + x1.suc }(0, i)","function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(1, i)","not 1 + i > 0","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](i.suc, 0)","function(x0: Nat) { 1 + x0 = x0.suc }(i)","not i.suc > 0","not 0 < i.suc","function(x0: Nat) { 0 + x0 = x0 }(i.suc)"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](i + 1, head, tail, List.cons(head, tail))","function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(i, 1)","function[T1](x0: Nat, x1: List[T1], x2: T1) { not x0 > 0 or x1.get_idx(x0 - 1) = List.cons[T1](x2, x1).get_idx(x0) }[T](i + 1, tail, head)","function(x0: Nat) { List.cons(head, tail).get_idx(i + 1) != tail.get_idx(i + x0 - x0) }(1)"]}
{"goal":"j + 1 > 0","proof":["function(x0: Nat, x1: Nat) { x0 < x0 + x1.suc }(0, j)","function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(1, j)","not 1 + j > 0","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](j.suc, 0)","function(x0: Nat) { 1 + x0 = x0.suc }(j)","not j.suc > 0","not 0 < j.suc","function(x0: Nat) { 0 + x0 = x0 }(j.suc)"]}
{"goal":"List.cons(head, tail).get_idx(j + 1) = tail.get_idx(j)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](j + 1, head, tail, List.cons(head, tail))","function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(j, 1)","function[T1](x0: Nat, x1: List[T1], x2: T1) { not x0 > 0 or x1.get_idx(x0 - 1) = List.cons[T1](x2, x1).get_idx(x0) }[T](j + 1, tail, head)","function(x0: Nat) { List.cons(head, tail).get_idx(j + 1) != tail.get_idx(j + x0 - x0) }(1)"]}
{"goal":"i + 1 < j + 1","proof":["function(x0: Nat, x1: Nat, x2: Nat) { not x0 < x1 or x2 + x0 < x2 + x1 }(i, j, 1)","function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(1, i)","not 1 + i < j + 1","function[T0: lib(add_comm_semigroup).AddCommSemigroup](x0: T0, x1: T0) { T0.add(x0, x1) = T0.add(x1, x0) }[Nat](1, j)","not 1 + i < 1 + j"]}
{"goal":"j + 1 = j.suc","proof":["function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(1, j)","1 + j != j.suc","function(x0: Nat) { 1 + x0 = x0.suc }(j)"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, List.cons(head, tail))","function(x0: T) { List.cons(head, tail) != List.cons(x0, tail) }(head)"]}
{"goal":"tail.length.suc <= j.suc or j.suc < tail.length.suc","proof":["function(x0: Nat, x1: Nat) { x0 < x1 or x1 <= x0 }(j.suc, tail.length.suc)"]}
{"goal":"not tail.length <= j or not j < tail.length","proof":["function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 <= x0 }(j, tail.length)"]}
{"goal":"not tail.length.suc <= j.suc or tail.length <= j","proof":["function(x0: Nat, x1: Nat) { not x0.suc <= x1.suc or x0 <= x1 }(tail.length, j)"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = Option.some(item)","proof":["List.cons(head, tail).get_idx(i + 1) != tail.get_idx(i)"]}
{"goal":"List.cons(head, tail).get_idx(j + 1) = Option.some(item)","proof":["List.cons(head, tail).get_idx(j + 1) != tail.get_idx(j)"]}
{"goal":"j + 1 < List.cons(head, tail).length","proof":[]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: Nat, x1: List[T], x2: Nat) { not x0 < x1.length or Option.some(item) != x1.get_idx(x2) or Option.some(item) != x1.get_idx(x0) or not x2 < x0 or p(x1) }(j + 1, List.cons(head, tail), i + 1)","function(x0: Nat) { not x0 < j + 1 or List.cons(head, tail).get_idx(x0) != Option.some(item) }(i + 1)"]}
{"goal":"p(list)","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T]) { x0.count(item) > 1 or p(x0) }(List.cons[T](s0(p), s1(p)))","function(x0: T, x1: List[T]) { not List.cons(x0, x1).count(item) > 1 or not p(x1) or p(List.cons(x0, x1)) }(s0(p), s1(p))","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](p, list)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](p, list)","p(s1(p))","not p(List.cons[T](s0(p), s1(p)))","List.cons[T](s0(p), s1(p)).count(item) > 1","not List.cons[T](s0(p), s1(p)).count(item) > 1"]}
{"goal":"duplicate_implies_duplicate_idx","proof":["let  (s0: List[T] -> Nat, s1: List[T] -> Nat) satisfy { forall(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s0(x0) < s1(x0) } and forall(x1: List[T]) { not x1.count(item) > 1 or not p(x1) or s1(x1) < x1.length } and forall(x2: List[T]) { not x2.count(item) > 1 or not p(x2) or x2.get_idx(s0(x2)) = Option.some[T](item) } and forall(x3: List[T]) { not x3.count(item) > 1 or not p(x3) or x3.get_idx(s1(x3)) = Option.some[T](item) } and forall(x4: List[T]) { x4.count(item) > 1 or p(x4) } and forall(x5: Nat, x6: List[T], x7: Nat) { not x5 < x6.length or Option.some[T](item) != x6.get_idx(x7) or Option.some[T](item) != x6.get_idx(x5) or not x7 < x5 or p(x6) } }","function(x0: Nat, x1: Nat) { not x0 < list.length or list.get_idx(x1) != Option.some(item) or list.get_idx(x0) != Option.some(item) or not x1 < x0 }(s1(list), s0(list))","function(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s0(x0) < s1(x0) }(list)","function(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s1(x0) < x0.length }(list)","function(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or x0.get_idx(s1(x0)) = Option.some(item) }(list)","function(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or x0.get_idx(s0(x0)) = Option.some(item) }(list)","s0(list) < s1(list)","s1(list) < list.length","list.get_idx(s0(list)) = Option.some(item)","list.get_idx(s1(list)) = Option.some(item)","list.get_idx(s1(list)) != Option.some(item)"]}
{"goal":"list.unique.length < list.length implies exists(k0: T) { list.count(k0) > 1 }","proof":["let s0[T0]: List[T0] -> T0 satisfy { forall(x0: List[T0]) { not x0.unique.length < x0.length or x0.count(s0(x0)) > 1 } }","function(x0: T) { not list.count(x0) > 1 }(s0(list))","function[T0](x0: List[T0]) { not x0.unique.length < x0.length or x0.count(s0(x0)) > 1 }[T](list)"]}
{"goal":"exists(k0: T) { list.count(k0) > 1 }","proof":["let s0: T satisfy { not list.unique.length < list.length or list.count(s0) > 1 }","function(x0: T) { not list.count(x0) > 1 }(s0)"]}
{"goal":"list.count(item) > 1 implies exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < list.length and list.get_idx(k0) = Option.some(item) and list.get_idx(k1) = Option.some(item) }","proof":["let [T0] (s0: (List[T0], T0) -> Nat, s1: (List[T0], T0) -> Nat) satisfy { forall(x0: List[T0], x1: T0) { not x0.count(x1) > 1 or s0(x0, x1) < s1(x0, x1) } and forall(x2: List[T0], x3: T0) { not x2.count(x3) > 1 or s1(x2, x3) < x2.length } and forall(x4: List[T0], x5: T0) { not x4.count(x5) > 1 or x4.get_idx(s0(x4, x5)) = Option.some[T0](x5) } and forall(x6: List[T0], x7: T0) { not x6.count(x7) > 1 or x6.get_idx(s1(x6, x7)) = Option.some[T0](x7) } }","function(x0: Nat, x1: Nat) { not x0 < list.length or list.get_idx(x1) != Option.some(item) or list.get_idx(x0) != Option.some(item) or not x1 < x0 }(s1(list, item), s0(list, item))","function[T0](x0: List[T0], x1: T0) { not x0.count(x1) > 1 or s1(x0, x1) < x0.length }[T](list, item)","function[T0](x0: List[T0], x1: T0) { not x0.count(x1) > 1 or x0.get_idx(s1(x0, x1)) = Option.some[T0](x1) }[T](list, item)","function[T0](x0: List[T0], x1: T0) { not x0.count(x1) > 1 or x0.get_idx(s0(x0, x1)) = Option.some[T0](x1) }[T](list, item)","function[T0](x0: List[T0], x1: T0) { not x0.count(x1) > 1 or s0(x0, x1) < s1(x0, x1) }[T](list, item)","s1(list, item) < list.length","s0(list, item) < s1(list, item)","list.get_idx(s0(list, item)) = Option.some(item)","list.get_idx(s1(list, item)) = Option.some(item)","list.get_idx(s1(list, item)) != Option.some(item)"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < list.length and list.get_idx(k0) = Option.some(item) and list.get_idx(k1) = Option.some(item) }","proof":["let  (s0: Nat, s1: Nat) satisfy { not list.count(item) > 1 or s0 < s1 and (not list.count(item) > 1 or s1 < list.length) and (not list.count(item) > 1 or list.get_idx(s0) = Option.some[T](item)) and (not list.count(item) > 1 or list.get_idx(s1) = Option.some[T](item)) }","function(x0: Nat, x1: Nat) { not x0 < list.length or list.get_idx(x1) != Option.some(item) or list.get_idx(x0) != Option.some(item) or not x1 < x0 }(s1, s0)","list.get_idx(s0) != Option.some(item)"]}
{"goal":"list.get_idx(i) = list.get_idx(j)","proof":["list.get_idx(i) != Option.some(item)"]}
{"goal":"index_pigeonhole","proof":["let [T0] (s0: (List[T0], T0) -> Nat, s1: (List[T0], T0) -> Nat) satisfy { forall(x0: List[T0], x1: T0) { not x0.count(x1) > 1 or s0(x0, x1) < s1(x0, x1) } and forall(x2: List[T0], x3: T0) { not x2.count(x3) > 1 or s1(x2, x3) < x2.length } and forall(x4: List[T0], x5: T0) { not x4.count(x5) > 1 or x4.get_idx(s0(x4, x5)) = Option.some[T0](x5) } and forall(x6: List[T0], x7: T0) { not x6.count(x7) > 1 or x6.get_idx(s1(x6, x7)) = Option.some[T0](x7) } }","let s2: T satisfy { not list.unique.length < list.length or list.count(s2) > 1 }","function(x0: Nat, x1: Nat) { not x0 < list.length or list.get_idx(x0) != list.get_idx(x1) or not x1 < x0 }(s1(list, s2), s0(list, s2))","function[T0](x0: List[T0], x1: T0) { not x0.count(x1) > 1 or s1(x0, x1) < x0.length }[T](list, s2)","function[T0](x0: List[T0], x1: T0) { not x0.count(x1) > 1 or x0.get_idx(s1(x0, x1)) = Option.some[T0](x1) }[T](list, s2)","function[T0](x0: List[T0], x1: T0) { not x0.count(x1) > 1 or x0.get_idx(s0(x0, x1)) = Option.some[T0](x1) }[T](list, s2)","function[T0](x0: List[T0], x1: T0) { not x0.count(x1) > 1 or s0(x0, x1) < s1(x0, x1) }[T](list, s2)","s1(list, s2) < list.length","s0(list, s2) < s1(list, s2)","list.get_idx(s0(list, s2)) = Option.some(s2)","list.get_idx(s1(list, s2)) = Option.some(s2)","list.get_idx(s1(list, s2)) != list.get_idx(s0(list, s2))","list.get_idx(s1(list, s2)) = list.get_idx(s0(list, s2))"]}
{"goal":"pl(0, l)","proof":["function(x0: Nat, x1: List[T]) { x0 < x1.length or pl(x0, x1) }(0, l)","function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](l)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](0, l.length)","0 < l.length","l.length = 0","l.length != 0"]}
{"goal":"List.cons(head, tail) = l","proof":[]}
{"goal":"l.get_idx(0) = Option.some(head)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[T](head, tail, l, 0)","let s0: Nat satisfy { true }","function(x0: Nat, x1: Nat) { not x0 > 0 or x0 - 1 - x1 < x0 }(0, s0)","function(x0: Nat) { not x0 < 0 }(0 - 1 - s0)","function(x0: List[T]) { List.cons(head, x0) != l or 0 > 0 }(tail)","0 > 0"]}
{"goal":"pl(0, l)","proof":["function(x0: List[T], x1: Nat, x2: T) { x0.get_idx(x1) != Option.some(x2) or pl(x1, x0) }(l, 0, head)"]}
{"goal":"pl(0, l)","proof":["function(x0: List[T]) { pl(0, x0) }(l)"]}
{"goal":"p(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pl(x0, x1) } and forall(x2: Nat) { not pl(x2, s0(x2)) or p(x2) } }","function(x0: List[T]) { pl(0, x0) }(s0(0))","function(x0: Nat) { not pl(x0, s0(x0)) or p(x0) }(0)"]}
{"goal":"i + 1 < l.length","proof":["function(x0: Nat, x1: Nat) { x0 < x1 or x1 <= x0 }(i + 1, l.length)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](i + 1, l.length)","l.length <= i + 1","not l.length <= i + 1"]}
{"goal":"exists(k0: T) { tail.get_idx(i) = Option.some(k0) }","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pl(x0, x1) or Option.some[T](s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { x2 < x3.length or pl(x2, x3) } and forall(x4: List[T], x5: Nat, x6: T) { x4.get_idx(x5) != Option.some[T](x6) or pl(x5, x4) } }","function(x0: T) { tail.get_idx(i) != Option.some(x0) }(s0(i, tail))","function(x0: Nat, x1: List[T]) { not p(x0) or pl(x0, x1) }(i, tail)","function(x0: Nat, x1: List[T]) { not x0 < x1.length or not pl(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) }(i, tail)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, l)","function(x0: Nat, x1: Nat) { not x0.suc < x1.suc or x0 < x1 }(i, tail.length)","function(x0: Nat) { x0 + 1 = x0.suc }(i)","i.suc < l.length","function(x0: List[T]) { pl(i, x0) }(tail)","not i < tail.length","tail.length.suc = l.length","not i.suc < tail.length.suc","i.suc < tail.length.suc"]}
{"goal":"not i + 1 < l.length or l.get_idx(i + 1) = l.tail.get_idx(i)","proof":["function[T0](x0: Nat, x1: List[T0]) { not x0 + 1 < x1.length or x1.get_idx(x0 + 1) = x1.tail.get_idx(x0) }[T](i, l)"]}
{"goal":"List.cons(head, tail) != l or l.tail = tail","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x2.tail = x1 }[T](head, tail, l)"]}
{"goal":"pl(i + 1, l)","proof":["function(x0: List[T], x1: Nat, x2: T) { x0.get_idx(x1) != Option.some(x2) or pl(x1, x0) }(l, i + 1, x)","l.get_idx(i + 1) = tail.get_idx(i)","function(x0: T) { l.get_idx(i + 1) != Option.some(x0) }(x)"]}
{"goal":"i + 1 < l.length or pl(i + 1, l)","proof":["function(x0: Nat, x1: List[T]) { x0 < x1.length or pl(x0, x1) }(i + 1, l)"]}
{"goal":"l.length <= i + 1 = i + 1 >= l.length","proof":["function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](i + 1, l.length)"]}
{"goal":"not l.length <= i + 1 or not i + 1 < l.length","proof":["i + 1 >= l.length","function(x0: Nat, x1: Nat) { not x1  x0.range or not x1 >= x0 }(l.length, i + 1)","function(x0: Nat, x1: Nat) { not x0 < x1 or x0  x1.range }(i + 1, l.length)","not i + 1  l.length.range","i + 1  l.length.range"]}
{"goal":"i + 1 = 1 + i","proof":["function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(i, 1)"]}
{"goal":"1 + i = i.suc","proof":["function(x0: Nat) { 1 + x0 = x0.suc }(i)"]}
{"goal":"i.suc - 0 = i.suc","proof":["function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(i.suc, 0)","function(x0: Nat) { x0 + 0 = x0 }(i.suc)"]}
{"goal":"not i + 1 < l.length or i + 1 != l.length","proof":["l.length < l.length","function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 < x0 }(l.length, l.length)"]}
{"goal":"pl(i + 1, l)","proof":["not i + 1 >= l.length","List.nil[T] = l","function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](l)","function(x0: Nat) { not x0 < 0 }(i + 1)","l.length = 0"]}
{"goal":"pl(i + 1, l)","proof":["function(x0: List[T]) { pl(i + 1, x0) }(l)"]}
{"goal":"p(i + 1)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pl(x0, x1) } and forall(x2: Nat) { not pl(x2, s0(x2)) or p(x2) } }","function(x0: Nat) { not pl(x0, s0(x0)) or p(x0) }(i + 1)","function(x0: List[T]) { pl(i + 1, x0) }(s0(i + 1))"]}
{"goal":"p(idx)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(0) or not x2(s0(x2).suc) or x2(x3) } }","function(x0: Nat) { not p(x0) or p(x0 + 1) }(s0(p))","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or not x0(s0(x0).suc) or x0(x1) }(p, idx)","not p(s0(p).suc)","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) }(p, idx)","p(s0(p))","function(x0: Nat) { x0 + 1 = x0.suc }(s0(p))","p(s0(p) + 1)","not p(s0(p) + 1)"]}
{"goal":"pl(idx, list)","proof":["function(x0: Nat, x1: List[T]) { not p(x0) or pl(x0, x1) }(idx, list)"]}
{"goal":"get_idx_always_some","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pl(x0, x1) or Option.some[T](s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { x2 < x3.length or pl(x2, x3) } and forall(x4: List[T], x5: Nat, x6: T) { x4.get_idx(x5) != Option.some[T](x6) or pl(x5, x4) } }","function(x0: T) { list.get_idx(idx) != Option.some(x0) }(s0(idx, list))","function(x0: Nat, x1: List[T]) { not x0 < x1.length or not pl(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) }(idx, list)"]}
{"goal":"pf(0, l)","proof":["function(x0: Nat, x1: List[T]) { x0 < x1.length or pf(x0, x1) }(0, l)","function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](l)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](0, l.length)","0 < l.length","l.length = 0","l.length != 0"]}
{"goal":"map[T, U](l, f).get_idx(0) = Option.some(f(head))","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[U](f(head), tail.map(f), l.map(f), 0)","function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), x1.map(x3)) = x2.map(x3) }[T, U](head, tail, l, f)","let s0: Nat satisfy { true }","function(x0: Nat, x1: Nat) { not x0 > 0 or x0 - 1 - x1 < x0 }(0, s0)","function[T0, T1](x0: List[T0], x1: T0 -> T1) { map[T0, T1](x0, x1) = x0.map(x1) }[T, U](l, f)","l.map(f).get_idx(0) != Option.some(f(head))","function(x0: Nat) { not x0 < 0 }(0 - 1 - s0)","function(x0: List[U]) { l.map(f) != List.cons(f(head), x0) or 0 > 0 }(tail.map(f))","function[T0](x0: T -> T0) { List.cons[T0](x0(head), tail.map(x0)) = l.map(x0) }[U](f)","0 > 0"]}
{"goal":"pf(0, l)","proof":["function(x0: List[T], x1: Nat, x2: T) { map[T, U](x0, f).get_idx(x1) != Option.some(f(x2)) or x0.get_idx(x1) != Option.some(x2) or pf(x1, x0) }(l, 0, head)","function[T0](x0: List[T0], x1: T0) { not x1  x0 or x0.get_idx(x0.find_first_idx(x1)) = Option.some[T0](x1) }[T](l, head)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or 0 = x2.find_first_idx(x3) }[T](head, tail, l, head)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or x3  x2 }[T](head, tail, l, head)","l.get_idx(0) != Option.some(head)","function(x0: T) { head != x0 or x0  l }(head)","head  l","function(x0: T) { head != x0 or l.find_first_idx(x0) = 0 }(head)","l.find_first_idx(head) = 0","l.get_idx(l.find_first_idx(head)) = Option.some(head)","l.get_idx(l.find_first_idx(head)) != Option.some(head)"]}
{"goal":"pf(0, l)","proof":["function(x0: List[T]) { pf(0, x0) }(l)"]}
{"goal":"p(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pf(x0, x1) } and forall(x2: Nat) { not pf(x2, s0(x2)) or p(x2) } }","function(x0: List[T]) { pf(0, x0) }(s0(0))","function(x0: Nat) { not pf(x0, s0(x0)) or p(x0) }(0)"]}
{"goal":"pf(i + 1, l)","proof":["function(x0: Nat, x1: List[T]) { x0 < x1.length or pf(x0, x1) }(i + 1, l)","function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 <= x0 }(i + 1, l.length)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](i + 1, l.length)","l.length <= i + 1","i + 1 < l.length","not i + 1 < l.length"]}
{"goal":"i + 1 = i.suc","proof":["function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(1, i)","1 + i != i.suc","function(x0: Nat) { 1 + x0 = x0.suc }(i)"]}
{"goal":"i.suc != 0","proof":["function(x0: Nat, x1: Nat) { x0 < x0 + x1.suc }(0, i)","function(x0: Nat) { 0 + x0 = x0 }(i.suc)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](0, i.suc)","not 0 < i.suc"]}
{"goal":"i + 1 > 0","proof":["function(x0: Nat, x1: Nat) { x0 < x1 or x1 <= x0 }(0, i.suc)","function(x0: Nat) { not x0 <= 0 or 0 = x0 }(i.suc)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](i + 1, 0)","not 0 < i + 1","not 0 < i.suc","not i.suc <= 0","i.suc <= 0"]}
{"goal":"i + 1 - 1 = i","proof":["i.suc - 1 != i","function(x0: Nat, x1: Nat, x2: Nat) { x0 + x1 != x2 or x2 - x1 = x0 }(i, 1, i.suc)"]}
{"goal":"tail.get_idx(i + 1 - 1) = l.get_idx(i + 1)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](i + 1, head, tail, l)","function(x0: T) { List.cons(x0, tail) != l }(head)"]}
{"goal":"l.get_idx(i + 1) = tail.get_idx(i)","proof":["tail.get_idx(i + 1 - 1) != l.get_idx(i + 1)"]}
{"goal":"i < tail.length","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, l)","function(x0: Nat, x1: Nat) { not x0.suc < x1.suc or x0 < x1 }(i, tail.length)","function(x0: Nat, x1: Nat) { x0 < x1 or x1 <= x0 }(i.suc, tail.length.suc)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](i + 1, l.length)","function(x0: Nat) { x0 + 1 = x0.suc }(i)","not l.length <= i + 1","not i.suc < tail.length.suc","not l.length <= i.suc","tail.length.suc = l.length","tail.length.suc <= i.suc","not tail.length.suc <= i.suc"]}
{"goal":"pf(i, tail)","proof":["function(x0: Nat, x1: List[T]) { not p(x0) or pf(x0, x1) }(i, tail)"]}
{"goal":"exists(k0: T) { tail.get_idx(i) = Option.some(k0) and map[T, U](tail, f).get_idx(i) = Option.some(f(k0)) }","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or Option.some[T](s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { not x2 < x3.length or not pf(x2, x3) or map[T, U](x3, f).get_idx(x2) = Option.some[U](f(s0(x2, x3))) } and forall(x4: Nat, x5: List[T]) { x4 < x5.length or pf(x4, x5) } and forall(x6: List[T], x7: Nat, x8: T) { map[T, U](x6, f).get_idx(x7) != Option.some[U](f(x8)) or x6.get_idx(x7) != Option.some[T](x8) or pf(x7, x6) } }","function(x0: T) { map[T, U](tail, f).get_idx(i) != Option.some(f(x0)) or tail.get_idx(i) != Option.some(x0) }(s0(i, tail))","function(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) }(i, tail)","function(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or map[T, U](x1, f).get_idx(x0) = Option.some(f(s0(x0, x1))) }(i, tail)","Option.some(s0(i, tail)) = tail.get_idx(i)","map[T, U](tail, f).get_idx(i) = Option.some(f(s0(i, tail)))","map[T, U](tail, f).get_idx(i) != Option.some(f(s0(i, tail)))"]}
{"goal":"List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","proof":["function[T0, T1](x0: T0, x1: List[T0], x2: List[T0], x3: T0 -> T1) { List.cons[T0](x0, x1) != x2 or List.cons[T1](x3(x0), map[T0, T1](x1, x3)) = map[T0, T1](x2, x3) }[T, U](head, tail, List.cons(head, tail), f)"]}
{"goal":"map[T, U](List.cons(head, tail), f).get_idx(i + 1) = map[T, U](tail, f).get_idx(i + 1 - 1)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[U](i + 1, f(head), map[T, U](tail, f), map[T, U](List.cons(head, tail), f))","function(x0: U) { map[T, U](List.cons(head, tail), f) != List.cons(x0, map[T, U](tail, f)) }(f(head))"]}
{"goal":"i + 1 - 1 = i","proof":[]}
{"goal":"l.get_idx(i + 1) = Option.some(x)","proof":["l.get_idx(i + 1) != tail.get_idx(i)"]}
{"goal":"map[T, U](l, f).get_idx(i + 1) = Option.some(f(x))","proof":[]}
{"goal":"pf(i + 1, l)","proof":["function(x0: List[T], x1: Nat, x2: T) { map[T, U](x0, f).get_idx(x1) != Option.some(f(x2)) or x0.get_idx(x1) != Option.some(x2) or pf(x1, x0) }(l, i + 1, x)"]}
{"goal":"pf(i + 1, l)","proof":["function(x0: Nat, x1: List[T]) { x0 < x1.length or pf(x0, x1) }(i + 1, l)","function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](l)","l.length = 0","function(x0: Nat) { not x0 < 0 }(i + 1)","i + 1 < l.length"]}
{"goal":"p(i) implies p(i.suc)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pf(x0, x1) } and forall(x2: Nat) { not pf(x2, s0(x2)) or p(x2) } }","function(x0: Nat) { not pf(x0, s0(x0)) or p(x0) }(i + 1)","function(x0: Nat, x1: List[T]) { not p(x0) or pf(x0 + 1, x1) }(i, s0(i + 1))","function(x0: Nat) { x0 + 1 = x0.suc }(i)","not p(i + 1)","function(x0: List[T]) { pf(i + 1, x0) }(s0(i + 1))"]}
{"goal":"p(idx)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(0) or not x2(s0(x2).suc) or x2(x3) } }","function(x0: Nat) { not p(x0) or p(x0.suc) }(s0(p))","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or not x0(s0(x0).suc) or x0(x1) }(p, idx)","not p(s0(p).suc)","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) }(p, idx)","not p(s0(p))","p(s0(p))"]}
{"goal":"pf(idx, a)","proof":["function(x0: Nat, x1: List[T]) { not p(x0) or pf(x0, x1) }(idx, a)"]}
{"goal":"map_under_idx","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or Option.some[T](s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { not x2 < x3.length or not pf(x2, x3) or map[T, U](x3, f).get_idx(x2) = Option.some[U](f(s0(x2, x3))) } and forall(x4: Nat, x5: List[T]) { x4 < x5.length or pf(x4, x5) } and forall(x6: List[T], x7: Nat, x8: T) { map[T, U](x6, f).get_idx(x7) != Option.some[U](f(x8)) or x6.get_idx(x7) != Option.some[T](x8) or pf(x7, x6) } }","function(x0: T) { map[T, U](a, f).get_idx(idx) != Option.some(f(x0)) or a.get_idx(idx) != Option.some(x0) }(s0(idx, a))","function(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) }(idx, a)","function(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or map[T, U](x1, f).get_idx(x0) = Option.some(f(s0(x0, x1))) }(idx, a)","Option.some(s0(idx, a)) = a.get_idx(idx)","map[T, U](a, f).get_idx(idx) = Option.some(f(s0(idx, a)))","map[T, U](a, f).get_idx(idx) != Option.some(f(s0(idx, a)))"]}
{"goal":"fp(0, l)","proof":["function(x0: Nat, x1: List[T]) { x0 < x1.length or fp(x0, x1) }(0, l)","function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](l)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](0, l.length)","0 < l.length","l.length = 0","l.length != 0"]}
{"goal":"(l + b).get_idx(0) = Option.some(head)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[T](head, tail + b, l + b, 0)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, l, b)","let s0: Nat satisfy { true }","function(x0: Nat, x1: Nat) { not x0 > 0 or x0 - 1 - x1 < x0 }(0, s0)","function(x0: Nat) { not x0 < 0 }(0 - 1 - s0)","function(x0: List[T]) { l + b != List.cons(head, x0) or 0 > 0 }(tail + b)","function(x0: List[T]) { List.cons(head, tail + x0) = l + x0 }(b)","0 > 0"]}
{"goal":"fp(0, l)","proof":["function(x0: List[T], x1: Nat) { (x0 + b).get_idx(x1) != x0.get_idx(x1) or fp(x1, x0) }(l, 0)","function[T0](x0: List[T0], x1: T0) { not x1  x0 or x0.get_idx(x0.find_first_idx(x1)) = Option.some[T0](x1) }[T](l, head)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or 0 = x2.find_first_idx(x3) }[T](head, tail, l, head)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or x3  x2 }[T](head, tail, l, head)","function(x0: T) { head != x0 or x0  l }(head)","head  l","(l + b).get_idx(0) != l.get_idx(0)","l.get_idx(0) != Option.some(head)","function(x0: T) { head != x0 or l.find_first_idx(x0) = 0 }(head)","l.find_first_idx(head) = 0","l.get_idx(l.find_first_idx(head)) = Option.some(head)","l.get_idx(l.find_first_idx(head)) != Option.some(head)"]}
{"goal":"fp(0, l)","proof":["function(x0: List[T]) { fp(0, x0) }(l)"]}
{"goal":"f(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not f(x0) or fp(x0, x1) } and forall(x2: Nat) { not fp(x2, s0(x2)) or f(x2) } }","function(x0: List[T]) { fp(0, x0) }(s0(0))","function(x0: Nat) { not fp(x0, s0(x0)) or f(x0) }(0)"]}
{"goal":"i + 1 = i.suc","proof":["function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(1, i)","1 + i != i.suc","function(x0: Nat) { 1 + x0 = x0.suc }(i)"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["tail.length.suc != l.length","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, l)"]}
{"goal":"i < tail.length","proof":["function(x0: Nat, x1: Nat) { not x0.suc < x1.suc or x0 < x1 }(i, tail.length)","not i.suc < tail.length.suc"]}
{"goal":"l.tail = tail","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x2.tail = x1 }[T](head, tail, l)"]}
{"goal":"fp(i, tail)","proof":["function(x0: Nat, x1: List[T]) { not f(x0) or fp(x0, x1) }(i, tail)"]}
{"goal":"(tail + b).get_idx(i) = tail.get_idx(i)","proof":["function(x0: Nat, x1: List[T]) { not x0 < x1.length or not fp(x0, x1) or (x1 + b).get_idx(x0) = x1.get_idx(x0) }(i, tail)"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = (tail + b).get_idx(i)","proof":["l.get_idx(i + 1) != (tail + b).get_idx(i)","function[T0](x0: Nat, x1: List[T0]) { not x0 + 1 < x1.length or x1.get_idx(x0 + 1) = x1.tail.get_idx(x0) }[T](i, l)","l.get_idx(i + 1) != tail.get_idx(i)","l.get_idx(i + 1) = l.tail.get_idx(i)","l.get_idx(i + 1) != l.tail.get_idx(i)"]}
{"goal":"i + 1 > 0","proof":["function(x0: Nat, x1: Nat) { x0 < x0 + x1.suc }(0, i)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](i + 1, 0)","not 0 < i + 1","not 0 < i.suc","function(x0: Nat) { 0 + x0 = x0 }(i.suc)"]}
{"goal":"List.cons(head, tail + b).get_idx(i + 1) = (tail + b).get_idx(i)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](i + 1, head, tail + b, List.cons(head, tail + b))","function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(i, 1)","function[T1](x0: Nat, x1: List[T1], x2: T1) { not x0 > 0 or x1.get_idx(x0 - 1) = List.cons[T1](x2, x1).get_idx(x0) }[T](i + 1, tail + b, head)","function(x0: Nat) { List.cons(head, tail + b).get_idx(i + 1) != (tail + b).get_idx(i + x0 - x0) }(1)"]}
{"goal":"fp(i + 1, l)","proof":["function(x0: List[T], x1: Nat) { (x0 + b).get_idx(x1) != x0.get_idx(x1) or fp(x1, x0) }(l, i + 1)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, List.cons(head, tail), b)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) + x2 = List.cons[T0](x0, x1 + x2) }[T](head, tail, b)","(l + b).get_idx(i + 1) != l.get_idx(i + 1)"]}
{"goal":"fp(i + 1, l)","proof":["function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](l)","l.length = 0","function(x0: Nat) { not x0 < 0 }(i + 1)"]}
{"goal":"fp(i + 1, l)","proof":["function(x0: Nat, x1: List[T]) { x0 < x1.length or fp(x0, x1) }(i + 1, l)","function(x0: List[T]) { not i + 1 < x0.length or fp(i + 1, x0) }(l)","i + 1 < l.length","not i + 1 < l.length"]}
{"goal":"f(i + 1)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not f(x0) or fp(x0, x1) } and forall(x2: Nat) { not fp(x2, s0(x2)) or f(x2) } }","function(x0: Nat) { not fp(x0, s0(x0)) or f(x0) }(i + 1)","function(x0: List[T]) { fp(i + 1, x0) }(s0(i + 1))"]}
{"goal":"f(n)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(0) or not x2(s0(x2).suc) or x2(x3) } }","function(x0: Nat) { not f(x0) or f(x0 + 1) }(s0(f))","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or not x0(s0(x0).suc) or x0(x1) }(f, n)","not f(s0(f).suc)","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) }(f, n)","f(s0(f))","function(x0: Nat) { x0 + 1 = x0.suc }(s0(f))","f(s0(f) + 1)","not f(s0(f) + 1)"]}
{"goal":"fp(n, a)","proof":["function(x0: Nat, x1: List[T]) { not f(x0) or fp(x0, x1) }(n, a)"]}
{"goal":"append_add_idx_left","proof":["function(x0: Nat, x1: List[T]) { not x0 < x1.length or not fp(x0, x1) or (x1 + b).get_idx(x0) = x1.get_idx(x0) }(n, a)"]}
{"goal":"List.cons(a, List.nil[T]) = List.singleton(a)","proof":["function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[T](a)"]}
{"goal":"List.nil[T] + List.singleton(a) = List.singleton(a)","proof":["function[T0](x0: List[T0], x1: List[T0]) { List.nil[T0] != x0 or x0 + x1 = x1 }[T](List.nil[T], List.singleton(a))"]}
{"goal":"List.nil[T].length = 0","proof":["function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](List.nil[T])"]}
{"goal":"List.singleton(a).get_idx(0) = Option.some(a)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[T](a, List.nil[T], List.singleton(a), 0)","let s0: Nat satisfy { true }","function(x0: Nat, x1: Nat) { not x0 > 0 or x0 - 1 - x1 < x0 }(0, s0)","function[T0](x0: T0) { List.cons[T0](x0, List.nil[T0]) = List.singleton[T0](x0) }[T](a)","function(x0: Nat) { not x0 < 0 }(0 - 1 - s0)","function(x0: List[T]) { List.singleton(a) != List.cons(a, x0) or 0 > 0 }(List.nil[T])","0 > 0"]}
{"goal":"f(List.nil[T])","proof":["function(x0: List[T]) { (x0 + List.singleton(a)).get_idx(x0.length) != Option.some(a) or f(x0) }(List.nil[T])","(List.nil[T] + List.singleton(a)).get_idx(List.nil[T].length) != Option.some(a)"]}
{"goal":"l.length = tail.length.suc","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, l)"]}
{"goal":"tail.length.suc - 1 = tail.length","proof":["function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(tail.length, 1)","function(x0: Nat) { x0 + 1 = x0.suc }(tail.length)"]}
{"goal":"l.length - 1 = tail.length","proof":["tail.length.suc - 1 != tail.length"]}
{"goal":"(tail + sa).get_idx(tail.length) = Option.some(a)","proof":["function(x0: List[T]) { not f(x0) or (x0 + List.singleton(a)).get_idx(x0.length) = Option.some(a) }(tail)","(tail + List.singleton(a)).get_idx(tail.length) != Option.some(a)","(tail + List.singleton(a)).get_idx(tail.length) = Option.some(a)"]}
{"goal":"(l + sa).get_idx(l.length) = (tail + sa).get_idx(l.length - 1)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, l, sa)","function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](l.length, head, tail + sa, l + sa)","function[T0](x0: List[T0], x1: T0) { not x1  x0 or x0.find_first_idx(x1) < x0.length }[T](l, head)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or 0 = x2.find_first_idx(x3) }[T](head, tail, l, head)","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or x0 != x3 or x3  x2 }[T](head, tail, l, head)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](l.length, 0)","function(x0: T) { head != x0 or x0  l }(head)","head  l","function(x0: T) { not l.length > 0 or List.cons(x0, tail + sa) != l + sa }(head)","function(x0: T) { head != x0 or l.find_first_idx(x0) = 0 }(head)","l.find_first_idx(head) = 0","function(x0: List[T]) { List.cons(head, tail + x0) = l + x0 }(sa)","not l.length > 0","not 0 < l.length","l.find_first_idx(head) < l.length","not l.find_first_idx(head) < l.length"]}
{"goal":"f(List.cons(head, tail))","proof":["function(x0: List[T]) { (x0 + List.singleton(a)).get_idx(x0.length) != Option.some(a) or f(x0) }(List.cons(head, tail))","(List.cons(head, tail) + List.singleton(a)).get_idx(List.cons(head, tail).length) != Option.some(a)"]}
{"goal":"append_add_singleton_right","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T], x1: T) { not f(x0) or f(List.cons(x1, x0)) }(s1(f), s0(f))","function(x0: List[T]) { not f(x0) or (x0 + List.singleton(a)).get_idx(x0.length) = Option.some(a) }(list)","not f(list)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](f, list)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](f, list)","function(x0: List[T]) { f(s1(f)) or f(x0) }(list)","f(s1(f))","function(x0: List[T]) { not f(List.cons[T](s0(f), s1(f))) or f(x0) }(list)","not f(List.cons[T](s0(f), s1(f)))"]}
{"goal":"f(0)","proof":["function(x0: Nat) { idx < x0 or f(x0) }(0)","function(x0: Nat) { not x0 < 0 }(idx)"]}
{"goal":"(m.range + List.singleton(m)).get_idx(idx) = m.range.get_idx(idx)","proof":["function[T0](x0: Nat, x1: List[T0], x2: List[T0]) { not x0 < x1.length or (x1 + x2).get_idx(x0) = x1.get_idx(x0) }[Nat](idx, m.range, List.singleton(m))","function(x0: Nat) { x0.range.length = x0 }(m)","not idx < m.range.length","idx < m.range.length"]}
{"goal":"f(m + 1)","proof":["function(x0: Nat) { x0.range.get_idx(idx) != Option.some(idx) or f(x0) }(m + 1)","function(x0: Nat) { not idx < x0 or not f(x0) or x0.range.get_idx(idx) = Option.some(idx) }(m)","function(x0: Nat, x1: Nat) { x0.suc != x1 or x0.range.append(x0) = x1.range }(m, m.suc)","function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[Nat](m.range, m)","function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(m, 1)","function(x0: Nat) { 1 + x0 = x0.suc }(m)","function(x0: Nat) { x0.range.append(x0) = x0.suc.range }(m)","(m + 1).range.get_idx(idx) != Option.some(idx)","m.range.get_idx(idx) = Option.some(idx)"]}
{"goal":"(m.range + List.singleton(m)).get_idx(m) = Option.some(m)","proof":["function[T0](x0: List[T0], x1: T0) { (x0 + List.singleton[T0](x1)).get_idx(x0.length) = Option.some[T0](x1) }[Nat](m.range, m)","function(x0: Nat) { x0.range.length = x0 }(m)"]}
{"goal":"f(m + 1)","proof":["function(x0: Nat) { x0.range.get_idx(idx) != Option.some(idx) or f(x0) }(m + 1)","function(x0: Nat, x1: Nat) { not x0 < x1.suc or x0 < x1 or x0 = x1 }(idx, m)","function(x0: Nat, x1: Nat) { x0.suc != x1 or x0.range.append(x0) = x1.range }(m, m.suc)","function[T0](x0: List[T0], x1: T0) { x0 + List.singleton[T0](x1) = x0.append(x1) }[Nat](m.range, m)","function(x0: Nat, x1: Nat) { x0 + x1 = x1 + x0 }(m, 1)","function(x0: Nat) { 1 + x0 = x0.suc }(m)","function(x0: Nat) { x0 + 1 = x0.suc }(m)","idx < m.suc","m = idx","function(x0: Nat) { x0.range.append(x0) = x0.suc.range }(m)","(m + 1).range.get_idx(idx) != Option.some(idx)"]}
{"goal":"idx < m + 1 or f(m + 1)","proof":["function(x0: Nat) { idx < x0 or f(x0) }(m + 1)"]}
{"goal":"f(m + 1)","proof":[]}
{"goal":"f(n)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(0) or not x2(s0(x2).suc) or x2(x3) } }","function(x0: Nat) { not f(x0) or f(x0 + 1) }(s0(f))","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or not x0(s0(x0).suc) or x0(x1) }(f, n)","not f(s0(f).suc)","function(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) }(f, n)","f(s0(f))","function(x0: Nat) { x0 + 1 = x0.suc }(s0(f))","f(s0(f) + 1)","not f(s0(f) + 1)"]}
{"goal":"range_idx_eq_idx","proof":["function(x0: Nat) { not idx < x0 or not f(x0) or x0.range.get_idx(idx) = Option.some(idx) }(n)"]}
{"goal":"map_range","proof":["function(x0: Nat, x1: Nat) { not x0 < x1 or x1.range.get_idx(x0) = Option.some(x0) }(idx, n)","let s0: Nat satisfy { not idx < n.range.length or n.range.get_idx(idx) = Option.some(s0) and (not idx < n.range.length or map[Nat, T](n.range, f).get_idx(idx) = Option.some[T](f(s0))) }","function[T0](x0: T0, x1: T0) { Option.some[T0](x0) != Option.some[T0](x1) or x0 = x1 }[Nat](s0, idx)","function(x0: Nat) { x0.range.length = x0 }(n)","idx < n.range.length","n.range.get_idx(idx) = Option.some(idx)","n.range.get_idx(idx) = Option.some(s0)","Option.some(s0) = Option.some(idx)","map[Nat, T](n.range, f).get_idx(idx) = Option.some(f(s0))","Option.some(f(s0)) != Option.some(f(idx))","f(s0) != f(idx)","s0 = idx","s0 != idx"]}
{"goal":"f_out.length = n.range.length","proof":["function[T0, T1](x0: List[T0], x1: T0 -> T1) { map[T0, T1](x0, x1).length = x0.length }[Nat, T](n.range, f)","map[Nat, T](n.range, f).length != n.range.length"]}
{"goal":"n.range.length = n","proof":["function(x0: Nat) { x0.range.length = x0 }(n)"]}
{"goal":"f_out.length = n","proof":["n.range.length != f_out.length"]}
{"goal":"f_out.unique.length < f_out.length","proof":[]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < f_out.length and f_out.get_idx(k0) = f_out.get_idx(k1) }","proof":["let [T0] (s0: List[T0] -> Nat, s1: List[T0] -> Nat) satisfy { forall(x0: List[T0]) { not x0.unique.length < x0.length or s0(x0) < s1(x0) } and forall(x1: List[T0]) { not x1.unique.length < x1.length or s1(x1) < x1.length } and forall(x2: List[T0]) { not x2.unique.length < x2.length or x2.get_idx(s1(x2)) = x2.get_idx(s0(x2)) } }","function(x0: Nat, x1: Nat) { not x0 < f_out.length or f_out.get_idx(x0) != f_out.get_idx(x1) or not x1 < x0 }(s1(f_out), s0(f_out))","function[T0](x0: List[T0]) { not x0.unique.length < x0.length or s1(x0) < x0.length }[T](f_out)","function[T0](x0: List[T0]) { not x0.unique.length < x0.length or s0(x0) < s1(x0) }[T](f_out)","function[T0](x0: List[T0]) { not x0.unique.length < x0.length or x0.get_idx(s1(x0)) = x0.get_idx(s0(x0)) }[T](f_out)","s0(f_out) < s1(f_out)","s1(f_out) < f_out.length","f_out.get_idx(s1(f_out)) = f_out.get_idx(s0(f_out))","f_out.get_idx(s1(f_out)) != f_out.get_idx(s0(f_out))"]}
{"goal":"j < n","proof":["not j < f_out.length"]}
{"goal":"map[Nat, T](n.range, f).get_idx(i) = Option.some(f(i))","proof":["function[T0](x0: Nat, x1: Nat, x2: Nat -> T0) { not x0 < x1 or map[Nat, T0](x1.range, x2).get_idx(x0) = Option.some[T0](x2(x0)) }[T](i, n, f)","not i < n","function(x0: Nat, x1: Nat, x2: Nat) { not x0 < x1 or not x1 <= x2 or x0 < x2 }(i, j, n)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Nat](j, n)","j <= n","function(x0: Nat) { not j <= x0 or i < x0 }(n)"]}
{"goal":"map[Nat, T](n.range, f).get_idx(j) = Option.some(f(j))","proof":["function[T0](x0: Nat, x1: Nat, x2: Nat -> T0) { not x0 < x1 or map[Nat, T0](x1.range, x2).get_idx(x0) = Option.some[T0](x2(x0)) }[T](j, n, f)"]}
{"goal":"Option.some(f(j)) = Option.some(f(i)) implies f(j) = f(i)","proof":["function[T0](x0: T0, x1: T0) { Option.some[T0](x0) != Option.some[T0](x1) or x0 = x1 }[T](f(i), f(j))"]}
{"goal":"f(i) = f(j)","proof":[]}
{"goal":"range_pigeonhole","proof":["function(x0: Nat, x1: Nat) { not x0 < n or not x1 < x0 or f(x0) != f(x1) }(j, i)","not i < j"]}
{"goal":"exists(k0: Nat) { k0.suc = i }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { 0 = x0 or s0(x0).suc = x0 } }","function(x0: Nat) { x0.suc != i }(s0(i))","function(x0: Nat) { 0 = x0 or s0(x0).suc = x0 }(i)"]}
{"goal":"i > 0","proof":["function(x0: Nat, x1: Nat) { x0 < x1 or x1 <= x0 }(0, i)","function(x0: Nat) { not x0 <= 0 or 0 = x0 }(i)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](i, 0)","not 0 < i","not i <= 0","i <= 0"]}
{"goal":"i_pred.suc - 1 = i_pred","proof":["function(x0: Nat, x1: Nat) { x0 + x1 - x1 = x0 }(i_pred, 1)","function(x0: Nat) { x0 + 1 = x0.suc }(i_pred)"]}
{"goal":"i - 1 = i_pred","proof":["i_pred.suc - 1 != i_pred"]}
{"goal":"List.cons(head, tail).get_idx(i) = tail.get_idx(i_pred)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](i, head, tail, List.cons(head, tail))","tail.get_idx(i - 1) != List.cons(head, tail).get_idx(i)","function[T1](x0: Nat, x1: List[T1], x2: T1) { not x0 > 0 or x1.get_idx(x0 - 1) = List.cons[T1](x2, x1).get_idx(x0) }[T](i, tail, head)"]}
{"goal":"List.cons(head, tail).get_idx(i) = Option.none[T]","proof":["function(x0: Nat, x1: List[T]) { not x0 >= x1.length or not p(x1) or x1.get_idx(x0) = Option.none[T] }(i_pred, tail)","tail.get_idx(i_pred) != Option.none[T]","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, List.cons(head, tail))","function(x0: Nat, x1: Nat) { not x0.suc <= x1.suc or x0 <= x1 }(tail.length, i_pred)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](i, tail.length.suc)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](i_pred, tail.length)","not i_pred >= tail.length","not tail.length <= i_pred","function[T0](x0: List[T0], x1: T0) { x0.length.suc = List.cons[T0](x1, x0).length }[T](tail, head)","i >= tail.length.suc","tail.length.suc <= i","not tail.length.suc <= i_pred.suc","tail.length.suc <= i_pred.suc"]}
{"goal":"List.cons(head, tail).length = tail.length.suc","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](head, tail, List.cons(head, tail))","function(x0: T) { List.cons(head, tail) != List.cons(x0, tail) }(head)"]}
{"goal":"tail.length.suc != 0","proof":["function(x0: Nat) { 0 != x0.suc }(tail.length)"]}
{"goal":"not tail.length.suc <= 0 or tail.length.suc = 0","proof":["function(x0: Nat) { not x0 <= 0 or 0 = x0 }(tail.length.suc)"]}
{"goal":"List.cons(head, tail).get_idx(0) = Option.some(head)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[T](head, tail, List.cons(head, tail), 0)","let s0: Nat satisfy { true }","function(x0: Nat, x1: Nat) { not x0 > 0 or x0 - 1 - x1 < x0 }(0, s0)","function(x0: Nat) { not x0 < 0 }(0 - 1 - s0)","function[T1](x0: Nat, x1: T1, x2: List[T1]) { x0 > 0 or List.cons[T1](x1, x2).get_idx(x0) = Option.some[T1](x1) }[T](0, head, tail)","0 > 0"]}
{"goal":"List.cons(head, tail).get_idx(0) != Option.none[T]","proof":["Option.some(head) = Option.none[T]","function[T0](x0: T0) { Option.none[T0] != Option.some[T0](x0) }[T](head)"]}
{"goal":"i >= List.cons(head, tail).length implies List.cons(head, tail).get_idx(i) = Option.none[T]","proof":["function(x0: Nat) { not x0 >= List.cons(head, tail).length or List.cons(head, tail).get_idx(x0) = Option.none[T] or 0 = x0 }(i)","0 = i","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](i, List.cons(head, tail).length)"]}
{"goal":"p(List.cons(head, tail))","proof":["let s0: List[T] -> Nat satisfy { forall(x0: Nat, x1: List[T]) { not x0 >= x1.length or not p(x1) or x1.get_idx(x0) = Option.none[T] } and forall(x2: List[T]) { s0(x2) >= x2.length or p(x2) } and forall(x3: List[T]) { x3.get_idx(s0(x3)) != Option.none[T] or p(x3) } }","function(x0: List[T]) { x0.get_idx(s0(x0)) != Option.none[T] or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { s0(x0) >= x0.length or p(x0) }(List.cons(head, tail))","function(x0: Nat) { not x0 >= List.cons(head, tail).length or List.cons(head, tail).get_idx(x0) = Option.none[T] }(s0(List.cons(head, tail)))","s0(List.cons(head, tail)) >= List.cons(head, tail).length","List.cons(head, tail).get_idx(s0(List.cons(head, tail))) != Option.none[T]","List.cons(head, tail).get_idx(s0(List.cons(head, tail))) = Option.none[T]"]}
{"goal":"get_idx_out_of_bounds","proof":["let [T0] (s0: (List[T0] -> Bool) -> T0, s1: (List[T0] -> Bool) -> List[T0]) satisfy { forall(x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T0] -> Bool, x3: List[T0]) { not x2(List.cons[T0](s0(x2), s1(x2))) or not x2(List.nil[T0]) or x2(x3) } }","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1(p), s0(p))","let s2: List[T] -> Nat satisfy { forall(x4: Nat, x5: List[T]) { not x4 >= x5.length or not p(x5) or x5.get_idx(x4) = Option.none[T] } and forall(x6: List[T]) { s2(x6) >= x6.length or p(x6) } and forall(x7: List[T]) { x7.get_idx(s2(x7)) != Option.none[T] or p(x7) } }","function(x0: List[T]) { x0.get_idx(s2(x0)) != Option.none[T] or p(x0) }(List.nil[T])","function(x0: Nat, x1: List[T]) { not x0 >= x1.length or not p(x1) or x1.get_idx(x0) = Option.none[T] }(idx, list)","not p(list)","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.cons[T0](s0(x0), s1(x0))) or not x0(List.nil[T0]) or x0(x1) }[T](p, list)","function[T0](x0: List[T0], x1: Nat) { List.nil[T0] != x0 or x0.get_idx(x1) = Option.none[T0] }[T](List.nil[T], s2(List.nil[T]))","function[T0](x0: List[T0] -> Bool, x1: List[T0]) { not x0(List.nil[T0]) or x0(s1(x0)) or x0(x1) }[T](p, list)","function[T0](x0: Nat) { List.nil[T0].get_idx(x0) = Option.none[T0] }[T](s2(List.nil[T]))","p(List.nil[T])","p(s1(p))","not p(List.cons[T](s0(p), s1(p)))"]}
{"goal":"exists(k0: T, k1: List[T]) { lb = List.cons(k0, k1) }","proof":["let [T0] (s0: List[T0] -> T0, s1: List[T0] -> List[T0]) satisfy { forall(x0: List[T0]) { List.cons[T0](s0(x0), s1(x0)) = x0 or List.nil[T0] = x0 } }","function(x0: T, x1: List[T]) { List.cons(x0, x1) != lb }(s0(lb), s1(lb))","function[T0](x0: List[T0]) { List.cons[T0](s0(x0), s1(x0)) = x0 or List.nil[T0] = x0 }[T](lb)"]}
{"goal":"lb.get_idx(0) = Option.some(hb)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[T](hb, tb, lb, 0)","let s0: Nat satisfy { true }","function(x0: Nat, x1: Nat) { not x0 > 0 or x0 - 1 - x1 < x0 }(0, s0)","function(x0: Nat) { not x0 < 0 }(0 - 1 - s0)","function(x0: List[T]) { List.cons(hb, x0) != lb or 0 > 0 }(tb)","0 > 0"]}
{"goal":"List.nil[T].get_idx(0) != lb.get_idx(0)","proof":["function[T0](x0: List[T0], x1: Nat) { List.nil[T0] != x0 or x0.get_idx(x1) = Option.none[T0] }[T](List.nil[T], Nat.zero)","function[T0](x0: T0) { Option.none[T0] != Option.some[T0](x0) }[T](hb)","lb.get_idx(0) = List.nil[T].get_idx(Nat.zero)","List.nil[T].get_idx(Nat.zero) = Option.some(hb)","function[T0](x0: Nat) { List.nil[T0].get_idx(x0) = Option.none[T0] }[T](Nat.zero)"]}
{"goal":"differ[T](List.nil[T], lb, n)","proof":["function[T0](x0: Nat, x1: Nat, x2: List[T0], x3: List[T0]) { not x0 < x1 or differ[T0](x2, x3, x1) or x2.get_idx(x0) = x3.get_idx(x0) }[T](0, n, List.nil[T], lb)","function(x0: Nat, x1: Nat) { x0 < x1 or x1 < x0 or x0 = x1 }(lb.length, 0)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lte(x0, x1) or T0.lt(x0, x1) or x0 = x1 }[Nat](0, n)","function[T0](x0: List[T0]) { 0 != x0.length or List.nil[T0] = x0 }[T](lb)","function[T0](x0: List[T0]) { List.nil[T0] != x0 or 0 = x0.length }[T](List.nil[T])","function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 <= x0 }(n, lb.length)","function(x0: Nat) { not x0 < 0 }(lb.length)","function[T0] { 0 = List.nil[T0].length }[T]","0 <= n","lb.length != 0","not n < lb.length","function(x0: Nat) { not x0 < n or List.nil[T].get_idx(x0) = lb.get_idx(x0) }(0)","not 0 < n","0 = n","0 < lb.length","not 0 < lb.length"]}
{"goal":"p(List.nil[T])","proof":["let s0: List[T] -> List[T] satisfy { forall(x0: List[T], x1: List[T]) { not x0.length <= n or not x1.length <= n or not p(x0) or differ[T](x0, x1, n) or x0 = x1 } and forall(x2: List[T]) { s0(x2) != x2 or p(x2) } and forall(x3: List[T]) { x3.length <= n or p(x3) } and forall(x4: List[T]) { s0(x4).length <= n or p(x4) } and forall(x5: List[T]) { not differ[T](x5, s0(x5), n) or p(x5) } }","function(x0: List[T]) { s0(x0) != x0 or p(x0) }(List.nil[T])","function(x0: List[T]) { not differ[T](x0, s0(x0), n) or p(x0) }(List.nil[T])","function(x0: List[T]) { x0.length <= n or p(x0) }(List.nil[T])","function(x0: List[T]) { s0(x0).length <= n or p(x0) }(List.nil[T])","function(x0: List[T]) { not List.nil[T].length <= n or not x0.length <= n or differ[T](List.nil[T], x0, n) or List.nil[T] = x0 }(s0(List.nil[T]))","s0(List.nil[T]) != List.nil[T]","List.nil[T].length <= n","s0(List.nil[T]).length <= n","not differ[T](List.nil[T], s0(List.nil[T]), n)","differ[T](List.nil[T], s0(List.nil[T]), n)"]}
{"goal":"List.cons(ha, ta).get_idx(0) = Option.some(ha)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[T](ha, ta, List.cons(ha, ta), 0)","let s0: Nat satisfy { true }","function(x0: Nat, x1: Nat) { not x0 > 0 or x0 - 1 - x1 < x0 }(0, s0)","function(x0: Nat) { not x0 < 0 }(0 - 1 - s0)","function[T1](x0: Nat, x1: T1, x2: List[T1]) { x0 > 0 or List.cons[T1](x1, x2).get_idx(x0) = Option.some[T1](x1) }[T](0, ha, ta)","0 > 0"]}
{"goal":"List.cons(ha, ta).get_idx(0) != lb.get_idx(0)","proof":["function[T0](x0: List[T0], x1: Nat) { List.nil[T0] != x0 or x0.get_idx(x1) = Option.none[T0] }[T](lb, Nat.zero)","function[T0](x0: T0) { Option.none[T0] != Option.some[T0](x0) }[T](ha)","List.cons(ha, ta).get_idx(0) = lb.get_idx(Nat.zero)","lb.get_idx(Nat.zero) = Option.some(ha)","function(x0: Nat) { lb.get_idx(x0) = Option.none[T] }(Nat.zero)"]}
{"goal":"not n < 0","proof":["function(x0: Nat) { not x0 <= 0 or 0 = x0 }(n)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Nat](n, 0)","n <= 0","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[Nat](n, 0)","0 = n","0 != n"]}
{"goal":"n < 0 or 0 < n or n = 0","proof":["function(x0: Nat, x1: Nat) { x0 < x1 or x1 < x0 or x0 = x1 }(n, 0)"]}
{"goal":"List.nil[T] != lb or lb.get_idx(0) = Option.none[T]","proof":["function[T0](x0: List[T0], x1: Nat) { List.nil[T0] != x0 or x0.get_idx(x1) = Option.none[T0] }[T](lb, 0)"]}
{"goal":"List.cons(ha, ta).length <= n = n >= List.cons(ha, ta).length","proof":["function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](n, List.cons(ha, ta).length)"]}
{"goal":"not n >= List.cons(ha, ta).length or List.cons(ha, ta).get_idx(n) = Option.none[T]","proof":["function[T0](x0: Nat, x1: List[T0]) { not x0 >= x1.length or x1.get_idx(x0) = Option.none[T0] }[T](n, List.cons(ha, ta))"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["function[T0](x0: Nat, x1: Nat, x2: List[T0], x3: List[T0]) { not x0 < x1 or differ[T0](x2, x3, x1) or x2.get_idx(x0) = x3.get_idx(x0) }[T](0, n, List.cons(ha, ta), lb)","n >= List.cons(ha, ta).length","List.cons(ha, ta).get_idx(0) != Option.none[T]","List.cons(ha, ta).get_idx(n) = Option.none[T]","function(x0: Nat) { not x0 < n or List.cons(ha, ta).get_idx(x0) = lb.get_idx(x0) }(0)","not 0 < n","0 = n"]}
{"goal":"exists(k0: T, k1: List[T]) { lb = List.cons(k0, k1) }","proof":["let [T0] (s0: List[T0] -> T0, s1: List[T0] -> List[T0]) satisfy { forall(x0: List[T0]) { List.cons[T0](s0(x0), s1(x0)) = x0 or List.nil[T0] = x0 } }","function(x0: T, x1: List[T]) { List.cons(x0, x1) != lb }(s0(lb), s1(lb))","function[T0](x0: List[T0]) { List.cons[T0](s0(x0), s1(x0)) = x0 or List.nil[T0] = x0 }[T](lb)"]}
{"goal":"List.cons(ha, ta).get_idx(0) = Option.some(ha)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[T](ha, ta, List.cons(ha, ta), 0)","let s0: Nat satisfy { true }","function(x0: Nat, x1: Nat) { not x0 > 0 or x0 - 1 - x1 < x0 }(0, s0)","function(x0: Nat) { not x0 < 0 }(0 - 1 - s0)","function[T1](x0: Nat, x1: T1, x2: List[T1]) { x0 > 0 or List.cons[T1](x1, x2).get_idx(x0) = Option.some[T1](x1) }[T](0, ha, ta)","0 > 0"]}
{"goal":"List.cons(hb, tb).get_idx(0) = Option.some(hb)","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: Nat) { List.cons[T0](x0, x1) != x2 or x3 > 0 or x2.get_idx(x3) = Option.some[T0](x0) }[T](hb, tb, List.cons(hb, tb), 0)","let s0: Nat satisfy { true }","function(x0: Nat, x1: Nat) { not x0 > 0 or x0 - 1 - x1 < x0 }(0, s0)","function(x0: Nat) { not x0 < 0 }(0 - 1 - s0)","function[T1](x0: Nat, x1: T1, x2: List[T1]) { x0 > 0 or List.cons[T1](x1, x2).get_idx(x0) = Option.some[T1](x1) }[T](0, hb, tb)","0 > 0"]}
{"goal":"tb.length < n","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](hb, tb, lb)","function(x0: Nat, x1: Nat, x2: Nat) { not x0 < x1 or not x1 <= x2 or x0 < x2 }(tb.length, tb.length.suc, n)","function(x0: Nat) { x0 < x0.suc }(tb.length)","function(x0: Nat) { not tb.length < x0 or not x0 <= n }(tb.length.suc)","not tb.length.suc <= n","tb.length.suc = lb.length"]}
{"goal":"differ[T](ta, tb, n)","proof":["function(x0: List[T], x1: List[T]) { not x0.length <= n or not x1.length <= n or not p(x0) or differ[T](x0, x1, n) or x0 = x1 }(ta, tb)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](ha, ta, List.cons(ha, ta))","function(x0: Nat, x1: Nat) { not x0 < x1 or x0 < x1.suc }(n, ta.length)","function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 <= x0 }(n, List.cons(ha, ta).length)","function(x0: Nat, x1: Nat) { x0 < x1 or x1 <= x0 }(n, ta.length)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[Nat](tb.length, n)","function[T0](x0: List[T0], x1: T0) { x0.length.suc = List.cons[T0](x1, x0).length }[T](ta, ha)","tb.length <= n","not ta.length <= n or tb = ta","List.cons(hb, tb) != List.cons(ha, ta)","not n < List.cons(ha, ta).length","List.cons(ha, tb) != List.cons(ha, ta)","tb != ta","not ta.length <= n","not n < ta.length.suc","n < ta.length","not n < ta.length"]}
{"goal":"exists(k0: Nat) { k0 < n and ta.get_idx(k0) != tb.get_idx(k0) }","proof":["let s0[T0]: (List[T0], List[T0], Nat) -> Nat satisfy { forall(x0: List[T0], x1: List[T0], x2: Nat) { not differ[T0](x0, x1, x2) or s0(x0, x1, x2) < x2 } and forall(x3: List[T0], x4: List[T0], x5: Nat) { x3.get_idx(s0(x3, x4, x5)) != x4.get_idx(s0(x3, x4, x5)) or not differ[T0](x3, x4, x5) } and forall(x6: Nat, x7: Nat, x8: List[T0], x9: List[T0]) { not x6 < x7 or differ[T0](x8, x9, x7) or x8.get_idx(x6) = x9.get_idx(x6) } }","function(x0: Nat) { not x0 < n or tb.get_idx(x0) = ta.get_idx(x0) }(s0(ta, tb, n))","function[T0](x0: List[T0], x1: List[T0], x2: Nat) { x0.get_idx(s0(x0, x1, x2)) != x1.get_idx(s0(x0, x1, x2)) or not differ[T0](x0, x1, x2) }[T](ta, tb, n)","function[T0](x0: List[T0], x1: List[T0], x2: Nat) { not differ[T0](x0, x1, x2) or s0(x0, x1, x2) < x2 }[T](ta, tb, n)","s0(ta, tb, n) < n","tb.get_idx(s0(ta, tb, n)) != ta.get_idx(s0(ta, tb, n))","tb.get_idx(s0(ta, tb, n)) = ta.get_idx(s0(ta, tb, n))"]}
{"goal":"exists(k0: Nat) { k0.suc = n }","proof":["function(x0: Nat) { x0.suc != n }(i)","function(x0: Nat, x1: Nat) { not x0 < x1 or x0.suc < x1 or x0.suc = x1 }(i, n)","i.suc < n","function(x0: Nat, x1: Nat) { not x1  x0.range or not x1 >= x0 }(n, i.suc)","function(x0: Nat, x1: Nat) { not x0 < x1 or x0  x1.range }(i.suc, n)","not i.suc  n.range","i.suc  n.range"]}
{"goal":"i = ip","proof":["function(x0: Nat, x1: Nat) { not x0 < x1 or x0.suc < x1 or x0.suc = x1 }(i, n)","function(x0: Nat, x1: Nat) { not x0 < x1 or not x1 <= x0 }(i.suc, n)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](i.suc, n)","n <= i.suc","function(x0: Nat, x1: Nat) { x0.suc != x1.suc or x0 = x1 }(ip, i)","ip.suc != i.suc","i.suc != n","not i.suc < n","i.suc < n"]}
{"goal":"ta.length <= ip","proof":["function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) != x2 or x1.length.suc = x2.length }[T](ha, ta, List.cons(ha, ta))","function(x0: Nat, x1: Nat) { not x0.suc <= x1.suc or x0 <= x1 }(ta.length, ip)","not ta.length.suc <= ip.suc","not ta.length.suc <= n","function[T0](x0: List[T0], x1: T0) { x0.length.suc = List.cons[T0](x1, x0).length }[T](ta, ha)"]}
{"goal":"tb.length <= ip","proof":["function(x0: Nat, x1: Nat) { not x0.suc <= x1.suc or x0 <= x1 }(tb.length, ip)","function(x0: Nat, x1: Nat) { not x0 < x1 or x0.suc <= x1 }(tb.length, n)","not tb.length.suc <= ip.suc","tb.length.suc <= n","not tb.length.suc <= n"]}
{"goal":"ta.length <= ip = ip >= ta.length","proof":["function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](ip, ta.length)"]}
{"goal":"tb.length <= ip = ip >= tb.length","proof":["function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](ip, tb.length)"]}
{"goal":"not ip >= ta.length or ta.get_idx(ip) = Option.none[T]","proof":["i >= ta.length","ta.get_idx(i) != Option.none[T]","function[T0](x0: Nat, x1: List[T0]) { not x0 >= x1.length or x1.get_idx(x0) = Option.none[T0] }[T](i, ta)"]}
{"goal":"not ip >= tb.length or tb.get_idx(ip) = Option.none[T]","proof":["i >= tb.length","tb.get_idx(i) != Option.none[T]","function[T0](x0: Nat, x1: List[T0]) { not x0 >= x1.length or x1.get_idx(x0) = Option.none[T0] }[T](i, tb)"]}
{"goal":"false","proof":["ip >= ta.length","ip >= tb.length","tb.get_idx(ip) = Option.none[T]","ta.get_idx(ip) = Option.none[T]"]}
{"goal":"i.suc > 0","proof":["function(x0: Nat, x1: Nat) { x0 < x0 + x1.suc }(0, i)","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gt(x0, x1) = T0.lt(x1, x0) }[Nat](i.suc, 0)","not 0 < i.suc","function(x0: Nat) { 0 + x0 = x0 }(i.suc)"]}
{"goal":"List.cons(ha, ta).get_idx(i.suc) = ta.get_idx(i)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](i.suc, ha, ta, List.cons(ha, ta))","function(x0: Nat) { x0.suc - 1 = x0 }(i)","ta.get_idx(i.suc - 1) != List.cons(ha, ta).get_idx(i.suc)","function[T1](x0: Nat, x1: List[T1], x2: T1) { not x0 > 0 or x1.get_idx(x0 - 1) = List.cons[T1](x2, x1).get_idx(x0) }[T](i.suc, ta, ha)"]}
{"goal":"List.cons(hb, tb).get_idx(i.suc) = tb.get_idx(i)","proof":["function[T0](x0: Nat, x1: T0, x2: List[T0], x3: List[T0]) { not x0 > 0 or List.cons[T0](x1, x2) != x3 or x2.get_idx(x0 - 1) = x3.get_idx(x0) }[T](i.suc, hb, tb, List.cons(hb, tb))","function(x0: Nat) { x0.suc - 1 = x0 }(i)","tb.get_idx(i.suc - 1) != List.cons(hb, tb).get_idx(i.suc)","function[T1](x0: Nat, x1: List[T1], x2: T1) { not x0 > 0 or x1.get_idx(x0 - 1) = List.cons[T1](x2, x1).get_idx(x0) }[T](i.suc, tb, hb)"]}
{"goal":"i.suc < n","proof":["function(x0: Nat, x1: Nat) { x0 < x1 or x1 <= x0 }(i.suc, n)","n <= i.suc","function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[Nat](i.suc, n)"]}
{"goal":"List.cons(ha, ta).get_idx(i.suc) != lb.get_idx(i.suc)","proof":[]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["function[T0](x0: Nat, x1: Nat, x2: List[T0], x3: List[T0]) { not x0 < x1 or differ[T0](x2, x3, x1) or x2.get_idx(x0) = x3.get_idx(x0) }[T](i.suc, n, List.cons(ha, ta), lb)","function(x0: Nat) { not x0 < n or List.cons(ha, ta).get_idx(x0) = lb.get_idx(x0) }(i.suc)"]}
{"goal":"0 < n","proof":["function(x0: Nat, x1: Nat, x2: Nat) { not x0 < x1 or not x1 <= x2 or x0 < x2 }(0, lb.length, n)","function(x0: Nat, x1: Nat) { x0 < x1 or x1 < x0 or x0 = x1 }(lb.length, 0)","function[T0](x0: List[T0]) { 0 != x0.length or List.nil[T0] = x0 }[T](lb)","function(x0: Nat) { not x0 < 0 }(lb.length)","function(x0: Nat) { not 0 < x0 or not x0 <= n }(lb.length)","not 0 < lb.length","lb.length != 0","lb.length = 0"]}
{"goal":"List.cons(ha, ta).get_idx(0) = Option.some(ha)","proof":[]}
{"goal":"lb.get_idx(0) = Option.some(hb)","proof":["List.cons(hb, tb).get_idx(0) != Option.some(hb)"]}
{"goal":"ha != hb","proof":[]}
{"goal":"List.cons(ha, ta).get_idx(0) != lb.get_idx(0)","proof":["List.cons(ha, ta).get_idx(0) = Option.some(hb)","Option.some(hb) = Option.some(ha)","function[T0](x0: T0, x1: T0) { Option.some[T0](x0) != Option.some[T0](x1) or x0 = x1 }[T](ha, hb)"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["function[T0](x0: Nat, x1: Nat, x2: List[T0], x3: List[T0]) { not x0 < x1 or differ[T0](x2, x3, x1) or x2.get_idx(x0) = x3.get_idx(x0) }[T](0, n, List.cons(ha, ta), lb)","function(x0: Nat) { not x0 < n or List.cons(ha, ta).get_idx(x0) = lb.get_idx(x0) }(0)"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":[]}
{"goal":"p(a)","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(a)","function(x0: List[T]) { p(s1) or p(x0) }(a)","p(s1)","let s2: List[T] -> List[T] satisfy { forall(x2: List[T], x3: List[T]) { not x2.length <= n or not x3.length <= n or not p(x2) or differ[T](x2, x3, n) or x2 = x3 } and forall(x4: List[T]) { s2(x4) != x4 or p(x4) } and forall(x5: List[T]) { x5.length <= n or p(x5) } and forall(x6: List[T]) { s2(x6).length <= n or p(x6) } and forall(x7: List[T]) { not differ[T](x7, s2(x7), n) or p(x7) } }","function(x0: List[T]) { s2(x0) != x0 or p(x0) }(List.cons(s0, s1))","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(a)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(a)","function(x0: List[T]) { not differ[T](x0, s2(x0), n) or p(x0) }(List.cons(s0, s1))","function(x0: List[T]) { x0.length <= n or p(x0) }(List.cons(s0, s1))","function(x0: List[T]) { s2(x0).length <= n or p(x0) }(List.cons(s0, s1))","not p(List.cons(s0, s1))","function(x0: T, x1: List[T], x2: List[T]) { not List.cons(x0, x1).length <= n or not x2.length <= n or not p(x1) or differ[T](List.cons(x0, x1), x2, n) or List.cons(x0, x1) = x2 }(s0, s1, s2(List.cons(s0, s1)))","List.cons(s0, s1).length <= n","s2(List.cons(s0, s1)) != List.cons(s0, s1)","s2(List.cons(s0, s1)).length <= n","not differ[T](List.cons(s0, s1), s2(List.cons(s0, s1)), n)","differ[T](List.cons(s0, s1), s2(List.cons(s0, s1)), n)"]}
{"goal":"differ[T](a, b, n)","proof":["function(x0: List[T], x1: List[T]) { not x0.length <= n or not x1.length <= n or not p(x0) or differ[T](x0, x1, n) or x0 = x1 }(a, b)"]}
{"goal":"lists_differ_at_index","proof":["not a.length <= n"]}
{"goal":"partial_zero","proof":["function[T0: AddCommMonoid](x0: Nat, x1: Nat -> T0) { sum[T0](map[Nat, T0](x0.range, x1)) = partial[T0](x1, x0) }[A](0, f)","function[T0, T1](x0: List[T0], x1: T0 -> T1) { List.nil[T0] != x0 or map[T0, T1](x0, x1) = List.nil[T1] }[Nat, A](Nat.zero.range, f)","function[T0: AddCommMonoid](x0: List[T0]) { List.nil[T0] != x0 or T0.0 = sum[T0](x0) }[A](map[Nat, A](0.range, f))","function(x0: Nat) { Nat.zero != x0 or List.nil[Nat] = x0.range }(Nat.zero)","Nat.zero.range = List.nil[Nat]","sum[A](map[Nat, A](0.range, f)) != A.0","map[Nat, A](0.range, f) != List.nil[A]","map[Nat, A](Nat.zero.range, f) != List.nil[A]"]}
{"goal":"differ[T](a, b, a.length)","proof":["function(x0: Nat) { x0 <= x0 }(a.length)","not b.length <= a.length"]}
{"goal":"a = b","proof":["let s0[T0]: (List[T0], List[T0], Nat) -> Nat satisfy { forall(x0: List[T0], x1: List[T0], x2: Nat) { not differ[T0](x0, x1, x2) or s0(x0, x1, x2) < x2 } and forall(x3: List[T0], x4: List[T0], x5: Nat) { x3.get_idx(s0(x3, x4, x5)) != x4.get_idx(s0(x3, x4, x5)) or not differ[T0](x3, x4, x5) } and forall(x6: Nat, x7: Nat, x8: List[T0], x9: List[T0]) { not x6 < x7 or differ[T0](x8, x9, x7) or x8.get_idx(x6) = x9.get_idx(x6) } }","function(x0: Nat) { not x0 < a.length or b.get_idx(x0) = a.get_idx(x0) }(s0(a, b, a.length))","function[T0](x0: List[T0], x1: List[T0], x2: Nat) { x0.get_idx(s0(x0, x1, x2)) != x1.get_idx(s0(x0, x1, x2)) or not differ[T0](x0, x1, x2) }[T](a, b, a.length)","function[T0](x0: List[T0], x1: List[T0], x2: Nat) { not differ[T0](x0, x1, x2) or s0(x0, x1, x2) < x2 }[T](a, b, a.length)","s0(a, b, a.length) < a.length","b.get_idx(s0(a, b, a.length)) != a.get_idx(s0(a, b, a.length))","b.get_idx(s0(a, b, a.length)) = a.get_idx(s0(a, b, a.length))"]}
{"goal":"list_extensionality","proof":["let s0: Nat satisfy { b.length != a.length or s0 < a.length or b = a and (b.get_idx(s0) != a.get_idx(s0) or b.length != a.length or b = a) }","function(x0: Nat) { not x0 < a.length or b.get_idx(x0) = a.get_idx(x0) }(s0)","s0 < a.length","b.get_idx(s0) != a.get_idx(s0)","b.get_idx(s0) = a.get_idx(s0)"]}
