{"goal":"c <= ub","proof":["not is_upper_bound(tail, ub) or not c ∈ tail or not p(tail) or c <= ub","not is_upper_bound(List.cons(c, tail), ub) or List.cons(c, tail) != List.cons(c, tail) or c <= ub","not is_upper_bound(List.cons(head, tail), ub) or is_upper_bound(tail, ub)","not c ∈ List.cons(head, tail) or c ∈ tail or head = c"]}
{"goal":"upper_bound_contains","proof":["not is_upper_bound(list, ub) or not c ∈ list or not p(list) or c <= ub","let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not is_upper_bound(List.cons(s0, s1), ub) or not c ∈ List.cons(s0, s1) or not p(s1) or c <= ub","c ∈ List.cons(s0, s1) or p(List.cons(s0, s1))","c ∈ List.nil[T] or p(List.nil[T])","is_upper_bound(List.cons(s0, s1), ub) or p(List.cons(s0, s1))","not p(List.nil[T]) or p(s1) or p(list)","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(list)","not c ∈ List.nil[T]"]}
{"goal":"p(List.cons(head, tail))","proof":["not is_upper_bound(List.cons(head, tail), ub) or p(List.cons(head, tail))","is_upper_bound(List.cons(head, tail) + list2, ub) or p(List.cons(head, tail))","not is_upper_bound(tail + list2, ub) or not p(tail) or is_upper_bound(tail, ub)","not is_upper_bound(List.cons(head, tail + list2), ub) or head <= ub","not is_upper_bound(List.cons(head, tail + list2), ub) or is_upper_bound(tail + list2, ub)","List.cons(head, tail) + list2 = List.cons(head, tail + list2)","not is_upper_bound(tail, ub) or not head <= ub or is_upper_bound(List.cons(head, tail), ub)"]}
{"goal":"upper_bound_add_left","proof":["not is_upper_bound(List.nil[T], ub) or p(List.nil[T])","let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(list1)","not p(s1) or p(List.cons(s0, s1))","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(list1)","not is_upper_bound(list1 + list2, ub) or not p(list1) or is_upper_bound(list1, ub)","is_upper_bound(List.nil[T], ub)"]}
{"goal":"p(List.cons(head, tail))","proof":["not is_upper_bound(list2, ub) or p(List.cons(head, tail))","not is_upper_bound(tail + list2, ub) or not p(tail) or is_upper_bound(list2, ub)","is_upper_bound(List.cons(head, tail) + list2, ub) or p(List.cons(head, tail))","not is_upper_bound(List.cons(head, tail + list2), ub) or is_upper_bound(tail + list2, ub)","List.cons(head, tail) + list2 = List.cons(head, tail + list2)"]}
{"goal":"upper_bound_add_right","proof":["not is_upper_bound(list1 + list2, ub) or not p(list1) or is_upper_bound(list2, ub)","let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(s1)","not p(s1) or p(List.cons(s0, s1))","is_upper_bound(List.nil[T] + list2, ub) or p(List.nil[T])","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(list1)","List.nil[T] + list2 = list2"]}
{"goal":"p(List.cons(head, tail))","proof":["not is_upper_bound(List.cons(head, tail), ub2) or p(List.cons(head, tail))","is_upper_bound(List.cons(head, tail), ub1) or p(List.cons(head, tail))","not ub1 <= ub2 or not is_upper_bound(tail, ub1) or not p(tail) or is_upper_bound(tail, ub2)","not lib(util).is_transitive[T](T.lte) or not head <= ub1 or not ub1 <= ub2 or head <= ub2","not is_upper_bound(List.cons(head, tail), ub1) or head <= ub1","not is_upper_bound(List.cons(head, tail), ub1) or is_upper_bound(tail, ub1)","not is_upper_bound(tail, ub2) or not head <= ub2 or is_upper_bound(List.cons(head, tail), ub2)"]}
{"goal":"upper_bound_monotone","proof":["not is_upper_bound(List.nil[T], ub2) or p(List.nil[T])","let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(list)","not p(s1) or p(List.cons(s0, s1))","not ub1 <= ub2 or not is_upper_bound(list, ub1) or not p(list) or is_upper_bound(list, ub2)","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(list)","is_upper_bound(List.nil[T], ub2)"]}
{"goal":"p(List.nil[T])","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T], x1: T) { not p(x0) or is_upper_bound(List.cons(x1, x0), list_max(x1, x0)) } and forall(x2: List[T]) { not is_upper_bound(List.cons(s0(x2), x2), list_max(s0(x2), x2)) or p(x2) } }","not is_upper_bound(List.cons(s0(List.nil[T]), List.nil[T]), list_max(s0(List.nil[T]), List.nil[T])) or p(List.nil[T])","is_upper_bound(List.nil[T], s0(List.nil[T]))","s0(List.nil[T]) <= s0(List.nil[T])","list_max(s0(List.nil[T]), List.nil[T]) = s0(List.nil[T])","not is_upper_bound(List.nil[T], s0(List.nil[T])) or not s0(List.nil[T]) <= s0(List.nil[T]) or is_upper_bound(List.cons(s0(List.nil[T]), List.nil[T]), s0(List.nil[T]))"]}
{"goal":"is_upper_bound(List.cons(next, rest), list_max(next, rest))","proof":["not p(rest) or is_upper_bound(List.cons(next, rest), list_max(next, rest))"]}
{"goal":"h.max(list_max(next, rest)) = list_max(h, List.cons(next, rest))","proof":["List.cons(next, rest) != List.cons(next, rest) or list_max(h, List.cons(next, rest)) = h.max(list_max(next, rest))"]}
{"goal":"h.max(list_max(next, rest)) >= list_max(next, rest)","proof":["h.max(list_max(next, rest)) >= list_max(next, rest)"]}
{"goal":"list_max(next, rest) <= list_max(h, List.cons(next, rest))","proof":["not list_max(next, rest) <= h.max(list_max(next, rest))","h.max(list_max(next, rest)) >= list_max(next, rest) = list_max(next, rest) <= h.max(list_max(next, rest))"]}
{"goal":"is_upper_bound(List.cons(next, rest), m)","proof":["not p(rest) or is_upper_bound(List.cons(next, rest), list_max(next, rest))","not is_upper_bound(List.cons(next, rest), list_max(next, rest)) or not list_max(next, rest) <= list_max(h, List.cons(next, rest)) or is_upper_bound(List.cons(next, rest), list_max(h, List.cons(next, rest)))","list_max(h, List.cons(next, rest)) >= list_max(next, rest) = list_max(next, rest) <= list_max(h, List.cons(next, rest))","h.max(list_max(next, rest)) >= list_max(next, rest)","h.max(list_max(next, rest)) = list_max(h, List.cons(next, rest))"]}
{"goal":"is_upper_bound(List.cons(h, List.cons(next, rest)), list_max(h, List.cons(next, rest)))","proof":["not is_upper_bound(List.cons(next, rest), list_max(h, List.cons(next, rest))) or not h <= list_max(h, List.cons(next, rest)) or List.cons(h, List.cons(next, rest)) != List.cons(h, List.cons(next, rest)) or is_upper_bound(List.cons(h, List.cons(next, rest)), list_max(h, List.cons(next, rest)))","list_max(h, List.cons(next, rest)) >= h = h <= list_max(h, List.cons(next, rest))","h.max(list_max(next, rest)) >= h","h.max(list_max(next, rest)) = list_max(h, List.cons(next, rest))"]}
{"goal":"list_max_is_upper_bound","proof":["let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(s1)","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(tail)","not p(tail) or is_upper_bound(List.cons(head, tail), list_max(head, tail))","let s2: List[T] -> T satisfy { forall(x2: List[T], x3: T) { not p(x2) or is_upper_bound(List.cons(x3, x2), list_max(x3, x2)) } and forall(x4: List[T]) { not is_upper_bound(List.cons(s2(x4), x4), list_max(s2(x4), x4)) or p(x4) } }","not is_upper_bound(List.cons(s2(List.cons(s0, s1)), List.cons(s0, s1)), list_max(s2(List.cons(s0, s1)), List.cons(s0, s1))) or p(List.cons(s0, s1))","not p(s1) or is_upper_bound(List.cons(s2(List.cons(s0, s1)), List.cons(s0, s1)), list_max(s2(List.cons(s0, s1)), List.cons(s0, s1)))"]}
{"goal":"list_has_upper_bound","proof":["not is_upper_bound(List.cons(head, tail), list_max(head, tail))","is_upper_bound(List.cons(head, tail), list_max(head, tail))"]}
{"goal":"lb <= c","proof":["not is_lower_bound(tail, lb) or not c ∈ tail or not p(tail) or lb <= c","not is_lower_bound(List.cons(c, tail), lb) or List.cons(c, tail) != List.cons(c, tail) or lb <= c","not is_lower_bound(List.cons(head, tail), lb) or is_lower_bound(tail, lb)","not c ∈ List.cons(head, tail) or c ∈ tail or head = c"]}
{"goal":"lower_bound_contains","proof":["not is_lower_bound(list, lb) or not c ∈ list or not p(list) or lb <= c","let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not is_lower_bound(List.cons(s0, s1), lb) or not c ∈ List.cons(s0, s1) or not p(s1) or lb <= c","c ∈ List.cons(s0, s1) or p(List.cons(s0, s1))","c ∈ List.nil[T] or p(List.nil[T])","is_lower_bound(List.cons(s0, s1), lb) or p(List.cons(s0, s1))","not p(List.nil[T]) or p(s1) or p(list)","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(list)","not c ∈ List.nil[T]"]}
{"goal":"p(List.cons(head, tail))","proof":["not is_lower_bound(List.cons(head, tail), lb) or p(List.cons(head, tail))","is_lower_bound(List.cons(head, tail) + list2, lb) or p(List.cons(head, tail))","not is_lower_bound(tail + list2, lb) or not p(tail) or is_lower_bound(tail, lb)","not is_lower_bound(List.cons(head, tail + list2), lb) or lb <= head","not is_lower_bound(List.cons(head, tail + list2), lb) or is_lower_bound(tail + list2, lb)","List.cons(head, tail) + list2 = List.cons(head, tail + list2)","not is_lower_bound(tail, lb) or not lb <= head or is_lower_bound(List.cons(head, tail), lb)"]}
{"goal":"lower_bound_add_left","proof":["not is_lower_bound(List.nil[T], lb) or p(List.nil[T])","let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(list1)","not p(s1) or p(List.cons(s0, s1))","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(list1)","not is_lower_bound(list1 + list2, lb) or not p(list1) or is_lower_bound(list1, lb)","is_lower_bound(List.nil[T], lb)"]}
{"goal":"p(List.cons(head, tail))","proof":["not is_lower_bound(list2, lb) or p(List.cons(head, tail))","not is_lower_bound(tail + list2, lb) or not p(tail) or is_lower_bound(list2, lb)","is_lower_bound(List.cons(head, tail) + list2, lb) or p(List.cons(head, tail))","not is_lower_bound(List.cons(head, tail + list2), lb) or is_lower_bound(tail + list2, lb)","List.cons(head, tail) + list2 = List.cons(head, tail + list2)"]}
{"goal":"lower_bound_add_right","proof":["not is_lower_bound(list1 + list2, lb) or not p(list1) or is_lower_bound(list2, lb)","let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(s1)","not p(s1) or p(List.cons(s0, s1))","is_lower_bound(List.nil[T] + list2, lb) or p(List.nil[T])","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(list1)","List.nil[T] + list2 = list2"]}
{"goal":"p(List.cons(head, tail))","proof":["not is_lower_bound(List.cons(head, tail), lb2) or p(List.cons(head, tail))","is_lower_bound(List.cons(head, tail), lb1) or p(List.cons(head, tail))","not lb2 <= lb1 or not is_lower_bound(tail, lb1) or not p(tail) or is_lower_bound(tail, lb2)","not lib(util).is_transitive[T](T.lte) or not lb2 <= lb1 or not lb1 <= head or lb2 <= head","not is_lower_bound(List.cons(head, tail), lb1) or lb1 <= head","not is_lower_bound(List.cons(head, tail), lb1) or is_lower_bound(tail, lb1)","not is_lower_bound(tail, lb2) or not lb2 <= head or is_lower_bound(List.cons(head, tail), lb2)"]}
{"goal":"lower_bound_monotone","proof":["not is_lower_bound(List.nil[T], lb2) or p(List.nil[T])","let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(list)","not p(s1) or p(List.cons(s0, s1))","not lb2 <= lb1 or not is_lower_bound(list, lb1) or not p(list) or is_lower_bound(list, lb2)","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(list)","is_lower_bound(List.nil[T], lb2)"]}
{"goal":"p(List.nil[T])","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T], x1: T) { not p(x0) or is_lower_bound(List.cons(x1, x0), list_min(x1, x0)) } and forall(x2: List[T]) { not is_lower_bound(List.cons(s0(x2), x2), list_min(s0(x2), x2)) or p(x2) } }","not is_lower_bound(List.cons(s0(List.nil[T]), List.nil[T]), list_min(s0(List.nil[T]), List.nil[T])) or p(List.nil[T])","is_lower_bound(List.nil[T], s0(List.nil[T]))","s0(List.nil[T]) <= s0(List.nil[T])","list_min(s0(List.nil[T]), List.nil[T]) = s0(List.nil[T])","not is_lower_bound(List.nil[T], s0(List.nil[T])) or not s0(List.nil[T]) <= s0(List.nil[T]) or is_lower_bound(List.cons(s0(List.nil[T]), List.nil[T]), s0(List.nil[T]))"]}
{"goal":"is_lower_bound(List.cons(next, rest), list_min(next, rest))","proof":["not p(rest) or is_lower_bound(List.cons(next, rest), list_min(next, rest))"]}
{"goal":"h.min(list_min(next, rest)) = list_min(h, List.cons(next, rest))","proof":["List.cons(next, rest) != List.cons(next, rest) or list_min(h, List.cons(next, rest)) = h.min(list_min(next, rest))"]}
{"goal":"h.min(list_min(next, rest)) <= list_min(next, rest)","proof":["h.min(list_min(next, rest)) <= list_min(next, rest)"]}
{"goal":"h.min(list_min(next, rest)) <= h","proof":["h.min(list_min(next, rest)) = list_min(next, rest).min(h)","not list_min(next, rest).min(h) <= h","list_min(next, rest).min(h) <= h"]}
{"goal":"is_lower_bound(List.cons(next, rest), m)","proof":["not is_lower_bound(List.cons(next, rest), list_min(next, rest)) or not m <= list_min(next, rest) or is_lower_bound(List.cons(next, rest), m)","not is_lower_bound(List.cons(next, rest), list_min(next, rest)) or not m <= list_min(next, rest)","not m <= list_min(next, rest)"]}
{"goal":"is_lower_bound(List.cons(h, List.cons(next, rest)), list_min(h, List.cons(next, rest)))","proof":["not is_lower_bound(List.cons(h, List.cons(next, rest)), m)","not is_lower_bound(List.cons(next, rest), m) or List.cons(h, List.cons(next, rest)) != List.cons(h, List.cons(next, rest)) or not m <= h or is_lower_bound(List.cons(h, List.cons(next, rest)), m)","not is_lower_bound(List.cons(next, rest), m) or not m <= h or is_lower_bound(List.cons(h, List.cons(next, rest)), m)","not m <= h"]}
{"goal":"p(List.cons(next, rest))","proof":["not p(rest) or is_lower_bound(List.cons(next, rest), list_min(next, rest))","let s0: List[T] -> T satisfy { forall(x0: List[T], x1: T) { not p(x0) or is_lower_bound(List.cons(x1, x0), list_min(x1, x0)) } and forall(x2: List[T]) { not is_lower_bound(List.cons(s0(x2), x2), list_min(s0(x2), x2)) or p(x2) } }","not is_lower_bound(List.cons(s0(List.cons(next, rest)), List.cons(next, rest)), list_min(s0(List.cons(next, rest)), List.cons(next, rest))) or p(List.cons(next, rest))","not is_lower_bound(List.cons(next, rest), list_min(next, rest)) or not s0(List.cons(next, rest)).min(list_min(next, rest)) <= list_min(next, rest) or is_lower_bound(List.cons(next, rest), s0(List.cons(next, rest)).min(list_min(next, rest)))","s0(List.cons(next, rest)).min(list_min(next, rest)) <= list_min(next, rest)","s0(List.cons(next, rest)).min(list_min(next, rest)) <= s0(List.cons(next, rest))","s0(List.cons(next, rest)).min(list_min(next, rest)) = list_min(s0(List.cons(next, rest)), List.cons(next, rest))","not is_lower_bound(List.cons(next, rest), s0(List.cons(next, rest)).min(list_min(next, rest))) or not s0(List.cons(next, rest)).min(list_min(next, rest)) <= s0(List.cons(next, rest)) or is_lower_bound(List.cons(s0(List.cons(next, rest)), List.cons(next, rest)), s0(List.cons(next, rest)).min(list_min(next, rest)))"]}
{"goal":"list_min_is_lower_bound","proof":["let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(s1)","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(tail)","not p(s1) or p(List.cons(s0, s1))","not p(tail) or is_lower_bound(List.cons(head, tail), list_min(head, tail))"]}
{"goal":"list_has_lower_bound","proof":["not is_lower_bound(List.cons(head, tail), list_min(head, tail))","is_lower_bound(List.cons(head, tail), list_min(head, tail))"]}
