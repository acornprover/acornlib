{"goal":"not List.nil[T].contains(c)","proof":["function[T0](x0: List[T0], x1: T0) { not x1 ∈ x0 or List.nil[T0] != x0 }[T](List.nil[T], c)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { c ∈ x0 or p(x0) }(List.nil[T])"]}
{"goal":"head <= ub","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_upper_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or T0.lte(x2, x1) }[T](List.cons(head, tail), ub, head, tail)","function(x0: List[T], x1: List[T]) { not is_upper_bound(x0, ub) or List.cons(head, x1) != x0 }(List.cons(head, tail), tail)","function(x0: List[T]) { not is_upper_bound(List.cons(head, x0), ub) }(tail)"]}
{"goal":"is_upper_bound(tail, ub)","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_upper_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or is_upper_bound[T0](x3, x1) }[T](List.cons(head, tail), ub, head, tail)","function(x0: List[T], x1: T) { not is_upper_bound(x0, ub) or List.cons(x1, tail) != x0 }(List.cons(head, tail), head)","function(x0: T) { not is_upper_bound(List.cons(x0, tail), ub) }(head)"]}
{"goal":"c <= ub","proof":["not head <= ub"]}
{"goal":"tail.contains(c)","proof":["function[T0](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not x1 ∈ x0 or List.cons[T0](x2, x3) != x0 or x1 ∈ x3 or x1 = x2 }[T](List.cons(head, tail), c, head, tail)","function[T0](x0: T0, x1: List[T0], x2: T0) { not x2 ∈ List.cons[T0](x0, x1) or x2 ∈ x1 or x0 = x2 }[T](head, tail, c)"]}
{"goal":"c <= ub","proof":["function(x0: List[T]) { not is_upper_bound(x0, ub) or not c ∈ x0 or not p(x0) or c <= ub }(tail)","function(x0: List[T]) { not is_upper_bound(x0, ub) or not c ∈ x0 or not p(x0) }(tail)","not is_upper_bound(tail, ub)"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { not c <= ub or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { c ∈ x0 or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { is_upper_bound(x0, ub) or p(x0) }(List.cons(head, tail))","not c <= ub","is_upper_bound(List.cons(head, tail), ub)","c ∈ List.cons(head, tail)","not c ∈ List.cons(head, tail)"]}
{"goal":"upper_bound_contains","proof":["function(x0: List[T]) { not is_upper_bound(x0, ub) or not c ∈ x0 or not p(x0) or c <= ub }(list)","function(x0: List[T]) { not is_upper_bound(x0, ub) or not c ∈ x0 or not p(x0) }(list)","let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1, s0)","p(s1)","not p(list)","not p(List.cons(s0, s1))"]}
{"goal":"is_upper_bound(List.nil[T], ub)","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0) { List.nil[T0] != x0 or is_upper_bound[T0](x0, x1) }[T](List.nil[T], ub)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { not is_upper_bound(x0, ub) or p(x0) }(List.nil[T])"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { not is_upper_bound(x0, ub) or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { is_upper_bound(x0 + list2, ub) or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { not is_upper_bound(x0 + list2, ub) or not p(x0) or is_upper_bound(x0, ub) }(tail)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0], x3: List[T0]) { not T0.lte(x0, x1) or not is_upper_bound[T0](x2, x1) or List.cons[T0](x0, x2) != x3 or is_upper_bound[T0](x3, x1) }[T](head, ub, tail, List.cons(head, tail))","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, List.cons(head, tail), list2)","function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_upper_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or is_upper_bound[T0](x3, x1) }[T](List.cons(head, tail + list2), ub, head, tail + list2)","function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_upper_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or T0.lte(x2, x1) }[T](List.cons(head, tail + list2), ub, head, tail + list2)","not is_upper_bound(List.cons(head, tail), ub)","is_upper_bound(List.cons(head, tail) + list2, ub)","function[T0: LinearOrder](x0: T0, x1: List[T0], x2: T0) { not is_upper_bound[T0](List.cons[T0](x0, x1), x2) or T0.lte(x0, x2) }[T](head, tail + list2, ub)","function[T0: LinearOrder](x0: T0, x1: List[T0], x2: T0) { not is_upper_bound[T0](List.cons[T0](x0, x1), x2) or is_upper_bound[T0](x1, x2) }[T](head, tail + list2, ub)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) + x2 = List.cons[T0](x0, x1 + x2) }[T](head, tail, list2)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0]) { not T0.lte(x0, x1) or not is_upper_bound[T0](x2, x1) or is_upper_bound[T0](List.cons[T0](x0, x2), x1) }[T](head, ub, tail)","is_upper_bound(List.cons(head, tail + list2), ub)","not is_upper_bound(tail + list2, ub) or is_upper_bound(tail, ub)","head <= ub","is_upper_bound(tail + list2, ub)","not is_upper_bound(tail, ub)","is_upper_bound(tail, ub)"]}
{"goal":"upper_bound_add_left","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list1)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1, s0)","function(x0: List[T]) { not is_upper_bound(x0 + list2, ub) or not p(x0) or is_upper_bound(x0, ub) }(list1)","p(s1)","not p(list1)","not p(List.cons(s0, s1))"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { not is_upper_bound(list2, ub) or p(x0) }(List.nil[T])","not is_upper_bound(list2, ub)","function(x0: List[T]) { is_upper_bound(x0 + list2, ub) or p(x0) }(List.nil[T])","function[T0](x0: List[T0]) { List.nil[T0] + x0 = x0 }[T](list2)","is_upper_bound(List.nil[T] + list2, ub)","not is_upper_bound(List.nil[T] + list2, ub)"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { not is_upper_bound(list2, ub) or p(x0) }(List.cons(head, tail))","not is_upper_bound(list2, ub)","function(x0: List[T]) { not is_upper_bound(x0 + list2, ub) or not p(x0) or is_upper_bound(list2, ub) }(tail)","function(x0: List[T]) { not is_upper_bound(x0 + list2, ub) or not p(x0) }(tail)","function(x0: List[T]) { is_upper_bound(x0 + list2, ub) or p(x0) }(List.cons(head, tail))","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, List.cons(head, tail), list2)","function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_upper_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or is_upper_bound[T0](x3, x1) }[T](List.cons(head, tail + list2), ub, head, tail + list2)","not is_upper_bound(tail + list2, ub)","is_upper_bound(List.cons(head, tail) + list2, ub)","function[T0: LinearOrder](x0: T0, x1: List[T0], x2: T0) { not is_upper_bound[T0](List.cons[T0](x0, x1), x2) or is_upper_bound[T0](x1, x2) }[T](head, tail + list2, ub)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) + x2 = List.cons[T0](x0, x1 + x2) }[T](head, tail, list2)","is_upper_bound(List.cons(head, tail + list2), ub)"]}
{"goal":"upper_bound_add_right","proof":["function(x0: List[T]) { not is_upper_bound(x0 + list2, ub) or not p(x0) or is_upper_bound(list2, ub) }(list1)","function(x0: List[T]) { not is_upper_bound(x0 + list2, ub) or not p(x0) }(list1)","let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list1)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1, s0)","p(s1)","not p(list1)","not p(List.cons(s0, s1))"]}
{"goal":"is_upper_bound(List.nil[T], ub2)","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0) { List.nil[T0] != x0 or is_upper_bound[T0](x0, x1) }[T](List.nil[T], ub2)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { not is_upper_bound(x0, ub2) or p(x0) }(List.nil[T])"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { not is_upper_bound(x0, ub2) or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { is_upper_bound(x0, ub1) or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { not ub1 <= ub2 or not is_upper_bound(x0, ub1) or not p(x0) or is_upper_bound(x0, ub2) }(tail)","function(x0: List[T]) { not is_upper_bound(x0, ub1) or not p(x0) or is_upper_bound(x0, ub2) }(tail)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0], x3: List[T0]) { not T0.lte(x0, x1) or not is_upper_bound[T0](x2, x1) or List.cons[T0](x0, x2) != x3 or is_upper_bound[T0](x3, x1) }[T](head, ub2, tail, List.cons(head, tail))","function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_upper_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or is_upper_bound[T0](x3, x1) }[T](List.cons(head, tail), ub1, head, tail)","function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_upper_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or T0.lte(x2, x1) }[T](List.cons(head, tail), ub1, head, tail)","function[T0](x0: (T0, T0) -> Bool, x1: T0, x2: T0, x3: T0) { not lib(util).is_transitive[T0](x0) or not x0(x1, x2) or not x0(x2, x3) or x0(x1, x3) }[T](T.lte, head, ub1, ub2)","function[T0: lib(order).PartialOrder] { lib(util).is_transitive[T0](T0.lte) }[T]","is_upper_bound(List.cons(head, tail), ub1)","not is_upper_bound(List.cons(head, tail), ub2)","function[T0: LinearOrder](x0: T0, x1: List[T0], x2: T0) { not is_upper_bound[T0](List.cons[T0](x0, x1), x2) or T0.lte(x0, x2) }[T](head, tail, ub1)","function[T0: LinearOrder](x0: T0, x1: List[T0], x2: T0) { not is_upper_bound[T0](List.cons[T0](x0, x1), x2) or is_upper_bound[T0](x1, x2) }[T](head, tail, ub1)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0]) { not T0.lte(x0, x1) or not is_upper_bound[T0](x2, x1) or is_upper_bound[T0](List.cons[T0](x0, x2), x1) }[T](head, ub2, tail)","not is_upper_bound(tail, ub1) or is_upper_bound(tail, ub2)","function(x0: T) { not lib(util).is_transitive[T](T.lte) or not x0 <= ub1 or x0 <= ub2 }(head)","is_upper_bound(tail, ub1)","head <= ub1","is_upper_bound(tail, ub2)","head <= ub2","not head <= ub2"]}
{"goal":"upper_bound_monotone","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1, s0)","function(x0: List[T]) { not ub1 <= ub2 or not is_upper_bound(x0, ub1) or not p(x0) or is_upper_bound(x0, ub2) }(list)","function(x0: List[T]) { not is_upper_bound(x0, ub1) or not p(x0) or is_upper_bound(x0, ub2) }(list)","p(s1)","not p(list)","not p(List.cons(s0, s1))"]}
{"goal":"list_max(h, List.nil[T]) = h","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0) { List.nil[T0] != x0 or list_max[T0](x1, x0) = x1 }[T](List.nil[T], h)"]}
{"goal":"h <= h","proof":["function[T0: LinearOrder](x0: T0, x1: T0) { T0.lte(x0, x1) or T0.lte(x1, x0) }[T](h, h)"]}
{"goal":"is_upper_bound(List.nil[T], h)","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0) { List.nil[T0] != x0 or is_upper_bound[T0](x0, x1) }[T](List.nil[T], h)"]}
{"goal":"is_upper_bound(List.cons(h, List.nil[T]), list_max(h, List.nil[T]))","proof":["not is_upper_bound(List.cons(h, List.nil[T]), h)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0], x3: List[T0]) { not T0.lte(x0, x1) or not is_upper_bound[T0](x2, x1) or List.cons[T0](x0, x2) != x3 or is_upper_bound[T0](x3, x1) }[T](h, h, List.nil[T], List.cons(h, List.nil[T]))","function[T0: LinearOrder](x0: T0, x1: T0) { T0.lte(x0, x1) or T0.lte(x1, x0) }[T](h, h)","function[T0: LinearOrder](x0: T0) { T0.lte(x0, x0) }[T](h)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0]) { not T0.lte(x0, x1) or not is_upper_bound[T0](x2, x1) or is_upper_bound[T0](List.cons[T0](x0, x2), x1) }[T](h, h, List.nil[T])"]}
{"goal":"p(List.nil[T])","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T], x1: T) { not p(x0) or is_upper_bound[T](List.cons[T](x1, x0), list_max[T](x1, x0)) } and forall(x2: List[T]) { not is_upper_bound[T](List.cons[T](s0(x2), x2), list_max[T](s0(x2), x2)) or p(x2) } }","function(x0: T) { is_upper_bound(List.cons(x0, List.nil[T]), list_max(x0, List.nil[T])) }(s0(List.nil[T]))","function(x0: List[T]) { not is_upper_bound(List.cons(s0(x0), x0), list_max(s0(x0), x0)) or p(x0) }(List.nil[T])"]}
{"goal":"is_upper_bound(List.cons(next, rest), list_max(next, rest))","proof":["function(x0: List[T], x1: T) { not p(x0) or is_upper_bound(List.cons(x1, x0), list_max(x1, x0)) }(rest, next)"]}
{"goal":"h.max(list_max(next, rest)) = list_max(h, List.cons(next, rest))","proof":["function[T0: LinearOrder](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or T0.max(x3, list_max[T0](x0, x1)) = list_max[T0](x3, x2) }[T](next, rest, List.cons(next, rest), h)"]}
{"goal":"h.max(list_max(next, rest)) >= list_max(next, rest)","proof":["function[T0: LinearOrder](x0: T0, x1: T0) { T0.max(x0, x1) >= x1 }[T](h, list_max(next, rest))"]}
{"goal":"list_max(next, rest) <= list_max(h, List.cons(next, rest))","proof":["function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[T](h.max(list_max(next, rest)), list_max(next, rest))"]}
{"goal":"is_upper_bound(List.cons(next, rest), m)","proof":["function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0]) { not T0.lte(x0, x1) or not is_upper_bound[T0](x2, x0) or is_upper_bound[T0](x2, x1) }[T](list_max(next, rest), m, List.cons(next, rest))","list_max(next, rest) <= m","function(x0: T) { not is_upper_bound(List.cons(next, rest), x0) or not x0 <= m }(list_max(next, rest))"]}
{"goal":"h.max(list_max(next, rest)) >= h","proof":["function[T0: LinearOrder](x0: T0, x1: T0) { T0.max(x0, x1) = T0.max(x1, x0) }[T](list_max(next, rest), h)","not list_max(next, rest).max(h) >= h","function[T0: LinearOrder](x0: T0, x1: T0) { T0.max(x0, x1) >= x1 }[T](list_max(next, rest), h)"]}
{"goal":"h <= list_max(h, List.cons(next, rest))","proof":["function[T0: lib(order).PartialOrder](x0: T0, x1: T0) { T0.gte(x0, x1) = T0.lte(x1, x0) }[T](h.max(list_max(next, rest)), h)"]}
{"goal":"is_upper_bound(List.cons(h, List.cons(next, rest)), list_max(h, List.cons(next, rest)))","proof":["not is_upper_bound(List.cons(h, List.cons(next, rest)), m)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0], x3: List[T0]) { not T0.lte(x0, x1) or not is_upper_bound[T0](x2, x1) or List.cons[T0](x0, x2) != x3 or is_upper_bound[T0](x3, x1) }[T](h, m, List.cons(next, rest), List.cons(h, List.cons(next, rest)))","h <= m","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0]) { not T0.lte(x0, x1) or not is_upper_bound[T0](x2, x1) or is_upper_bound[T0](List.cons[T0](x0, x2), x1) }[T](h, m, List.cons(next, rest))"]}
{"goal":"list_max_is_upper_bound","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(tail)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(tail)","function(x0: List[T], x1: T) { not p(x0) or is_upper_bound(List.cons(x1, x0), list_max(x1, x0)) }(tail, head)","let s2: List[T] -> T satisfy { forall(x2: List[T], x3: T) { not p(x2) or is_upper_bound[T](List.cons[T](x3, x2), list_max[T](x3, x2)) } and forall(x4: List[T]) { not is_upper_bound[T](List.cons[T](s2(x4), x4), list_max[T](s2(x4), x4)) or p(x4) } }","function(x0: List[T]) { not is_upper_bound(List.cons(s2(x0), x0), list_max(s2(x0), x0)) or p(x0) }(List.cons(s0, s1))","function(x0: List[T], x1: T, x2: T) { not p(x0) or is_upper_bound(List.cons(x1, List.cons(x2, x0)), list_max(x1, List.cons(x2, x0))) }(s1, s2(List.cons(s0, s1)), s0)","p(s1)","not p(tail)","not p(List.cons(s0, s1))","function(x0: T, x1: T) { is_upper_bound(List.cons(x0, List.cons(x1, s1)), list_max(x0, List.cons(x1, s1))) }(s2(List.cons(s0, s1)), s0)"]}
{"goal":"list_has_upper_bound","proof":["function(x0: T) { not is_upper_bound(List.cons(head, tail), x0) }(list_max(head, tail))","function[T0: LinearOrder](x0: T0, x1: List[T0]) { is_upper_bound[T0](List.cons[T0](x0, x1), list_max[T0](x0, x1)) }[T](head, tail)"]}
{"goal":"not List.nil[T].contains(c)","proof":["function[T0](x0: List[T0], x1: T0) { not x1 ∈ x0 or List.nil[T0] != x0 }[T](List.nil[T], c)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { c ∈ x0 or p(x0) }(List.nil[T])"]}
{"goal":"lb <= head","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_lower_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or T0.lte(x1, x2) }[T](List.cons(head, tail), lb, head, tail)","function(x0: List[T], x1: List[T]) { not is_lower_bound(x0, lb) or List.cons(head, x1) != x0 }(List.cons(head, tail), tail)","function(x0: List[T]) { not is_lower_bound(List.cons(head, x0), lb) }(tail)"]}
{"goal":"is_lower_bound(tail, lb)","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_lower_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or is_lower_bound[T0](x3, x1) }[T](List.cons(head, tail), lb, head, tail)","function(x0: List[T], x1: T) { not is_lower_bound(x0, lb) or List.cons(x1, tail) != x0 }(List.cons(head, tail), head)","function(x0: T) { not is_lower_bound(List.cons(x0, tail), lb) }(head)"]}
{"goal":"lb <= c","proof":["not lb <= head"]}
{"goal":"tail.contains(c)","proof":["function[T0](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not x1 ∈ x0 or List.cons[T0](x2, x3) != x0 or x1 ∈ x3 or x1 = x2 }[T](List.cons(head, tail), c, head, tail)","function[T0](x0: T0, x1: List[T0], x2: T0) { not x2 ∈ List.cons[T0](x0, x1) or x2 ∈ x1 or x0 = x2 }[T](head, tail, c)"]}
{"goal":"lb <= c","proof":["function(x0: List[T]) { not is_lower_bound(x0, lb) or not c ∈ x0 or not p(x0) or lb <= c }(tail)","function(x0: List[T]) { not is_lower_bound(x0, lb) or not c ∈ x0 or not p(x0) }(tail)","not is_lower_bound(tail, lb)"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { not lb <= c or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { c ∈ x0 or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { is_lower_bound(x0, lb) or p(x0) }(List.cons(head, tail))","not lb <= c","is_lower_bound(List.cons(head, tail), lb)","c ∈ List.cons(head, tail)","not c ∈ List.cons(head, tail)"]}
{"goal":"lower_bound_contains","proof":["function(x0: List[T]) { not is_lower_bound(x0, lb) or not c ∈ x0 or not p(x0) or lb <= c }(list)","function(x0: List[T]) { not is_lower_bound(x0, lb) or not c ∈ x0 or not p(x0) }(list)","let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1, s0)","p(s1)","not p(list)","not p(List.cons(s0, s1))"]}
{"goal":"is_lower_bound(List.nil[T], lb)","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0) { List.nil[T0] != x0 or is_lower_bound[T0](x0, x1) }[T](List.nil[T], lb)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { not is_lower_bound(x0, lb) or p(x0) }(List.nil[T])"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { not is_lower_bound(x0, lb) or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { is_lower_bound(x0 + list2, lb) or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { not is_lower_bound(x0 + list2, lb) or not p(x0) or is_lower_bound(x0, lb) }(tail)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0], x3: List[T0]) { not T0.lte(x0, x1) or not is_lower_bound[T0](x2, x0) or List.cons[T0](x1, x2) != x3 or is_lower_bound[T0](x3, x0) }[T](lb, head, tail, List.cons(head, tail))","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, List.cons(head, tail), list2)","function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_lower_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or is_lower_bound[T0](x3, x1) }[T](List.cons(head, tail + list2), lb, head, tail + list2)","function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_lower_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or T0.lte(x1, x2) }[T](List.cons(head, tail + list2), lb, head, tail + list2)","not is_lower_bound(List.cons(head, tail), lb)","is_lower_bound(List.cons(head, tail) + list2, lb)","function[T0: LinearOrder](x0: T0, x1: List[T0], x2: T0) { not is_lower_bound[T0](List.cons[T0](x0, x1), x2) or T0.lte(x2, x0) }[T](head, tail + list2, lb)","function[T0: LinearOrder](x0: T0, x1: List[T0], x2: T0) { not is_lower_bound[T0](List.cons[T0](x0, x1), x2) or is_lower_bound[T0](x1, x2) }[T](head, tail + list2, lb)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) + x2 = List.cons[T0](x0, x1 + x2) }[T](head, tail, list2)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0]) { not T0.lte(x0, x1) or not is_lower_bound[T0](x2, x0) or is_lower_bound[T0](List.cons[T0](x1, x2), x0) }[T](lb, head, tail)","is_lower_bound(List.cons(head, tail + list2), lb)","not is_lower_bound(tail + list2, lb) or is_lower_bound(tail, lb)","lb <= head","is_lower_bound(tail + list2, lb)","not is_lower_bound(tail, lb)","is_lower_bound(tail, lb)"]}
{"goal":"lower_bound_add_left","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list1)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1, s0)","function(x0: List[T]) { not is_lower_bound(x0 + list2, lb) or not p(x0) or is_lower_bound(x0, lb) }(list1)","p(s1)","not p(list1)","not p(List.cons(s0, s1))"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { not is_lower_bound(list2, lb) or p(x0) }(List.nil[T])","not is_lower_bound(list2, lb)","function(x0: List[T]) { is_lower_bound(x0 + list2, lb) or p(x0) }(List.nil[T])","function[T0](x0: List[T0]) { List.nil[T0] + x0 = x0 }[T](list2)","is_lower_bound(List.nil[T] + list2, lb)","not is_lower_bound(List.nil[T] + list2, lb)"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { not is_lower_bound(list2, lb) or p(x0) }(List.cons(head, tail))","not is_lower_bound(list2, lb)","function(x0: List[T]) { not is_lower_bound(x0 + list2, lb) or not p(x0) or is_lower_bound(list2, lb) }(tail)","function(x0: List[T]) { not is_lower_bound(x0 + list2, lb) or not p(x0) }(tail)","function(x0: List[T]) { is_lower_bound(x0 + list2, lb) or p(x0) }(List.cons(head, tail))","function[T0](x0: T0, x1: List[T0], x2: List[T0], x3: List[T0]) { List.cons[T0](x0, x1) != x2 or List.cons[T0](x0, x1 + x3) = x2 + x3 }[T](head, tail, List.cons(head, tail), list2)","function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_lower_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or is_lower_bound[T0](x3, x1) }[T](List.cons(head, tail + list2), lb, head, tail + list2)","not is_lower_bound(tail + list2, lb)","is_lower_bound(List.cons(head, tail) + list2, lb)","function[T0: LinearOrder](x0: T0, x1: List[T0], x2: T0) { not is_lower_bound[T0](List.cons[T0](x0, x1), x2) or is_lower_bound[T0](x1, x2) }[T](head, tail + list2, lb)","function[T0](x0: T0, x1: List[T0], x2: List[T0]) { List.cons[T0](x0, x1) + x2 = List.cons[T0](x0, x1 + x2) }[T](head, tail, list2)","is_lower_bound(List.cons(head, tail + list2), lb)"]}
{"goal":"lower_bound_add_right","proof":["function(x0: List[T]) { not is_lower_bound(x0 + list2, lb) or not p(x0) or is_lower_bound(list2, lb) }(list1)","function(x0: List[T]) { not is_lower_bound(x0 + list2, lb) or not p(x0) }(list1)","let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list1)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1, s0)","p(s1)","not p(list1)","not p(List.cons(s0, s1))"]}
{"goal":"is_lower_bound(List.nil[T], lb2)","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0) { List.nil[T0] != x0 or is_lower_bound[T0](x0, x1) }[T](List.nil[T], lb2)"]}
{"goal":"p(List.nil[T])","proof":["function(x0: List[T]) { not is_lower_bound(x0, lb2) or p(x0) }(List.nil[T])"]}
{"goal":"p(List.cons(head, tail))","proof":["function(x0: List[T]) { not is_lower_bound(x0, lb2) or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { is_lower_bound(x0, lb1) or p(x0) }(List.cons(head, tail))","function(x0: List[T]) { not lb2 <= lb1 or not is_lower_bound(x0, lb1) or not p(x0) or is_lower_bound(x0, lb2) }(tail)","function(x0: List[T]) { not is_lower_bound(x0, lb1) or not p(x0) or is_lower_bound(x0, lb2) }(tail)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0], x3: List[T0]) { not T0.lte(x0, x1) or not is_lower_bound[T0](x2, x0) or List.cons[T0](x1, x2) != x3 or is_lower_bound[T0](x3, x0) }[T](lb2, head, tail, List.cons(head, tail))","function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_lower_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or is_lower_bound[T0](x3, x1) }[T](List.cons(head, tail), lb1, head, tail)","function[T0: LinearOrder](x0: List[T0], x1: T0, x2: T0, x3: List[T0]) { not is_lower_bound[T0](x0, x1) or List.cons[T0](x2, x3) != x0 or T0.lte(x1, x2) }[T](List.cons(head, tail), lb1, head, tail)","function[T0](x0: (T0, T0) -> Bool, x1: T0, x2: T0, x3: T0) { not lib(util).is_transitive[T0](x0) or not x0(x1, x2) or not x0(x2, x3) or x0(x1, x3) }[T](T.lte, lb2, lb1, head)","function[T0: lib(order).PartialOrder] { lib(util).is_transitive[T0](T0.lte) }[T]","is_lower_bound(List.cons(head, tail), lb1)","not is_lower_bound(List.cons(head, tail), lb2)","function[T0: LinearOrder](x0: T0, x1: List[T0], x2: T0) { not is_lower_bound[T0](List.cons[T0](x0, x1), x2) or T0.lte(x2, x0) }[T](head, tail, lb1)","function[T0: LinearOrder](x0: T0, x1: List[T0], x2: T0) { not is_lower_bound[T0](List.cons[T0](x0, x1), x2) or is_lower_bound[T0](x1, x2) }[T](head, tail, lb1)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0]) { not T0.lte(x0, x1) or not is_lower_bound[T0](x2, x0) or is_lower_bound[T0](List.cons[T0](x1, x2), x0) }[T](lb2, head, tail)","not is_lower_bound(tail, lb1) or is_lower_bound(tail, lb2)","function(x0: T) { not lib(util).is_transitive[T](T.lte) or not lb1 <= x0 or lb2 <= x0 }(head)","is_lower_bound(tail, lb1)","lb1 <= head","is_lower_bound(tail, lb2)","lb2 <= head","not lb2 <= head"]}
{"goal":"lower_bound_monotone","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(list)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(list)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1, s0)","function(x0: List[T]) { not lb2 <= lb1 or not is_lower_bound(x0, lb1) or not p(x0) or is_lower_bound(x0, lb2) }(list)","function(x0: List[T]) { not is_lower_bound(x0, lb1) or not p(x0) or is_lower_bound(x0, lb2) }(list)","p(s1)","not p(list)","not p(List.cons(s0, s1))"]}
{"goal":"list_min(h, List.nil[T]) = h","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0) { List.nil[T0] != x0 or list_min[T0](x1, x0) = x1 }[T](List.nil[T], h)"]}
{"goal":"h <= h","proof":["function[T0: LinearOrder](x0: T0, x1: T0) { T0.lte(x0, x1) or T0.lte(x1, x0) }[T](h, h)"]}
{"goal":"is_lower_bound(List.nil[T], h)","proof":["function[T0: LinearOrder](x0: List[T0], x1: T0) { List.nil[T0] != x0 or is_lower_bound[T0](x0, x1) }[T](List.nil[T], h)"]}
{"goal":"is_lower_bound(List.cons(h, List.nil[T]), list_min(h, List.nil[T]))","proof":["not is_lower_bound(List.cons(h, List.nil[T]), h)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0], x3: List[T0]) { not T0.lte(x0, x1) or not is_lower_bound[T0](x2, x0) or List.cons[T0](x1, x2) != x3 or is_lower_bound[T0](x3, x0) }[T](h, h, List.nil[T], List.cons(h, List.nil[T]))","function[T0: LinearOrder](x0: T0, x1: T0) { T0.lte(x0, x1) or T0.lte(x1, x0) }[T](h, h)","function[T0: LinearOrder](x0: T0) { T0.lte(x0, x0) }[T](h)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0]) { not T0.lte(x0, x1) or not is_lower_bound[T0](x2, x0) or is_lower_bound[T0](List.cons[T0](x1, x2), x0) }[T](h, h, List.nil[T])"]}
{"goal":"p(List.nil[T])","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T], x1: T) { not p(x0) or is_lower_bound[T](List.cons[T](x1, x0), list_min[T](x1, x0)) } and forall(x2: List[T]) { not is_lower_bound[T](List.cons[T](s0(x2), x2), list_min[T](s0(x2), x2)) or p(x2) } }","function(x0: T) { is_lower_bound(List.cons(x0, List.nil[T]), list_min(x0, List.nil[T])) }(s0(List.nil[T]))","function(x0: List[T]) { not is_lower_bound(List.cons(s0(x0), x0), list_min(s0(x0), x0)) or p(x0) }(List.nil[T])"]}
{"goal":"is_lower_bound(List.cons(next, rest), list_min(next, rest))","proof":["function(x0: List[T], x1: T) { not p(x0) or is_lower_bound(List.cons(x1, x0), list_min(x1, x0)) }(rest, next)"]}
{"goal":"h.min(list_min(next, rest)) = list_min(h, List.cons(next, rest))","proof":["function[T0: LinearOrder](x0: T0, x1: List[T0], x2: List[T0], x3: T0) { List.cons[T0](x0, x1) != x2 or T0.min(x3, list_min[T0](x0, x1)) = list_min[T0](x3, x2) }[T](next, rest, List.cons(next, rest), h)"]}
{"goal":"h.min(list_min(next, rest)) <= list_min(next, rest)","proof":["function[T0: LinearOrder](x0: T0, x1: T0) { T0.min(x0, x1) <= x1 }[T](h, list_min(next, rest))"]}
{"goal":"h.min(list_min(next, rest)) <= h","proof":["function[T0: LinearOrder](x0: T0, x1: T0) { T0.min(x0, x1) = T0.min(x1, x0) }[T](list_min(next, rest), h)","not list_min(next, rest).min(h) <= h","function[T0: LinearOrder](x0: T0, x1: T0) { T0.min(x0, x1) <= x1 }[T](list_min(next, rest), h)"]}
{"goal":"list_min(h, List.cons(next, rest)) <= h","proof":[]}
{"goal":"is_lower_bound(List.cons(next, rest), m)","proof":["function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0]) { not T0.lte(x0, x1) or not is_lower_bound[T0](x2, x1) or is_lower_bound[T0](x2, x0) }[T](m, list_min(next, rest), List.cons(next, rest))","list_min(h, List.cons(next, rest)) <= list_min(next, rest)","m <= list_min(next, rest)","function(x0: T) { not is_lower_bound(List.cons(next, rest), x0) or not m <= x0 }(list_min(next, rest))"]}
{"goal":"is_lower_bound(List.cons(h, List.cons(next, rest)), list_min(h, List.cons(next, rest)))","proof":["not is_lower_bound(List.cons(h, List.cons(next, rest)), m)","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0], x3: List[T0]) { not T0.lte(x0, x1) or not is_lower_bound[T0](x2, x0) or List.cons[T0](x1, x2) != x3 or is_lower_bound[T0](x3, x0) }[T](m, h, List.cons(next, rest), List.cons(h, List.cons(next, rest)))","m <= h","function[T0: LinearOrder](x0: T0, x1: T0, x2: List[T0]) { not T0.lte(x0, x1) or not is_lower_bound[T0](x2, x0) or is_lower_bound[T0](List.cons[T0](x1, x2), x0) }[T](m, h, List.cons(next, rest))"]}
{"goal":"p(List.cons(next, rest))","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T], x1: T) { not p(x0) or is_lower_bound[T](List.cons[T](x1, x0), list_min[T](x1, x0)) } and forall(x2: List[T]) { not is_lower_bound[T](List.cons[T](s0(x2), x2), list_min[T](s0(x2), x2)) or p(x2) } }","function(x0: List[T]) { not is_lower_bound(List.cons(s0(x0), x0), list_min(s0(x0), x0)) or p(x0) }(List.cons(next, rest))","function(x0: T) { is_lower_bound(List.cons(x0, List.cons(next, rest)), list_min(x0, List.cons(next, rest))) }(s0(List.cons(next, rest)))"]}
{"goal":"list_min_is_lower_bound","proof":["let  (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons[T](s0, s1)) or not p(List.nil[T]) or p(x1) } }","function(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) }(s1)","function(x0: List[T]) { p(s1) or p(x0) }(s1)","function(x0: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x0) }(tail)","function(x0: List[T]) { not p(List.cons(s0, s1)) or p(x0) }(tail)","function(x0: List[T], x1: T) { not p(x0) or p(List.cons(x1, x0)) }(s1, s0)","function(x0: List[T], x1: T) { not p(x0) or is_lower_bound(List.cons(x1, x0), list_min(x1, x0)) }(tail, head)","p(s1)","not p(tail)","not p(List.cons(s0, s1))"]}
{"goal":"list_has_lower_bound","proof":["function(x0: T) { not is_lower_bound(List.cons(head, tail), x0) }(list_min(head, tail))","function[T0: LinearOrder](x0: T0, x1: List[T0]) { is_lower_bound[T0](List.cons[T0](x0, x1), list_min[T0](x0, x1)) }[T](head, tail)"]}
