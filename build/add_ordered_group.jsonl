{"goal":"is_transitive[G](G.lte)","proof":["function[T0: PartialOrder] { is_transitive[T0](T0.lte) }[G]"]}
{"goal":"a < b implies a <= b","proof":["function[T0: PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[G](a, b)"]}
{"goal":"b < c implies b <= c","proof":["function[T0: PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or T0.lte(x0, x1) }[G](b, c)"]}
{"goal":"a.min(c) <= a","proof":["function[T0: LinearOrder](x0: T0, x1: T0) { T0.min(x0, x1) <= x0 }[G](a, c)"]}
{"goal":"a < c or a.min(c) = c","proof":["function[T0: LinearOrder](x0: T0, x1: T0) { T0.min(x0, x1) = x0 or T0.min(x0, x1) = x1 }[G](a, c)","a.min(c) = a","c != a","function[T0: LinearOrder](x0: T0, x1: T0) { T0.max(x0, x1) = x1 or T0.gte(x0, x1) }[G](a, c)","function[T0: LinearOrder](x0: T0, x1: T0) { T0.max(x0, x1) = x0 or T0.lt(x0, x1) }[G](a, c)","a.max(c) = a","function[T0: LinearOrder](x0: T0, x1: T0) { not T0.gte(x0, x1) or T0.min(x0, x1) = x1 }[G](a, c)","not a >= c","a.max(c) != c","a.max(c) = c"]}
{"goal":"lt_trans","proof":["c <= a","function[T0](x0: (T0, T0) -> Bool, x1: T0, x2: T0, x3: T0) { not is_transitive[T0](x0) or not x0(x1, x2) or not x0(x2, x3) or x0(x1, x3) }[G](G.lte, b, c, a)","function[T0](x0: (T0, T0) -> Bool, x1: T0, x2: T0) { not lib(util).is_antisymmetric[T0](x0) or not x0(x1, x2) or not x0(x2, x1) or x1 = x2 }[G](G.lte, b, a)","function[T0: PartialOrder](x0: T0, x1: T0) { not T0.lt(x0, x1) or x0 != x1 }[G](a, b)","b != a","function[T0: PartialOrder] { lib(util).is_antisymmetric[T0](T0.lte) }[G]","function(x0: G) { not x0 <= c or x0 <= a }(b)","b <= a"]}
{"goal":"negative_of_nonnegative","proof":["function[T0: AddLeftOrderedGroup](x0: T0, x1: T0, x2: T0) { not T0.lte(x0, x1) or T0.add(x2, x0) <= T0.add(x2, x1) }[G](G.0, --a, -a)","function[T0: AddGroup](x0: T0) { T0.add(x0, T0.neg(x0)) = T0.0 }[G](-a)","function[T0: AddGroup](x0: T0) { -T0.neg(x0) = x0 }[G](a)","function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.add(x0, T0.0) = x0 }[G](-a)","not -a + G.0 <= G.0","G.0 <= --a","function(x0: G) { not -a + G.0 <= x0 + -x0 }(-a)"]}
{"goal":"negative_of_negative","proof":["function[T0: AddLeftOrderedGroup](x0: T0, x1: T0, x2: T0) { not T0.lte(x0, x1) or T0.add(x2, x0) <= T0.add(x2, x1) }[G](--a, G.0, -a)","function[T0: AddGroup](x0: T0) { T0.add(x0, T0.neg(x0)) = T0.0 }[G](-a)","function[T0: AddGroup](x0: T0) { -T0.neg(x0) = x0 }[G](a)","function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.add(x0, T0.0) = x0 }[G](-a)","not G.0 <= -a + G.0","--a <= G.0","function(x0: G) { not x0 + -x0 <= -a + G.0 }(-a)"]}
{"goal":"add_inequality","proof":["function[T0: AddOrderedGroup](x0: T0, x1: T0, x2: T0) { not T0.lte(x0, x1) or T0.add(x0, x2) <= T0.add(x1, x2) }[F](a, b, c)","function[T0: AddLeftOrderedGroup](x0: T0, x1: T0, x2: T0) { not T0.lte(x0, x1) or T0.add(x2, x0) <= T0.add(x2, x1) }[F](c, d, b)","function[T0](x0: (T0, T0) -> Bool, x1: T0, x2: T0, x3: T0) { not is_transitive[T0](x0) or not x0(x1, x2) or not x0(x2, x3) or x0(x1, x3) }[F](F.lte, a + c, b + c, b + d)","function[T0: PartialOrder] { is_transitive[T0](T0.lte) }[F]","function(x0: F) { not x0 <= b + d or not a + c <= x0 or not is_transitive[F](F.lte) }(b + c)","function(x0: F) { x0 + c <= x0 + d }(b)","function(x0: F) { a + x0 <= b + x0 }(c)"]}
{"goal":"F.0 <= b + -a","proof":["function[T0: AddOrderedGroup](x0: T0, x1: T0, x2: T0) { not T0.lte(x0, x1) or T0.add(x0, x2) <= T0.add(x1, x2) }[F](a, b, -a)","function[T0: AddGroup](x0: T0) { T0.add(x0, T0.neg(x0)) = T0.0 }[F](a)","function(x0: F) { not x0 + -x0 <= b + -a }(a)"]}
{"goal":"F.0 <= b + -a implies -b + F.0 <= -b + (b + -a)","proof":["function[T0: AddLeftOrderedGroup](x0: T0, x1: T0, x2: T0) { not T0.lte(x0, x1) or T0.add(x2, x0) <= T0.add(x2, x1) }[F](F.0, b + -a, -b)"]}
{"goal":"-b + (b + -a) = -b + b + -a","proof":["function[T0: lib(add_semigroup).AddSemigroup](x0: T0, x1: T0, x2: T0) { T0.add(x0, x1) + x2 = T0.add(x0, T0.add(x1, x2)) }[F](-b, b, -a)"]}
{"goal":"-b + b = F.0","proof":["function[T0: AddGroup](x0: T0) { T0.neg(x0) + x0 = T0.0 }[F](b)"]}
{"goal":"-b + F.0 = -b","proof":["function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.add(x0, T0.0) = x0 }[F](-b)"]}
{"goal":"F.0 + -a = -a","proof":["function[T0: lib(add_monoid).AddMonoid](x0: T0) { T0.0 + x0 = x0 }[F](-a)"]}
{"goal":"minus_flips_inequality","proof":[]}
