{"goal":"closure_constraint[G](is_identity[G])","proof":["let [T0: Group] (s0: (T0 -> Bool) -> T0, s1: (T0 -> Bool) -> T0) satisfy { forall(x0: T0 -> Bool, x1: T0, x2: T0) { not closure_constraint[T0](x0) or not x0(x1) or not x0(x2) or x0(T0.mul(x1, x2)) } and forall(x3: T0 -> Bool) { closure_constraint[T0](x3) or x3(s0(x3)) } and forall(x4: T0 -> Bool) { closure_constraint[T0](x4) or x4(s1(x4)) } and forall(x5: T0 -> Bool) { not x5(T0.mul(s0(x5), s1(x5))) or closure_constraint[T0](x5) } }","not is_identity(G.mul(s0(is_identity[G]), s1(is_identity[G]))) or closure_constraint[G](is_identity[G])","closure_constraint[G](is_identity[G]) or is_identity[G](s1(is_identity[G]))","closure_constraint[G](is_identity[G]) or is_identity[G](s0(is_identity[G]))","not is_identity[G](s0(is_identity[G])) or s0(is_identity[G]) = G.1","G.1 * s1(is_identity[G]) = s1(is_identity[G])","is_identity[G](s0(is_identity[G]))","is_identity[G](s1(is_identity[G]))","not is_identity(G.mul(s0(is_identity[G]), s1(is_identity[G])))","s0(is_identity[G]) = G.1","not is_identity(G.1 * s1(is_identity[G]))"]}
{"goal":"G.1.inverse = G.1","proof":["G.1 * G.1.inverse = G.1","G.1 * G.1.inverse = G.1.inverse"]}
{"goal":"is_identity(a) implies is_identity(a.inverse)","proof":["a.inverse != G.1 or is_identity(a.inverse)","a.inverse != G.1","not is_identity(a) or G.1 = a","G.1 = a"]}
{"goal":"inverse_constraint[G](is_identity[G])","proof":["let s0[T0: Group]: (T0 -> Bool) -> T0 satisfy { forall(x0: T0 -> Bool, x1: T0) { not inverse_constraint[T0](x0) or not x0(x1) or x0(T0.inverse(x1)) } and forall(x2: T0 -> Bool) { inverse_constraint[T0](x2) or x2(s0(x2)) } and forall(x3: T0 -> Bool) { not x3(T0.inverse(s0(x3))) or inverse_constraint[T0](x3) } }","not is_identity[G](s0(is_identity[G])) or is_identity(G.inverse(s0(is_identity[G])))","not is_identity(G.inverse(s0(is_identity[G]))) or inverse_constraint[G](is_identity[G])","inverse_constraint[G](is_identity[G]) or is_identity[G](s0(is_identity[G]))","is_identity[G](s0(is_identity[G]))","not is_identity(G.inverse(s0(is_identity[G])))","is_identity(G.inverse(s0(is_identity[G])))"]}
{"goal":"identity_subgroup_constraint","proof":["not inverse_constraint[G](is_identity[G]) or not closure_constraint[G](is_identity[G]) or not identity_constraint[G](is_identity[G]) or subgroup_constraint[G](is_identity[G])","not identity_constraint[G](is_identity[G])","G.1 != G.1 or is_identity(G.1)","identity_constraint[G](is_identity[G]) = is_identity(G.1)","not is_identity(G.1)"]}
{"goal":"exists(k0: G -> Bool) { subgroup_constraint[G](k0) }","proof":["not subgroup_constraint[G](is_identity[G])","subgroup_constraint[G](is_identity[G])"]}
{"goal":"identity_subgroup_only_has_identity","proof":["not subgroup_constraint[G](is_identity[G]) or g ∈ Subgroup.new[G](is_identity[G]) = is_identity(g)","Subgroup.new[G](is_identity[G]) = identity_subgroup[G]","not is_identity(g) or G.1 = g","not is_identity(g)","subgroup_constraint[G](is_identity[G])","not g ∈ Subgroup.new[G](is_identity[G]) or not subgroup_constraint[G](is_identity[G]) or is_identity(g)","g ∈ Subgroup.new[G](is_identity[G])","not g ∈ Subgroup.new[G](is_identity[G])"]}
