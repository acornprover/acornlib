{"goal":"closure_constraint[G](is_identity[G])","proof":["let [T0: Group] (s0: (T0 -> Bool) -> T0, s1: (T0 -> Bool) -> T0) satisfy { forall(x0: T0 -> Bool, x1: T0, x2: T0) { not closure_constraint[T0](x0) or not x0(x1) or not x0(x2) or x0(T0.mul(x1, x2)) } and forall(x3: T0 -> Bool) { closure_constraint[T0](x3) or x3(s0(x3)) } and forall(x4: T0 -> Bool) { x4(s1(x4)) or closure_constraint[T0](x4) } and forall(x5: T0 -> Bool) { not x5(T0.mul(s0(x5), s1(x5))) or closure_constraint[T0](x5) } }","function[T0: Group](x0: T0 -> Bool) { not x0(T0.mul(s0(x0), s1(x0))) or closure_constraint[T0](x0) }[G](is_identity[G])","function[T0: Group](x0: T0 -> Bool) { x0(s1(x0)) or closure_constraint[T0](x0) }[G](is_identity[G])","function[T0: Group](x0: T0 -> Bool) { closure_constraint[T0](x0) or x0(s0(x0)) }[G](is_identity[G])","function[T0: Group](x0: T0) { not is_identity[T0](x0) or T0.1 = x0 }[G](s0(is_identity[G]))","function[T0: lib(monoid).Monoid](x0: T0) { T0.1 * x0 = x0 }[G](s1(is_identity[G]))","is_identity[G](s0(is_identity[G]))","is_identity[G](s1(is_identity[G]))","not is_identity(G.mul(s0(is_identity[G]), s1(is_identity[G])))","s0(is_identity[G]) = G.1","not is_identity(G.1 * s1(is_identity[G]))"]}
{"goal":"G.1.inverse = G.1","proof":["function[T0: Group](x0: T0) { T0.mul(x0, T0.inverse(x0)) = T0.1 }[G](G.1)","function[T0: lib(monoid).Monoid](x0: T0) { T0.1 * x0 = x0 }[G](G.1.inverse)"]}
{"goal":"is_identity(a) implies is_identity(a.inverse)","proof":["function[T0: Group](x0: T0) { T0.1 != x0 or is_identity[T0](x0) }[G](a.inverse)","a.inverse != G.1","function[T0: Group](x0: T0) { not is_identity[T0](x0) or T0.1 = x0 }[G](a)","G.1 = a"]}
{"goal":"inverse_constraint[G](is_identity[G])","proof":["let s0[T0: Group]: (T0 -> Bool) -> T0 satisfy { forall(x0: T0 -> Bool, x1: T0) { not inverse_constraint[T0](x0) or not x0(x1) or x0(T0.inverse(x1)) } and forall(x2: T0 -> Bool) { x2(s0(x2)) or inverse_constraint[T0](x2) } and forall(x3: T0 -> Bool) { not x3(T0.inverse(s0(x3))) or inverse_constraint[T0](x3) } }","function(x0: G) { not is_identity(x0) or is_identity(x0.inverse) }(s0(is_identity[G]))","function[T0: Group](x0: T0 -> Bool) { not x0(T0.inverse(s0(x0))) or inverse_constraint[T0](x0) }[G](is_identity[G])","function[T0: Group](x0: T0 -> Bool) { x0(s0(x0)) or inverse_constraint[T0](x0) }[G](is_identity[G])","is_identity[G](s0(is_identity[G]))","not is_identity(G.inverse(s0(is_identity[G])))","is_identity(G.inverse(s0(is_identity[G])))"]}
{"goal":"identity_subgroup_constraint","proof":["function[T0: Group](x0: T0 -> Bool) { not inverse_constraint[T0](x0) or not closure_constraint[T0](x0) or not identity_constraint[T0](x0) or subgroup_constraint[T0](x0) }[G](is_identity[G])","not identity_constraint[G](is_identity[G])","function[T0: Group](x0: T0) { T0.1 != x0 or is_identity[T0](x0) }[G](G.1)","function[T0: Group](x0: T0 -> Bool) { identity_constraint[T0](x0) = x0(T0.1) }[G](is_identity[G])","not is_identity(G.1)"]}
{"goal":"exists(k0: G -> Bool) { subgroup_constraint[G](k0) }","proof":["function(x0: G -> Bool) { not subgroup_constraint[G](x0) }(is_identity[G])","function[T0: Group] { subgroup_constraint[T0](is_identity[T0]) }[G]"]}
{"goal":"identity_subgroup_only_has_identity","proof":["function[T0: Group](x0: T0 -> Bool, x1: T0) { not subgroup_constraint[T0](x0) or x1 ∈ Subgroup.new[T0](x0) = x0(x1) }[G](is_identity[G], g)","function[T0: Group] { Subgroup.new[T0](is_identity[T0]) = identity_subgroup[T0] }[G]","function[T0: Group](x0: T0) { not is_identity[T0](x0) or T0.1 = x0 }[G](g)","not is_identity(g)","function[T0: Group] { subgroup_constraint[T0](is_identity[T0]) }[G]","function[T0: Group](x0: T0 -> Bool, x1: T0) { not x1 ∈ Subgroup.new[T0](x0) or not subgroup_constraint[T0](x0) or x0(x1) }[G](is_identity[G], g)","g ∈ Subgroup.new[G](is_identity[G])","not g ∈ Subgroup.new[G](is_identity[G])"]}
