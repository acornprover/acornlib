{"goal":"identity_constraint[G](is_identity[G])","proof":["identity_constraint[G](is_identity[G]) = is_identity(G.1)","not is_identity(G.1)","G.1 != G.1 or is_identity(G.1)"]}
{"goal":"closure_constraint[G](is_identity[G])","proof":["let (s0: (G -> Bool) -> G, s1: (G -> Bool) -> G) satisfy { forall(x0: G -> Bool, x1: G, x2: G) { not closure_constraint[G](x0) or not x0(x1) or not x0(x2) or x0(x1 * x2) } and forall(x3: G -> Bool) { x3(s0(x3)) or closure_constraint[G](x3) } and forall(x4: G -> Bool) { x4(s1(x4)) or closure_constraint[G](x4) } and forall(x5: G -> Bool) { not x5(s0(x5) * s1(x5)) or closure_constraint[G](x5) } }","not is_identity(s0(is_identity[G]) * s1(is_identity[G])) or closure_constraint[G](is_identity[G])","not is_identity(s0(is_identity[G]) * s1(is_identity[G]))","is_identity(s1(is_identity[G])) or closure_constraint[G](is_identity[G])","is_identity(s1(is_identity[G]))","is_identity(s0(is_identity[G])) or closure_constraint[G](is_identity[G])","is_identity(s0(is_identity[G]))","s0(is_identity[G]) * G.1 = s0(is_identity[G])","not is_identity(s1(is_identity[G])) or s1(is_identity[G]) = G.1","s1(is_identity[G]) = G.1"]}
{"goal":"inverse_constraint[G](is_identity[G])","proof":["let s0: (G -> Bool) -> G satisfy { forall(x0: G -> Bool, x1: G) { not inverse_constraint[G](x0) or not x0(x1) or x0(x1.inverse) } and forall(x2: G -> Bool) { x2(s0(x2)) or inverse_constraint[G](x2) } and forall(x3: G -> Bool) { not x3(s0(x3).inverse) or inverse_constraint[G](x3) } }","not is_identity(s0(is_identity[G]).inverse) or inverse_constraint[G](is_identity[G])","not is_identity(s0(is_identity[G]).inverse)","is_identity(s0(is_identity[G])) or inverse_constraint[G](is_identity[G])","is_identity(s0(is_identity[G]))","s0(is_identity[G]) * s0(is_identity[G]).inverse = G.1","identity_constraint[G](is_identity[G]) = is_identity(G.1)","is_identity(G.1)","not is_identity(s0(is_identity[G])) or s0(is_identity[G]) = G.1","G.1 * s0(is_identity[G]).inverse = s0(is_identity[G]).inverse","is_identity(s0(is_identity[G]) * s0(is_identity[G]).inverse)","s0(is_identity[G]) = G.1","not is_identity(G.1 * s0(is_identity[G]).inverse)"]}
{"goal":"identity_subgroup_constraint","proof":["not inverse_constraint[G](is_identity[G]) or not identity_constraint[G](is_identity[G]) or not closure_constraint[G](is_identity[G]) or subgroup_constraint[G](is_identity[G])"]}
{"goal":"exists(k0: G -> Bool) { subgroup_constraint[G](k0) }","proof":["not subgroup_constraint[G](is_identity[G])"]}
{"goal":"identity_subgroup_only_has_identity","proof":["not Subgroup.new[G](is_identity[G]).contains(g) or not subgroup_constraint[G](is_identity[G]) or is_identity(g)","not is_identity(g) or G.1 = g","not is_identity(g)","Subgroup.new[G](is_identity[G]).contains(g)","not Subgroup.new[G](is_identity[G]).contains(g)"]}
