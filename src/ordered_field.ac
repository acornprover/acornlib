from field import Field
from add_ordered_group import AddOrderedGroup

typeclass F: OrderedField extends Field, AddOrderedGroup {
    /// product of non-negative elements is non-negative
    mul_preserves_nonnegativity(a: F, b: F) {
        F.0 <= a and F.0 <= b implies F.0 <= a * b
    }
}

theorem multiply_inequality_with_nonnegative_element[F: OrderedField](a: F, b: F, c: F) {
    a <= b and F.0 <= c implies a * c <= b * c
} by {
    F.0 <= b - a
    F.0 <= (b - a) * c
    F.0 <= b * c - a * c
    F.0 + a * c <= b * c - a * c + a * c
    a * c <= b * c + (-a * c) + a * c
}

theorem multiply_with_nonpositive_flips_inequality[F: OrderedField](a: F, b: F, c: F) {
    a <= b and c <= F.0 implies b * c <= a * c
}

theorem inverse_on_positive_flips_inequality[F: OrderedField](a: F, b: F) {
    a < b and F.0 < a and F.0 < b implies b.inverse < a.inverse
} by {
    b.inverse != a.inverse
    F.0 <= a.inverse
    F.0 <= b.inverse
    a * a.inverse <= b * a.inverse
    F.1 <= b * a.inverse
    b.inverse * F.1 <= b.inverse * b * a.inverse
    b.inverse * b = F.1
    b.inverse <= F.1 * a.inverse
    b.inverse <= a.inverse
}

theorem squares_are_nonnegative[F: OrderedField](a: F) {
    a * a >= F.0
} by {
    if a >= F.0 {

    } else {
        -a >= F.0
        a * a = -a * -a
    }
}

from nat import Nat

theorem even_pows_are_nonnegative[F: OrderedField](a: F, n: Nat) {
    a.pow(Nat.2 * n) >= F.0
}

from int import Int

theorem nonnegative_even_zpows_are_nonnegative[F: OrderedField](a: F, n: Int) {
    n >= Int.0 implies a.zpow(Int.2 * n) >= F.0
} by {
    let k: Nat satisfy {
        n = Int.from_nat(k)
    }
    Int.2 * n = Int.from_nat(Nat.2 * k)
    a.zpow(Int.2 * n) = a.pow(Nat.2 * k)
}

theorem even_zpows_are_nonnegative[F: OrderedField](a: F, n: Int) {
    a.zpow(Int.2 * n) >= F.0
} by {
    if n >= Int.0 {
    } else {
        a.zpow(Int.2 * n) = a.zpow(Int.2 * -n).inverse
        n <= Int.0
        -n >= Int.0
        Int.2 * -n >= Int.0
        a.zpow(Int.2 * -n) >= F.0
        a.zpow(Int.2 * -n).inverse >= F.0
    }
}

theorem zero_is_smaller_than_one[F: OrderedField] {
    F.0 < F.1
}

theorem pows_of_nonnegative_are_nonnegative[F: OrderedField](a: F, n: Nat) {
    F.0 <= a implies F.0 <= a.pow(n)
} by {
    // Define a helper function for induction
    define f(x: Nat) -> Bool { F.0 <= a.pow(x) }

    // Base case
    f(Nat.0)
}

theorem nonnegative_zpows_of_nonnegative_are_nonnegative[F: OrderedField](a: F, n: Int) {
    F.0 <= a and n >= Int.0 implies F.0 <= a.zpow(n)
} by {
    let k: Nat satisfy {
        n = Int.from_nat(k)
    }
    a.zpow(n) = a.pow(k)
}

theorem inverse_of_nonnegative_is_nonnegative[F: OrderedField](a: F) {
    F.0 <= a implies F.0 <= a.inverse
} by {
    if F.0 > a.inverse {
        a != F.0
        F.0 * a.inverse >= a * a.inverse
        F.0 >= a * a.inverse
        F.0 >= F.1
        false
    }
}

theorem zpows_of_nonnegative_are_nonnegative[F: OrderedField](a: F, n: Int) {
    F.0 <= a implies F.0 <= a.zpow(n)
} by {
    if n >= Int.0 {}
    else {
        -n >= Int.0
        a.zpow(n) = a.zpow(-n).inverse
        F.0 <= a.zpow(-n)
        F.0 <= a.zpow(-n).inverse
    }
}

theorem odd_pows_of_negative_are_negative[F: OrderedField](a: F, n: Nat) {
    a < F.0 implies a.pow(Nat.2 * n + Nat.1) < F.0
} by {
    F.0 <= a.pow(Nat.2)
    a.pow(Nat.2 * n) * a <= F.0 * a
    a.pow(Nat.2 * n + Nat.1) <= F.0
    a.pow(Nat.2 * n + Nat.1) != F.0
}

theorem nonnegative_odd_zpows_of_negative_are_negative[F: OrderedField](a: F, n: Int) {
    a < F.0 and Int.0 <= n implies a.zpow(Int.2 * n + Int.1) < F.0
} by {
    let k: Nat satisfy {
        n = Int.from_nat(k)
    }
    Int.2 * n + Int.1 = Int.from_nat(Nat.2 * k + Nat.1)
}