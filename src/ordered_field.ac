from field import Field
from add_ordered_group import AddOrderedGroup

/// A field with a total order compatible with the field operations.
typeclass F: OrderedField extends Field, AddOrderedGroup {
    /// product of non-negative elements is non-negative
    mul_preserves_nonnegativity(a: F, b: F) {
        F.0 <= a and F.0 <= b implies F.0 <= a * b
    }
}

theorem multiply_inequality_with_nonnegative_element[F: OrderedField](a: F, b: F, c: F) {
    a <= b and F.0 <= c implies a * c <= b * c
} by {
    a + -a <= b + -a
    b + -a = b - a
    a + -a = F.0
    F.0 <= b - a
    F.0 <= (b - a) * c
    (b - a) * c = b * c + -a * c
    a * c <= (b - a) * c + a * c
    a * c <= b * c + (-a * c) + a * c
    (b + -a) * c + a * c = (b + -a + a) * c
    b + -a + a = b + (-a + a)
    -a + a = F.0
    b + F.0 = b
}

theorem multiply_with_nonpositive_flips_inequality[F: OrderedField](a: F, b: F, c: F) {
    a <= b and c <= F.0 implies b * c <= a * c
} by {
    -b <= -a
    F.0 <= -c
    -b * -c <= -a * -c
    -a * -c = a * c
    -b * -c = b * c
}

theorem inverse_on_positive_flips_inequality[F: OrderedField](a: F, b: F) {
    a < b and F.0 < a and F.0 < b implies b.inverse < a.inverse
} by {
    F.0 <= a
    F.0 != a
    a * a.inverse = F.1
    a.inverse * a = a * a.inverse
    a.inverse <= F.0 or F.0 <= a.inverse
    F.0 * a = F.0
    F.0 <= a.inverse
    F.0 <= b
    F.0 != b
    b * b.inverse = F.1
    b.inverse * b = b * b.inverse
    b.inverse <= F.0 or F.0 <= b.inverse
    F.0 * b = F.0
    F.0 <= b.inverse
    F.1 <= b * a.inverse
    b.inverse * b = F.1
    F.1 * b.inverse <= b * a.inverse * b.inverse
    b * a.inverse * b.inverse = b * (a.inverse * b.inverse)
    b.inverse * a.inverse = a.inverse * b.inverse
    b * b.inverse * a.inverse = b * (b.inverse * a.inverse)
    F.1 * b.inverse = b.inverse
    b.inverse <= F.1 * a.inverse
}

theorem squares_are_nonnegative[F: OrderedField](a: F) {
    a * a >= F.0
} by {
    if a >= F.0 {

    } else {
    }
}

from nat import Nat

theorem even_pows_are_nonnegative[F: OrderedField](a: F, n: Nat) {
    a.pow(Nat.2 * n) >= F.0
} by {
    a.pow(n) * a.pow(n) = a.pow(n + n)
    a.pow(n) * a.pow(n) >= F.0
    Nat.1 * n = n
    n + Nat.1 * n = Nat.1.suc * n
}

from int import Int

theorem nonnegative_even_zpows_are_nonnegative[F: OrderedField](a: F, n: Int) {
    n >= Int.0 implies a.zpow(Int.2 * n) >= F.0
} by {
    a.zpow(n) * a.zpow(n) = a.zpow(n + n)
    Int.2 * n = n + n
    a.zpow(n) * a.zpow(n) >= F.0
}

theorem even_zpows_are_nonnegative[F: OrderedField](a: F, n: Int) {
    a.zpow(Int.2 * n) >= F.0
} by {
    if n >= Int.0 {
    } else {
        n <= Int.0
        a.zpow(Int.2 * -n).inverse >= F.0
    }
}

theorem zero_is_smaller_than_one[F: OrderedField] {
    F.0 < F.1
}

theorem pows_of_nonnegative_are_nonnegative[F: OrderedField](a: F, n: Nat) {
    F.0 <= a implies F.0 <= a.pow(n)
} by {
    // Define a helper function for induction
    define f(x: Nat) -> Bool { F.0 <= a.pow(x) }

    // Base case
    f(Nat.0)

    // Inductive step
    forall(k: Nat) {
        a * a.pow(k) = a.pow(k.suc)
        f(k) implies f(k.suc)
    }
}

theorem nonnegative_zpows_of_nonnegative_are_nonnegative[F: OrderedField](a: F, n: Int) {
    F.0 <= a and n >= Int.0 implies F.0 <= a.zpow(n)
} by {
    let k: Nat satisfy {
        n = Int.from_nat(k)
    }
}

theorem inverse_of_nonnegative_is_nonnegative[F: OrderedField](a: F) {
    F.0 <= a implies F.0 <= a.inverse
} by {
    if F.0 > a.inverse {
        a != F.0
        F.0 >= a * a.inverse
        false
    }
}

theorem zpows_of_nonnegative_are_nonnegative[F: OrderedField](a: F, n: Int) {
    F.0 <= a implies F.0 <= a.zpow(n)
} by {
    if n >= Int.0 {}
    else {
        n <= Int.0
        Int.0 <= -n
        -n >= Int.0
        F.0 <= a.zpow(-n)
        F.0 <= a.zpow(-n).inverse
    }
}

theorem odd_pows_of_negative_are_negative[F: OrderedField](a: F, n: Nat) {
    a < F.0 implies a.pow(Nat.2 * n + Nat.1) < F.0
} by {
    a <= F.0
    a.pow(Nat.2 * n) >= F.0
    F.0 <= a.pow(Nat.2 * n)
    a.pow(Nat.2 * n) * a <= F.0 * a
    F.0 * a = F.0
    a.pow(Nat.2 * n) * a <= F.0
    a.pow(Nat.1) = a
    a.pow(Nat.2 * n) * a.pow(Nat.1) = a.pow(Nat.2 * n + Nat.1)
    F.0 != a
    a.pow((Nat.2 * n).suc) != F.0
    a.pow(Nat.2 * n) * a = a * a.pow(Nat.2 * n)
    a * a.pow(Nat.2 * n) = a.pow((Nat.2 * n).suc)
    a.pow(Nat.2 * n) * a != F.0
    a.pow(Nat.2 * n) * a < F.0
}

theorem nonnegative_odd_zpows_of_negative_are_negative[F: OrderedField](a: F, n: Int) {
    a < F.0 and Int.0 <= n implies a.zpow(Int.2 * n + Int.1) < F.0
} by {
    let k: Nat satisfy {
        n = Int.from_nat(k)
    }
    Int.2 * n + Int.1 = Int.from_nat(Nat.2 * k + Nat.1)
    a.pow(Nat.2 * k + Nat.1) < F.0
    a.zpow(Int.from_nat(Nat.2 * k + Nat.1)) = a.pow(Nat.2 * k + Nat.1)
}