from nat import Nat
numerals Nat

/// A generic list data structure that can hold elements of any type.
/// Lists are constructed using nil (empty list) and cons (prepending an element).
inductive List<T> {
    /// The empty list.
    nil
    /// Constructs a list by prepending an element to an existing list.
    cons(T, List<T>)
}

attributes List<T> {
    /// Concatenates two lists together.
    define add(self, other: List<T>) -> List<T> {
        match self {
            List.nil {
                other
            }
            List.cons(head, tail) {
                List.cons(head, tail.add(other))
            }
        }
    }

    /// True if this list contains the given item.
    define contains(self, item: T) -> Bool {
        match self {
            List.nil {
                false
            }
            List.cons(head, tail) {
                if head = item {
                    true
                } else {
                    tail.contains(item)
                }
            }
        }
    }
}

theorem add_nil<T>(list: List<T>) {
    list + List.nil<T> = list
}

theorem nil_add<T>(list: List<T>) {
    List.nil<T> + list = list
}

theorem add_contains_left<T>(left: List<T>, right: List<T>, item: T) {
    left.contains(item) implies (left + right).contains(item)
} by {
    define f(x: List<T>) -> Bool {
        x.contains(item) implies (x + right).contains(item)
    }
    f(List.nil)
    forall(head: T, tail: List<T>) {
        if f(tail) {
            f(List.cons(head, tail))
        }
    }
}

theorem add_contains_right<T>(left: List<T>, right: List<T>, item: T) {
    right.contains(item) implies (left + right).contains(item)
} by {
    define f(x: List<T>) -> Bool {
        (x + right).contains(item)
    }
    f(List.nil)
    forall(head: T, tail: List<T>) {
        if f(tail) {
            f(List.cons(head, tail))
        }
    }
}

attributes List<T> {
    /// True if this list contains every element of type T.
    define contains_every(self) -> Bool {
        forall(x: T) {
            self.contains(x)
        }
    }

    /// Yields the number of elements in the list.
    define length(self) -> Nat {
        match self {
            List.nil {
                Nat.0
            }
            List.cons(_, tail) {
                tail.length.suc
            }
        }
    }
}

theorem add_length<T>(left: List<T>, right: List<T>) {
    left.length + right.length = (left + right).length
} by {
    define f(x: List<T>) -> Bool {
        x.length + right.length = (x + right).length
    }
    f(List.nil)
    forall(head: T, tail: List<T>) {
        if f(tail) {
            f(List.cons(head, tail))
        }
    }
}

attributes List<T> {
    /// Creates a list containing a single element.
    let singleton: T -> List<T> = function(x: T) {
        List.cons(x, List.nil<T>)
    }

    /// Removes all duplicate elements from the list.
    /// When duplicates exist, the last occurrence is kept.
    define unique(self) -> List<T> {
        match self {
            List.nil {
                List.nil<T>
            }
            List.cons(head, tail) {
                if tail.contains(head) {
                    tail.unique
                } else {
                    List.cons(head, tail.unique)
                }
            }
        }
    }

    define is_unique(self) -> Bool {
        self.unique = self
    }
}

theorem singleton_unique<T>(item: T) {
    List.singleton(item).is_unique
}

theorem unique_length<T>(list: List<T>) {
    list.unique.length <= list.length
} by {
    define f(x: List<T>) -> Bool {
        x.unique.length <= x.length
    }
    f(List.nil)
    forall(head: T, tail: List<T>) {
        if f(tail) {
            tail.unique.length <= tail.length
            if tail.contains(head) {
                List.cons(head, tail).unique.length <= List.cons(head, tail).length
            } else {
                List.cons(head, tail).unique.length <= List.cons(head, tail).length
            }
            f(List.cons(head, tail))
        }
    }
}

theorem unique_preserves_contains<T>(list: List<T>, item: T) {
    list.unique.contains(item) = list.contains(item)
} by {
    define p(l: List<T>, x: T) -> Bool {
        l.unique.contains(x) = l.contains(x)
    }

    // Base case: empty list
    p(List.nil<T>, item)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail, item) {
            if tail.contains(head) {
                // If the tail contains the head, then the unique list is just the tail's unique list.
                tail.unique.contains(item) = tail.contains(item)
                List.cons(head, tail).unique = tail.unique

                // Obviously if the tail contains the item, so does the cons list.
                List.cons(head, tail).contains(item) implies tail.contains(item)
                tail.contains(item) implies List.cons(head, tail).contains(item)
                List.cons(head, tail).contains(item) = tail.contains(item)

                // Proves proposition
                p(List.cons(head, tail), item)
            } else {
                // If the tail doesn't contain the item, then have to append head
                List.cons(head, tail).unique = List.cons(head, tail.unique)

                // Trick to help prover here (tail.unique.contains = tail.contains, rest is defns)
                List.cons(head, tail.unique).contains(item) implies List.cons(head, tail).contains(item)
                List.cons(head, tail).contains(item) implies List.cons(head, tail.unique).contains(item)
                List.cons(head, tail).contains(item) = List.cons(head, tail.unique).contains(item)

                p(List.cons(head, tail), item)
            }
            p(List.cons(head, tail), item)
        }
    }

    List.induction(function (l: List<T>) {
        p(l, item)
    })

    // Prover help
    list.unique.contains(item) implies list.contains(item)
    list.contains(item) implies list.unique.contains(item)
}

theorem unique_indemp<T>(list: List<T>) {
    list.unique.unique = list.unique
} by {
    let list_unique = list.unique

    define f(x: List<T>) -> Bool {
        x.unique.unique = x.unique
    }

    // Base case
    f(List.nil)

    // Induction
    forall(head: T, tail: List<T>) {
        if f(tail) {
            tail.unique.unique = tail.unique

            if tail.contains(head) {
                tail.unique.contains(head)
                // Definition of unique and induction assumption
                List.cons(head, tail).unique.unique = List.cons(head, tail).unique
            } else {
                not tail.unique.contains(head)
                // Head is not in tail, so added to end (definition)
                List.cons(head, tail).unique.unique = List.cons(head, tail).unique
            }

            List.cons(head, tail).unique = List.cons(head, tail).unique.unique
            f(List.cons(head, tail))
        }
    }
}

theorem unique_list_is_unique<T>(list: List<T>) {
    list.unique.is_unique
}

theorem unique_implies_tail_unique<T>(head: T, tail: List<T>) {
    List.cons(head, tail).is_unique implies tail.is_unique
} by {
    if tail.contains(head) {
        List.cons(head, tail).unique = tail.unique
        tail.length < List.cons(head, tail).length

        not List.cons(head, tail).is_unique
    } else {
        List.cons(head, tail).unique = List.cons(head, tail.unique)
    }
}

attributes List<T> {
    define count(self, item: T) -> Nat {
        match self {
            List.nil<T> {
                Nat.0
            }
            List.cons(head, tail) {
                if head = item {
                    1 + tail.count(item)
                } else {
                    tail.count(item)
                }
            }
        }
    }
}

theorem list_contains_implies_count_geq_one<T>(list: List<T>, item: T) {
    list.contains(item) implies list.count(item) >= Nat.1
} by {
    define p(l: List<T>, x: T) -> Bool {
        l.contains(x) implies l.count(x) >= Nat.1
    }

    // Base case: empty list
    p(List.nil<T>, item)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail, item) {
            if List.cons(head, tail).contains(item) {
                if head = item {
                    List.cons(head, tail).count(item) = 1 + tail.count(item)
                    List.cons(head, tail).count(item) >= Nat.1
                } else {
                    tail.count(item) >= Nat.1
                    List.cons(head, tail).count(item) = tail.count(item)
                    List.cons(head, tail).count(item) >= Nat.1
                }
                p(List.cons(head, tail), item)
            }
        }
    }

    List.induction(function (l: List<T>) {
        p(l, item)
    })
}

theorem list_not_contains_impl_count_zero<T>(list: List<T>, item: T) {
    not list.contains(item) implies list.count(item) = Nat.0
} by {
    define p(l: List<T>, x: T) -> Bool {
        not l.contains(x) implies l.count(x) = Nat.0
    }

    // Base case: empty list
    p(List.nil<T>, item)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail, item) {
            if not List.cons(head, tail).contains(item) {
                List.cons(head, tail).count(item) = tail.count(item)
                tail.count(item) = Nat.0
                p(List.cons(head, tail), item)
            }

            p(List.cons(head, tail), item)
        }
    }

    List.induction(function (l: List<T>) {
        p(l, item)
    })

    p(list, item)
}

theorem unique_implies_no_duplicate<T>(list: List<T>, item: T) {
    list.is_unique implies list.count(item) <= Nat.1
} by {
    define p(l: List<T>, x: T) -> Bool {
        l.is_unique implies l.count(x) <= Nat.1
    }

    // Base case: empty list
    p(List.nil<T>, item)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail, item) {
            if List.cons(head, tail).is_unique {
                List.cons(head, tail).unique = List.cons(head, tail)
                if tail.contains(head) {
                    List.cons(head, tail).length = tail.unique.length
                    false
                } 
                not tail.contains(head)
                if head = item {
                    List.cons(head, tail).count(item) = 1 + tail.count(item)
                    tail.count(item) = 0
                    List.cons(head, tail).count(item) <= 1
                } else {
                    List.cons(head, tail).count(item) = tail.count(item)
                    List.cons(head, tail).count(item) <= 1
                }
                List.cons(head, tail).count(item) <= 1
                p(List.cons(head, tail), item)
            }
            p(List.cons(head, tail), item)
        }
    }

    List.induction(function (l: List<T>) {
        p(l, item)
    })
}

theorem unique_len_smaller_implies_duplicate<T>(list: List<T>) {
    list.unique.length < list.length implies exists(x: T) {
        list.count(x) > 1
    }
} by {
    define p(l: List<T>) -> Bool {
        l.unique.length < l.length implies exists(x: T) {
            l.count(x) > 1
        }
    }

    // Base case: empty list
    p(List.nil<T>)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail) {
            if List.cons(head, tail).unique.length < List.cons(head, tail).length {
                if tail.unique.length < tail.length {
                    // x is in tail, use hypothesis
                    let x: T satisfy {
                        tail.count(x) > 1
                    }

                    if head = x {
                        List.cons(head, tail).count(x) = 1 + tail.count(x)
                        List.cons(head, tail).count(x) >= tail.count(x)
                    } else {
                        List.cons(head, tail).count(x) = tail.count(x)
                    }
                    List.cons(head, tail).count(x) >= tail.count(x)

                    p(List.cons(head, tail))
                } else {
                    // x is not in tail so head must be the duplicate
                    tail.contains(head)
                    tail.count(head) >= 1
                    List.cons(head, tail).count(head) = 1 + tail.count(head)
                    List.cons(head, tail).count(head) > 1

                    p(List.cons(head, tail))
                }

                p(List.cons(head, tail))
            }

            p(List.cons(head, tail))
        }
    }

    List.induction(function (l: List<T>) {
        p(l)
    })
}

theorem cons_duplicate_inequality<T>(tail: List<T>, head: T, x: T, n: Nat) {
    tail.count(x) >= n implies List.cons(head, tail).count(x) >= n
} by {
    if tail.count(x) >= n {
        if head = x {
            List.cons(head, tail).count(x) = 1 + tail.count(x)
            List.cons(head, tail).count(x) >= tail.count(x)
        } else {
            List.cons(head, tail).count(x) = tail.count(x)
        }
        List.cons(head, tail).count(x) >= n
    }
}

theorem not_unique_implies_duplicate<T>(list: List<T>) {
    not list.is_unique implies exists(x: T) {
        list.count(x) > 1
    }
} by {
    define p(l: List<T>) -> Bool {
        not l.is_unique implies exists(x: T) {
            l.count(x) > 1
        }
    }

    // Base case: empty list
    p(List.nil<T>)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail) {
            if not List.cons(head, tail).is_unique {
                if not tail.is_unique {
                    let x: T satisfy {
                        tail.count(x) > 1
                    }
                    if x = head {
                        List.cons(head, tail).count(x) = 1 + tail.count(x)
                    } else {
                        List.cons(head, tail).count(x) = tail.count(x)
                    }
                    List.cons(head, tail).count(x) >= tail.count(x)
                    List.cons(head, tail).count(x) > 1

                    p(List.cons(head, tail))
                } else {
                    // If tail is unique, then head must be the duplicate
                    tail.is_unique

                    tail.contains(head)
                    tail.count(head) = 1
                    List.cons(head, tail).count(head) > 1

                    p(List.cons(head, tail))
                }
                p(List.cons(head, tail))
            }

            p(List.cons(head, tail))
        }
    }
}

attributes List<T> {
    /// Appends a single element to the end of the list.
    define append(self, item: T) -> List<T> {
        self + List.singleton(item)
    }
}

attributes Nat {
    /// Creates a list of natural numbers from 0 to n-1.
    define range(self) -> List<Nat> {
        match self {
            Nat.0 {
                List.nil<Nat>
            }
            Nat.suc(n) {
                n.range.append(n)
            }
        }
    }
}

attributes List<T> {
    /// Alternate name for `Nat.range`.
    /// Creates a list of natural numbers from 0 to n-1.
    let range: Nat -> List<Nat> = Nat.range

    /// Filters the list, keeping only elements that satisfy the given predicate.
    define filter(self, f: T -> Bool) -> List<T> {
        match self {
            List.nil {
                List.nil<T>
            }
            List.cons(head, tail) {
                if f(head) {
                    List.cons(head, tail.filter(f))
                } else {
                    tail.filter(f)
                }
            }
        }
    }

    /// Remove all instances of an element from the list.
    // XXX: Todo, prove that this matches filter in the expected case
    define remove_elem(self, elem: T) -> List<T> {
        match self {
            List.nil {
                List.nil<T>
            }
            List.cons(head, tail) {
                if head != elem {
                    List.cons(head, tail.remove_elem(elem))
                } else {
                    tail.remove_elem(elem)
                }
            }
        }
    }
}

// Filter theorems (kinda ugly, but alas)
theorem filter_only_removes_elems<T>(list: List<T>, f: T -> Bool) {
    list.filter(f).length <= list.length
} by {
    define p(l: List<T>) -> Bool {
        l.filter(f).length <= l.length
    }

    // Base case: empty list
    p(List.nil<T>)
    forall(head: T, tail: List<T>) {
        if p(tail) {
            // Induction hypothesis: tail.filter(f).length <= tail.length
            if f(head) {
                List.cons(head, tail).filter(f).length <= List.cons(head, tail).length
            } else {
                List.cons(head, tail).filter(f).length <= List.cons(head, tail).length
            }
            p(List.cons(head, tail))
        }
    }
}

theorem filter_contains_and<T>(list: List<T>, f: T -> Bool, item: T) {
    (list.contains(item) and f(item)) implies list.filter(f).contains(item)
} by {
    define p(l: List<T>, x: T) -> Bool {
        l.contains(x) and f(x) implies l.filter(f).contains(x)
    }

    // Base case: empty list
    p(List.nil<T>, item)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail, item) {
            if tail.contains(item) {
                tail.filter(f).contains(item)
                if f(head) {
                    List.cons(head, tail).filter(f) = List.cons(head, tail.filter(f))
                    List.cons(head, tail).filter(f).contains(item)
                } else {
                    List.cons(head, tail).filter(f) = tail.filter(f)
                    List.cons(head, tail).filter(f).contains(item)
                }
            } else {
                not tail.contains(item)
                if head = item {
                    List.cons(head, tail).filter(f) = List.cons(head, tail.filter(f))
                    List.cons(head, tail).filter(f).contains(item)
                }
            }
            p(List.cons(head, tail), item)
        }
    }

    List.induction(function (l: List<T>) {
        p(l, item)
    })
}

theorem filter_contained_by_and<T>(list: List<T>, f: T -> Bool, item: T) {
    list.filter(f).contains(item) implies (list.contains(item) and f(item))
} by {
    define p(l: List<T>, x: T) -> Bool {
        l.filter(f).contains(x) implies (l.contains(x) and f(x))
    }

    // Base case: empty list
    p(List.nil<T>, item)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail, item) {
            if List.cons(head, tail).filter(f).contains(item) {
                // If the filter contains the item then item must either
                // be in tail or head
                if tail.filter(f).contains(item) {
                    // `and` phrase here is needed to help prover
                    f(item) and List.cons(head, tail).contains(item)
                } else {
                    f(head)
                    head = item
                    f(item) and List.cons(head, tail).contains(item)
                }
                f(item) and List.cons(head, tail).contains(item)
            }
            List.cons(head, tail).filter(f).contains(item) implies (List.cons(head, tail).contains(item) and f(item))
            p(List.cons(head, tail), item)
        }
    }

    List.induction(function (l: List<T>) {
        p(l, item)
    })
}

theorem filter_equivalent_to_and<T>(list: List<T>, f: T -> Bool, item: T) {
    (list.contains(item) and f(item)) = list.filter(f).contains(item)
} by {
    list.filter(f).contains(item) implies (list.contains(item) and f(item))
    (list.contains(item) and f(item)) implies list.filter(f).contains(item)
}

// Length theorems
theorem length_range(n: Nat) {
    n.range.length = n
} by {
    // Induction on n
    define f(x: Nat) -> Bool {
        x.range.length = x
    }

    // Base case: 0.range.length = 0
    0.range = List.nil<Nat>
    List.nil<Nat>.length = Nat.0
    f(0)

    // Inductive step
    forall(x: Nat) {
        if f(x) {
            // Induction hypothesis: x.range.length = x
            x.suc.range = x.suc.range
            x.suc.range = x.range.append(x)
            x.suc.range = x.range + List.singleton(x)

            // Use add_length theorem
            x.range.length + List.singleton(x).length = (x.range + List.singleton(x)).length
            x.range.length + List.singleton(x).length = x.suc.range.length

            // Simplify the left side
            x.range.length = x
            List.singleton(x).length = Nat.1
            x + Nat.1 = x.suc
            x + List.singleton(x).length = x.suc
            x.range.length + List.singleton(x).length = x.suc

            // Therefore
            x.suc.range.length = x.suc
            f(x.suc)
        }
    }

    // Conclusion
    f(n)
}

// If a list does not contain an element, removing it does not change the list.
theorem remove_element_not_in_list<T>(list: List<T>, item: T) {
    not list.contains(item) implies list.remove_elem(item) = list
} by {
    define p(l: List<T>, x: T) -> Bool {
        not l.contains(x) implies l.remove_elem(x) = l
    }

    // Base case: empty list
    p(List.nil<T>, item)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail, item) {
            if not List.cons(head, tail).contains(item) {
                head != item
                not tail.contains(item)
                List.cons(head, tail).remove_elem(item) = List.cons(head, tail)
            }
            p(List.cons(head, tail), item)
        }
    }

    List.induction(function (l: List<T>) {
        p(l, item)
    })
}

// Calling `remove_element(item)` on a list containing `item` actually does
// remove all instances of the element.
theorem remove_element_removes_element<T>(list: List<T>, item: T) {
    list.contains(item) implies not list.remove_elem(item).contains(item)
} by {
    define p(l: List<T>, x: T) -> Bool {
        l.contains(x) implies not l.remove_elem(x).contains(x)
    }

    // Base case: empty list
    p(List.nil<T>, item)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail, item) {
            let cons_list = List.cons(head, tail)
            if cons_list.contains(item) {
                // If the cons list contains the item, then it must be in either head or tail
                if head = item {
                    cons_list.remove_elem(item) = tail.remove_elem(item)
                    not cons_list.remove_elem(item).contains(item)
                } else {
                    cons_list.remove_elem(item) = List.cons(head, tail.remove_elem(item))
                    not tail.remove_elem(item).contains(item)
                    not cons_list.remove_elem(item).contains(item)
                }
                not cons_list.remove_elem(item).contains(item)

            } 
            p(List.cons(head, tail), item)
        }
    }

    List.induction(function (l: List<T>) {
        p(l, item)
    })
}

// Removing an element from a list does not affect the presence of other elements.
theorem remove_element_removes_no_other_elements<T>(list: List<T>, removed_item: T, elem: T) {
    removed_item != elem implies list.remove_elem(removed_item).contains(elem) = list.contains(elem)
} by {
    define p(l: List<T>, r: T, e: T) -> Bool {
        r != e implies l.remove_elem(r).contains(e) = l.contains(e)
    }

    // Base case: empty list
    p(List.nil<T>, removed_item, elem)

    // Induction
    forall(head: T, tail: List<T>) {
        let cons_list = List.cons(head, tail)
        if p(tail, removed_item, elem) {
            // Hypothesis
            if removed_item != elem {
                // If we don't remove anything, then trivial
                if not cons_list.contains(removed_item) {
                    p(cons_list, removed_item, elem)
                }

                // If the removed item is contained, it is either in head or tail
                // If head, then cons_list.remove_elem(removed_item) = tail.remove_elem(removed_item)
                if head = removed_item {
                    cons_list.remove_elem(removed_item) = tail.remove_elem(removed_item)
                    tail.remove_elem(removed_item).contains(elem) = tail.contains(elem)
                    cons_list.contains(elem) = tail.contains(elem)
                    cons_list.remove_elem(removed_item).contains(elem) = cons_list.contains(elem)

                    p(cons_list, removed_item, elem)
                } else {
                    // If the removed item is in tail then induction takes care of the rest
                    cons_list.remove_elem(removed_item).contains(elem) = (head = elem) or tail.remove_elem(removed_item).contains(elem)

                    if head = elem {
                        cons_list.remove_elem(removed_item).contains(elem)
                        cons_list.contains(elem)

                        p(cons_list, removed_item, elem)
                    } else {
                        tail.remove_elem(removed_item).contains(elem) = tail.contains(elem)
                        cons_list.contains(elem) = tail.contains(elem)
                        cons_list.remove_elem(removed_item).contains(elem) = tail.remove_elem(removed_item).contains(elem)

                        p(cons_list, removed_item, elem)
                    }

                    cons_list.remove_elem(removed_item).contains(elem) = cons_list.contains(elem)
                    p(cons_list, removed_item, elem)
                }
            }
            p(cons_list, removed_item, elem)
            p(List.cons(head, tail), removed_item, elem)
        }
    }

    List.induction(function (l: List<T>) {
        p(l, removed_item, elem)
    })

    p(list, removed_item, elem)

}

// Removing an element contained in a list results in a `.unique` list with one fewer element.
// Statement is list.unique.remove_elem(item).length + Nat.1 = list.unique.length rather than
// list.unique.remove_elem(item).length = list.unique.length - Nat.1 because cancellation laws
// don't work if list.unique.length = Nat.0.
theorem remove_element_in_unique_equals_length_minus_one<T>(list: List<T>, item: T) {
    list.contains(item) implies list.unique.remove_elem(item).length + Nat.1 = list.unique.length
} by {
    define p(l: List<T>) -> Bool {
        l.contains(item) implies l.unique.remove_elem(item).length + Nat.1 = l.unique.length
    }

    // Base case: empty list, does not contain any item
    p(List.nil<T>)

    // Induction
    forall(head: T, tail: List<T>) {
        if p(tail) {
            if List.cons(head, tail).contains(item) {
                // Either head is a duplicate or not
                if tail.contains(head) {
                    // If it's a duplicate, we can safely ignore it and the induction hypothesis
                    // carries us through
                    List.cons(head, tail).unique = tail.unique

                    List.cons(head, tail).unique.remove_elem(item).length + Nat.1 = List.cons(head, tail).unique.length
                } else {
                    // If it is not a duplicate, then either the item is head or in tail.unique
                    List.cons(head, tail).unique = List.cons(head, tail.unique)
                    if head = item {
                        // If the item is in head, it's not in tail.unique, and it will be one removed
                        not tail.contains(item)

                        // Prover help: item is head, remove
                        List.cons(head, tail).unique.remove_elem(item) = tail.unique

                        List.cons(head, tail).unique.remove_elem(item).length + Nat.1 = List.cons(head, tail).unique.length
                    } else {
                        // If it's in tail then we're done by induction hypothesis
                        tail.contains(item)

                        // Prover help: item is in tail
                        List.cons(head, tail).unique.remove_elem(item) = List.cons(head, tail.unique.remove_elem(item))

                        List.cons(head, tail).unique.remove_elem(item).length + Nat.1 = List.cons(head, tail).unique.length
                    }
                }
            }
            p(List.cons(head, tail))
        }
    }
}

theorem unique_comm_remove_elem<T>(list: List<T>, elem: T) {
    list.remove_elem(elem).unique = list.unique.remove_elem(elem)
} by {
    define p(l: List<T>, e: T) -> Bool {
        l.remove_elem(e).unique = l.unique.remove_elem(e)
    }

    // Base case: empty list
    p(List.nil<T>, elem)

    forall(head: T, tail: List<T>) {
        if p(tail, elem) {
            if head = elem {
                // If elem is head, easy
                List.cons(head, tail).unique.remove_elem(elem) = tail.unique.remove_elem(elem)
                List.cons(head, tail).remove_elem(elem) = tail.remove_elem(elem)

                p(List.cons(head, tail), elem)
            } else {
                // If not, then either elem is in tail or not
                List.cons(head, tail).remove_elem(elem).unique = List.cons(head, tail.remove_elem(elem)).unique
                // Now, either head is in tail or not
                if tail.contains(head) {
                    // If head is in tail, then tail.unique carries us through
                    p(List.cons(head, tail), elem)
                } else {
                    // Otherwise, head is not in tail and elem is not head so unique and remove contains head
                    p(List.cons(head, tail), elem)
                }

                p(List.cons(head, tail), elem)
            }

            p(List.cons(head, tail), elem)
        }
    }

    List.induction(function (l: List<T>) {
        p(l, elem)
    })

    p(list, elem)
}

// And the big one: the smallest (by `.length`) list containing all elements of
// a list is its `.unique`. This now enables us to talk about "cardinality" of a
// set as being unique via `.filter(set.contains).unique` or, by the previous
// theorem, via `.unique.filter(set.contains)`.
theorem unique_is_smallest_containing_list<T>(list: List<T>, container: List<T>) {
    forall(x: T) {
        list.contains(x) implies container.contains(x)
    } implies list.unique.length <= container.length
} by {
    // Simple helper functions here
    define is_contained(a: T -> Bool, b: T -> Bool) -> Bool {
        forall(x: T) {
            a(x) implies b(x)
        }
    }

    define pc(x: List<T>, c: List<T>) -> Bool {
        is_contained(x.contains, c.contains) implies x.unique.length <= c.unique.length
    }

    define p(x: List<T>) -> Bool {
        forall(c: List<T>) {
            pc(x, c)
        }
    }

    p(List.nil<T>)

    forall(head: T, tail: List<T>) {
        if p(tail) {
            forall(c: List<T>) {
                if is_contained(List.cons(head, tail).contains, c.contains) {
                    // Either head is in tail or not
                    if tail.contains(head) {
                        c.contains(head)
                        List.cons(head, tail).unique = tail.unique
                        List.cons(head, tail).unique.length = tail.unique.length

                        // Hypothesis
                        is_contained(tail.contains, c.contains)
                        tail.unique.length <= c.unique.length
                        
                        pc(List.cons(head, tail), c)
                    } else {
                        // Head is not in the tail, so gets added
                        c.contains(head)
                        List.cons(head, tail).unique = List.cons(head, tail.unique)
                        List.cons(head, tail).unique.length = tail.unique.length + Nat.1

                        // Remove one from the container
                        c.unique.remove_elem(head).length + Nat.1 = c.unique.length
                        tail.remove_elem(head) = tail
                        
                        // Prove that tail.contains(x) implies c.remove_elem(head).contains(x)
                        forall(x: T) {
                            if x != head {
                                tail.contains(x) implies c.remove_elem(head).contains(x)
                            } else {
                                not tail.contains(x)
                                not c.remove_elem(head).contains(x)
                            }
                            
                            tail.contains(x) implies c.remove_elem(head).contains(x)
                        }
                        is_contained(tail.contains, c.remove_elem(head).contains)

                        // Given this, we know know that adding head to both should give result
                        pc(tail, c.remove_elem(head))
                        tail.unique.length <= c.remove_elem(head).unique.length
                        List.cons(head, tail).unique.length = tail.unique.length + Nat.1
                        c.remove_elem(head).unique.length + Nat.1 = c.unique.length
                        
                        tail.unique.length + Nat.1 <= c.remove_elem(head).unique.length + Nat.1
                        List.cons(head, tail).unique.length <= c.unique.length
                    }

                    pc(List.cons(head, tail), c)
                }

                // Prover help
                forall(c: List<T>) {
                    pc(List.cons(head, tail), c)
                }
                p(List.cons(head, tail))
            }
        }
    }

    List.induction(function (l: List<T>) {
        p(l)
    })

    pc(list, container)
}


/// Applies a function to each element of a list, creating a new list of results.
define map<T, U>(items: List<T>, f: T -> U) -> List<U> {
    match items {
        List.nil {
            List.nil<U>
        }
        List.cons(head, tail) {
            List.cons(f(head), map(tail, f))
        }
    }
}


from add_comm_monoid import AddCommMonoid

/// Computes the sum of all elements in a list (requires elements to form an additive commutative monoid).
define sum<A: AddCommMonoid>(items: List<A>) -> A {
    match items {
        List.nil {
            A.0
        }
        List.cons(head, tail) {
            head + sum(tail)
        }
    }
}

/// Computes the partial sum of a series up to index n.
/// Returns the sum of f(0) + f(1) + ... + f(n-1).
define partial<A: AddCommMonoid>(f: Nat -> A, n: Nat) -> A {
    sum(map(n.range, f))
}

theorem sum_add<A: AddCommMonoid>(left: List<A>, right: List<A>) {
    sum(left + right) = sum(left) + sum(right)
} by {
    define p(x: List<A>) -> Bool {
        sum(x + right) = sum(x) + sum(right)
    }

    // Base case: sum(nil + right) = sum(nil) + sum(right)
    sum(List.nil<A> + right) = sum(right)
    sum(List.nil<A>) = A.0
    A.0 + sum(right) = sum(right)
    p(List.nil)

    // Inductive step
    forall(head: A, tail: List<A>) {
        if p(tail) {
            // Induction hypothesis: sum(tail + right) = sum(tail) + sum(right)

            // Left side: sum(List.cons(head, tail) + right)
            sum(List.cons(head, tail) + right) = sum(List.cons(head, tail + right))
            sum(List.cons(head, tail + right)) = head + sum(tail + right)

            // Use induction hypothesis
            head + sum(tail + right) = head + (sum(tail) + sum(right))

            // Right side: sum(List.cons(head, tail)) + sum(right)
            sum(List.cons(head, tail)) = head + sum(tail)
            sum(List.cons(head, tail)) + sum(right) = (head + sum(tail)) + sum(right)

            // Use associativity
            (head + sum(tail)) + sum(right) = head + (sum(tail) + sum(right))

            // Therefore
            sum(List.cons(head, tail) + right) = sum(List.cons(head, tail)) + sum(right)
            p(List.cons(head, tail))
        }
    }
}

theorem map_add<T, U>(left: List<T>, right: List<T>, f: T -> U) {
    map(left + right, f) = map(left, f) + map(right, f)
} by {
    define p(x: List<T>) -> Bool {
        map(x + right, f) = map(x, f) + map(right, f)
    }

    // Base case: map(nil + right, f) = map(nil, f) + map(right, f)
    map(List.nil<T> + right, f) = map(right, f)
    map(List.nil<T>, f) = List.nil<U>
    List.nil<U> + map(right, f) = map(right, f)
    p(List.nil)

    // Inductive step

    forall(head: T, tail: List<T>) {
        if p(tail) {
            // Induction hypothesis: map(tail + right, f) = map(tail, f) + map(right, f)

            // Left side: map(List.cons(head, tail) + right, f)
            map(List.cons(head, tail) + right, f) = map(List.cons(head, tail + right), f)
            map(List.cons(head, tail + right), f) = List.cons(f(head), map(tail + right, f))

            // Use induction hypothesis
            List.cons(f(head), map(tail + right, f)) = List.cons(f(head), map(tail, f) + map(right, f))

            // Right side: map(List.cons(head, tail), f) + map(right, f)
            map(List.cons(head, tail), f) = List.cons(f(head), map(tail, f))
            map(List.cons(head, tail), f) + map(right, f) = List.cons(f(head), map(tail, f)) + map(right, f)
            List.cons(f(head), map(tail, f)) + map(right, f) = List.cons(f(head), map(tail, f) + map(right, f))

            // Therefore
            map(List.cons(head, tail) + right, f) = map(List.cons(head, tail), f) + map(right, f)
            p(List.cons(head, tail))
        }
    }
}

theorem map_append<T, U>(initial: List<T>, last: T, f: T -> U) {
    map(initial.append(last), f) = map(initial, f).append(f(last))
}

theorem sum_append<A: AddCommMonoid>(initial: List<A>, last: A) {
    sum(initial.append(last)) = sum(initial) + last
}

theorem add_assoc<T>(a: List<T>, b: List<T>, c: List<T>) {
    (a + b) + c = a + (b + c)
} by {
    define p(x: List<T>) -> Bool {
        (x + b) + c = x + (b + c)
    }

    // Base case: (nil + b) + c = nil + (b + c)
    (List.nil<T> + b) + c = b + c
    List.nil<T> + (b + c) = b + c
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List<T>) {
        if p(tail) {
            // Induction hypothesis: (tail + b) + c = tail + (b + c)

            // Left side: (List.cons(head, tail) + b) + c
            (List.cons(head, tail) + b) + c = List.cons(head, tail + b) + c
            List.cons(head, tail + b) + c = List.cons(head, (tail + b) + c)

            // Use induction hypothesis
            List.cons(head, (tail + b) + c) = List.cons(head, tail + (b + c))

            // Right side: List.cons(head, tail) + (b + c)
            List.cons(head, tail) + (b + c) = List.cons(head, tail + (b + c))

            // Therefore
            (List.cons(head, tail) + b) + c = List.cons(head, tail) + (b + c)
            p(List.cons(head, tail))
        }
    }
}

theorem map_singleton<T, U>(f: T -> U, x: T) {
    map(List.singleton(x), f) = List.singleton(f(x))
}

theorem length_zero_imp_nil<T>(list: List<T>) {
    list.length = Nat.0 implies list = List.nil<T>
}

theorem add_to_nil<T>(a: List<T>, b: List<T>) {
    a + b = List.nil<T> implies a = List.nil<T> and b = List.nil<T>
}

theorem append_not_nil<T>(a: List<T>, t: T) {
    a.append(t) != List.nil<T>
}

from util import compose

theorem map_map<T, U, V>(items: List<T>, f: T -> U, g: U -> V) {
    map(map(items, f), g) = map(items, compose(g, f))
} by {
    define p(x: List<T>) -> Bool {
        map(map(x, f), g) = map(x, compose(g, f))
    }

    // Base case
    map(map(List.nil<T>, f), g) = map(List.nil<U>, g)
    map(List.nil<U>, g) = List.nil<V>
    map(List.nil<T>, compose(g, f)) = List.nil<V>
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List<T>) {
        if p(tail) {
            // Left side
            map(map(List.cons(head, tail), f), g) = map(List.cons(f(head), map(tail, f)), g)
            map(List.cons(f(head), map(tail, f)), g) = List.cons(g(f(head)), map(map(tail, f), g))

            // Use induction hypothesis
            map(map(tail, f), g) = map(tail, compose(g, f))

            // Right side
            map(List.cons(head, tail), compose(g, f)) = List.cons(compose(g, f)(head), map(tail, compose(g, f)))
            List.cons(compose(g, f)(head), map(tail, compose(g, f))) = List.cons(g(f(head)), map(tail, compose(g, f)))

            // Therefore
            map(map(List.cons(head, tail), f), g) = map(List.cons(head, tail), compose(g, f))
            p(List.cons(head, tail))
        }
    }
}

theorem map_length<T, U>(list: List<T>, f: T -> U) {
    map(list, f).length = list.length
} by {
    define p(x: List<T>) -> Bool {
        map(x, f).length = x.length
    }

    // Base case
    p(List.nil<T>)

    // Inductive step
    forall(head: T, tail: List<T>) {
        if p(tail) {
            map(List.cons(head, tail), f).length = List.cons(head, tail).length
        }
    }

    p(list)
}

theorem map_contains<T, U>(list: List<T>, f: T -> U, item: U) {
    map(list, f).contains(item) implies exists(x: T) {
        list.contains(x) and f(x) = item
    }
} by {
    define p(x: List<T>) -> Bool {
        map(x, f).contains(item) implies exists(y: T) {
            x.contains(y) and f(y) = item
        }
    }

    // Base case
    p(List.nil<T>)

    // Inductive step
    forall(head: T, tail: List<T>) {
        if p(tail) {
            if map(List.cons(head, tail), f).contains(item) {
                // If the map contains the item, it must be from either head or tail
                if map(tail, f).contains(item) {
                    // If tail contains the item, then we can use the induction hypothesis
                    p(List.cons(head, tail))
                } else {
                    // If head is the source of the item
                    f(head) = item
                    exists(y: T) {
                        y = head and List.cons(head, tail).contains(y)
                    }
                    p(List.cons(head, tail))
                }
                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l: List<T>) {
        p(l)
    })
}

theorem pigeonhole_unique_map<T, U>(items: List<T>, f: T -> U) {
    items.is_unique and not map(items, f).is_unique implies
    exists(x: T, y: T) {
        x != y and f(x) = f(y)
    }
} by {
    define p(l: List<T>) -> Bool {
        l.is_unique and not map(l, f).is_unique implies
        exists(a: T, b: T) {
            a != b and f(a) = f(b)
        }
    }

    define has_duplicate(list: List<U>) -> Bool {
        exists(y: U) {
            list.count(y) > 1
        }
    }

    // Base case: empty list
    p(List.nil<T>)

    // Inductive step
    forall(head: T, tail: List<T>) {
        if p(tail) {
            if List.cons(head, tail).is_unique and not map(List.cons(head, tail), f).is_unique {
                let tail_map = map(tail, f)
                // Either tail already has duplicate or not
                if has_duplicate(tail_map) {
                    not tail_map.is_unique
                    not map(tail, f).is_unique

                    if not tail.is_unique {
                        let x: T satisfy {
                            tail.count(x) > 1
                        }
                        List.cons(head, tail).count(x) >= tail.count(x)
                        not List.cons(head, tail).is_unique
                        false
                    }
                    
                    tail.is_unique

                    let (a: T, b: T) satisfy {
                        a != b and f(a) = f(b)
                    }

                    p(List.cons(head, tail))
                } else {
                    // If tail_map does not have a duplicate, f(head) is the
                    // duplicate
                    let dup = f(head)

                    tail_map.is_unique
                    tail_map.contains(dup)
                    tail_map.count(dup) = 1
                    not tail.contains(head)
                    let x: T satisfy {
                        tail.contains(x) and f(x) = dup
                    }

                    map(List.cons(head, tail), f).count(dup) = 1 + tail_map.count(dup)
                    map(List.cons(head, tail), f).count(dup) > 1

                    f(head) = f(x)
                    head != x

                    p(List.cons(head, tail))
                }

                p(List.cons(head, tail))
            }
            p(List.cons(head, tail))
        }
    }
}

theorem pigeonhole_map<U, T>(items: List<T>, f: T -> U) {
    items.is_unique and items.length > map(items, f).unique.length implies
    exists(x: T, y: T) {
        x != y and f(x) = f(y)
    }
} by {
    items.length = map(items, f).length
    map(items, f).unique.length < map(items, f).length
    not map(items, f).is_unique
}

attributes List<T> {
    /// Yields the list without its first element.
    /// Yields nil for an empty list.
    define tail(self) -> List<T> {
        match self {
            List.nil {
                List.nil<T>
            }
            List.cons(h, t) {
                t
            }
        }
    }

    /// Removes the first n elements from the list.
    define drop(self, n: Nat) -> List<T> {
        match n {
            Nat.0 {
                self
            }
            Nat.suc(pred) {
                self.tail.drop(pred)
            }
        }
    }
}

theorem tail_cancels_cons<T>(a: T, b: List<T>) {
    List.cons(a, b).tail = b
}

theorem drop_zero<T>(a: List<T>) {
    a.drop(Nat.0) = a
}

theorem drop_one<T>(a: List<T>) {
    a.drop(Nat.1) = a.tail
}

theorem drop_cancels_add<T>(a: List<T>, b: List<T>) {
    (a + b).drop(a.length) = b
} by {
    define p(x: List<T>) -> Bool {
        (x + b).drop(x.length) = b
    }

    // Base case
    (List.nil<T> + b).drop(List.nil<T>.length) = b.drop(Nat.0)
    b.drop(Nat.0) = b
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List<T>) {
        if p(tail) {
            // Induction hypothesis: (tail + b).drop(tail.length) = b

            // Left side
            (List.cons(head, tail) + b).drop(List.cons(head, tail).length) = (List.cons(head, tail + b)).drop(tail.length.suc)
            (List.cons(head, tail + b)).drop(tail.length.suc) = (tail + b).drop(tail.length)

            // Use induction hypothesis
            (tail + b).drop(tail.length) = b

            // Therefore
            p(List.cons(head, tail))
        }
    }
}

theorem drop_twice<T>(a: List<T>, m: Nat, n: Nat) {
    a.drop(m).drop(n) = a.drop(m + n)
} by {
    define f(x: Nat) -> Bool {
        forall(l: List<T>, k: Nat) {
            l.drop(x).drop(k) = l.drop(x + k)
        }
    }

    Nat.induction(f)

    forall(l: List<T>, k: Nat) {
        l.drop(Nat.0) = l
        drop_zero(l)
        l.drop(Nat.0).drop(k) = l.drop(k)
        Nat.0 + k = k
        l.drop(Nat.0 + k) = l.drop(k)
    }
    f(Nat.0)

    forall(x: Nat) {
        if f(x) {
            forall(l: List<T>, k: Nat) {
                // Induction hypothesis: l.drop(x).drop(k) = l.drop(x + k)
                l.drop(x.suc).drop(k) = l.tail.drop(x).drop(k)
                f(x)
                l.tail.drop(x).drop(k) = l.tail.drop(x + k)
                x.suc + k = (x + k).suc
                l.drop(x.suc + k) = l.drop((x + k).suc)
                l.drop((x + k).suc) = l.tail.drop(x + k)
                l.drop(x.suc).drop(k) = l.drop(x.suc + k)
            }
            f(x.suc)
        }
    }

    f(m)
}

attributes List<T> {
    /// Removes the last n elements from the list.
    define drop_last(self, n: Nat) -> List<T> {
        match self {
            List.nil {
                List.nil<T>
            }
            List.cons(head, tail) {
                if tail.length < n {
                    List.nil<T>
                } else {
                    List.cons(head, tail.drop_last(n))
                }
            }
        }
    }
}

theorem drop_last_zero<T>(a: List<T>) {
    a.drop_last(Nat.0) = a
} by {
    define q(x: List<T>) -> Bool {
        x.drop_last(Nat.0) = x
    }
    q(List.nil)
    forall(head: T, tail: List<T>) {
        if q(tail) {
            List.cons(head, tail).drop_last(Nat.0) = List.cons(head, tail.drop_last(Nat.0))
            List.cons(head, tail.drop_last(Nat.0)) = List.cons(head, tail)
            q(List.cons(head, tail))
        }
    }
    q(a)
}

theorem drop_last_all<T>(l: List<T>) {
    l.drop_last(l.length) = List.nil<T>
} by {
    define r(x: List<T>) -> Bool {
        x.drop_last(x.length) = List.nil<T>
    }
    r(List.nil)
    forall(head: T, tail: List<T>) {
        if r(tail) {
            List.cons(head, tail).drop_last(List.cons(head, tail).length) = List.cons(head, tail).drop_last(tail.length.suc)
            List.cons(head, tail).drop_last(tail.length.suc) = List.nil<T>
            r(List.cons(head, tail))
        }
    }
    r(l)
}

theorem drop_last_cancels_add<T>(a: List<T>, b: List<T>) {
    (a + b).drop_last(b.length) = a
} by {
    define p(x: List<T>) -> Bool {
        (x + b).drop_last(b.length) = x
    }
    drop_last_all(b)
    p(List.nil)
    forall(head: T, tail: List<T>) {
        if p(tail) {
            add_length(tail, b)
            let (c: Nat) satisfy { b.length + c = (tail + b).length }
            c = tail.length
            b.length <= (tail + b).length
            (List.cons(head, tail) + b).drop_last(b.length) = List.cons(head, tail + b).drop_last(b.length)
            List.cons(head, tail + b).drop_last(b.length) = List.cons(head, (tail + b).drop_last(b.length))
            p(tail)
            List.cons(head, (tail + b).drop_last(b.length)) = List.cons(head, tail)
            p(List.cons(head, tail))
        }
    }
    p(a)
}

attributes Nat {
    /// Creates a list of natural numbers from self to n-1 (exclusive of n).
    define until(self, n: Nat) -> List<Nat> {
        n.range.drop(self)
    }

    /// Creates a list of natural numbers from self to n (inclusive).
    define upto(self, n: Nat) -> List<Nat> {
        self.until(n.suc)
    }
}

theorem zero_until(n: Nat) {
    Nat.0.until(n) = n.range
} by {
    drop_zero(n.range)
}

theorem until_self(n: Nat) {
    n.until(n) = List.nil<Nat>
} by {
    n.range.length = n
    drop_cancels_add(n.range, List.nil<Nat>)
}

theorem until_suc(n: Nat) {
    n.until(n.suc) = List.singleton(n)
} by {
    n.suc.range = n.range + List.singleton(n)
    n.range.length = n
    drop_cancels_add(n.range, List.singleton(n))
}

theorem zero_upto(n: Nat) {
    Nat.0.upto(n) = n.suc.range
}

theorem upto_self(n: Nat) {
    n.upto(n) = List.singleton(n)
}

theorem range_add_until(a: Nat, b: Nat) {
    a <= b implies a.range + a.until(b) = b.range
} by {
    let (k: Nat) satisfy { a + k = b }

    define f(x: Nat) -> Bool {
        a.range + a.until(a + x) = (a + x).range
    }

    // Base case: x = 0
    until_self(a)
    add_nil(a.range)
    f(Nat.0)

    // Inductive step
    forall(x: Nat) {
        if f(x) {
            // Show a.until(a + x.suc) = a.until(a + x) + List.singleton(a + x)
            a.until(a + x.suc) = (a + x.suc).range.drop(a)
            (a + x.suc).range = (a + x).range + List.singleton(a + x)
            a.until(a + x.suc) = ((a + x).range + List.singleton(a + x)).drop(a)
            f(x)
            (a + x).range = a.range + a.until(a + x)
            a.until(a + x.suc) = (a.range + a.until(a + x) + List.singleton(a + x)).drop(a)
            a.range.length = a
            drop_cancels_add(a.range, a.until(a + x) + List.singleton(a + x))
            a.until(a + x.suc) = a.until(a + x) + List.singleton(a + x)

            // Now show f(x.suc)
            a.range + a.until(a + x.suc) = a.range + (a.until(a + x) + List.singleton(a + x))
            add_assoc(a.range, a.until(a + x), List.singleton(a + x))
            (a.range + a.until(a + x)) + List.singleton(a + x) = (a + x).range + List.singleton(a + x)
            f(x)
            (a + x).range + List.singleton(a + x) = (a + x).suc.range
            f(x.suc)
        }
    }

    f(k)
    a + k = b
}

// Could be generalized to arbitrary functions over a set with 0, not
// necessarily associative as in `add`. `LinearOrder` with smallest element 0
// would similarly work (or with `option`). Technically `Nat`s w/ `max` defines a
// `Monoid`, which would also work w/ definition of `add` above.
define max_list(list: List<Nat>) -> Nat {
    match list {
        List<Nat>.nil {
            0
        }
        List.cons(head, tail) {
            head.max(max_list(tail))
        }
    }
}

theorem list_has_max(list: List<Nat>, n: Nat) {
    max_list(list) <= n implies
    forall(m: Nat) {
        list.contains(m) implies m <= n
    }
} by {
    define f(l: List<Nat>) -> Bool {
        forall(k: Nat) {
            l.contains(k) implies k <= max_list(l)
        }
    }

    forall(head: Nat, tail: List<Nat>) {
        if f(tail) {
            let k = max_list(tail)
            let m: Nat = head.max(k)
            m >= max_list(List.cons(head, tail))
            m >= max_list(tail)
            forall(x: Nat) {
                head = x implies x <= m
                tail.contains(x) implies x <= m

                List.cons(head, tail).contains(x) implies x <= m
            }
            f(List.cons(head, tail))
        }
    }

    f(list)
}

theorem no_list_contains_nat(list: List<Nat>) {
    exists(n: Nat) {
        not list.contains(n)
    }
}