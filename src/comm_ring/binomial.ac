from comm_ring.base import CommRing
from nat import Nat
from nat.nat_combo import choose, pascal
from semiring.from_nat import from_nat
from list import partial
from add_semigroup import add_fn
from semigroup import mul_fn
from util import compose

numerals Nat

/// The binomial theorem for commutative rings.
///
/// This file proves that (a + b)^n equals the sum of binomial terms for elements
/// of a commutative ring, generalizing the binomial theorem from natural numbers.

/// A term in the binomial expansion of (a + b)^n.
/// Represents n.choose(k) * a^k * b^(n-k).
define binomial_term[R: CommRing](a: R, b: R, n: Nat, k: Nat) -> R {
    from_nat[R](n.choose(k)) * a.pow(k) * b.pow(n - k)
}

/// The boundary term at k=0 for the binomial expansion.
theorem binomial_term_zero[R: CommRing](a: R, b: R, m: Nat) {
    binomial_term[R](a, b, m.suc, 0) = b * binomial_term[R](a, b, m, 0)
} by {
    // Expand both sides
    binomial_term[R](a, b, m, 0) = from_nat[R](m.choose(0)) * a.pow(0) * b.pow(m)
    binomial_term[R](a, b, m, 0) = from_nat[R](1) * R.1 * b.pow(m)
    binomial_term[R](a, b, m, 0) = b.pow(m)

    binomial_term[R](a, b, m.suc, 0) = from_nat[R](m.suc.choose(0)) * a.pow(0) * b.pow(m.suc)
    binomial_term[R](a, b, m.suc, 0) = from_nat[R](1) * R.1 * b.pow(m.suc)
    binomial_term[R](a, b, m.suc, 0) = b.pow(m.suc)
    binomial_term[R](a, b, m.suc, 0) = b * b.pow(m)
}

/// The boundary term at k=m+1 for the binomial expansion.
theorem binomial_term_top[R: CommRing](a: R, b: R, m: Nat) {
    binomial_term[R](a, b, m.suc, m.suc) = a * binomial_term[R](a, b, m, m)
} by {
    // Expand both sides
    binomial_term[R](a, b, m, m) = from_nat[R](m.choose(m)) * a.pow(m) * b.pow(0)
    binomial_term[R](a, b, m, m) = from_nat[R](1) * a.pow(m) * R.1
    binomial_term[R](a, b, m, m) = a.pow(m)

    binomial_term[R](a, b, m.suc, m.suc) = from_nat[R](m.suc.choose(m.suc)) * a.pow(m.suc) * b.pow(0)
    binomial_term[R](a, b, m.suc, m.suc) = from_nat[R](1) * a.pow(m.suc) * R.1
    binomial_term[R](a, b, m.suc, m.suc) = a.pow(m.suc)
    binomial_term[R](a, b, m.suc, m.suc) = a * a.pow(m)
}

/// Recursive relation for binomial terms: each term for n+1 equals a times the shifted
/// term for n plus b times the corresponding term for n.
theorem binomial_term_recurrence[R: CommRing](a: R, b: R, m: Nat, k: Nat) {
    0 < k and k <= m implies
    binomial_term[R](a, b, m.suc, k) =
    a * binomial_term[R](a, b, m, k - 1) + b * binomial_term[R](a, b, m, k)
} by {
    // Establish k_pred for k - 1
    let (k_pred: Nat) satisfy { k_pred.suc = k }
    k_pred <= m

    // Expand LHS: binomial_term(a, b, m.suc, k)
    binomial_term[R](a, b, m.suc, k) = from_nat[R](m.suc.choose(k)) * a.pow(k) * b.pow(m.suc - k)

    // Use Pascal's identity
    m.suc.choose(k) = m.choose(k - 1) + m.choose(k)
    from_nat[R](m.suc.choose(k)) = from_nat[R](m.choose(k - 1) + m.choose(k))
    from_nat[R](m.suc.choose(k)) = from_nat[R](m.choose(k - 1)) + from_nat[R](m.choose(k))

    // Distribute
    binomial_term[R](a, b, m.suc, k) = (from_nat[R](m.choose(k - 1)) + from_nat[R](m.choose(k))) * a.pow(k) * b.pow(m.suc - k)
    binomial_term[R](a, b, m.suc, k) = from_nat[R](m.choose(k - 1)) * a.pow(k) * b.pow(m.suc - k) + from_nat[R](m.choose(k)) * a.pow(k) * b.pow(m.suc - k)

    // First term: a * binomial_term(a, b, m, k - 1)
    a.pow(k) = a * a.pow(k_pred)
    m - k_pred + k_pred = m
    m - k_pred + k = m.suc
    m - k_pred = m.suc - k
    from_nat[R](m.choose(k_pred)) * a.pow(k) * b.pow(m.suc - k) = from_nat[R](m.choose(k_pred)) * a * a.pow(k_pred) * b.pow(m - k_pred)
    from_nat[R](m.choose(k_pred)) * a.pow(k) * b.pow(m.suc - k) = a * (from_nat[R](m.choose(k_pred)) * a.pow(k_pred) * b.pow(m - k_pred))

    // Second term: b * binomial_term(a, b, m, k)
    m - k + k = m
    m - k + 1 = (m - k).suc
    (m - k).suc + k = (m - k + k).suc
    m - k + 1 + k = m.suc
    b.pow(m.suc - k) = b.pow(m - k + 1)
    b.pow(m - k + 1) = b * b.pow(m - k)
    from_nat[R](m.choose(k)) * a.pow(k) * b.pow(m.suc - k) = from_nat[R](m.choose(k)) * a.pow(k) * b * b.pow(m - k)
    from_nat[R](m.choose(k)) * a.pow(k) * b.pow(m.suc - k) = b * (from_nat[R](m.choose(k)) * a.pow(k) * b.pow(m - k))
}

/// Alternative form of the binomial term recurrence, avoiding subtraction by using k.suc.
theorem alt_binomial_term_recurrence[R: CommRing](a: R, b: R, m: Nat, k: Nat) {
    k < m implies
    binomial_term[R](a, b, m.suc, k.suc) =
    a * binomial_term[R](a, b, m, k) + b * binomial_term[R](a, b, m, k.suc)
} by {
    // We have k < m, which gives us k.suc <= m and 0 < k.suc
    binomial_term[R](a, b, m.suc, k.suc) = a * binomial_term[R](a, b, m, k.suc - 1) + b * binomial_term[R](a, b, m, k.suc)
}

/// Helper: the middle partial sum splits into two parts using the recurrence.
theorem binomial_middle_sum[R: CommRing](a: R, b: R, m: Nat) {
    partial(compose(binomial_term[R](a, b, m.suc), Nat.suc), m) =
        a * partial(binomial_term[R](a, b, m), m) + b * partial(compose(binomial_term[R](a, b, m), Nat.suc), m)
} by {
    // Define helper functions for clarity
    define f(k: Nat) -> R { binomial_term[R](a, b, m, k) }
    define g(k: Nat) -> R { compose(binomial_term[R](a, b, m), Nat.suc)(k) }
    define h(k: Nat) -> R { compose(binomial_term[R](a, b, m.suc), Nat.suc)(k) }

    // Show pointwise equality: for each k < m, h(k) = a * f(k) + b * g(k)
    forall(k: Nat) {
        if k < m {
            // h(k) = binomial_term(a, b, m.suc, k.suc)
            h(k) = binomial_term[R](a, b, m.suc, k.suc)

            // Use alt_binomial_term_recurrence
            binomial_term[R](a, b, m.suc, k.suc) = a * binomial_term[R](a, b, m, k) + b * binomial_term[R](a, b, m, k.suc)
            h(k) = a * binomial_term[R](a, b, m, k) + b * binomial_term[R](a, b, m, k.suc)

            // Simplify RHS
            h(k) = a * f(k) + b * g(k)
            h(k) = mul_fn(a, f)(k) + mul_fn(b, g)(k)
        }
    }

    // Use partial_pointwise_eq
    partial(h, m) = partial(add_fn(mul_fn(a, f), mul_fn(b, g)), m)

    // Use partial_add to split the sum
    partial(h, m) = partial(mul_fn(a, f), m) + partial(mul_fn(b, g), m)

    // Use partial_scalar_mul to factor out the scalars
    partial(h, m) = a * partial(f, m) + b * partial(g, m)
}

/// Distributing (a + b) across a partial sum of binomial terms gives the next row.
theorem binomial_distribution[R: CommRing](a: R, b: R, m: Nat) {
    (a + b) * partial(binomial_term[R](a, b, m), m.suc) = partial(binomial_term[R](a, b, m.suc), m.suc.suc)
} by {
    // LHS: Expand using distributivity
    (a + b) * partial(binomial_term[R](a, b, m), m.suc) = a * partial(binomial_term[R](a, b, m), m.suc) + b * partial(binomial_term[R](a, b, m), m.suc)

    // RHS: Peel off the last term using partial_split_last
    partial(binomial_term[R](a, b, m.suc), m.suc.suc) = partial(binomial_term[R](a, b, m.suc), m.suc) + binomial_term[R](a, b, m.suc, m.suc)

    // Simplify the last term
    binomial_term[R](a, b, m.suc, m.suc) = a * binomial_term[R](a, b, m, m)

    // Now peel off the first term using partial_shift_suc
    partial(binomial_term[R](a, b, m.suc), m.suc) = binomial_term[R](a, b, m.suc, 0) + partial(compose(binomial_term[R](a, b, m.suc), Nat.suc), m)

    // Simplify the first term
    binomial_term[R](a, b, m.suc, 0) = b * binomial_term[R](a, b, m, 0)

    // Use binomial_middle_sum to split the middle partial sum
    partial(compose(binomial_term[R](a, b, m.suc), Nat.suc), m) = a * partial(binomial_term[R](a, b, m), m) + b * partial(compose(binomial_term[R](a, b, m), Nat.suc), m)

    // Build up the RHS step by step
    // Start with: RHS = first + middle + last
    let rhs_part1 = b * binomial_term[R](a, b, m, 0) + partial(compose(binomial_term[R](a, b, m.suc), Nat.suc), m)

    // Expand the middle part using binomial_middle_sum
    rhs_part1 = b * binomial_term[R](a, b, m, 0) + a * partial(binomial_term[R](a, b, m), m) + b * partial(compose(binomial_term[R](a, b, m), Nat.suc), m)

    // Combine the 'b' terms using partial_shift_suc
    b * binomial_term[R](a, b, m, 0) + b * partial(compose(binomial_term[R](a, b, m), Nat.suc), m) = b * partial(binomial_term[R](a, b, m), m.suc)

    // So rhs_part1 = b * partial(...) + a * partial(..., m)
    rhs_part1 = b * partial(binomial_term[R](a, b, m), m.suc) + a * partial(binomial_term[R](a, b, m), m)

    // Therefore the full RHS is
    partial(binomial_term[R](a, b, m.suc), m.suc.suc) = b * partial(binomial_term[R](a, b, m), m.suc) + a * partial(binomial_term[R](a, b, m), m) + a * binomial_term[R](a, b, m, m)

    // Combine the 'a' terms using partial_split_last
    a * partial(binomial_term[R](a, b, m), m) + a * binomial_term[R](a, b, m, m) = a * partial(binomial_term[R](a, b, m), m.suc)

    // Final result
    partial(binomial_term[R](a, b, m.suc), m.suc.suc) = b * partial(binomial_term[R](a, b, m), m.suc) + a * partial(binomial_term[R](a, b, m), m.suc)
    partial(binomial_term[R](a, b, m.suc), m.suc.suc) = (a + b) * partial(binomial_term[R](a, b, m), m.suc)
}

/// The binomial theorem for commutative rings: (a + b)^n equals the sum of binomial terms.
theorem binomial[R: CommRing](a: R, b: R, n: Nat) {
    (a + b).pow(n) = partial(binomial_term[R](a, b, n), n.suc)
} by {
    define f(x: Nat) -> Bool {
        (a + b).pow(x) = partial(binomial_term[R](a, b, x), x.suc)
    }

    // Base case: n = 0
    (a + b).pow(0) = R.1
    binomial_term[R](a, b, 0, 0) = from_nat[R](0.choose(0)) * a.pow(0) * b.pow(0)
    binomial_term[R](a, b, 0, 0) = from_nat[R](1) * R.1 * R.1
    binomial_term[R](a, b, 0, 0) = R.1
    partial(binomial_term[R](a, b, 0), 0.suc) = binomial_term[R](a, b, 0, 0)
    partial(binomial_term[R](a, b, 0), 0.suc) = R.1
    f(0)

    // Inductive step
    forall(m: Nat) {
        if f(m) {
            // Induction hypothesis: (a + b)^m = partial(binomial_term(a, b, m), m.suc)

            // LHS: (a + b)^(m+1) = (a + b) * (a + b)^m
            (a + b).pow(m.suc) = (a + b) * (a + b).pow(m)
            partial[R](binomial_term(a, b, m), m.suc) = (a + b).pow(m)
            (a + b).pow(m.suc) = (a + b) * partial(binomial_term[R](a, b, m), m.suc)

            // Apply binomial_distribution to complete the inductive step
            (a + b).pow(m.suc) = partial(binomial_term[R](a, b, m.suc), m.suc.suc)

            f(m.suc)
        }
    }

    f(n)
}
