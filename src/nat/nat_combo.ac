from nat.nat_gcd import Nat
from list import partial
from semigroup import mul_fn
from add_semigroup import add_fn
from util import compose

numerals Nat

// This file contains basic combinatorics.

// We want to define "n choose k", but it's a bit tricky to prove it's a natural number.
// We're going to do induction, but it'll be simpler to separate these out into named functions.
// We are essentially proving that n choose k is integral using the Pascal's triangle recurrence,
// except we are expressing the steps without using rational numbers.

define choose_exists(x: Nat, y: Nat) -> Bool {
    (x.factorial * y.factorial).divides((x + y).factorial)
}

// This will be the inductive hypothesis
define choose_hyp(n: Nat) -> Bool {
    forall(x: Nat, y: Nat) {
        if x + y = n {
            choose_exists(x, y)
        }
    }
}

theorem choose_exists_left_zero(x: Nat) {
    choose_exists(0, x)
}

theorem choose_exists_right_zero(x: Nat) {
    choose_exists(x, 0)
}

theorem choose_base {
    choose_hyp(0)
}

theorem choose_lemma(a: Nat, b: Nat) {
    a != 0 and b != 0 and choose_hyp(a + b - 1) implies
    (a.factorial * b.factorial).divides((a + b - 1).factorial * b)
} by {
    (a - 1) + 1 = a
    (b - 1) + 1 = b
    choose_hyp(a + (b - 1))

    // a! (b - 1)! divides (a + b - 1)!
    choose_exists(a, b - 1)
    a + b - 1 = a + (b - 1)
    (a.factorial * (b - 1).factorial).divides((a + b - 1).factorial)

    // a! b! (b - 1)! divides (a + b - 1)! b!
    (a.factorial * (b - 1).factorial * b.factorial).divides((a + b - 1).factorial * b.factorial)
    (a.factorial * b.factorial * (b - 1).factorial).divides((a + b - 1).factorial * b.factorial)
                        
    // a! b! (b - 1)! divides (a + b - 1)! b * (b - 1)!
    b.factorial = b * (b - 1).factorial
    (a.factorial * b.factorial * (b - 1).factorial).divides((a + b - 1).factorial * b * (b - 1).factorial)

    // a! b! divides (a + b - 1)! b
    (a.factorial * b.factorial).divides((a + b - 1).factorial * b)
}

theorem choose_exists_is_true(z1: Nat, z2: Nat) {
    choose_exists(z1, z2)
} by {
    forall(x: Nat) {
        if choose_hyp(x) {
            forall(a: Nat, b: Nat) {
                if a + b = x.suc {
                    if a = 0 {
                        choose_exists(a, b)
                    }
                    if b = 0 {
                        choose_exists(a, b)
                    }
                    if a != 0 and b != 0 {
                        // Use the lemma one way
                        (a.factorial * b.factorial).divides((a + b - 1).factorial * b)

                        // Use the lemma the other way
                        (b.factorial * a.factorial).divides((b + a - 1).factorial * a)
                        (a.factorial * b.factorial).divides((a + b - 1).factorial * a)

                        (a + b - 1).factorial * b + (a + b - 1).factorial * a = (a + b).factorial
                        (a.factorial * b.factorial).divides((a + b).factorial)
                        choose_exists(a, b)
                    }
                    choose_exists(a, b)
                }
            }
            choose_hyp(x.suc)
        }
    }

    choose_hyp(z1 + z2)
}

theorem choose_exists_sub_form(n: Nat, k: Nat) {
    k <= n implies exists(c: Nat) {
        c * k.factorial * (n - k).factorial = n.factorial
    }
} by {
    (n - k) + k = n
    (k.factorial * (n - k).factorial).divides(n.factorial)
    let c: Nat satisfy {
        (k.factorial * (n - k).factorial) * c = n.factorial
    }
}

let choose(n: Nat, k: Nat) -> c: Nat satisfy {
    if n < k {
        c = 0
    } else {
        c * k.factorial * (n - k).factorial = n.factorial
    }
}

attributes Nat {
    let choose = choose
}

theorem factorial_nonzero(n: Nat) {
    n.factorial != 0
} by {
    factorial_nonzero(0)
    forall(x: Nat) {
        if factorial_nonzero(x) {
            factorial_nonzero(x.suc)
        }
    }
}

theorem choose_zero(n: Nat) {
    n.choose(0) = 1
} by {
    not n < 0
    n.choose(0) * 0.factorial * (n - 0).factorial = n.factorial
    n.choose(0) * 1 * n.factorial = n.factorial
    n.choose(0) * n.factorial = n.factorial
    n.factorial != 0
}

theorem choose_n(n: Nat) {
    n.choose(n) = 1
} by {
    not n < n
    n.choose(n) * n.factorial * (n - n).factorial = n.factorial
    n.choose(n) * n.factorial * 1 = n.factorial
    n.choose(n) * n.factorial = n.factorial
    n.factorial != 0
}

theorem choose_add(a: Nat, b: Nat) {
    (a + b).choose(a) * a.factorial * b.factorial = (a + b).factorial
} by {
    not (a + b) < a
    (a + b).choose(a) * a.factorial * (a + b - a).factorial = (a + b).factorial
    (a + b - a).factorial = b.factorial
}

theorem choose_symm_add_form(a: Nat, b: Nat) {
    (a + b).choose(a) = (a + b).choose(b)
} by {
    a.factorial * b.factorial != 0
    (a + b).choose(a) * a.factorial * b.factorial = (a + b).factorial
    (a + b).choose(a) * (a.factorial * b.factorial) = (a + b).factorial
    (a + b).choose(b) * b.factorial * a.factorial = (a + b).factorial
    (a + b).choose(b) * (a.factorial * b.factorial) = (a + b).factorial
}

theorem choose_symm_sub_form(n: Nat, k: Nat) {
    k <= n implies n.choose(k) = n.choose(n - k)
} by {
    let a: Nat satisfy {
        k + a = n
    }
}

theorem choose_one(n: Nat) {
    n.choose(1) = n
} by {
    if n < 1 {
        n.choose(1) = 0
        n.choose(1) = n
    } else {
        n.choose(1) * 1.factorial * (n - 1).factorial = n.factorial
        n.choose(1) * 1 * (n - 1).factorial = n.factorial
        n.choose(1) * (n - 1).factorial = n.factorial
        n.factorial = n * (n - 1).factorial
        n.choose(1) * (n - 1).factorial = n * (n - 1).factorial
        (n - 1).factorial != 0
        n.choose(1) = n
    }
}

/// When k > n, the binomial coefficient is zero.
theorem choose_out_of_bounds(n: Nat, k: Nat) {
    n < k implies n.choose(k) = 0
}

/// Pascal's identity: each entry in Pascal's triangle is the sum of the two entries above it.
theorem pascal(n: Nat, k: Nat) {
    0 < k and k <= n implies n.suc.choose(k) = n.choose(k - 1) + n.choose(k)
} by {
    // Establish key facts about k
    let (k_pred: Nat) satisfy { k_pred.suc = k }
    k_pred + 1 = k
    k - 1 = k_pred

    // Establish bounds
    k_pred < k
    k_pred <= n
    k_pred <= k
    k <= n.suc

    k.factorial * (n.suc - k).factorial != 0

    // LHS
    not n.suc < k
    n.suc.choose(k) * k.factorial * (n.suc - k).factorial = n.suc.factorial
    n.suc.choose(k) * (k.factorial * (n.suc - k).factorial) = n.suc.factorial

    // First term of RHS
    not n < k_pred
    n.choose(k_pred) * k_pred.factorial * (n - k_pred).factorial = n.factorial
    n - k_pred = n.suc - k
    n.choose(k_pred) * k_pred.factorial * (n.suc - k).factorial = n.factorial
    k.factorial = k * k_pred.factorial
    n.choose(k_pred) * k * k_pred.factorial * (n.suc - k).factorial = k * n.factorial
    n.choose(k_pred) * (k.factorial * (n.suc - k).factorial) = k * n.factorial
    n.choose(k - 1) * (k.factorial * (n.suc - k).factorial) = k * n.factorial

    // Second term of RHS
    not n < k
    n.choose(k) * k.factorial * (n - k).factorial = n.factorial
    n.suc - k = (n - k).suc
    (n.suc - k).factorial = (n - k).suc.factorial
    (n.suc - k).factorial = (n - k + 1) * (n - k).factorial
    n.choose(k) * k.factorial * (n.suc - k).factorial = n.choose(k) * k.factorial * (n - k + 1) * (n - k).factorial
    n.choose(k) * k.factorial * (n.suc - k).factorial = (n - k + 1) * n.choose(k) * k.factorial * (n - k).factorial
    n.choose(k) * k.factorial * (n.suc - k).factorial = (n - k + 1) * n.factorial
    n.choose(k) * (k.factorial * (n.suc - k).factorial) = (n - k + 1) * n.factorial

    // Sum
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = k * n.factorial + (n - k + 1) * n.factorial
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = (k + n - k + 1) * n.factorial
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = (n + 1) * n.factorial
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = n.suc * n.factorial
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = n.suc.factorial

    n.suc.choose(k) = n.choose(k - 1) + n.choose(k)
}

// Helper function for the binomial theorem
define binomial_term(a: Nat, b: Nat, n: Nat, k: Nat) -> Nat {
    n.choose(k) * a.exp(k) * b.exp(n - k)
}

/// The boundary term at k=0 for the binomial expansion.
theorem binomial_term_zero(a: Nat, b: Nat, m: Nat) {
    binomial_term(a, b, m.suc, 0) = b * binomial_term(a, b, m, 0)
} by {
    binomial_term(a, b, m.suc, 0) = m.suc.choose(0) * a.exp(0) * b.exp(m.suc)
    binomial_term(a, b, m.suc, 0) = 1 * 1 * b.exp(m.suc)
    binomial_term(a, b, m.suc, 0) = b.exp(m.suc)
    b.exp(m.suc) = b * b.exp(m)
    binomial_term(a, b, m.suc, 0) = b * b.exp(m)

    binomial_term(a, b, m, 0) = m.choose(0) * a.exp(0) * b.exp(m)
    binomial_term(a, b, m, 0) = 1 * 1 * b.exp(m)
    binomial_term(a, b, m, 0) = b.exp(m)

    binomial_term(a, b, m.suc, 0) = b * binomial_term(a, b, m, 0)
}

/// The boundary term at k=m+1 for the binomial expansion.
theorem binomial_term_top(a: Nat, b: Nat, m: Nat) {
    binomial_term(a, b, m.suc, m.suc) = a * binomial_term(a, b, m, m)
} by {
    binomial_term(a, b, m.suc, m.suc) = m.suc.choose(m.suc) * a.exp(m.suc) * b.exp(0)
    binomial_term(a, b, m.suc, m.suc) = 1 * a.exp(m.suc) * 1
    binomial_term(a, b, m.suc, m.suc) = a.exp(m.suc)
    a.exp(m.suc) = a * a.exp(m)
    binomial_term(a, b, m.suc, m.suc) = a * a.exp(m)

    binomial_term(a, b, m, m) = m.choose(m) * a.exp(m) * b.exp(0)
    binomial_term(a, b, m, m) = 1 * a.exp(m) * 1
    binomial_term(a, b, m, m) = a.exp(m)

    binomial_term(a, b, m.suc, m.suc) = a * binomial_term(a, b, m, m)
}

/// Recursive relation for binomial terms: each term for n+1 equals a times the shifted
/// term for n plus b times the corresponding term for n.
theorem binomial_term_recurrence(a: Nat, b: Nat, m: Nat, k: Nat) {
    0 < k and k <= m implies
    binomial_term(a, b, m.suc, k) =
    a * binomial_term(a, b, m, k - 1) + b * binomial_term(a, b, m, k)
} by {
    // Establish k_pred for k - 1
    let (k_pred: Nat) satisfy { k_pred.suc = k }
    k_pred + 1 = k
    k - 1 = k_pred
    k_pred < k
    k_pred <= m

    // Expand LHS: binomial_term(a, b, m.suc, k)
    binomial_term(a, b, m.suc, k) = m.suc.choose(k) * a.exp(k) * b.exp(m.suc - k)

    // Expand first term of RHS: a * binomial_term(a, b, m, k - 1)
    binomial_term(a, b, m, k_pred) = m.choose(k_pred) * a.exp(k_pred) * b.exp(m - k_pred)
    a * binomial_term(a, b, m, k_pred) = a * (m.choose(k_pred) * a.exp(k_pred) * b.exp(m - k_pred))
    a * binomial_term(a, b, m, k_pred) = a * m.choose(k_pred) * a.exp(k_pred) * b.exp(m - k_pred)
    a * binomial_term(a, b, m, k_pred) = m.choose(k_pred) * (a * a.exp(k_pred)) * b.exp(m - k_pred)
    a.exp(k) = a * a.exp(k_pred)
    a * binomial_term(a, b, m, k_pred) = m.choose(k_pred) * a.exp(k) * b.exp(m - k_pred)
    m - k_pred = m.suc - k
    a * binomial_term(a, b, m, k_pred) = m.choose(k_pred) * a.exp(k) * b.exp(m.suc - k)
    a * binomial_term(a, b, m, k - 1) = m.choose(k - 1) * a.exp(k) * b.exp(m.suc - k)

    // Expand second term of RHS: b * binomial_term(a, b, m, k)
    k <= m
    binomial_term(a, b, m, k) = m.choose(k) * a.exp(k) * b.exp(m - k)
    b * binomial_term(a, b, m, k) = b * (m.choose(k) * a.exp(k) * b.exp(m - k))
    b * binomial_term(a, b, m, k) = b * m.choose(k) * a.exp(k) * b.exp(m - k)
    b * binomial_term(a, b, m, k) = m.choose(k) * a.exp(k) * (b * b.exp(m - k))
    m - k + 1 = m.suc - k
    b.exp(m.suc - k) = b.exp(m - k + 1)
    b.exp(m - k + 1) = b * b.exp(m - k)
    b * binomial_term(a, b, m, k) = m.choose(k) * a.exp(k) * b.exp(m.suc - k)

    // Combine the two terms using the distributive property
    let rhs_sum = a * binomial_term(a, b, m, k - 1) + b * binomial_term(a, b, m, k)
    rhs_sum = m.choose(k - 1) * a.exp(k) * b.exp(m.suc - k) + m.choose(k) * a.exp(k) * b.exp(m.suc - k)
    rhs_sum = (m.choose(k - 1) + m.choose(k)) * a.exp(k) * b.exp(m.suc - k)

    // Apply Pascal's identity
    m.suc.choose(k) = m.choose(k - 1) + m.choose(k)
    rhs_sum = m.suc.choose(k) * a.exp(k) * b.exp(m.suc - k)

    // Connect LHS and RHS
    binomial_term(a, b, m.suc, k) = rhs_sum
    binomial_term(a, b, m.suc, k) = a * binomial_term(a, b, m, k - 1) + b * binomial_term(a, b, m, k)
}

/// Alternative form of the binomial term recurrence, avoiding subtraction by using k.suc.
theorem alt_binomial_term_recurrence(a: Nat, b: Nat, m: Nat, k: Nat) {
    k < m implies
    binomial_term(a, b, m.suc, k.suc) =
    a * binomial_term(a, b, m, k) + b * binomial_term(a, b, m, k.suc)
} by {
    // We have k < m, which gives us k.suc <= m and 0 < k.suc
    k.suc <= m
    0 < k.suc
    binomial_term(a, b, m.suc, k.suc) = a * binomial_term(a, b, m, k.suc - 1) + b * binomial_term(a, b, m, k.suc)
    k.suc - 1 = k
    binomial_term(a, b, m.suc, k.suc) = a * binomial_term(a, b, m, k) + b * binomial_term(a, b, m, k.suc)
}

/// Helper: the middle partial sum splits into two parts using the recurrence.
theorem binomial_middle_sum(a: Nat, b: Nat, m: Nat) {
    partial(compose(binomial_term(a, b, m.suc), Nat.suc), m) =
        a * partial(binomial_term(a, b, m), m) + b * partial(compose(binomial_term(a, b, m), Nat.suc), m)
} by {
    // Define helper functions for clarity
    define f(k: Nat) -> Nat { binomial_term(a, b, m, k) }
    define g(k: Nat) -> Nat { compose(binomial_term(a, b, m), Nat.suc)(k) }
    define h(k: Nat) -> Nat { compose(binomial_term(a, b, m.suc), Nat.suc)(k) }

    // Show pointwise equality: for each k < m, h(k) = a * f(k) + b * g(k)
    forall(k: Nat) {
        if k < m {
            // h(k) = binomial_term(a, b, m.suc, k.suc)
            h(k) = compose(binomial_term(a, b, m.suc), Nat.suc)(k)
            h(k) = binomial_term(a, b, m.suc, k.suc)

            // Use alt_binomial_term_recurrence
            binomial_term(a, b, m.suc, k.suc) = a * binomial_term(a, b, m, k) + b * binomial_term(a, b, m, k.suc)

            // Simplify RHS
            f(k) = binomial_term(a, b, m, k)
            g(k) = binomial_term(a, b, m, k.suc)

            h(k) = a * f(k) + b * g(k)
            h(k) = mul_fn(a, f)(k) + mul_fn(b, g)(k)
            h(k) = add_fn(mul_fn(a, f), mul_fn(b, g))(k)
        }
    }

    // Use partial_pointwise_eq
    partial(h, m) = partial(add_fn(mul_fn(a, f), mul_fn(b, g)), m)

    // Use partial_add to split the sum
    partial(add_fn(mul_fn(a, f), mul_fn(b, g)), m) = partial(mul_fn(a, f), m) + partial(mul_fn(b, g), m)

    // Use partial_scalar_mul to factor out the scalars
    partial(mul_fn(a, f), m) = a * partial(f, m)
    partial(mul_fn(b, g), m) = b * partial(g, m)

    // Combine everything
    partial(h, m) = a * partial(f, m) + b * partial(g, m)
    partial(compose(binomial_term(a, b, m.suc), Nat.suc), m) = a * partial(binomial_term(a, b, m), m) + b * partial(compose(binomial_term(a, b, m), Nat.suc), m)
}

/// Distributing (a + b) across a partial sum of binomial terms gives the next row.
theorem binomial_distribution(a: Nat, b: Nat, m: Nat) {
    (a + b) * partial(binomial_term(a, b, m), m.suc) = partial(binomial_term(a, b, m.suc), m.suc.suc)
} by {
    // LHS: Expand using distributivity
    (a + b) * partial(binomial_term(a, b, m), m.suc) = a * partial(binomial_term(a, b, m), m.suc) + b * partial(binomial_term(a, b, m), m.suc)

    // RHS: Peel off the last term using partial_split_last
    partial(binomial_term(a, b, m.suc), m.suc.suc) = partial(binomial_term(a, b, m.suc), m.suc) + binomial_term(a, b, m.suc, m.suc)

    // Simplify the last term
    binomial_term(a, b, m.suc, m.suc) = a * binomial_term(a, b, m, m)

    // Now peel off the first term using partial_shift_suc
    partial(binomial_term(a, b, m.suc), m.suc) = binomial_term(a, b, m.suc, 0) + partial(compose(binomial_term(a, b, m.suc), Nat.suc), m)

    // Simplify the first term
    binomial_term(a, b, m.suc, 0) = b * binomial_term(a, b, m, 0)

    // Use binomial_middle_sum to split the middle partial sum
    partial(compose(binomial_term(a, b, m.suc), Nat.suc), m) = a * partial(binomial_term(a, b, m), m) + b * partial(compose(binomial_term(a, b, m), Nat.suc), m)

    // Build up the RHS step by step
    // Start with: RHS = first + middle + last
    let rhs_part1 = b * binomial_term(a, b, m, 0) + partial(compose(binomial_term(a, b, m.suc), Nat.suc), m)
    partial(binomial_term(a, b, m.suc), m.suc) = rhs_part1
    partial(binomial_term(a, b, m.suc), m.suc.suc) = rhs_part1 + a * binomial_term(a, b, m, m)

    // Expand the middle part using binomial_middle_sum
    rhs_part1 = b * binomial_term(a, b, m, 0) + a * partial(binomial_term(a, b, m), m) + b * partial(compose(binomial_term(a, b, m), Nat.suc), m)

    // Combine the 'b' terms using partial_shift_suc
    b * binomial_term(a, b, m, 0) + b * partial(compose(binomial_term(a, b, m), Nat.suc), m) = b * (binomial_term(a, b, m, 0) + partial(compose(binomial_term(a, b, m), Nat.suc), m))
    binomial_term(a, b, m, 0) + partial(compose(binomial_term(a, b, m), Nat.suc), m) = partial(binomial_term(a, b, m), m.suc)
    b * binomial_term(a, b, m, 0) + b * partial(compose(binomial_term(a, b, m), Nat.suc), m) = b * partial(binomial_term(a, b, m), m.suc)

    // So rhs_part1 = b * partial(...) + a * partial(..., m)
    rhs_part1 = b * partial(binomial_term(a, b, m), m.suc) + a * partial(binomial_term(a, b, m), m)

    // Therefore the full RHS is
    partial(binomial_term(a, b, m.suc), m.suc.suc) = b * partial(binomial_term(a, b, m), m.suc) + a * partial(binomial_term(a, b, m), m) + a * binomial_term(a, b, m, m)

    // Combine the 'a' terms using partial_split_last
    a * partial(binomial_term(a, b, m), m) + a * binomial_term(a, b, m, m) = a * (partial(binomial_term(a, b, m), m) + binomial_term(a, b, m, m))
    partial(binomial_term(a, b, m), m) + binomial_term(a, b, m, m) = partial(binomial_term(a, b, m), m.suc)
    a * partial(binomial_term(a, b, m), m) + a * binomial_term(a, b, m, m) = a * partial(binomial_term(a, b, m), m.suc)

    // Final result
    partial(binomial_term(a, b, m.suc), m.suc.suc) = b * partial(binomial_term(a, b, m), m.suc) + a * partial(binomial_term(a, b, m), m.suc)
    partial(binomial_term(a, b, m.suc), m.suc.suc) = a * partial(binomial_term(a, b, m), m.suc) + b * partial(binomial_term(a, b, m), m.suc)
}

/// The binomial theorem: (a + b)^n equals the sum of binomial terms.
theorem binomial(a: Nat, b: Nat, n: Nat) {
    (a + b).exp(n) = partial(binomial_term(a, b, n), n.suc)
} by {
    define f(x: Nat) -> Bool {
        (a + b).exp(x) = partial(binomial_term(a, b, x), x.suc)
    }

    // Base case: n = 0
    (a + b).exp(0) = 1
    binomial_term(a, b, 0, 0) = 0.choose(0) * a.exp(0) * b.exp(0)
    binomial_term(a, b, 0, 0) = 1 * 1 * 1
    binomial_term(a, b, 0, 0) = 1
    partial(binomial_term(a, b, 0), 1) = binomial_term(a, b, 0, 0)
    (a + b).exp(0) = partial(binomial_term(a, b, 0), 0.suc)
    f(0)

    // Inductive step
    forall(m: Nat) {
        if f(m) {
            // Induction hypothesis
            (a + b).exp(m) = partial(binomial_term(a, b, m), m.suc)

            // LHS: (a + b)^(m+1) = (a + b) * (a + b)^m
            (a + b).exp(m.suc) = (a + b) * (a + b).exp(m)
            (a + b).exp(m.suc) = (a + b) * partial(binomial_term(a, b, m), m.suc)

            // Apply binomial_distribution to complete the inductive step
            (a + b) * partial(binomial_term(a, b, m), m.suc) = partial(binomial_term(a, b, m.suc), m.suc.suc)
            (a + b).exp(m.suc) = partial(binomial_term(a, b, m.suc), m.suc.suc)

            f(m.suc)
        }
    }

    f(n)
}