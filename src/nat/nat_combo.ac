from nat.lattice import Nat
from list import partial
from semigroup import mul_fn
from add_semigroup import add_fn
from util import compose

numerals Nat

// This file contains basic combinatorics.

// We want to define "n choose k", but it's a bit tricky to prove it's a natural number.
// We're going to do induction, but it'll be simpler to separate these out into named functions.
// We are essentially proving that n choose k is integral using the Pascal's triangle recurrence,
// except we are expressing the steps without using rational numbers.

define choose_exists(x: Nat, y: Nat) -> Bool {
    (x.factorial * y.factorial).divides((x + y).factorial)
}

// This will be the inductive hypothesis
define choose_hyp(n: Nat) -> Bool {
    forall(x: Nat, y: Nat) {
        if x + y = n {
            choose_exists(x, y)
        }
    }
}

theorem choose_exists_left_zero(x: Nat) {
    choose_exists(0, x)
}

theorem choose_exists_right_zero(x: Nat) {
    choose_exists(x, 0)
}

theorem choose_base {
    choose_hyp(0)
}

theorem choose_lemma(a: Nat, b: Nat) {
    a != 0 and b != 0 and choose_hyp(a + b - 1) implies
    (a.factorial * b.factorial).divides((a + b - 1).factorial * b)
} by {

    // a! (b - 1)! divides (a + b - 1)!
    a + b - 1 = a + (b - 1)

    // a! b! (b - 1)! divides (a + b - 1)! b!
    (a.factorial * (b - 1).factorial * b.factorial).divides((a + b - 1).factorial * b.factorial)

    // a! b! (b - 1)! divides (a + b - 1)! b * (b - 1)!
    b.factorial = b * (b - 1).factorial
    (a.factorial * b.factorial * (b - 1).factorial).divides((a + b - 1).factorial * b * (b - 1).factorial)

    // a! b! divides (a + b - 1)! b
}

theorem choose_exists_is_true(z1: Nat, z2: Nat) {
    choose_exists(z1, z2)
} by {
    forall(x: Nat) {
        if choose_hyp(x) {
            forall(a: Nat, b: Nat) {
                if a + b = x.suc {
                    if b = 0 {
                        choose_exists(a, b)
                    }
                    if a != 0 and b != 0 {
                        // Use the lemma one way
                        (a.factorial * b.factorial).divides((a + b - 1).factorial * b)

                        // Use the lemma the other way
                        (b.factorial * a.factorial).divides((b + a - 1).factorial * a)

                        (a + b - 1).factorial * b + (a + b - 1).factorial * a = (a + b).factorial
                        (a.factorial * b.factorial).divides((a + b).factorial)
                    }
                    choose_exists(a, b)
                }
            }
            choose_hyp(x.suc)
        }
    }

}

theorem choose_exists_sub_form(n: Nat, k: Nat) {
    k <= n implies exists(c: Nat) {
        c * k.factorial * (n - k).factorial = n.factorial
    }
} by {
    let c: Nat satisfy {
        (k.factorial * (n - k).factorial) * c = n.factorial
    }
}

/// The binomial coefficient "n choose k".
let choose(n: Nat, k: Nat) -> c: Nat satisfy {
    if n < k {
        c = 0
    } else {
        c * k.factorial * (n - k).factorial = n.factorial
    }
}

attributes Nat {
    /// The binomial coefficient "n choose k".
    let choose = choose
}

theorem factorial_nonzero(n: Nat) {
    n.factorial != 0
}

theorem choose_zero(n: Nat) {
    n.choose(0) = 1
} by {
    n.choose(0) * 0.factorial * (n - 0).factorial = n.factorial
}

theorem choose_n(n: Nat) {
    n.choose(n) = 1
} by {
    n.choose(n) * n.factorial * (n - n).factorial = n.factorial
}

theorem choose_add(a: Nat, b: Nat) {
    (a + b).choose(a) * a.factorial * b.factorial = (a + b).factorial
} by {
    (a + b - a).factorial = b.factorial
}

theorem choose_symm_add_form(a: Nat, b: Nat) {
    (a + b).choose(a) = (a + b).choose(b)
} by {
    (a + b).choose(b) * (a.factorial * b.factorial) = (a + b).factorial
}

theorem choose_symm_sub_form(n: Nat, k: Nat) {
    k <= n implies n.choose(k) = n.choose(n - k)
} by {
    let a: Nat satisfy {
        k + a = n
    }
}

theorem choose_one(n: Nat) {
    n.choose(1) = n
} by {
    if n < 1 {
    } else {
        n.factorial = n * (n - 1).factorial
        n.choose(1) = n
    }
}

/// When k > n, the binomial coefficient is zero.
theorem choose_out_of_bounds(n: Nat, k: Nat) {
    n < k implies n.choose(k) = 0
}

/// Pascal's identity: each entry in Pascal's triangle is the sum of the two entries above it.
theorem pascal(n: Nat, k: Nat) {
    0 < k and k <= n implies n.suc.choose(k) = n.choose(k - 1) + n.choose(k)
} by {
    // Establish key facts about k
    let (k_pred: Nat) satisfy { k_pred.suc = k }

    // Establish bounds

    k.factorial * (n.suc - k).factorial != 0

    // LHS
    n.suc.choose(k) * (k.factorial * (n.suc - k).factorial) = n.suc.factorial

    // First term of RHS
    not n < k_pred
    n - k_pred = n.suc - k
    n.choose(k_pred) * k_pred.factorial * (n.suc - k).factorial = n.factorial
    n.choose(k_pred) * k * k_pred.factorial * (n.suc - k).factorial = k * n.factorial

    // Second term of RHS
    n.choose(k) * k.factorial * (n - k).factorial = n.factorial
    (n.suc - k).factorial = (n - k + 1) * (n - k).factorial
    n.choose(k) * k.factorial * (n.suc - k).factorial = (n - k + 1) * n.choose(k) * k.factorial * (n - k).factorial

    // Sum
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = k * n.factorial + (n - k + 1) * n.factorial
    (n.choose(k - 1) + n.choose(k)) * (k.factorial * (n.suc - k).factorial) = n.suc.factorial

}

// Helper function for the binomial theorem
define binomial_term(a: Nat, b: Nat, n: Nat, k: Nat) -> Nat {
    n.choose(k) * a.pow(k) * b.pow(n - k)
}

/// The boundary term at k=0 for the binomial expansion.
theorem binomial_term_zero(a: Nat, b: Nat, m: Nat) {
    binomial_term(a, b, m.suc, 0) = b * binomial_term(a, b, m, 0)
} by {

    binomial_term(a, b, m, 0) = b.pow(m)

}

/// The boundary term at k=m+1 for the binomial expansion.
theorem binomial_term_top(a: Nat, b: Nat, m: Nat) {
    binomial_term(a, b, m.suc, m.suc) = a * binomial_term(a, b, m, m)
} by {

    binomial_term(a, b, m, m) = a.pow(m)

}

/// Recursive relation for binomial terms: each term for n+1 equals a times the shifted
/// term for n plus b times the corresponding term for n.
theorem binomial_term_recurrence(a: Nat, b: Nat, m: Nat, k: Nat) {
    0 < k and k <= m implies
    binomial_term(a, b, m.suc, k) =
    a * binomial_term(a, b, m, k - 1) + b * binomial_term(a, b, m, k)
} by {
    // Establish k_pred for k - 1
    let (k_pred: Nat) satisfy { k_pred.suc = k }
    k_pred <= m

    // Expand LHS: binomial_term(a, b, m.suc, k)

    // Expand first term of RHS: a * binomial_term(a, b, m, k - 1)
    a.pow(k) = a * a.pow(k_pred)
    a * binomial_term(a, b, m, k_pred) = m.choose(k_pred) * a.pow(k) * b.pow(m - k_pred)
    m - k_pred = m.suc - k

    // Expand second term of RHS: b * binomial_term(a, b, m, k)
    b * binomial_term(a, b, m, k) = m.choose(k) * a.pow(k) * (b * b.pow(m - k))
    b.pow(m.suc - k) = b.pow(m - k + 1)

    // Combine the two terms using the distributive property
    let rhs_sum = a * binomial_term(a, b, m, k - 1) + b * binomial_term(a, b, m, k)
    rhs_sum = (m.choose(k - 1) + m.choose(k)) * a.pow(k) * b.pow(m.suc - k)

    // Apply Pascal's identity

    // Connect LHS and RHS
}

/// Alternative form of the binomial term recurrence, avoiding subtraction by using k.suc.
theorem alt_binomial_term_recurrence(a: Nat, b: Nat, m: Nat, k: Nat) {
    k < m implies
    binomial_term(a, b, m.suc, k.suc) =
    a * binomial_term(a, b, m, k) + b * binomial_term(a, b, m, k.suc)
} by {
    // We have k < m, which gives us k.suc <= m and 0 < k.suc
    binomial_term(a, b, m.suc, k.suc) = a * binomial_term(a, b, m, k.suc - 1) + b * binomial_term(a, b, m, k.suc)
}

/// Helper: the middle partial sum splits into two parts using the recurrence.
theorem binomial_middle_sum(a: Nat, b: Nat, m: Nat) {
    partial(compose(binomial_term(a, b, m.suc), Nat.suc), m) =
        a * partial(binomial_term(a, b, m), m) + b * partial(compose(binomial_term(a, b, m), Nat.suc), m)
} by {
    // Define helper functions for clarity
    define f(k: Nat) -> Nat { binomial_term(a, b, m, k) }
    define g(k: Nat) -> Nat { compose(binomial_term(a, b, m), Nat.suc)(k) }
    define h(k: Nat) -> Nat { compose(binomial_term(a, b, m.suc), Nat.suc)(k) }

    // Show pointwise equality: for each k < m, h(k) = a * f(k) + b * g(k)
    forall(k: Nat) {
        if k < m {
            // h(k) = binomial_term(a, b, m.suc, k.suc)

            // Use alt_binomial_term_recurrence

            // Simplify RHS

            h(k) = mul_fn(a, f)(k) + mul_fn(b, g)(k)
        }
    }

    // Use partial_pointwise_eq
    partial(h, m) = partial(add_fn(mul_fn(a, f), mul_fn(b, g)), m)

    // Use partial_add to split the sum

    // Use partial_scalar_mul to factor out the scalars

    // Combine everything
}

/// Distributing (a + b) across a partial sum of binomial terms gives the next row.
theorem binomial_distribution(a: Nat, b: Nat, m: Nat) {
    (a + b) * partial(binomial_term(a, b, m), m.suc) = partial(binomial_term(a, b, m.suc), m.suc.suc)
} by {
    // LHS: Expand using distributivity

    // RHS: Peel off the last term using partial_split_last

    // Simplify the last term

    // Now peel off the first term using partial_shift_suc

    // Simplify the first term

    // Use binomial_middle_sum to split the middle partial sum

    // Build up the RHS step by step
    // Start with: RHS = first + middle + last
    let rhs_part1 = b * binomial_term(a, b, m, 0) + partial(compose(binomial_term(a, b, m.suc), Nat.suc), m)

    // Expand the middle part using binomial_middle_sum

    // Combine the 'b' terms using partial_shift_suc

    // So rhs_part1 = b * partial(...) + a * partial(..., m)
    rhs_part1 = b * partial(binomial_term(a, b, m), m.suc) + a * partial(binomial_term(a, b, m), m)

    // Therefore the full RHS is

    // Combine the 'a' terms using partial_split_last
    a * partial(binomial_term(a, b, m), m) + a * binomial_term(a, b, m, m) = a * partial(binomial_term(a, b, m), m.suc)

    // Final result
    partial(binomial_term(a, b, m.suc), m.suc.suc) = b * partial(binomial_term(a, b, m), m.suc) + a * partial(binomial_term(a, b, m), m.suc)
}

/// The binomial theorem: (a + b)^n equals the sum of binomial terms.
theorem binomial(a: Nat, b: Nat, n: Nat) {
    (a + b).pow(n) = partial(binomial_term(a, b, n), n.suc)
} by {
    define f(x: Nat) -> Bool {
        (a + b).pow(x) = partial(binomial_term(a, b, x), x.suc)
    }

    // Base case: n = 0
    (a + b).pow(0) = partial(binomial_term(a, b, 0), 0.suc)

    // Inductive step
    forall(m: Nat) {
        if f(m) {
            // Induction hypothesis

            // LHS: (a + b)^(m+1) = (a + b) * (a + b)^m

            // Apply binomial_distribution to complete the inductive step

            f(m.suc)
        }
    }

    f(n)
}