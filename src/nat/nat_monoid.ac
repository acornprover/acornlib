from nat.nat_base import Nat
from monoid import Monoid
from semigroup import Semigroup
numerals Nat

instance Nat: Semigroup {
    let mul: (Nat, Nat) -> Nat = Nat.mul
}

instance Nat: Monoid {
    let 1: Nat = Nat.1
}

// attributes Nat {
//     let exp = Nat.pow
// }

theorem exp_one(a: Nat) {
    a.pow(1) = a
}

theorem exp_zero(a: Nat) {
    a.pow(0) = 1
}

theorem exp_add(a: Nat, b: Nat, c: Nat) {
    a.pow(b + c) = a.pow(b) * a.pow(c)
} by {
    // Inductive step
    let f: Nat -> Bool = function(x: Nat) {
        a.pow(b + x) = a.pow(b) * a.pow(x)
    }
    f(0)
    forall(x: Nat) {
        if f(x) {
            a.pow(b + x) = a.pow(b) * a.pow(x)
            a.pow(b + x.suc) = a.pow(b) * a.pow(x.suc)
            f(x.suc)
        }
    }
    f(c)
}

theorem exp_mul(a: Nat, b: Nat, c: Nat) {
    a.pow(b * c) = a.pow(b).pow(c)
} by {
    // Inductive step
    let f: Nat -> Bool = function(x: Nat) {
        a.pow(b * x) = a.pow(b).pow(x)
    }
    f(0)
    forall(x: Nat) {
        if f(x) {
            a.pow(b * x) = a.pow(b).pow(x)
            a.pow(b * x.suc) = a.pow(b).pow(x.suc)
            f(x.suc)
        }
    }
    f(c)
}

theorem zero_exp(n: Nat) {
    n != 0 implies 0.pow(n) = 0
} by {
    let b: Nat satisfy {
        n = b.suc
    }
}

theorem one_exp(n: Nat) {
    1.pow(n) = 1
} by {
    one_exp(0)
    one_exp(n)
}

theorem exp_gte_one(a: Nat, b: Nat) {
    a != 0 implies 1 <= a.pow(b)
} by {
    // Induction step
    let f: Nat -> Bool = function(x: Nat) {
        1 <= a.pow(x)
    }
    f(0)
    forall(x: Nat) {
        if f(x) {
            1 <= a.pow(x)
            a.pow(x) <= a.pow(x.suc)
            1 <= a.pow(x.suc)
            f(x.suc)
        }
    }
    f(b)
}

theorem exp_gt_one(a: Nat, b: Nat) {
    1 < a and b != 0 implies 1 < a.pow(b)
} by {
    let b_pred: Nat satisfy {
        b = b_pred.suc
    }
    a.pow(b) = a * a.pow(b_pred)
    1 <= a.pow(b_pred)
}

theorem exp_ne_zero(a: Nat, b: Nat) {
    a != 0 implies a.pow(b) != 0
} by {
    1 <= a.pow(b)
}

theorem lte_imp_exp_lte(a: Nat, b: Nat, c: Nat) {
    a != 0 and b <= c implies a.pow(b) <= a.pow(c)
} by {
    let d: Nat satisfy {
        b + d = c
    }
    a.pow(c) = a.pow(b) * a.pow(d)
    a.pow(d) != 0
    a.pow(b) <= a.pow(c)
}

theorem lte_exp(a: Nat, b: Nat) {
    a != 0 and b != 0 implies a <= a.pow(b)
}

theorem lt_imp_exp_lt(a: Nat, b: Nat, c: Nat) {
    1 < a and b < c implies a.pow(b) < a.pow(c)
} by {
    let d: Nat satisfy {
        b + d = c
    }
    d != 0
    a.pow(c) = a.pow(b) * a.pow(d)
    a.pow(b) != 0
    1 < a.pow(d)
}

theorem exp_lte_imp_lte(a: Nat, b: Nat, c: Nat) {
    1 < a and a.pow(b) <= a.pow(c)
    implies
    b <= c
}

theorem exp_lt_imp_lt(a: Nat, b: Nat, c: Nat) {
    1 < a and a.pow(b) < a.pow(c)
    implies
    b < c
}

theorem exp_eq_one_imp(a: Nat, b: Nat) {
    a != 1 and a.pow(b) = 1 implies b = 0
} by {
    if b != 0 {
        let b_pred: Nat satisfy {
            b = b_pred.suc
        }
        a.pow(b) = a * a.pow(b_pred)
        false
    }
}

theorem sq_eq_mul(a: Nat) {
    a.pow(2) = a * a
}