from real import Real
from add import Add
from mul import Mul
from neg import Neg
from inverse import Inverse

/// Complex numbers consist of a real part and an imaginary part.
/// They extend the real numbers and satisfy the equation i² = -1.
structure Complex {
    /// The real part of the complex number.
    re: Real
    /// The imaginary part of the complex number.
    im: Real
}

/// Adds two complex numbers component-wise.
instance Complex: Add {
    define add(self, other: Complex) -> Complex {
        Complex.new(self.re + other.re, self.im + other.im)
    }
}

/// Multiplies two complex numbers using the formula (a+bi)(c+di) = (ac-bd)+(ad+bc)i.
instance Complex: Mul {
    define mul(self, other: Complex) -> Complex {
        // (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
        Complex.new(
            self.re * other.re - self.im * other.im,
            self.re * other.im + self.im * other.re
        )
    }
}

attributes Complex {
    /// Converts a real number to a complex number (with zero imaginary part).
    let from_real: Real -> Complex = function(r: Real) {
        Complex.new(r, Real.0)
    }

    /// The imaginary unit, satisfying `i² = -1`.
    let i: Complex = Complex.new(Real.0, Real.1)

    /// True if this complex number has no imaginary component.
    define is_real(self) -> Bool {
        self.im = Real.0
    }

    /// True if this complex number is purely imaginary (no real component).
    define is_imaginary(self) -> Bool {
        self.re = Real.0 and self.im != Real.0
    }

    /// Yields the complex conjugate (negates the imaginary part).
    define conj(self) -> Complex {
        Complex.new(self.re, -self.im)
    }

    /// Computes the squared magnitude |z|² = re² + im².
    define abs_squared(self) -> Real {
        self.re * self.re + self.im * self.im
    }
}

from zero import Zero

instance Complex: Zero {
    let 0: Complex = Complex.new(Real.0, Real.0)
}

from one import One

instance Complex: One {
    let 1: Complex = Complex.new(Real.1, Real.0)
}

// Alias for convenience
let i = Complex.i

// Theorems for complex numbers

// Addition properties
theorem add_comm(a: Complex, b: Complex) {
    a + b = b + a
}

theorem add_assoc(a: Complex, b: Complex, c: Complex) {
    (a + b) + c = a + (b + c)
} by {
    // Component-wise expansion
    let left_re1 = (a + b).re + c.re
    let left_im1 = (a + b).im + c.im
    let left_re2 = (a.re + b.re) + c.re
    let left_im2 = (a.im + b.im) + c.im

    let right_re1 = a.re + (b + c).re
    let right_im1 = a.im + (b + c).im
    let right_re2 = a.re + (b.re + c.re)
    let right_im2 = a.im + (b.im + c.im)

    // Apply real number associativity
      // Real.assoc_add

      // Real.assoc_add

    // Build final complexes
    let final_left = Complex.new(left_re2, left_im2)
    let final_right = Complex.new(right_re2, right_im2)

    // Component-wise equality
    a.im + (b.im + c.im) = a.im + b.im + c.im
    a.re + (b.re + c.re) = a.re + b.re + c.re
    Complex.new((a + b).re + c.re, (a + b).im + c.im) = a + b + c
    Complex.new(a.re + (b + c).re, a.im + (b + c).im) = a + (b + c)
    Complex.new(a.re + b.re, a.im + b.im) = a + b
    Complex.new(b.re + c.re, b.im + c.im) = b + c
    Complex.new(a.re + b.re, a.im + b.im).im = a.im + b.im
    Complex.new(b.re + c.re, b.im + c.im).im = b.im + c.im
    Complex.new(a.re + b.re, a.im + b.im).re = a.re + b.re
    Complex.new(b.re + c.re, b.im + c.im).re = b.re + c.re
}

theorem add_zero_right(a: Complex) {
    a + Complex.0 = a
} by {
    Complex.new(a.re + Complex.0.re, a.im + Complex.0.im) = a + Complex.0
    Complex.new(a.re, a.im) = a
    a.im + Complex.0.im = Complex.0.im + a.im
    a.re + Complex.0.re = Complex.0.re + a.re
    Complex.new(Real.0, Real.0).im = Real.0
    Complex.new(Real.0, Real.0).re = Real.0
    Real.0 + a.im = a.im
    Real.0 + a.re = a.re
}

theorem add_zero_left(a: Complex) {
    Complex.0 + a = a
}

// Multiplication properties
theorem mul_comm(a: Complex, b: Complex) {
    a * b = b * a
}

// Distributive property of multiplication over addition
theorem distrib(a: Complex, b: Complex, c: Complex) {
    a * (b + c) = a * b + a * c
} by {
    let left = a * (b + c)
    let right = a * b + a * c

    // Expand (b + c)
    (b + c).re = b.re + c.re
    (b + c).im = b.im + c.im

    // Simplify left.re
    left.re = a.re * (b + c).re - a.im * (b + c).im
    a.re * (b.re + c.re) = a.re * b.re + a.re * c.re
    a.im * (b.im + c.im) = a.im * b.im + a.im * c.im
    left.re = a.re * b.re + a.re * c.re - a.im * b.im - a.im * c.im

    // Simplify left.im
    left.im = a.re * (b + c).im + a.im * (b + c).re
    a.re * (b.im + c.im) = a.re * b.im + a.re * c.im
    a.im * (b.re + c.re) = a.im * b.re + a.im * c.re
    left.im = a.re * b.im + a.re * c.im + a.im * b.re + a.im * c.re

    // Simplify right.re
    (a * b).re = a.re * b.re - a.im * b.im
    (a * c).re = a.re * c.re - a.im * c.im
    right.re = (a * b).re + (a * c).re
    right.re = a.re * b.re - a.im * b.im + a.re * c.re - a.im * c.im
    a.re * b.re - a.im * b.im + a.re * c.re - a.im * c.im = a.re * b.re + a.re * c.re - a.im * b.im - a.im * c.im

    // Simplify right.im
    (a * b).im = a.re * b.im + a.im * b.re
    (a * c).im = a.re * c.im + a.im * c.re
    right.im = (a * b).im + (a * c).im
    right.im = a.re * b.im + a.im * b.re + a.re * c.im + a.im * c.re
    // Rearrange terms
    a.im * b.re + a.re * c.im = a.re * c.im + a.im * b.re
    a.re * b.im + a.im * b.re + a.re * c.im = a.re * b.im + a.re * c.im + a.im * b.re
    a.re * b.im + a.im * b.re + a.re * c.im + a.im * c.re = a.re * b.im + a.re * c.im + a.im * b.re + a.im * c.re
}

theorem mul_three_re(a: Complex, b: Complex, c: Complex) {
    ((a * b) * c).re = a.re * b.re * c.re - a.re * b.im * c.im - a.im * b.re * c.im - a.im * b.im * c.re
} by {
    (a * b).re = a.re * b.re - a.im * b.im
    (a * b).im = a.re * b.im + a.im * b.re
    ((a * b) * c).re = (a * b).re * c.re - (a * b).im * c.im
    ((a * b) * c).re = (a.re * b.re - a.im * b.im) * c.re - (a.re * b.im + a.im * b.re) * c.im
    (a.re * b.re - a.im * b.im) * c.re = a.re * b.re * c.re - a.im * b.im * c.re
    (a.re * b.im + a.im * b.re) * c.im = a.re * b.im * c.im + a.im * b.re * c.im
}

theorem mul_three_im(a: Complex, b: Complex, c: Complex) {
    ((a * b) * c).im = a.re * b.re * c.im + a.re * b.im * c.re + a.im * b.re * c.re - a.im * b.im * c.im
} by {
    (a * b).re = a.re * b.re - a.im * b.im
    (a * b).im = a.re * b.im + a.im * b.re
    ((a * b) * c).im = (a * b).re * c.im + (a * b).im * c.re
    ((a * b) * c).im = (a.re * b.re - a.im * b.im) * c.im + (a.re * b.im + a.im * b.re) * c.re
    (a.re * b.re - a.im * b.im) * c.im = a.re * b.re * c.im - a.im * b.im * c.im
    (a.re * b.im + a.im * b.re) * c.re = a.re * b.im * c.re + a.im * b.re * c.re
}

theorem mul_assoc(a: Complex, b: Complex, c: Complex) {
    (a * b) * c = a * (b * c)
} by {
    // The real parts are equal
    a.im * (b.im * c.re) = a.im * b.im * c.re
    a.im * (b.re * c.im) = a.im * b.re * c.im
    a.re * (b.im * c.im) = a.re * b.im * c.im
    a.re * (b.re * c.re) = a.re * b.re * c.re
    a.re * b.re * c.re - a.im * b.re * c.im - a.re * b.im * c.im = a.re * b.re * c.re - a.re * b.im * c.im - a.im * b.re * c.im
    b.re * c.re * a.re - b.re * c.im * a.im - b.im * c.im * a.re - b.im * c.re * a.im = b.re * c.re * a.re - b.re * c.im * a.im - b.im * c.re * a.im - b.im * c.im * a.re
    a * (b * c) = b * c * a
    a.im * (b.im * c.re) = b.im * c.re * a.im
    a.im * (b.re * c.im) = b.re * c.im * a.im
    a.re * (b.im * c.im) = b.im * c.im * a.re
    a.re * (b.re * c.re) = b.re * c.re * a.re
    a.re * b.re * c.re - a.re * b.im * c.im - a.im * b.re * c.im - a.im * b.im * c.re = (a * b * c).re
    b.re * c.re * a.re - b.re * c.im * a.im - b.im * c.re * a.im - b.im * c.im * a.re = (b * c * a).re
    ((a * b) * c).re = (a * (b * c)).re

    // The imaginary parts are equal
    a.im * (b.im * c.im) = a.im * b.im * c.im
    a.im * (b.re * c.re) = a.im * b.re * c.re
    a.re * (b.im * c.re) = a.re * b.im * c.re
    a.re * (b.re * c.im) = a.re * b.re * c.im
    b.re * c.re * a.im + (b.re * c.im * a.re + b.im * c.re * a.re) = b.re * c.re * a.im + b.re * c.im * a.re + b.im * c.re * a.re
    a.im * (b.im * c.im) = b.im * c.im * a.im
    a.im * (b.re * c.re) = b.re * c.re * a.im
    a.re * (b.im * c.re) = b.im * c.re * a.re
    a.re * (b.re * c.im) = b.re * c.im * a.re
    a.im * b.re * c.re + (a.re * b.re * c.im + a.re * b.im * c.re) = a.re * b.re * c.im + a.re * b.im * c.re + a.im * b.re * c.re
    a.re * b.re * c.im + a.re * b.im * c.re + a.im * b.re * c.re - a.im * b.im * c.im = (a * b * c).im
    b.re * c.re * a.im + b.re * c.im * a.re + b.im * c.re * a.re - b.im * c.im * a.im = (b * c * a).im
    ((a * b) * c).im = (a * (b * c)).im
}

/// Yields the additive inverse of this complex number.
instance Complex: Neg {
    define neg(self) -> Complex {
        Complex.new(-self.re, -self.im)
    }
}

theorem neg_one {
    -Complex.1 = Complex.new(-Real.1, Real.0)
} by {
    Complex.1 = Complex.new(Real.1, Real.0)
    -Complex.1 = Complex.new(-Complex.1.re, -Complex.1.im)
    Complex.1.re = Real.1
    Complex.1.im = Real.0
    -Real.0 = Real.0
    (-Complex.1).re = -Real.1
    (-Complex.1).im = Real.0
}

theorem neg_re(a: Complex) {
    -(a.re) = (-a).re
}

theorem neg_im(a: Complex) {
    -(a.im) = (-a).im
}

theorem neg_one_lifts {
    -Complex.1 = Complex.from_real(-Real.1)
}

// Properties of i
theorem i_squared {
    Complex.i * Complex.i = Complex.new(-Real.1, Real.0)
} by {
    Complex.i = Complex.new(Real.0, Real.1)
    Complex.new(Real.0, Real.1).re = Real.0
    Complex.new(Real.0, Real.1).im = Real.1
    Complex.i * Complex.i = Complex.new(Real.0 * Real.0 - Real.1 * Real.1, Real.0 * Real.1 + Real.1 * Real.0)
    Real.0 * Real.0 = Real.0
    Real.1 * Real.1 = Real.1
    Real.0 - Real.1 = -Real.1
    Real.0 * Real.1 = Real.0
    Real.1 * Real.0 = Real.0
    Real.0 + Real.0 = Real.0
    Complex.new(Real.0 * Real.0 - Real.1 * Real.1, Real.0 * Real.1 + Real.1 * Real.0) = Complex.new(-Real.1, Real.0)
}

theorem conj_mul(a: Complex, b: Complex) {
    (a * b).conj = a.conj * b.conj
} by {
    a.conj = Complex.new(a.re, -a.im)
    b.conj = Complex.new(b.re, -b.im)
    Complex.new(a.re, -a.im).re = a.re
    Complex.new(a.re, -a.im).im = -a.im
    Complex.new(b.re, -b.im).re = b.re
    Complex.new(b.re, -b.im).im = -b.im

    // Calculate components of a.conj * b.conj
    let real_part: Real = a.re * b.re - (-a.im) * (-b.im)
    let imag_part: Real = a.re * (-b.im) + (-a.im) * b.re

    // Simplify real_part
    -a.im * -b.im = a.im * b.im
    real_part = a.re * b.re - a.im * b.im
    (a * b).re = a.re * b.re - a.im * b.im

    // Simplify imag_part
    a.re * -b.im = -(a.re * b.im)
    -a.im * b.re = -(a.im * b.re)
    imag_part = -(a.re * b.im) + -(a.im * b.re)
    -(a.re * b.im) + -(a.im * b.re) = -(a.re * b.im + a.im * b.re)
    (a * b).im = a.re * b.im + a.im * b.re
    imag_part = -((a * b).im)

    (a * b).conj = Complex.new((a * b).re, -((a * b).im))
    Complex.new(real_part, imag_part) = Complex.new((a * b).re, -((a * b).im))
}

theorem conj_conj(a: Complex) {
    a.conj.conj = a
}

// Absolute value properties
theorem abs_squared_conj(a: Complex) {
    a * a.conj = Complex.new(a.abs_squared, Real.0)
} by {
    a.conj = Complex.new(a.re, -a.im)
    Complex.new(a.re, -a.im).re = a.re
    Complex.new(a.re, -a.im).im = -a.im
    a * a.conj = Complex.new(a.re * a.re - a.im * (-a.im), a.re * (-a.im) + a.im * a.re)
    a.im * -a.im = -(a.im * a.im)
    --(a.im * a.im) = a.im * a.im
    a.re * a.re - -(a.im * a.im) = a.re * a.re + a.im * a.im
    a.re * -a.im = -(a.re * a.im)
    a.im * a.re = a.re * a.im
    -(a.re * a.im) + a.re * a.im = Real.0
    a.abs_squared = a.re * a.re + a.im * a.im
}

// Absolute value squared is non-negative
theorem abs_squared_nonneg(a: Complex) {
    a.abs_squared >= Real.0
} by {
    // Definition of abs_squared

    // Define variables for clearer proof steps
    let re_square: Real = a.re * a.re
    let im_square: Real = a.im * a.im

    // Squares of real numbers are non-negative

    // By definition of re_square and im_square

    // Therefore
    re_square >= Real.0
    im_square >= Real.0

    // If x >= 0 and y >= 0, then x + y >= 0
    re_square + im_square >= Real.0

    // By definition of abs_squared
}

// Multiplicative identity
theorem mul_one_right(a: Complex) {
    a * Complex.1 = a
} by {
    Complex.1 = Complex.new(Real.1, Real.0)
    Complex.new(Real.1, Real.0).re = Real.1
    Complex.new(Real.1, Real.0).im = Real.0
    a * Complex.1 = Complex.new(
        a.re * Real.1 - a.im * Real.0,
        a.re * Real.0 + a.im * Real.1
    )
    a.re * Real.1 = a.re
    a.im * Real.0 = Real.0
    a.re * Real.0 = Real.0
    a.im * Real.1 = a.im
    a.re - Real.0 = a.re
    Real.0 + a.im = a.im
}

theorem mul_one_left(a: Complex) {
    Complex.1 * a = a
}

// Conjugate distribution over addition
theorem conj_add(a: Complex, b: Complex) {
    (a + b).conj = a.conj + b.conj
} by {
    a + b = Complex.new(a.re + b.re, a.im + b.im)
    (a + b).conj = Complex.new(a.re + b.re, -(a.im + b.im))
    -(a.im + b.im) = -a.im + -b.im
    a.conj = Complex.new(a.re, -a.im)
    b.conj = Complex.new(b.re, -b.im)
    a.conj + b.conj = Complex.new(a.re + b.re, -a.im + -b.im)
}

/// Computes the multiplicative inverse (1/z) for non-zero complex numbers.
/// Yields 0 when applied to 0 (division by zero yields zero).
instance Complex: Inverse {
    define inverse(self) -> Complex {
        self.conj * Complex.from_real(self.abs_squared.inverse)
    }
}

theorem mul_from_real(c: Complex, r: Real) {
    c * Complex.from_real(r) = Complex.new(c.re * r, c.im * r)
} by {
    Complex.from_real(r) = Complex.new(r, Real.0)
    Complex.new(r, Real.0).re = r
    Complex.new(r, Real.0).im = Real.0
    c * Complex.new(r, Real.0) = Complex.new(r, Real.0) * c
    Complex.new(r, Real.0) * c = Complex.new(r * c.re - Real.0 * c.im, r * c.im + Real.0 * c.re)
    r * c.re = c.re * r
    r * c.im = c.im * r
    Real.0 * c.im = Real.0
    Real.0 * c.re = Real.0
    c * Complex.new(r, Real.0) = Complex.new(c.re * r - Real.0, c.im * r + Real.0)
    c.re * r - Real.0 = c.re * r
    c.im * r + Real.0 = c.im * r
}

theorem real_mul_lifts(a: Real, b: Real) {
    Complex.from_real(a * b) = Complex.from_real(a) * Complex.from_real(b)
} by {
    Complex.from_real(a * b) = Complex.new(a * b, Real.0)
    Complex.from_real(a) = Complex.new(a, Real.0)
    Complex.from_real(b) = Complex.new(b, Real.0)
    Complex.new(a, Real.0).re = a
    Complex.new(a, Real.0).im = Real.0
    Complex.from_real(a) * Complex.from_real(b) = Complex.new(a * b, Real.0 * b)
    Real.0 * b = Real.0
}

theorem real_add_lifts(a: Real, b: Real) {
    Complex.from_real(a + b) = Complex.from_real(a) + Complex.from_real(b)
} by {
    Complex.from_real(a + b) = Complex.new(a + b, Real.0)
    Complex.from_real(a) = Complex.new(a, Real.0)
    Complex.from_real(b) = Complex.new(b, Real.0)
    Complex.from_real(a) + Complex.from_real(b) = Complex.new(a + b, Real.0 + Real.0)
    Real.0 + Real.0 = Real.0
}

theorem neg_eq_mul_neg_one(a: Complex) {
    -a = (-Complex.1) * a
}

theorem abs_sq_zero_imp_zero(a: Complex) {
    a.abs_squared = Real.0 implies a = Complex.0
} by {
    a.abs_squared = a.re * a.re + a.im * a.im
    a.re * a.re + a.im * a.im = Real.0
    Real.0 <= a.re * a.re
    a.im * a.im = Real.0 - a.re * a.re
    Real.0 - a.re * a.re <= Real.0
    a.im * a.im <= Real.0
    a.im = Real.0
    a.re * a.re = Real.0
    a.re = Real.0
}

theorem mul_inverse(a: Complex) {
    a != Complex.0 implies a * a.inverse = Complex.1
} by {
    a * (a.conj * Complex.from_real(a.abs_squared.inverse)) = a * a.conj * Complex.from_real(a.abs_squared.inverse)
    Complex.from_real(a.abs_squared) * Complex.from_real(a.abs_squared.inverse) = Complex.from_real(a.abs_squared * a.abs_squared.inverse)
    a.conj * Complex.from_real(a.abs_squared.inverse) = a.inverse
    Complex.new(a.abs_squared, Real.0) = a * a.conj
    a.abs_squared * a.abs_squared.inverse = Real.1 or a.abs_squared = Real.0
    a.abs_squared != Real.0 or Complex.0 = a
    Complex.new(Complex.1.re, Real.0) = Complex.from_real(Complex.1.re)
    Complex.new(a.abs_squared, Real.0) = Complex.from_real(a.abs_squared)
    Complex.new(Real.1, Real.0).re = Real.1
}

theorem mul_right_cancel(a: Complex, b: Complex, c: Complex) {
    a * c = b * c and c != Complex.0 implies a = b
} by {
    a * c * c.inverse = a * (c * c.inverse)
    b * c * c.inverse = b * (c * c.inverse)
    c * c.inverse = Complex.1 or Complex.0 = c
    a * Complex.1 = Complex.1 * a
    b * Complex.1 = Complex.1 * b
    Complex.new(a.re, a.im) = a
    Complex.new(b.re, b.im) = b
    Complex.1 * Complex.new(a.re, a.im) = Complex.new(a.re, a.im)
    Complex.1 * Complex.new(b.re, b.im) = Complex.new(b.re, b.im)
}

theorem mul_left_cancel(a: Complex, b: Complex, c: Complex) {
    a * b = a * c and a != Complex.0 implies b = c
}

theorem inverse_lifts(a: Real) {
    Complex.from_real(a).inverse = Complex.from_real(a.inverse)
} by {
    // Key definitions that help the prover
    Complex.new(a, Real.0).re = a
    Complex.new(a, Real.0).im = Real.0
    Complex.from_real(a) = Complex.new(a, Real.0)
    Complex.new(Real.0.inverse, Real.0) = Complex.from_real(Real.0.inverse)
    Real.1 + Real.0 = Real.1
    Real.1 * Real.0 = Real.0
    Complex.from_real(a).re = a
    Complex.from_real(a).im = Real.0

    // Abs squared and conj from definitions
    Complex.from_real(a).re * Complex.from_real(a).re + Complex.from_real(a).im * Complex.from_real(a).im = Complex.from_real(a).abs_squared
    a * a + Real.0 * Real.0 = Complex.from_real(a).abs_squared
    Real.0 * Real.0 = Real.0
    a * a + Real.0 = a * a
    Complex.from_real(a).abs_squared = a * a
    Complex.from_real(a).conj * Complex.from_real(Complex.from_real(a).abs_squared.inverse) = Complex.from_real(a).inverse

    // Conj of from_real(a)
    Complex.from_real(a).conj = Complex.new(a, -Real.0)
    -Real.0 = Real.0
    Complex.from_real(a).conj = Complex.new(a, Real.0)
    Complex.from_real(a).conj = Complex.from_real(a)

    // Compute the mul_from_real result
    Complex.new(Complex.from_real(a).conj.re * Complex.from_real(a).abs_squared.inverse, Complex.from_real(a).conj.im * Complex.from_real(a).abs_squared.inverse) = Complex.from_real(a).conj * Complex.from_real(Complex.from_real(a).abs_squared.inverse)

    if a = Real.0 {
        Real.0.inverse = Real.0
        a.inverse = Real.0
        Complex.from_real(Real.0) = Complex.0
        Complex.0.inverse = Complex.0
        Complex.from_real(a.inverse) = Complex.0
        Complex.from_real(a).inverse = Complex.0
    } else {
        a != Real.0
        Complex.0 = Complex.new(Real.0, Real.0)
        Complex.new(a, Real.0) != Complex.new(Real.0, Real.0)
        Complex.from_real(a) != Complex.0

        // Compute the inverse of Complex.from_real(a)
        Complex.from_real(a).inverse = Complex.from_real(a) * Complex.from_real((a * a).inverse)

        // Use real_mul_lifts
        Complex.from_real(a) * Complex.from_real((a * a).inverse) = Complex.from_real(a * (a * a).inverse)

        // Show a * (a * a).inverse = a.inverse
        (a * a).inverse * (a * a) = Real.1 or a * a = Real.0
        a * a != Real.0
        (a * a).inverse * (a * a) = Real.1
        a * (a * a).inverse * a = Real.1
        a.inverse * a = Real.1
        a * (a * a).inverse = a.inverse

        Complex.from_real(a * (a * a).inverse) = Complex.from_real(a.inverse)
        Complex.from_real(a).inverse = Complex.from_real(a.inverse)
    }
}

theorem zero_inverse {
    Complex.0.inverse = Complex.0
}

attributes Complex {
    /// Divides this complex number by another.
    /// Division by zero returns zero (making this a total function).
    define div(self, other: Complex) -> Complex {
        self * other.inverse
    }
}

// Demonstrating that Complex is a field.

from add_semigroup import AddSemigroup

instance Complex: AddSemigroup

from add_comm_semigroup import AddCommSemigroup

instance Complex: AddCommSemigroup

from add_monoid import AddMonoid

instance Complex: AddMonoid

from add_comm_monoid import AddCommMonoid

instance Complex: AddCommMonoid

from semigroup import Semigroup

instance Complex: Semigroup

from monoid import Monoid

instance Complex: Monoid

theorem mul_zero_right(a: Complex) {
    a * Complex.0 = Complex.0
} by {
    a * Complex.new(Real.0, Real.0) = Complex.new(Real.0, Real.0)
}

theorem mul_zero_left(a: Complex) {
    Complex.0 * a = Complex.0
}

from semiring import Semiring

instance Complex: Semiring

from add_group import AddGroup

theorem add_neg_cancel(a: Complex) {
    a + -a = Complex.0
} by {
    (-a).re = -a.re
    (-a).im = -a.im
    a.re + -a.re = Real.0
    a.im + -a.im = Real.0
}

instance Complex: AddGroup

from add_comm_group import AddCommGroup

instance Complex: AddCommGroup

from ring import Ring

instance Complex: Ring

from comm_semigroup import CommSemigroup

instance Complex: CommSemigroup

from comm_monoid import CommMonoid

instance Complex: CommMonoid

from comm_ring import CommRing

instance Complex: CommRing

from field import Field

theorem zero_is_different_than_one {
    Complex.0 != Complex.1
} by {
    Complex.0 = Complex.new(Real.0, Real.0)
    Complex.1 = Complex.new(Real.1, Real.0)
    Complex.new(Real.0, Real.0).re = Real.0
    Complex.new(Real.1, Real.0).re = Real.1
    Real.0 != Real.1
}

instance Complex: Field