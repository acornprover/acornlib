from list import List, map
from group import Group, has_finite_order
from nat import Nat
numerals Nat

/// A group is finite if its elements can be placed in a (finite) list
typeclass G: FiniteGroup extends Group {
    /// A list containing all elements of the group.
    elements: List[G]

    /// Every group element appears in the elements list.
    all_group_elements_in_elements(g: G) {
        G.elements.contains_every
    }
    /// The elements list contains no duplicates.
    unique_elements_list {
        G.elements.is_unique
    }
}

attributes G: FiniteGroup {
    /// The number of elements in the group.
    let order: Nat = G.elements.length
}

from subgroup import Subgroup, subgroup_constraint, identity_subgroup
from set import finite_constraint

theorem subgroup_of_finite_group_is_finite[G: FiniteGroup](s: Subgroup[G]) {
    finite_constraint(s.contains)
}

/// A finite subgroup of a finite group.
structure FiniteSubgroup[G: FiniteGroup] {
    /// A list containing all elements of the subgroup.
    elements: List[G]
} constraint {
    elements.is_unique and subgroup_constraint(elements.contains)
} by {
    let s = List.singleton[G](G.1)

    forall(x: G) {
        if s.contains(x) {
            x = G.1
            identity_subgroup[G].contains(x)
        } else {
            not identity_subgroup[G].contains(x)
        }
        s.contains(x) = identity_subgroup[G].contains(x)
    }
    s.contains = identity_subgroup[G].contains
    subgroup_constraint(s.contains)
}

attributes FiniteSubgroup[G: FiniteGroup] {
    /// The number of elements in the subgroup.
    define order(self) -> Nat {
        self.elements.length
    }
}

attributes G: FiniteGroup {
    /// The trivial subgroup containing only the identity element.
    let identity_subgroup: FiniteSubgroup[G] = FiniteSubgroup.new(List.singleton[G](G.1))

    /// The cyclic subgroup generated by this element.
    // TODO: prove this actually is the subgroup you'd expect, not a degenerate case.
    define cyclic_subgroup(self) -> FiniteSubgroup[G] {
        FiniteSubgroup.new(map(G.order.range, self.pow).unique)
    }
}

theorem subgroup_has_order_at_most_G_order[G: FiniteGroup](s: FiniteSubgroup[G]) {
    s.order <= G.order
} by {
    forall(x: G) {
        s.elements.contains(x) implies G.elements.contains(x)
    }
    s.elements.unique.length <= G.elements.length
    s.elements.is_unique
}

from option import Option

theorem all_elements_have_order_at_most_G[G: FiniteGroup](g: G) {
    exists (n: Nat) {
        n > 0 and n <= G.order and g.pow(n) = G.1
    }
} by {
    // Proof idea: apply pigeonhole. G has |G| elements, take n = |G|+1 powers
    // of g, [1, g, ..., g.pow(n)], which means two elements at some indices i <
    // j match. Then `g.pow(i) = g.pow(j)` so we must have `g.pow(j - i) = G.1`,
    // or that the order is <= j - i <= |G|.
    let n = G.order + 1
    let f = g.pow
    let cyclic_subgroup = map(n.range, f)

    cyclic_subgroup.length = n
    cyclic_subgroup.unique.length <= G.elements.length

    // Prover help
    map(n.range, f).unique.length <= G.elements.length
    cyclic_subgroup.unique.length < cyclic_subgroup.length

    let (i: Nat, j: Nat) satisfy {
        i < j and j < cyclic_subgroup.length and
        f(i) = f(j)
    }

    j < n
    i < n
    // Prover help stuff
    g.pow(i) = g.pow(j)
    g.pow(j - i) = G.1

    // Weird prover help stuff
    let m = j - i
    j > i
    i + m = j
    m > 0
    // Since m + i = j < n
    m + i < n
    m < n
    
    // Conclusion
    m <= G.order
    g.pow(m) = G.1
}

theorem all_elements_have_finite_order[G: FiniteGroup](g: G) {
    has_finite_order(g)
}
