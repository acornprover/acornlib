from list import List, map
from group import Group, has_finite_order
from nat import Nat
numerals Nat

/// A group is finite if its elements can be placed in a (finite) list
typeclass G: FiniteGroup extends Group {
    /// A list containing all elements of the group.
    elements: List[G]

    /// Every group element appears in the elements list.
    all_group_elements_in_elements(g: G) {
        G.elements.contains_every
    }
    /// The elements list contains no duplicates.
    unique_elements_list {
        G.elements.is_unique
    }
}

attributes G: FiniteGroup {
    /// The number of elements in the group.
    let order: Nat = G.elements.length
}

from subgroup import Subgroup, subgroup_constraint, identity_constraint, inverse_constraint, closure_constraint, identity_subgroup, is_identity
from set import finite_constraint

theorem subgroup_of_finite_group_is_finite[G: FiniteGroup](s: Subgroup[G]) {
    finite_constraint(s.contains)
} by {
    forall(x: G) {
        s.contains(x) implies G.elements.contains(x)
    }
}

/// A finite subgroup of a finite group.
structure FiniteSubgroup[G: FiniteGroup] {
    /// A list containing all elements of the subgroup.
    elements: List[G]
} constraint {
    elements.is_unique and subgroup_constraint(elements.contains)
} by {
    let s = List.singleton[G](G.1)

    forall(x: G) {
        if s.contains(x) {
        } else {
            not identity_subgroup[G].contains(x)
        }
        not List.nil[G].contains(x)
        List.cons(G.1, List.nil[G]) = List.singleton(G.1)
        s.contains(x) = (x = G.1)
        s.contains(x) = identity_subgroup[G].contains(x)
    }
    s.contains = identity_subgroup[G].contains
    subgroup_constraint(s.contains)
}

attributes FiniteSubgroup[G: FiniteGroup] {
    /// The number of elements in the subgroup.
    define order(self) -> Nat {
        self.elements.length
    }
}

theorem identity_list_is_unique[G: FiniteGroup] {
    List.singleton[G](G.1).is_unique
}

theorem identity_meets_identity_constraint[G: FiniteGroup] {
    identity_constraint(List.singleton[G](G.1).contains)
}

theorem identity_meets_closure_constraint[G: FiniteGroup] {
    closure_constraint(List.singleton[G](G.1).contains)
} by {
    let s = List.singleton[G](G.1)
    forall(a: G, b: G) {
        if s.contains(a) and s.contains(b) {
            not List.nil[G].contains(a)
            List.cons(G.1, List.nil[G]) = s
            a = G.1
            b = G.1
            a * b = G.1
            s.contains(a * b)
        }
    }
}

theorem identity_meets_inverse_constraint[G: FiniteGroup] {
    inverse_constraint(List.singleton[G](G.1).contains)
} by {
    let s = List.singleton[G](G.1)
    forall(a: G) {
        if s.contains(a) {
            not List.nil[G].contains(a)
            List.cons(G.1, List.nil[G]) = s
            a = G.1
            G.1.inverse = G.1
            s.contains(a.inverse)
        }
    }
}

theorem identity_meets_subgroup_constraint[G: FiniteGroup] {
    subgroup_constraint(List.singleton[G](G.1).contains)
}

theorem identity_meets_fs_constraint[G: FiniteGroup] {
    FiniteSubgroup.constraint(List.singleton[G](G.1))
}

// TODO: why is this not just one step?
// let isg[G: FiniteGroup]: FiniteSubgroup[G] satisfy {
//     some(isg) = FiniteSubgroup.new_option(List.singleton[G](G.1))
// }

attributes G: FiniteGroup {
    /// The trivial subgroup containing only the identity element.
    let identity_subgroup: FiniteSubgroup[G] = FiniteSubgroup.new(List.singleton[G](G.1))

    /// The cyclic subgroup generated by this element.
    // TODO: prove this actually is the subgroup you'd expect, not a degenerate case.
    define cyclic_subgroup(self) -> FiniteSubgroup[G] {
        FiniteSubgroup.new(map(G.order.range, self.pow).unique)
    }
}

theorem subgroup_has_order_at_most_G_order[G: FiniteGroup](s: FiniteSubgroup[G]) {
    s.order <= G.order
} by {
    s.elements.unique.length <= G.elements.length
    s.elements.is_unique
}

theorem all_elements_have_order_at_most_G[G: FiniteGroup](g: G) {
    exists (n: Nat) {
        n > 0 and n <= G.order and g.pow(n) = G.1
    }
} by {
    // Proof idea: apply pigeonhole. G has |G| elements, take n = |G|+1 powers
    // of g, [1, g, ..., g.pow(n)], which means two elements at some indices i <
    // j match. Then `g.pow(i) = g.pow(j)` so we must have `g.pow(j - i) = G.1`,
    // or that the order is <= j - i <= |G|.
    let n = G.order + 1
    let f = g.pow
    let cyclic_subgroup = map(n.range, f)

    map[Nat, G](n.range, f).length = n.range.length
    n.range.length = n
    cyclic_subgroup.length = n

    // Prover help
    map(n.range, f).unique.length <= G.elements.length
    cyclic_subgroup.unique.length <= G.elements.length
    G.elements.length < n
    cyclic_subgroup.unique.length < n
    cyclic_subgroup.unique.length < cyclic_subgroup.length
    map(n.range, f).unique.length < n

    let (i: Nat, j: Nat) satisfy {
        i < j and j < cyclic_subgroup.length and
        f(i) = f(j)
    }

    // Prover help stuff

    // Weird prover help stuff
    let m = j - i
    i + m = j
    // Since m + i = j < n
    m < n

    // Conclusion
    m <= G.order
    g.pow(m) = G.1
}

theorem all_elements_have_finite_order[G: FiniteGroup](g: G) {
    has_finite_order(g)
} by {
    let (n: Nat) satisfy {
        n > 0 and n <= G.order and g.pow(n) = G.1
    }
    n != Nat.0
}
