from nat import Nat
from int import Int
from comm_ring import CommRing
from monoid import Monoid

/// A field is a commutative ring with multiplicative inverses for all non-zero elements.
typeclass F: Field extends CommRing {
    /// The multiplicative inverse function.
    inverse: F -> F

    /// We define the field inverse so that the inverse of zero is zero.
    /// It would be nice to instead express that an inverse is "not valid" or yields "no value"
    /// but it is not convenient to do so in the current type system.
    field_inverse_zero {
        F.0.inverse = F.0
    }

    /// The definition of "multiplicative inverse" in a field.
    field_inverse(f: F) {
        f != F.0 implies f * f.inverse = F.1
    }

    zero_and_one_are_distinct {
        F.0 != F.1
    }
}

attributes F: Field {
    /// Extends Monoid.pow to raise a field element to an integer.
    /// Similar to how we define Field.inverse this defines `F.0`.zpow(x) for negative x to be `0`.
    define zpow(self, exp: Int) -> F {
        match exp {
            Int.from_nat(n) {
                self.pow(n)
            }
            Int.neg_suc(k) {
                self.pow(k.suc).inverse
            }
        }
    }
}

theorem zero_pow_nonnegative[F: Field](n: Int) {
    n > Int.0 implies F.0.zpow(n) = F.0
} by {
    match n {
        Int.from_nat(k) {
            F.0.zpow(n) = F.0.pow(k)
            F.0.zpow(n) = F.0
        }
        Int.neg_suc(k) {
            n < Int.0
        }
    }
}

// inverses are unique
theorem unique_inverse[F: Field](a: F, b: F) {
    a * b = F.1 implies b = a.inverse
} by {
    if F.0 = F.1 {
        b = F.0
        a.inverse = F.0
    } else {
        a != F.0
        a.inverse * a * b = a.inverse * F.1
        a * a.inverse * b = a.inverse
        F.1 * b = a.inverse
    }
    
}

theorem inverse_inverse[F: Field](a: F) {
    a.inverse.inverse = a
}

// (a * b).inverse = a.inverse * b.inverse
theorem inverse_dist[F: Field](a: F, b: F) {
    (a * b).inverse = a.inverse * b.inverse
} by {
    if a = F.0 {
        (a * b).inverse = F.0.inverse
        (a * b).inverse = F.0
        a.inverse * b.inverse = F.0 * b.inverse
        a.inverse * b.inverse = F.0
        (a * b).inverse = a.inverse * b.inverse
    } else {
        if b = F.0 {
            (a * b).inverse = F.0.inverse
            (a * b).inverse = F.0
            a.inverse * b.inverse = a.inverse * F.0
            a.inverse * b.inverse = F.0
        } else {
            a * b * a.inverse * b.inverse = a * a.inverse * b * b.inverse
            a * b * a.inverse * b.inverse = F.1 * b * b.inverse
            (a * b) * (a.inverse * b.inverse) = F.1 * F.1
            (a * b) * (a.inverse * b.inverse) = F.1
            a.inverse * b.inverse = (a * b).inverse
        }
    }   
}

// a^(-n) = (a.inverse)^n for n Nat and >=1
theorem pow_inverse_nat[F: Field](a: F, k: Nat) {
    // n = k + 1
    a.zpow(Int.neg_suc(k)) = a.inverse.zpow(Int.from_nat(k.suc))
} by {
    let f: Nat -> Bool = function(x: Nat) {
        a.zpow(Int.neg_suc(x)) = a.inverse.zpow(Int.from_nat(x.suc))
    }
    // base case
    f(Nat.0)

    // Inductive step
    forall(l: Nat) {
        if f(l) {
            a.pow(l.suc.suc) = a.pow(l.suc) * a
            (a.pow(l.suc) * a).inverse = a.pow(l.suc).inverse * a.inverse
            f(l.suc)
        }
    }
}

// a^(-n) = (a.inverse)^n
theorem pow_inverse[F: Field](a: F, n: Int) {
    a.zpow(-n) = a.inverse.zpow(n)
} by {
    match n {
        Int.from_nat(k) {
            if k = Nat.0 {
                -n = Int.0
                a.zpow(-n) = F.1
                a.inverse.zpow(n) = F.1
                a.zpow(-n) = a.inverse.zpow(n)
            } else {
                let l: Nat satisfy { l.suc = k }
                -n = Int.neg_suc(l)
                a.zpow(-n) = a.inverse.zpow(Int.from_nat(l.suc))
                a.zpow(-n) = a.inverse.zpow(n)
            }
        }
        Int.neg_suc(k) {
            -n = Int.from_nat(k.suc)
            a.inverse.zpow(n) = a.inverse.inverse.zpow(Int.from_nat(k.suc))
            a.inverse.zpow(n) = a.zpow(Int.from_nat(k.suc))
            a.zpow(-n) = a.inverse.zpow(n)
        }
    }
}

theorem pow_nat_times_inverse[F: Field](a: F, n: Nat) {
   a != F.0 implies a.pow(n.suc) * a.inverse = a.pow(n)
} by {
    let f: Nat -> Bool = function(x: Nat) {
        a.pow(x.suc) * a.inverse = a.pow(x)
    }

    // base case
    f(Nat.0)

    // Induction step
    forall(l: Nat) {
        if f(l) {
            a.pow(l.suc) = a.pow(l) * a
            a.pow(l.suc) * a.inverse = a.pow(l)
            f(l.suc)
        }
    }
}

theorem pow_nat_sub_inverse[F: Field](a: F, n: Nat, m: Nat) {
    a != F.0 and m <= n implies a.pow(n) * a.inverse.pow(m) = a.pow(n - m)
} by {
    let f: Nat -> Bool = function(x: Nat) {
        x > n or a.pow(n) * a.inverse.pow(x) = a.pow(n - x)
    }

    // base case
    f(Nat.0)

    // Inductive step
    forall(l: Nat) {
        if f(l) {
            if l >= n {
                l.suc > n
                f(l.suc)
            } else {
                l.suc <= n
                a.inverse.pow(l.suc) = a.inverse.pow(l) * a.inverse
                a.pow(n) * a.inverse.pow(l.suc) = a.pow(n) * a.inverse.pow(l) * a.inverse
                a.pow(n) * a.inverse.pow(l.suc) = a.pow(n - l) * a.inverse
                n - l = (n - l.suc).suc
                a.pow(n) * a.inverse.pow(l.suc) = a.pow(n - l.suc)
                f(l.suc)
            }
        }
    }
}

theorem pow_sub_inverse[F: Field](a: F, n: Int, m: Int) {
    a != F.0 and n >= Int.0 and m >= Int.0 implies a.zpow(n) * a.inverse.zpow(m) = a.zpow(n - m)
} by {
    let l: Nat satisfy {
        n = Int.from_nat(l)
    }
    let k: Nat satisfy {
        m = Int.from_nat(k)
    }
    if m <= n {
        a.zpow(n) * a.inverse.zpow(m) = a.pow(l) * a.inverse.pow(k)
        k <= l
        a.zpow(n) * a.inverse.zpow(m) = a.pow(l - k)
        a.zpow(n) * a.inverse.zpow(m) = a.zpow(n - m)
    } else {
        a.zpow(n) * a.inverse.zpow(m) = a.inverse.zpow(m) * a.inverse.inverse.zpow(n)
        a.zpow(n) * a.inverse.zpow(m) = a.inverse.pow(k) * a.inverse.inverse.pow(l)
        l <= k
        a.inverse != F.0
        a.zpow(n) * a.inverse.zpow(m) = a.inverse.pow(k - l)
        a.zpow(n) * a.inverse.zpow(m) = a.inverse.zpow(m - n)
        a.zpow(n) * a.inverse.zpow(m) = a.zpow(n - m)
    }
}

theorem pow_add_nonnegative[F: Field](a: F, n: Int, m: Int) {
    n >= Int.0 and m >= Int.0 implies a.zpow(n) * a.zpow(m) = a.zpow(n + m)
} by {
    let l: Nat satisfy {
        n = Int.from_nat(l)
    }
    let k: Nat satisfy {
        m = Int.from_nat(k)
    }
    a.zpow(n) * a.zpow(m) = a.pow(l) * a.pow(k)
}

theorem pow_add[F: Field](a: F, n: Int, m: Int) {
    (n >= Int.0 and m >= Int.0) or a != F.0 implies a.zpow(n) * a.zpow(m) = a.zpow(n + m)
} by {
    if n >= Int.0 {
        if m >= Int.0 {
            a.zpow(n) * a.zpow(m) = a.zpow(n + m)
        } else {
            a.zpow(n) * a.zpow(m) = a.zpow(n) * a.inverse.zpow(-m)
            a.zpow(n) * a.zpow(m) = a.zpow(n - (-m))
            a.zpow(n) * a.zpow(m) = a.zpow(n + m)
        }
    } else {
        -n >= Int.0
        if m >= Int.0 {
            a.zpow(n) * a.zpow(m) = a.inverse.zpow(-n) * a.zpow(m)
            a.zpow(n) * a.zpow(m) = a.zpow(m) * a.inverse.zpow(-n)
            a.zpow(n) * a.zpow(m) = a.zpow(m - (-n))
            a.zpow(n) * a.zpow(m) = a.zpow(n + m)
        } else {
            -m >= Int.0
            a.zpow(n) * a.zpow(m) = a.inverse.zpow(-n) * a.inverse.zpow(-m)
            a.zpow(n) * a.zpow(m) = a.inverse.zpow(-n + (-m))
            a.zpow(n) * a.zpow(m) = a.zpow(n + m)
        }
    }
}

theorem zero_pow[F: Field](n: Int) {
    n != Int.0 implies F.0.zpow(n) = F.0
} by {
    if n > Int.0 {
    } else {
        n < Int.0
    }
}

theorem pow_inverse2[F: Field](a: F, n: Int) {
    a.zpow(-n) = a.zpow(n).inverse
} by {
    if a = F.0 {
        if n = Int.0 {
            a.zpow(-n) = F.1
            a.zpow(n) = F.1
            a.zpow(-n) = a.zpow(n).inverse
        } else {
            a.zpow(-n) = a.inverse.zpow(n)
            a.zpow(-n) = F.0.zpow(n)
            a.zpow(-n) = F.0
            a.zpow(n) = F.0
            a.zpow(-n) = a.zpow(n).inverse
        }
    } else {
        a.zpow(n) * a.zpow(-n) = a.zpow(n + -n)
    }
}

theorem one_pow[F: Field](n: Int) {
    F.1.zpow(n) = F.1
} by {
    match n {
        Int.from_nat(k) {
        }
        Int.neg_suc(k) {
            F.1.zpow(n) = F.1.inverse.zpow(-n)
            F.1.inverse = F.1
            F.1.zpow(n) = F.1.pow(k.suc)
        }
    }
}

theorem pow_pow_nonnegative[F: Field](a: F, n: Int, m: Int) {
    n >= Int.0 and m >= Int.0 implies a.zpow(n).zpow(m) = a.zpow(n * m)
} by {
     let l: Nat satisfy {
        n = Int.from_nat(l)
    }
    let k: Nat satisfy {
        m = Int.from_nat(k)
    }
    a.zpow(n).zpow(m) = a.pow(l).pow(k)
    a.zpow(n * m) = a.pow(l * k)
}

// Proof that (a^n)^m = a ^ (n * m)
theorem pow_pow[F: Field](a: F, n: Int, m: Int) {
    a != F.0 or (n >= Int.0 and m >= Int.0) implies a.zpow(n).zpow(m) = a.zpow(n * m)
} by {
    if n >= Int.0 {
        if m >= Int.0 {
            a.zpow(n).zpow(m) = a.zpow(n * m)
        } else {
            a != F.0
            a.zpow(n).zpow(m) = a.zpow(n).zpow(-m).inverse
            -m >= Int.0
            a.zpow(n).zpow(m) = a.zpow(n * (-m)).inverse
            a.zpow(n).zpow(m) = a.zpow(n * m)
        }
    } else {
        a != F.0
        -n >= Int.0
        if m >= Int.0 {
            a.zpow(n).zpow(m) = a.inverse.zpow(-n).zpow(m)
            a.zpow(n).zpow(m) = a.inverse.zpow(-n * m)
            a.zpow(n).zpow(m) = a.zpow(n * m)
        } else {
            m.is_negative
            -m >= Int.0
            a.zpow(n).zpow(m) = a.inverse.zpow(-n).zpow(-m).inverse
            a.zpow(n).zpow(m) = a.inverse.zpow(-n * -m).inverse
            a.zpow(n).zpow(m) = a.zpow(n * m)
        }
    }
}