from nat import Nat
from int import Int
from comm_ring import CommRing
from monoid import Monoid

/// A field is a commutative ring with multiplicative inverses for all non-zero elements.
typeclass F: Field extends CommRing {
    /// The multiplicative inverse function.
    inverse: F -> F

    /// We define the field inverse so that the inverse of zero is zero.
    /// It would be nice to instead express that an inverse is "not valid" or yields "no value"
    /// but it is not convenient to do so in the current type system.
    field_inverse_zero {
        F.0.inverse = F.0
    }

    /// The definition of "multiplicative inverse" in a field.
    field_inverse(f: F) {
        f != F.0 implies f * f.inverse = F.1
    }
}

attributes F: Field {
    /// Extends Monoid.pow to raise a field element to an integer.
    /// Similar to how we define Field.inverse this defines `F.0`.pow(x) for negative x to be `0`.
    define pow(self, exp: Int) -> F {
        match exp {
            Int.from_nat(n) {
                Monoid.pow(self, n)
            }
            Int.neg_suc(k) {
                Monoid.pow(self, k.suc).inverse
            }
        }
    }
}

// inverses are unique
theorem unique_inverse[F: Field](a: F, b: F) {
    a * b = F.1 implies a = b.inverse
} by {
    a * b * b.inverse = F.1 * b.inverse
    a * F.1 = b.inverse
}

// (a * b).inverse = a.inverse * b.inverse
theorem inverse_dist[F: Field](a: F, b: F) {
    (a * b).inverse = a.inverse * b.inverse
} by {
    b * a.inverse = a.inverse * b
    a * b * a.inverse * b.inverse = a * a.inverse * b * b.inverse
}

// a^(-n) = (a.inverse)^n
theorem pow_inverse[F: Field](a: F, k: Nat) {
    // n = k + 1
    a.pow(Int.neg_suc(k)) = a.inverse.pow(Int.from_nat(k.suc))
} by {
    // base case
    a.pow(Int.neg_suc(Nat.0)) = a.inverse.pow(Int.from_nat(Nat.0.suc))

    // Inductive step
    forall(l: Nat) {
        if a.pow(Int.neg_suc(l)) = a.inverse.pow(Int.from_nat(l.suc)) {
            Monoid.pow(a, l.suc.suc) = Monoid.pow(a, l.suc) * a
            (Monoid.pow(a, l.suc) * a).inverse = Monoid.pow(a, l.suc).inverse * a.inverse
        }
    }
}

// // Proof that a^n * a^m = a^(n+m)
// theorem pow_add[F: Field](a: F, n: Int, m: Int) {
//     a.pow(n) * a.pow(m) = a.pow(n + m)
// } by {
//     match n {
//         Int.from_nat(k) {
//             match m {
//                 Int.from_nat(l) {
//                     Monoid.pow(a, k) * Monoid.pow(a, l) = Monoid.pow(a, k + l)
//                 }
//                 Int.neg_suc(l) {
//                     if l.suc <= k {

//                     } else {
//                     }
//                     Monoid.pow(a, k) * Monoid.pow(a, l.suc).inverse = 
//                 }
//             }
//         }
//         Int.neg_suc(k) {

//         }
//     }
// }
