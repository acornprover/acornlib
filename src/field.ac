from nat import Nat
from int import Int
from comm_ring import CommRing
from monoid import Monoid

/// A field is a commutative ring with multiplicative inverses for all non-zero elements.
typeclass F: Field extends CommRing {
    /// The multiplicative inverse function.
    inverse: F -> F

    /// We define the field inverse so that the inverse of zero is zero.
    /// It would be nice to instead express that an inverse is "not valid" or yields "no value"
    /// but it is not convenient to do so in the current type system.
    field_inverse_zero {
        F.0.inverse = F.0
    }

    /// The definition of "multiplicative inverse" in a field.
    field_inverse(f: F) {
        f != F.0 implies f * f.inverse = F.1
    }
}

attributes F: Field {
    /// Extends Monoid.pow to raise a field element to an integer.
    /// Similar to how we define Field.inverse this defines `F.0`.pow(x) for negative x to be `0`.
    define pow(self, exp: Int) -> F {
        match exp {
            Int.from_nat(n) {
                Monoid.pow(self, n)
            }
            Int.neg_suc(k) {
                Monoid.pow(self, k.suc).inverse
            }
        }
    }
}

theorem zero_pow[F: Field](n: Int) {
    n > Int.0 implies F.0.pow(n) = F.0
} by {
    match n {
        Int.from_nat(k) {
            F.0.pow(n) = Monoid.pow(F.0, k)
            F.0.pow(n) = F.0
        }
        Int.neg_suc(k) {
            n < Int.0
        }
    }
}

// inverses are unique
theorem unique_inverse[F: Field](a: F, b: F) {
    a * b = F.1 implies b = a.inverse
} by {
    if F.0 = F.1 {
        b = F.0
        a.inverse = F.0
    } else {
        a != F.0
        a.inverse * a * b = a.inverse * F.1
        a * a.inverse * b = a.inverse
        F.1 * b = a.inverse
    }
    
}

theorem inverse_inverse[F: Field](a: F) {
    a.inverse.inverse = a
}

// (a * b).inverse = a.inverse * b.inverse
theorem inverse_dist[F: Field](a: F, b: F) {
    (a * b).inverse = a.inverse * b.inverse
} by {
    if a = F.0 {
        (a * b).inverse = F.0.inverse
        (a * b).inverse = F.0
        a.inverse * b.inverse = F.0 * b.inverse
        a.inverse * b.inverse = F.0
        (a * b).inverse = a.inverse * b.inverse
    } else {
        if b = F.0 {
            (a * b).inverse = F.0.inverse
            (a * b).inverse = F.0
            a.inverse * b.inverse = a.inverse * F.0
            a.inverse * b.inverse = F.0
        } else {
            a * b * a.inverse * b.inverse = a * a.inverse * b * b.inverse
            a * b * a.inverse * b.inverse = F.1 * b * b.inverse
            (a * b) * (a.inverse * b.inverse) = F.1 * F.1
            (a * b) * (a.inverse * b.inverse) = F.1
            a.inverse * b.inverse = (a * b).inverse
        }
    }   
}

// a^(-n) = (a.inverse)^n for n Nat and >=1
theorem pow_inverse_nat[F: Field](a: F, k: Nat) {
    // n = k + 1
    a.pow(Int.neg_suc(k)) = a.inverse.pow(Int.from_nat(k.suc))
} by {
    let f: Nat -> Bool = function(x: Nat) {
        a.pow(Int.neg_suc(x)) = a.inverse.pow(Int.from_nat(x.suc))
    }
    // base case
    f(Nat.0)

    // Inductive step
    forall(l: Nat) {
        if f(l) {
            Monoid.pow(a, l.suc.suc) = Monoid.pow(a, l.suc) * a
            (Monoid.pow(a, l.suc) * a).inverse = Monoid.pow(a, l.suc).inverse * a.inverse
            f(l.suc)
        }
    }
}

// a^(-n) = (a.inverse)^n
theorem pow_inverse[F: Field](a: F, n: Int) {
    a.pow(-n) = a.inverse.pow(n)
} by {
    match n {
        Int.from_nat(k) {
            if k = Nat.0 {
                -n = Int.0
                a.pow(-n) = F.1
                a.inverse.pow(n) = F.1
                a.pow(-n) = a.inverse.pow(n)
            } else {
                let l: Nat satisfy { l.suc = k }
                -n = Int.neg_suc(l)
                a.pow(-n) = a.inverse.pow(Int.from_nat(l.suc))
                a.pow(-n) = a.inverse.pow(n)
            }
        }
        Int.neg_suc(k) {
            -n = Int.from_nat(k.suc)
            a.inverse.pow(n) = a.inverse.inverse.pow(Int.from_nat(k.suc))
            a.inverse.pow(n) = a.pow(Int.from_nat(k.suc))
            a.pow(-n) = a.inverse.pow(n)
        }
    }
}

theorem pow_nat_times_inverse[F: Field](a: F, n: Nat) {
   a != F.0 implies Monoid.pow(a, n.suc) * a.inverse = Monoid.pow(a, n)
} by {
    let f: Nat -> Bool = function(x: Nat) {
        Monoid.pow(a, x.suc) * a.inverse = Monoid.pow(a, x)
    }

    // base case
    f(Nat.0)

    // Induction step
    forall(l: Nat) {
        if f(l) {
            Monoid.pow(a, l.suc) = Monoid.pow(a, l) * a
            Monoid.pow(a, l.suc) * a.inverse = Monoid.pow(a, l)
            f(l.suc)
        }
    }
}

theorem pow_nat_sub_inverse[F: Field](a: F, n: Nat, m: Nat) {
    a != F.0 and m <= n implies Monoid.pow(a, n) * Monoid.pow(a.inverse, m) = Monoid.pow(a, n - m)
} by {
    let f: Nat -> Bool = function(x: Nat) {
        x > n or Monoid.pow(a, n) * Monoid.pow(a.inverse, x) = Monoid.pow(a, n - x)
    }

    // base case
    f(Nat.0)

    // Inductive step
    forall(l: Nat) {
        if f(l) {
            if l >= n {
                l.suc > n
                f(l.suc)
            } else {
                l.suc <= n
                Monoid.pow(a.inverse, l.suc) = Monoid.pow(a.inverse, l) * a.inverse
                Monoid.pow(a, n) * Monoid.pow(a.inverse, l.suc) = Monoid.pow(a, n) * Monoid.pow(a.inverse, l) * a.inverse
                Monoid.pow(a, n) * Monoid.pow(a.inverse, l.suc) = Monoid.pow(a, n - l) * a.inverse
                n - l = (n - l.suc).suc
                Monoid.pow(a, n) * Monoid.pow(a.inverse, l.suc) = Monoid.pow(a, n - l.suc)
                f(l.suc)
            }
        }
    }
}

theorem pow_sub_inverse[F: Field](a: F, n: Int, m: Int) {
    a != F.0 and n >= Int.0 and m >= Int.0 implies a.pow(n) * a.inverse.pow(m) = a.pow(n - m)
} by {
    let l: Nat satisfy {
        n = Int.from_nat(l)
    }
    let k: Nat satisfy {
        m = Int.from_nat(k)
    }
    if m <= n {
        a.pow(n) * a.inverse.pow(m) = Monoid.pow(a, l) * Monoid.pow(a.inverse, k)
        k <= l
        a.pow(n) * a.inverse.pow(m) = Monoid.pow(a, l - k)
        a.pow(n) * a.inverse.pow(m) = a.pow(n - m)
    } else {
        a.pow(n) * a.inverse.pow(m) = a.inverse.pow(m) * a.inverse.inverse.pow(n)
        a.pow(n) * a.inverse.pow(m) = Monoid.pow(a.inverse, k) * Monoid.pow(a.inverse.inverse, l)
        l <= k
        a.inverse != F.0
        a.pow(n) * a.inverse.pow(m) = Monoid.pow(a.inverse, k - l)
        a.pow(n) * a.inverse.pow(m) = a.inverse.pow(m - n)
        a.pow(n) * a.inverse.pow(m) = a.pow(n - m)
    }
}

theorem pow_add_nonnegative[F: Field](a: F, n: Int, m: Int) {
    n >= Int.0 and m >= Int.0 implies a.pow(n) * a.pow(m) = a.pow(n + m)
} by {
    let l: Nat satisfy {
        n = Int.from_nat(l)
    }
    let k: Nat satisfy {
        m = Int.from_nat(k)
    }
    a.pow(n) * a.pow(m) = Monoid.pow(a, l) * Monoid.pow(a, k)
}

theorem pow_add[F: Field](a: F, n: Int, m: Int) {
    (n >= Int.0 and m >= Int.0) or a != F.0 implies a.pow(n) * a.pow(m) = a.pow(n + m)
} by {
    if n >= Int.0 {
        if m >= Int.0 {
            a.pow(n) * a.pow(m) = a.pow(n + m)
        } else {
            a.pow(n) * a.pow(m) = a.pow(n) * a.inverse.pow(-m)
            a.pow(n) * a.pow(m) = a.pow(n - (-m))
            a.pow(n) * a.pow(m) = a.pow(n + m)
        }
    } else {
        -n >= Int.0
        if m >= Int.0 {
            a.pow(n) * a.pow(m) = a.inverse.pow(-n) * a.pow(m)
            a.pow(n) * a.pow(m) = a.pow(m) * a.inverse.pow(-n)
            a.pow(n) * a.pow(m) = a.pow(m - (-n))
            a.pow(n) * a.pow(m) = a.pow(n + m)
        } else {
            -m >= Int.0
            a.pow(n) * a.pow(m) = a.inverse.pow(-n) * a.inverse.pow(-m)
            a.pow(n) * a.pow(m) = a.inverse.pow(-n + (-m))
            a.pow(n) * a.pow(m) = a.pow(n + m)
        }
    }
} 