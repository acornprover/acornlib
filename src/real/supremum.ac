from real.real_ring import Real
from real.real_set import ub_imp_lub
from set import Set

// This file defines supremum-related concepts for sets of real numbers.

/// True if the set s is nonempty.
define is_nonempty(s: Set[Real]) -> Bool {
    exists(x: Real) {
        s.contains(x)
    }
}

/// True if b is an upper bound for the set s.
define is_set_upper_bound(s: Set[Real], b: Real) -> Bool {
    forall(x: Real) {
        s.contains(x) implies x <= b
    }
}

/// True if the set s has an upper bound.
define has_upper_bound(s: Set[Real]) -> Bool {
    exists(b: Real) {
        is_set_upper_bound(s, b)
    }
}

/// True if b is a lower bound for the set s.
define is_set_lower_bound(s: Set[Real], b: Real) -> Bool {
    forall(x: Real) {
        s.contains(x) implies b <= x
    }
}

/// True if sup is the supremum (least upper bound) of the set s.
define is_set_supremum(s: Set[Real], sup: Real) -> Bool {
    is_set_upper_bound(s, sup) and
    forall(b: Real) {
        is_set_upper_bound(s, b) implies sup <= b
    }
}

/// True if inf is the infimum (greatest lower bound) of the set s.
define is_set_infimum(s: Set[Real], inf: Real) -> Bool {
    is_set_lower_bound(s, inf) and
    forall(b: Real) {
        is_set_lower_bound(s, b) implies b <= inf
    }
}

/// Every nonempty set of real numbers that is bounded above has a supremum.
/// This is the completeness property of the real numbers.
theorem completeness(s: Set[Real]) {
    is_nonempty(s) and has_upper_bound(s)
    implies
    exists(sup: Real) {
        is_set_supremum(s, sup)
    }
} by {
    let ub: Real satisfy {
        is_set_upper_bound(s, ub)
    }

    // Convert Set[Real] to Real -> Bool representation
    let f = s.contains

    // f is nonempty
    let x: Real satisfy {
        s.contains(x)
    }
    f(x)

    // ub is an upper bound for f
    forall(y: Real) {
        if f(y) {
            y <= ub
        }
    }
    ub.is_set_upper_bound(f)

    // Apply the completeness theorem from real_set.ac
    let lub: Real satisfy {
        lub.is_set_least_upper_bound(f)
    }

    // Show that lub is the supremum of s
    // Part 1: lub is an upper bound of s
    forall(y: Real) {
        if s.contains(y) {
            f(y)
            y <= lub
        }
    }
    is_set_upper_bound(s, lub)

    // Part 2: lub is the least upper bound
    forall(b: Real) {
        if is_set_upper_bound(s, b) {
            // Show that b is an upper bound for f
            forall(y: Real) {
                if f(y) {
                    s.contains(y)
                    y <= b
                }
            }
            b.is_set_upper_bound(f)

            // Therefore lub <= b
            lub <= b
        }
    }

    is_set_supremum(s, lub)
}

/// If S ⊆ T, S is nonempty, and sup T exists, then sup S exists.
theorem supremum_exists_for_subset(s: Set[Real], t: Set[Real], sup_t: Real) {
    s.subset(t) and is_nonempty(s) and is_set_supremum(t, sup_t)
    implies
    exists(sup_s: Real) {
        is_set_supremum(s, sup_s)
    }
} by {
    // sup_t is an upper bound for s
    forall(x: Real) {
        if s.contains(x) {
            t.contains(x)
            x <= sup_t
        }
    }
    is_set_upper_bound(s, sup_t)
    has_upper_bound(s)

    // By completeness, s has a supremum
    let sup_s: Real satisfy {
        is_set_supremum(s, sup_s)
    }
}

/// If S ⊆ T, then sup S ≤ sup T.
theorem supremum_subset_le(s: Set[Real], t: Set[Real], sup_s: Real, sup_t: Real) {
    s.subset(t) and is_set_supremum(s, sup_s) and is_set_supremum(t, sup_t)
    implies
    sup_s <= sup_t
} by {
    // sup_t is an upper bound for t, hence for s
    forall(x: Real) {
        if s.contains(x) {
            t.contains(x)
            x <= sup_t
        }
    }
    is_set_upper_bound(s, sup_t)

    // sup_s is the least upper bound of s
    sup_s <= sup_t
}

/// If S and T have suprema, then sup(S ∪ T) = max(sup S, sup T).
theorem supremum_union_max(s: Set[Real], t: Set[Real], sup_s: Real, sup_t: Real) {
    is_set_supremum(s, sup_s) and is_set_supremum(t, sup_t)
    implies
    is_set_supremum(s.union(t), sup_s.max(sup_t))
} by {
    let m = sup_s.max(sup_t)

    // Part 1: m is an upper bound for s ∪ t
    forall(x: Real) {
        if s.union(t).contains(x) {
            // x is in s or in t
            if s.contains(x) {
                x <= sup_s
                x <= m
            } else {
                t.contains(x)
                x <= sup_t
                x <= m
            }
        }
    }
    is_set_upper_bound(s.union(t), m)

    // Part 2: m is the least upper bound for s ∪ t
    forall(b: Real) {
        if is_set_upper_bound(s.union(t), b) {
            // b is an upper bound for s ∪ t, so it's an upper bound for s
            forall(x: Real) {
                if s.contains(x) {
                    s.union(t).contains(x)
                    x <= b
                }
            }
            is_set_upper_bound(s, b)

            // Since sup_s is the least upper bound of s
            sup_s <= b

            // Similarly, b is an upper bound for t
            forall(x: Real) {
                if t.contains(x) {
                    s.union(t).contains(x)
                    x <= b
                }
            }
            is_set_upper_bound(t, b)

            // Since sup_t is the least upper bound of t
            sup_t <= b

            // Therefore m = max(sup_s, sup_t) ≤ b
            // By case analysis: m equals either sup_s or sup_t
            if m = sup_s {
                m <= b
            } else {
                m = sup_t
                m <= b
            }
        }
    }

    is_set_supremum(s.union(t), m)
}
