from nat import Nat
from nat.nat_base import add_zero_right, add_suc_right, add_comm, add_imp_sub
from list import partial, sum, map, List
from list.list_sum import map_add, sum_add, map_sum_add, partial_pointwise_eq, partial_scalar_mul, partial_split_last, partial_zero
from add_comm_monoid import AddCommMonoid
from add_semigroup import add_fn
from semigroup import mul_fn
from real.real_ring import Real, lte_mul_nonneg_right, lte_mul_nonneg_left, mul_distrib_left, mul_distrib_right
from real.real_series import is_lower_bound, nonneg_imp_partial_increasing, is_increasing, distant_increasing, partial_mul_scalar_right
from real.real_base import lte_add_right, lte_trans_eq

numerals Real

/// Helper: compute the sum of row i in a double sum.
/// This avoids nested lambdas by making all parameters explicit.
define row_sum(m: Nat, f: (Nat, Nat) -> Real, i: Nat) -> Real {
    sum(map(m.range, f(i)))
}

/// Helper: tail rows starting at index k.
/// This maps an offset d to the row sum at absolute index k + d.
define row_sum_offset(m: Nat, f: (Nat, Nat) -> Real, k: Nat) -> (Nat -> Real) {
    function(d: Nat) { row_sum(m, f, k + d) }
}

/// Helper: get the value at column j for row i.
/// This extracts f(i, j) in a way that can be partially applied.
define col_val(f: (Nat, Nat) -> Real, j: Nat, i: Nat) -> Real {
    f(i, j)
}

/// Double sum: sum over pairs (i, j) where i ∈ [0, n) and j ∈ [0, m).
/// This computes ∑_{i=0}^{n-1} ∑_{j=0}^{m-1} f(i, j).
/// Using a named helper function instead of nested lambdas to help Acorn's normalizer.
define double_sum(n: Nat, m: Nat, f: (Nat, Nat) -> Real) -> Real {
    sum(map(n.range, row_sum(m, f)))
}

theorem double_sum_expands(n: Nat, m: Nat, f: (Nat, Nat) -> Real) {
    double_sum(n, m, f) = sum(map(n.range, row_sum(m, f)))
}

/// Expanding double_sum by adding a column: when we increment the column count,
/// we get the old double_sum plus the sum over the new column.
theorem double_sum_col_expand(n: Nat, m: Nat, f: (Nat, Nat) -> Real) {
    double_sum(n, m.suc, f) = double_sum(n, m, f) + sum(map(n.range, col_val(f, m)))
} by {
    map_sum_add(n.range, row_sum(m, f), col_val(f, m))

    forall(i: Nat) {
        add_fn(row_sum(m, f), col_val(f, m))(i) = row_sum(m, f, i) + f(i, m)
        add_fn(row_sum(m, f), col_val(f, m))(i) = row_sum(m.suc, f, i)
    }

    sum(map(n.range, add_fn(row_sum(m, f), col_val(f, m)))) = sum(map(n.range, row_sum(m.suc, f)))
}

/// Helper: get the value at row i for column j.
/// This extracts f(i, j) as a function of j for a fixed i.
define row_val(f: (Nat, Nat) -> Real, i: Nat) -> (Nat -> Real) {
    function(j: Nat) { f(i, j) }
}

/// Expanding double_sum by adding a row: when we increment the row count,
/// we get the old double_sum plus the sum over the new row.
theorem double_sum_row_expand(n: Nat, m: Nat, f: (Nat, Nat) -> Real) {
    double_sum(n.suc, m, f) = double_sum(n, m, f) + sum(map(m.range, row_val(f, n)))
} by {
    map_add(n.range, List.singleton(n), row_sum(m, f))

    row_sum(m, f, n) = sum(map(m.range, row_val(f, n)))

    sum_add(map(n.range, row_sum(m, f)), List.singleton(sum(map(m.range, row_val(f, n)))))
}

/// Splitting a double sum at a row index.
/// Summing n rows equals the sum of the first k rows plus the remaining rows.
theorem double_sum_split_row_index(n: Nat, m: Nat, f: (Nat, Nat) -> Real, k: Nat) {
    k <= n implies
    double_sum(n, m, f) = double_sum(k, m, f) + sum(map((n - k).range, row_sum_offset(m, f, k)))
} by {
    if k <= n {
        let diff: Nat satisfy { k + diff = n }

        define tail(d: Nat) -> Real { row_sum(m, f, k + d) }

        define q(d: Nat) -> Bool {
            double_sum(k + d, m, f) = double_sum(k, m, f) + sum(map(d.range, tail))
        }

        add_zero_right(k)
        q(Nat.0)

        forall(d: Nat) {
            if q(d) {
                add_suc_right(k, d)
                double_sum_row_expand(k + d, m, f)

                sum(map(m.range, row_val(f, k + d))) = row_sum(m, f, k + d)

                double_sum(k + d.suc, m, f) = double_sum(k, m, f) + sum(map(d.range, tail)) + row_sum(m, f, k + d)

                map_add(d.range, List.singleton(d), tail)
                sum_add(map(d.range, tail), List.singleton(tail(d)))

                q(d.suc)
            }
        }

        q(diff)

        row_sum_offset(m, f, k) = tail

        add_comm(diff, k)
        add_imp_sub(diff, k, n)

        double_sum(n, m, f) = double_sum(k, m, f) + sum(map((n - k).range, row_sum_offset(m, f, k)))
    }
}

/// Helper: scalar multiplication distributes into a sum.
/// For a constant c: c * ∑ᵢ b(i) = ∑ᵢ (c * b(i))
theorem scalar_mul_sum(c: Real, b: Nat -> Real, n: Nat) {
    c * sum(map(n.range, b)) = sum(map(n.range, mul_fn(c, b)))
} by {
    partial_mul_scalar_right(b, c, n)
}

/// Helper: product function for double sums.
define prod_fn(a: Nat -> Real, b: Nat -> Real) -> ((Nat, Nat) -> Real) {
    function(i: Nat, j: Nat) { a(i) * b(j) }
}

/// Product of two partial sums equals a double sum over the product.
/// This is the key lemma for expanding (∑aᵢ)(∑bⱼ) into ∑ᵢ∑ⱼ aᵢbⱼ.
theorem partial_product_as_double_sum(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(a, n) * partial(b, n) = double_sum(n, n, prod_fn(a, b))
} by {
    define p(m: Nat) -> Bool {
        partial(a, m) * partial(b, m) = double_sum(m, m, prod_fn(a, b))
    }

    partial_zero(a)
    partial_zero(b)

    double_sum_expands(Nat.0, Nat.0, prod_fn(a, b))

    p(Nat.0)

    forall(m: Nat) {
        if p(m) {
            map_add(m.range, List.singleton(m), a)
            sum_add(map(m.range, a), List.singleton(a(m)))

            map_add(m.range, List.singleton(m), b)
            sum_add(map(m.range, b), List.singleton(b(m)))

            mul_distrib_left(partial(a, m), a(m), partial(b, m) + b(m))

            mul_distrib_right(partial(a, m), partial(b, m), b(m))

            mul_distrib_right(a(m), partial(b, m), b(m))

            scalar_mul_sum(b(m), a, m)

            scalar_mul_sum(a(m), b, m)

            double_sum_row_expand(m, m.suc, prod_fn(a, b))

            double_sum_col_expand(m, m, prod_fn(a, b))

            map_add(m.range, List.singleton(m), row_val(prod_fn(a, b), m))
            sum_add(map(m.range, row_val(prod_fn(a, b), m)), List.singleton(row_val(prod_fn(a, b), m)(m)))

            col_val(prod_fn(a, b), m) = mul_fn(b(m), a)

            row_val(prod_fn(a, b), m) = mul_fn(a(m), b)

            p(m.suc)
        }
    }

}

/// Multiplication is monotone for nonnegative reals.
theorem mul_le_mul_nonneg(a: Real, b: Real, c: Real, d: Real) {
    a >= Real.0 and b >= Real.0 and c >= Real.0 and d >= Real.0 and a <= c and b <= d
    implies
    a * b <= c * d
} by {
    a * b <= c * b
    c * b <= c * d
}

/// Partial sums are monotone for nonnegative sequences.
/// For nonnegative sequences, partial(a, n) <= partial(a, n.suc).
theorem partial_monotone(a: Nat -> Real, n: Nat) {
    is_lower_bound(a, Real.0) implies partial(a, n) <= partial(a, n.suc)
}

/// Helper: Adding a nonnegative term doesn't decrease a sum.
theorem add_nonneg_preserves_lte(x: Real, y: Real) {
    y >= Real.0 implies x <= x + y
}

/// Helper: Extending a double sum row-wise with nonnegative terms doesn't decrease the sum.
theorem double_sum_row_monotone(n: Nat, m: Nat, f: (Nat, Nat) -> Real) {
    (forall(i: Nat, j: Nat) { f(i, j) >= Real.0 })
    implies
    double_sum(n, m, f) <= double_sum(n.suc, m, f)
} by {
    if forall(i: Nat, j: Nat) { f(i, j) >= Real.0 } {
        double_sum_row_expand(n, m, f)

        nonneg_imp_partial_increasing(row_val(f, n))

        Nat.0 <= m
        distant_increasing(partial(row_val(f, n)), Nat.0, m)
        partial(row_val(f, n), Nat.0) <= partial(row_val(f, n), m)

        add_nonneg_preserves_lte(double_sum(n, m, f), sum(map(m.range, row_val(f, n))))
        double_sum(n, m, f) <= double_sum(n.suc, m, f)
    }
}

/// Helper: Extending a double sum column-wise with nonnegative terms doesn't decrease the sum.
theorem double_sum_col_monotone(n: Nat, m: Nat, f: (Nat, Nat) -> Real) {
    (forall(i: Nat, j: Nat) { f(i, j) >= Real.0 })
    implies
    double_sum(n, m, f) <= double_sum(n, m.suc, f)
} by {
    if forall(i: Nat, j: Nat) { f(i, j) >= Real.0 } {
        double_sum_col_expand(n, m, f)

        nonneg_imp_partial_increasing(col_val(f, m))

        Nat.0 <= n
        distant_increasing(partial(col_val(f, m)), Nat.0, n)
        partial(col_val(f, m), Nat.0) <= partial(col_val(f, m), n)

        add_nonneg_preserves_lte(double_sum(n, m, f), sum(map(n.range, col_val(f, m))))
        double_sum(n, m, f) <= double_sum(n, m.suc, f)
    }
}

/// Helper: Indicator for diagonal elements in a double sum.
/// Returns 1 if i + j = m, otherwise 0.
define diagonal_indicator(m: Nat, i: Nat, j: Nat) -> Real {
    if i + j = m { Real.1 } else { Real.0 }
}

// ============================================================================
// Conditional Sum Infrastructure for Subset Sum Inequalities
// ============================================================================

/// Helper: decompose a sum into two parts based on a predicate.
/// The first part sums f(x) where pred(x) is true, the second where pred(x) is false.
define cond_part(f: Nat -> Real, pred: Nat -> Bool, x: Nat) -> Real {
    if pred(x) { f(x) } else { Real.0 }
}

define comp_part(f: Nat -> Real, pred: Nat -> Bool, x: Nat) -> Real {
    if pred(x) { Real.0 } else { f(x) }
}

/// For nonnegative f, conditional sum is bounded by full sum (single variable case).
///
/// This is the key lemma for subset sum inequalities: if we sum f only where
/// a predicate is true, the result is at most the full sum of f.
theorem sum_cond_le_sum_1d(f: Nat -> Real, pred: Nat -> Bool, n: Nat) {
    (forall(x: Nat) { f(x) >= Real.0 })
    implies
    sum(map(n.range, cond_part(f, pred))) <= sum(map(n.range, f))
} by {

    if forall(x: Nat) { f(x) >= Real.0 } {
        // Strategy: Decompose f = cond_part + comp_part, show comp_part >= 0,
        // then cond_part <= cond_part + comp_part = f

        // Show decomposition: f(x) = cond_part(f, pred, x) + comp_part(f, pred, x)
        forall(x: Nat) {
            if pred(x) {
                add_fn(cond_part(f, pred), comp_part(f, pred))(x) = f(x)
            } else {
                add_fn(cond_part(f, pred), comp_part(f, pred))(x) = f(x)
            }
        }

        // Apply map_sum_add to lift decomposition to sums
        map_sum_add(n.range, cond_part(f, pred), comp_part(f, pred))
        let sum_cond = sum(map(n.range, cond_part(f, pred)))
        let sum_comp = sum(map(n.range, comp_part(f, pred)))

        // Show comp_part is nonnegative
        forall(x: Nat) {
            if pred(x) {
                comp_part(f, pred, x) >= Real.0
            } else {
                comp_part(f, pred, x) >= Real.0
            }
        }

        // Therefore sum_comp >= 0
        nonneg_imp_partial_increasing(comp_part(f, pred))
        distant_increasing(partial(comp_part(f, pred)), Nat.0, n)
        Real.0 <= partial(comp_part(f, pred), n)

        // Final step: sum_cond <= sum_cond + sum_comp = sum(f), therefore sum_cond <= sum(f)
        add_nonneg_preserves_lte(sum_cond, sum_comp)

        // We have: sum_cond + sum_comp = sum(f)
        let sum_f = sum(map(n.range, f))

        // Apply transitivity: sum_cond <= sum_cond + sum_comp and sum_cond + sum_comp = sum_f
        lte_trans_eq(sum_cond, sum_cond + sum_comp, sum_f)

        // Therefore
        sum(map(n.range, cond_part(f, pred))) <= sum(map(n.range, f))
    }
}

/// Helper: Conditional product for diagonal elements.
/// Returns a(i)*b(j) if i+j=m, otherwise 0.
define diag_cond_prod(a: Nat -> Real, b: Nat -> Real, m: Nat, i: Nat, j: Nat) -> Real {
    if i + j = m { a(i) * b(j) } else { Real.0 }
}

/// Helper: For a fixed row i, the conditional product in column j.
define row_cond_prod(a: Nat -> Real, b: Nat -> Real, m: Nat, i: Nat) -> (Nat -> Real) {
    function(j: Nat) { diag_cond_prod(a, b, m, i, j) }
}

/// Helper: For a fixed row i and diagonal m, sum over columns conditionally.
/// This computes sum_{j: i+j=m} a(i)*b(j), which is just a(i)*b(m-i) when i <= m.
define diag_row_contrib(a: Nat -> Real, b: Nat -> Real, m: Nat, i: Nat) -> Real {
    sum(map(m.suc.range, function(j: Nat) { diag_cond_prod(a, b, m, i, j) }))
}

define is_zero_before(f: Nat -> Real, n: Nat) -> Bool {
    forall(j: Nat) {
        j < n implies f(j) = Real.0
    }
}

/// Helper: Partial sum of constant zero function is zero.
theorem partial_all_zeros(g: Nat -> Real, m: Nat) {
    (forall(j: Nat) { j < m implies g(j) = Real.0 })
    implies
    partial(g, m) = Real.0
} by {
    define p(k: Nat) -> Bool {
        (forall(j: Nat) { j < k implies g(j) = Real.0 })
        implies
        partial(g, k) = Real.0
    }

    // Base case

    // Inductive step
    forall(k: Nat) {
        if p(k) {
            if forall(j: Nat) { j < k.suc implies g(j) = Real.0 } {
                // g(j) = 0 for all j < k

                // By IH: partial(g, k) = 0

                // Also g(k) = 0

                // Therefore partial(g, k.suc) = 0 + 0 = 0
                partial(g, k.suc) = Real.0
            }
            p(k.suc)
        }
    }

    p(m)
}

/// Helper lemma: Sum of a function that equals a constant at one index and zero elsewhere.
/// If g(j) = c when j = k, and g(j) = 0 otherwise, then sum(g, n) = c (when k < n).
theorem sum_singleton(g: Nat -> Real, c: Real, k: Nat, n: Nat) {
    k < n and
    g(k) = c and
    (forall(j: Nat) { j < n and j != k implies g(j) = Real.0 })
    implies
    partial(g, n) = c
} by {
    if k < n and g(k) = c and (forall(j: Nat) { j < n and j != k implies g(j) = Real.0 }) {
        // Step 1: Show partial(g, k) = 0
        partial_all_zeros(g, k)
        partial(g, k) = Real.0

        // Step 2: Show partial(g, k.suc) = c

        // Step 3: Extend from k.suc to n by induction on the distance
        // Define predicate in terms of distance d, where m = k.suc + d
        define q(d: Nat) -> Bool {
            (forall(j: Nat) { k < j and j < k.suc + d implies g(j) = Real.0 })
            implies
            partial(g, k.suc + d) = c
        }

        q(Nat.0)

        forall(d: Nat) {
            if q(d) {
                if forall(j: Nat) { k < j and j < k.suc + d.suc implies g(j) = Real.0 } {
                    forall(j: Nat) {
                        if k < j and j < k.suc + d {
                            g(j) = Real.0
                        }
                    }

                    k < k.suc + d
                    g(k.suc + d) = Real.0

                    partial(g, k.suc + d.suc) = c
                }
                q(d.suc)
            }
        }

        let d: Nat satisfy { k.suc + d = n }

        q(d)
        partial(g, n) = c
    }
}

/// Lemma: Sum of conditional where exactly one index satisfies predicate.
/// When pred(k) holds and is the unique satisfier in [0,n), sum of cond_part equals f(k).
theorem sum_cond_unique(f: Nat -> Real, pred: Nat -> Bool, n: Nat, k: Nat) {
    k < n and
    pred(k) and
    (forall(j: Nat) { j < n and j != k implies not pred(j) })
    implies
    sum(map(n.range, cond_part(f, pred))) = f(k)
} by {

}

/// Lemma: For each row i <= m, the diagonal contribution equals a(i)*b(m-i).
/// In row i, only column j=m-i satisfies i+j=m, so only that term is non-zero.
theorem diag_row_contrib_eq(a: Nat -> Real, b: Nat -> Real, m: Nat, i: Nat) {
    i <= m implies diag_row_contrib(a, b, m, i) = a(i) * b(m - i)
} by {

    if i <= m {
        define is_diag(j: Nat) -> Bool {
            i + j = m
        }

        define diag_fn(j: Nat) -> Real {
            if i + j = m { a(i) * b(j) } else { Real.0 }
        }

        forall(j: Nat) {
            if i + j = m {
                cond_part(prod_fn(a, b)(i), is_diag, j) = diag_fn(j)
            } else {
                cond_part(prod_fn(a, b)(i), is_diag, j) = diag_fn(j)
            }
        }

        forall(j: Nat) {
            if i + j = m {
                diag_cond_prod(a, b, m, i, j) = diag_fn(j)
            } else {
                diag_cond_prod(a, b, m, i, j) = diag_fn(j)
            }
        }

        partial_pointwise_eq(function(j: Nat) { diag_cond_prod(a, b, m, i, j) }, diag_fn, m.suc)

        let j_unique: Nat satisfy { j_unique + i = m }
        j_unique < m.suc

        forall(j: Nat) {
            if j < m.suc and j != j_unique {
                not is_diag(j)
            }
        }

        sum_cond_unique(prod_fn(a, b)(i), is_diag, m.suc, j_unique)

        sum(map(m.suc.range, diag_fn)) = prod_fn(a, b)(i)(j_unique)

        diag_row_contrib(a, b, m, i) = a(i) * b(m - i)
    }
}

/// Adding two inequalities preserves the inequality.
/// If a ≤ b and c ≤ d, then a + c ≤ b + d.
theorem add_lte_add(a: Real, b: Real, c: Real, d: Real) {
    a <= b and c <= d implies a + c <= b + d
}

/// Sum monotonicity: if f(i) ≤ g(i) for all i in range, then sum(f) ≤ sum(g).
theorem partial_lte_partial(f: Nat -> Real, g: Nat -> Real, n: Nat) {
    (forall(i: Nat) { i < n implies f(i) <= g(i) })
    implies
    partial(f, n) <= partial(g, n)
} by {
    // Prove by induction on n
    define p(m: Nat) -> Bool {
        (forall(i: Nat) { i < m implies f(i) <= g(i) }) implies partial(f, m) <= partial(g, m)
    }

    // Base case: m = 0
    p(Nat.0)

    // Inductive step: p(m) implies p(m.suc)
    forall(m: Nat) {
        if p(m) {
            if forall(i: Nat) { i < m.suc implies f(i) <= g(i) } {
                // Split the range [0, m.suc) into [0, m) and {m}

                // Apply induction hypothesis to get partial(f, m) <= partial(g, m)

                // Now handle the m-th element

                // Use partial_split_last to expand

                // Since partial(f, m) <= partial(g, m) and f(m) <= g(m), we have:
                // partial(f, m) + f(m) <= partial(g, m) + g(m)
                add_lte_add(partial(f, m), partial(g, m), f(m), g(m))
                partial(f, m) + f(m) <= partial(g, m) + g(m)
                partial(f, m.suc) <= partial(g, m.suc)
            }
            p(m.suc)
        }
    }

    // Apply induction to conclude p(n)
    p(n)
}

/// Pointwise comparison for double sums: if f(i,j) <= g(i,j) for all i < n and j < m,
/// then double_sum(n, m, f) <= double_sum(n, m, g).
theorem double_sum_pointwise_le(n: Nat, m: Nat, f: (Nat, Nat) -> Real, g: (Nat, Nat) -> Real) {
    (forall(i: Nat, j: Nat) { i < n and j < m implies f(i, j) <= g(i, j) })
    implies
    double_sum(n, m, f) <= double_sum(n, m, g)
} by {
    if forall(i: Nat, j: Nat) { i < n and j < m implies f(i, j) <= g(i, j) } {
        // Strategy: Show that each row sum satisfies row_sum(m, f, i) <= row_sum(m, g, i)
        // Then apply partial_lte_partial to conclude the result.

        // First, show that for each i < n, the row sums satisfy row_sum(m, f, i) <= row_sum(m, g, i)
        forall(i: Nat) {
            if i < n {
                // For this fixed i, we have forall j < m: f(i, j) <= g(i, j)

                // Define the row functions

                // Show that row_val(f, i) <= row_val(g, i) for all j < m

                // Apply partial_lte_partial to get the sum inequality
                partial_lte_partial(row_val(f, i), row_val(g, i), m)

                // Since partial(h, m) = sum(map(m.range, h)), we have:
                sum(map(m.range, row_val(f, i))) <= sum(map(m.range, row_val(g, i)))

                // By definition, row_sum(m, f, i) = sum(map(m.range, row_val(f, i)))
                row_sum(m, f, i) = sum(map(m.range, row_val(f, i)))
                row_sum(m, g, i) = sum(map(m.range, row_val(g, i)))
                row_sum(m, f, i) <= row_sum(m, g, i)
            }
        }

        // Now we have: forall i < n, row_sum(m, f, i) <= row_sum(m, g, i)
        // Define helper functions for the row sums
        define f_rows(i: Nat) -> Real { row_sum(m, f, i) }
        define g_rows(i: Nat) -> Real { row_sum(m, g, i) }

        // Apply partial_lte_partial to get the sum inequality for rows
        partial_lte_partial(f_rows, g_rows, n)

        // Since partial(h, n) = sum(map(n.range, h)), we have:

        // By definition of double_sum
        double_sum_expands(n, m, f)
        double_sum_expands(n, m, g)

        // The functions are pointwise equal to our helper functions

        // By pointwise equality, the sums are equal
        partial_pointwise_eq(function(i: Nat) { row_sum(m, f, i) }, f_rows, n)
        partial_pointwise_eq(function(i: Nat) { row_sum(m, g, i) }, g_rows, n)

        // Combine everything
        sum(map(n.range, f_rows)) <= sum(map(n.range, g_rows))
        double_sum(n, m, f) <= double_sum(n, m, g)
    }
}

/// Double sum distributes over pointwise addition of functions.
/// If h(i,j) = f(i,j) + g(i,j) for all i, j, then double_sum(n, m, h) = double_sum(n, m, f) + double_sum(n, m, g).
theorem double_sum_pointwise_add(n: Nat, m: Nat, f: (Nat, Nat) -> Real, g: (Nat, Nat) -> Real, h: (Nat, Nat) -> Real) {
    (forall(i: Nat, j: Nat) { h(i, j) = f(i, j) + g(i, j) })
    implies
    double_sum(n, m, h) = double_sum(n, m, f) + double_sum(n, m, g)
} by {

    if forall(i: Nat, j: Nat) { h(i, j) = f(i, j) + g(i, j) } {
        // For each row i, show row_sum(m, h, i) = row_sum(m, f, i) + row_sum(m, g, i)
        forall(i: Nat) {
            // Define row functions
            define h_row(j: Nat) -> Real { h(i, j) }
            define f_row(j: Nat) -> Real { f(i, j) }
            define g_row(j: Nat) -> Real { g(i, j) }

            // Show pointwise equality for this row

            // Apply map_sum_add to this row
            map_sum_add(m.range, f_row, g_row)

            // Show add_fn(f_row, g_row) equals h_row

            partial_pointwise_eq(add_fn(f_row, g_row), h_row, m)

            // Therefore row sums add

            partial_pointwise_eq(row_val(f, i), f_row, m)

            partial_pointwise_eq(row_val(g, i), g_row, m)

            partial_pointwise_eq(row_val(h, i), h_row, m)

            sum(map(m.range, f_row)) + sum(map(m.range, g_row)) = sum(map(m.range, h_row))
            row_sum(m, h, i) = row_sum(m, f, i) + row_sum(m, g, i)
        }

        // Now apply map_sum_add to the outer sum
        map_sum_add(n.range, row_sum(m, f), row_sum(m, g))

        // Show add_fn(row_sum(m, f), row_sum(m, g)) equals row_sum(m, h)

        partial_pointwise_eq(add_fn(row_sum(m, f), row_sum(m, g)), row_sum(m, h), n)

        // Expand double_sums
        double_sum_expands(n, m, f)
        double_sum_expands(n, m, g)
        double_sum_expands(n, m, h)

        // Combine
        sum(map(n.range, row_sum(m, f))) + sum(map(n.range, row_sum(m, g))) = sum(map(n.range, row_sum(m, h)))
    }
}

/// Helper: Value at position i along diagonal k
define diagonal_val(f: (Nat, Nat) -> Real, k: Nat, i: Nat) -> Real {
    f(i, k - i)
}

/// Helper: Sum along a single diagonal k, where j = k - i.
/// For diagonal k, sum f(i, k-i) for i from 0 to k.
define diagonal_sum(f: (Nat, Nat) -> Real, k: Nat) -> Real {
    sum(map(k.suc.range, diagonal_val(f, k)))
}

/// Helper: Indicator for the triangular region i + j < n.
define triangle_region(n: Nat, i: Nat, j: Nat) -> Real {
    if i + j < n { Real.1 } else { Real.0 }
}

/// Helper: Product restricted to triangular region.
define triangle_fn(f: (Nat, Nat) -> Real, n: Nat, i: Nat, j: Nat) -> Real {
    if i + j < n { f(i, j) } else { Real.0 }
}

/// Helper function: diagonal indicator.
define diag_indicator(f: (Nat, Nat) -> Real, m: Nat, i: Nat, j: Nat) -> Real {
    if i + j = m { f(i, j) } else { Real.0 }
}

/// Helper: diagonal_sum expressed as a double_sum over a diagonal indicator.
/// The key insight: In row i, only column j=m-i contributes, giving f(i, m-i).
/// Therefore double_sum reduces to sum_{i=0}^m f(i, m-i) = diagonal_sum(f, m).
theorem diagonal_as_double_sum(f: (Nat, Nat) -> Real, m: Nat) {
    diagonal_sum(f, m) = double_sum(m.suc, m.suc, diag_indicator(f, m))
} by {

    // Use the diagonal function
    define diag_fn(i: Nat, j: Nat) -> Real {
        diag_indicator(f, m, i, j)
    }

    // RHS: double_sum(m.suc, m.suc, diag_fn) = sum_{i=0}^m row_sum(m.suc, diag_fn, i)
    double_sum_expands(m.suc, m.suc, diag_fn)

    // Now show that for each i < m.suc, row_sum(m.suc, diag_fn, i) = f(i, m-i)
    forall(i: Nat) {
        if i < m.suc {
            i <= m

            // Define the row function for this i
            define row_i(j: Nat) -> Real {
                diag_fn(i, j)
            }

            // Show that row_i has exactly one non-zero term at j = m-i
            forall(j: Nat) {
                if j = m - i {
                    // At j = m-i, we have i+j = i + (m-i) = m
                } else {
                    // At j != m-i, we have i+j != m
                    diag_fn(i, j) = Real.0
                }
            }

            // Now row_i(m-i) = f(i, m-i) and row_i(j) = 0 for j != m-i
            // We need m-i < m.suc
            m - i < m.suc

            // Explicitly state preconditions for sum_singleton
            row_i(m - i) = f(i, m - i)

            // Apply sum_singleton: this proves partial(row_i, m.suc) = f(i, m - i)
            sum_singleton(row_i, f(i, m - i), m - i, m.suc)

            // row_sum(m.suc, diag_fn, i) = sum over diag_fn(i)

            // row_val(diag_fn, i)(j) = diag_fn(i, j) = row_i(j)

            // By pointwise equality
            partial_pointwise_eq(row_val(diag_fn, i), row_i, m.suc)

            // From sum_singleton, we have partial(row_i, m.suc) = f(i, m - i)
            row_sum(m.suc, diag_fn, i) = f(i, m - i)
        }
    }

    // Now both sides are sum_{i=0}^m f(i, m-i)
    // LHS function: function(i) { f(i, m-i) }
    // RHS function: function(i) { row_sum(m.suc, diag_fn, i) }
    // These are pointwise equal

    partial_pointwise_eq(function(i: Nat) { f(i, m - i) }, function(i: Nat) { row_sum(m.suc, diag_fn, i) }, m.suc)

    // From line 2158, we have double_sum(m.suc, m.suc, diag_fn) = sum(map(..., row_sum(...)))

    // By transitivity with line 2249

    // By transitivity: we have sum(...f(i, m-i)...) = double_sum

    // Show that function(i) { f(i, m-i) } equals diagonal_val(f, m) pointwise

    partial_pointwise_eq(function(i: Nat) { f(i, m - i) }, diagonal_val(f, m), m.suc)

    // By definition, diagonal_sum(f, m) = sum(map(m.suc.range, diagonal_val(f, m)))
    sum(map(m.suc.range, diagonal_val(f, m))) = double_sum(m.suc, m.suc, diag_fn)

    // diag_fn(i, j) = diag_indicator(f, m, i, j), so double_sum(m.suc, m.suc, diag_fn) = double_sum(m.suc, m.suc, diag_indicator(f, m))
}

/// Key lemma: Expanding double_sum with triangle restriction adds exactly one diagonal.
/// When going from (m, m) to (m+1, m+1) with triangle_fn restriction,
/// the new terms are exactly those on diagonal m (where i+j = m).
theorem double_sum_triangle_expand(f: (Nat, Nat) -> Real, m: Nat) {
    double_sum(m.suc, m.suc, triangle_fn(f, m.suc))
    =
    double_sum(m, m, triangle_fn(f, m)) + diagonal_sum(f, m)
} by {
    // Key insight: triangle_fn(f, m.suc) decomposes as triangle_fn(f, m) + diag_indicator(f, m)
    // For any i, j:
    // - If i+j < m: triangle_fn(f, m.suc, i, j) = f(i,j) and triangle_fn(f, m, i, j) = f(i,j), diag_indicator = 0
    // - If i+j = m: triangle_fn(f, m.suc, i, j) = f(i,j) and triangle_fn(f, m, i, j) = 0, diag_indicator = f(i,j)
    // - If i+j >= m.suc: all three are 0

    // Prove pointwise decomposition
    forall(i: Nat, j: Nat) {

        if i + j = m {
            // In this case: i+j = m < m.suc

            triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j) = Real.0 + f(i, j)
            triangle_fn(f, m.suc, i, j) = triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j)
        }

        if i + j >= m.suc {
            // All three functions are 0

            diag_indicator(f, m, i, j) = Real.0

            triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j) = Real.0 + Real.0
            triangle_fn(f, m.suc, i, j) = triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j)
        }

        // One of the three cases must hold
        if not (i + j < m) and not (i + j = m) and not (i + j >= m.suc) {
            // This is impossible: must have either i+j < m, i+j = m, or i+j >= m.suc
            i + j < m or i + j = m or i + j >= m.suc
        }

        triangle_fn(f, m.suc, i, j) = triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j)
    }

    // Apply double_sum_pointwise_add
    double_sum_pointwise_add(m.suc, m.suc, triangle_fn(f, m), diag_indicator(f, m), triangle_fn(f, m.suc))

    // Use diagonal_as_double_sum
    diagonal_as_double_sum(f, m)

    // So far we have: double_sum(m.suc, m.suc, triangle_fn(f, m.suc)) = double_sum(m.suc, m.suc, triangle_fn(f, m)) + diagonal_sum(f, m)
    // But we need: double_sum(m.suc, m.suc, triangle_fn(f, m.suc)) = double_sum(m, m, triangle_fn(f, m)) + diagonal_sum(f, m)
    // So we need to show double_sum(m.suc, m.suc, triangle_fn(f, m)) = double_sum(m, m, triangle_fn(f, m))

    // This is true because triangle_fn(f, m, i, j) = 0 whenever i+j >= m
    // So the extra row (i=m) and column (j=m) contribute 0

    // For the row i=m: show that triangle_fn(f, m)(m) is the zero function

    // Apply partial_all_zeros
    partial_all_zeros(triangle_fn(f, m)(m), m.suc)

    // By definition of row_sum

    // Now expand double_sum(m.suc, m.suc, triangle_fn(f, m)) using row expansion
    double_sum_row_expand(m, m.suc, triangle_fn(f, m))

    // Show row_val(triangle_fn(f, m), m) = triangle_fn(f, m)(m) pointwise

    partial_pointwise_eq(row_val(triangle_fn(f, m), m), triangle_fn(f, m)(m), m.suc)
    sum(map(m.suc.range, row_val(triangle_fn(f, m), m))) = Real.0

    // Similarly for column j=m:

    partial_all_zeros(col_val(triangle_fn(f, m), m), m)

    double_sum_col_expand(m, m, triangle_fn(f, m))
    sum(map(m.range, col_val(triangle_fn(f, m), m))) = Real.0

    // Combine

    // Final result
}

/// Finite double sum exchange for triangular regions (discrete Fubini).
/// Summing along diagonals equals summing over the triangular region.
/// LHS: sum over diagonals k, then over i ≤ k (where j = k-i)
/// RHS: sum over all (i,j) in the triangle i+j < n
theorem finite_double_sum_exchange(f: (Nat, Nat) -> Real, n: Nat) {
    sum(map(n.range, diagonal_sum(f)))
    =
    double_sum(n, n, triangle_fn(f, n))
} by {

    // Induction on n
    define p(k: Nat) -> Bool {
        sum(map(k.range, diagonal_sum(f))) = double_sum(k, k, triangle_fn(f, k))
    }

    // Base case: k = 0

    double_sum_expands(Nat.0, Nat.0, triangle_fn(f, Nat.0))

    p(Nat.0)

    // Inductive step
    forall(k: Nat) {
        if p(k) {
            // Assume: sum(map(k.range, diagonal_sum(f))) = double_sum(k, k, triangle_fn(f, k))
            // Need to prove: sum(map(k.suc.range, diagonal_sum(f))) = double_sum(k.suc, k.suc, triangle_fn(f, k.suc))

            // LHS: Expand k.suc.range
            map_add(k.range, List.singleton(k), diagonal_sum(f))

            sum_add(map(k.range, diagonal_sum(f)), List.singleton(diagonal_sum(f, k)))

            // RHS: Use double_sum_triangle_expand
            double_sum_triangle_expand(f, k)

            // By IH

            // Combine

            p(k.suc)
        }
    }

    // By induction, p(k) holds for all k, including n
}
