from nat import Nat
from int import Int
from rat import Rat
from real.real_field import Real
from real.real_ring import converges, limit, mul_abs
from real.real_base import abs_from_rat
from real.abs_conv import absolutely_converges, abs_fn, absolutely_converges_comparison
from real.real_series import seq_lte, abs_pow, tail, partial_tail_conv_imp_partial_conv, comparison_test, const_converges, mul_seq, is_lower_bound, geom_converges
from list import partial
from util import constant

numerals Real
numerals Nat

/// The nth term in the Taylor series expansion of e^x.
/// For a real number x and natural number n, this returns x^n / n!
define exp_term(x: Real, n: Nat) -> Real {
    x.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
}

// Helper lemmas for working with exp_term

/// Factorial is positive for all n.
theorem factorial_pos(n: Nat) {
    Real.from_rat(Rat.from_nat(n.factorial)) > Real.0
} by {
    // 1 <= n.factorial for all n
    // So Rat.1 <= Rat.from_nat(n.factorial)
    // And Real.1 <= Real.from_rat(Rat.from_nat(n.factorial))
    // Therefore Real.from_rat(Rat.from_nat(n.factorial)) > Real.0
    Nat.1 <= n.factorial
    Rat.1 <= Rat.from_nat(n.factorial)
    Real.from_rat(Rat.1) <= Real.from_rat(Rat.from_nat(n.factorial))
}

/// The absolute value of the reciprocal equals the reciprocal of the absolute value.
theorem abs_reciprocal(b: Real) {
    b != Real.0 implies b.reciprocal.abs = b.abs.reciprocal
} by {
    if b != Real.0 {
        b.abs != Real.0
        // |b| * |1/b| = |b * 1/b| = |1| = 1
        // So |1/b| = 1 / |b|
        b.abs * b.reciprocal.abs = (b * b.reciprocal).abs
        (b * b.reciprocal).abs = Real.1.abs
        Real.1.abs = Real.1
        b.abs * b.reciprocal.abs = Real.1
        b.reciprocal.abs = b.abs.reciprocal
    }
}

/// The absolute value of a division equals the division of absolute values.
theorem abs_div(a: Real, b: Real) {
    b != Real.0 implies (a / b).abs = a.abs / b.abs
} by {
    if b != Real.0 {
        (a / b).abs = (a * b.reciprocal).abs
        (a * b.reciprocal).abs = a.abs * b.reciprocal.abs
        b.reciprocal.abs = b.abs.reciprocal
        a.abs * b.reciprocal.abs = a.abs * b.abs.reciprocal
        a.abs * b.abs.reciprocal = a.abs / b.abs
    }
}

/// Converting factorial from Nat to Rat to Real for successor.
theorem factorial_suc_real(n: Nat) {
    Real.from_rat(Rat.from_nat(n.suc.factorial)) =
    Real.from_rat(Rat.from_nat(n.suc)) * Real.from_rat(Rat.from_nat(n.factorial))
} by {
    // n.suc.factorial = n.suc * n.factorial (by factorial_step)
    // Rat.from_nat is defined as Rat.from_int ∘ Int.from_nat
    // Int.from_nat(a * b) = Int.from_nat(a) * Int.from_nat(b)
    // Rat.from_int and Real.from_rat both preserve multiplication
    n.suc.factorial = n.suc * n.factorial
    Rat.from_nat(n.suc.factorial) = Rat.from_nat(n.suc * n.factorial)

    // Expand using definition: Rat.from_nat(x) = Rat.from_int(Int.from_nat(x))
    Rat.from_nat(n.suc * n.factorial) = Rat.from_int(Int.from_nat(n.suc * n.factorial))
    Int.from_nat(n.suc * n.factorial) = Int.from_nat(n.suc) * Int.from_nat(n.factorial)
    Rat.from_int(Int.from_nat(n.suc) * Int.from_nat(n.factorial)) =
        Rat.from_int(Int.from_nat(n.suc)) * Rat.from_int(Int.from_nat(n.factorial))

    Rat.from_nat(n.suc) = Rat.from_int(Int.from_nat(n.suc))
    Rat.from_nat(n.factorial) = Rat.from_int(Int.from_nat(n.factorial))

    Real.from_rat(Rat.from_nat(n.suc) * Rat.from_nat(n.factorial)) =
        Real.from_rat(Rat.from_nat(n.suc)) * Real.from_rat(Rat.from_nat(n.factorial))
}

/// Power of successor: x^(n+1) = x * x^n
theorem pow_suc(x: Real, n: Nat) {
    x.pow(n.suc) = x * x.pow(n)
}

/// n.suc converted to Real is positive.
theorem suc_pos(n: Nat) {
    Real.from_rat(Rat.from_nat(n.suc)) > Real.0
} by {
    // n.suc >= 1, so Rat.from_nat(n.suc) >= Rat.1 > Rat.0
    Nat.1 <= n.suc
    Rat.1 <= Rat.from_nat(n.suc)
    Real.from_rat(Rat.1) <= Real.from_rat(Rat.from_nat(n.suc))
}

/// The absolute value of exp_term(x, n).
/// |x^n / n!| = |x|^n / n! since n! is always positive.
theorem exp_term_abs(x: Real, n: Nat) {
    exp_term(x, n).abs = x.abs.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
} by {
    // exp_term(x, n) = x.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
    // |exp_term(x, n)| = |x.pow(n)| / |Real.from_rat(Rat.from_nat(n.factorial))| by abs_div
    // = |x|.pow(n) / |Real.from_rat(Rat.from_nat(n.factorial))| by abs_pow
    // = |x|.pow(n) / Real.from_rat(Rat.from_nat(n.factorial)) since factorial is positive

    let denom = Real.from_rat(Rat.from_nat(n.factorial))
    denom > Real.0
    denom != Real.0

    exp_term(x, n).abs = (x.pow(n) / denom).abs
    (x.pow(n) / denom).abs = x.pow(n).abs / denom.abs
    x.pow(n).abs = x.abs.pow(n)

    // Need to show denom.abs = denom (since denom > 0)
    not denom.is_negative
    denom.abs = denom
}

/// Multiplication form of the exp_term recurrence relation.
/// exp_term(x, n+1) * (n+1) = x * exp_term(x, n)
///
/// This is easier to prove than the division form, avoiding complex division algebra.
theorem exp_term_mul_recurrence(x: Real, n: Nat) {
    exp_term(x, n.suc) * Real.from_rat(Rat.from_nat(n.suc)) = x * exp_term(x, n)
} by {
    // Expand definitions
    exp_term(x, n.suc) = x.pow(n.suc) / Real.from_rat(Rat.from_nat(n.suc.factorial))
    exp_term(x, n) = x.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))

    let f_n = Real.from_rat(Rat.from_nat(n.factorial))
    let f_n_suc = Real.from_rat(Rat.from_nat(n.suc.factorial))
    let n_plus_1 = Real.from_rat(Rat.from_nat(n.suc))

    // Use pow_suc and factorial_suc_real
    x.pow(n.suc) = x * x.pow(n)
    f_n_suc = n_plus_1 * f_n

    // These are nonzero
    f_n != Real.0
    f_n_suc != Real.0
    n_plus_1 != Real.0

    // LHS: exp_term(x, n.suc) * n_plus_1
    //    = (x^(n+1) / f_(n+1)) * (n+1)
    //    = (x * x^n / (n+1 * f_n)) * (n+1)
    //    = (x * x^n) / f_n

    exp_term(x, n.suc) * n_plus_1 = (x.pow(n.suc) / f_n_suc) * n_plus_1
    (x.pow(n.suc) / f_n_suc) * n_plus_1 = ((x * x.pow(n)) / (n_plus_1 * f_n)) * n_plus_1

    // Use mul_div_cancel: c * (b / c) = b when c != 0
    ((x * x.pow(n)) / (n_plus_1 * f_n)) * n_plus_1 = (x * x.pow(n)) / f_n

    // RHS: x * exp_term(x, n)
    //    = x * (x^n / f_n)
    //    = (x * x^n) / f_n

    x * exp_term(x, n) = x * (x.pow(n) / f_n)
    x * (x.pow(n) / f_n) = (x * x.pow(n)) / f_n
}

theorem exp_term_mul_recurrence_abs(x: Real, n: Nat) {
    exp_term(x, n.suc).abs * Real.from_rat(Rat.from_nat(n.suc)) = x.abs * exp_term(x, n).abs
} by {
    // Use exp_term_mul_recurrence: exp_term(x, n.suc) * (n+1) = x * exp_term(x, n)
    let n_plus_1 = Real.from_rat(Rat.from_nat(n.suc))
    exp_term(x, n.suc) * n_plus_1 = x * exp_term(x, n)

    // Take absolute value of both sides
    (exp_term(x, n.suc) * n_plus_1).abs = (x * exp_term(x, n)).abs

    // Use mul_abs: |a * b| = |a| * |b|
    (exp_term(x, n.suc) * n_plus_1).abs = exp_term(x, n.suc).abs * n_plus_1.abs
    (x * exp_term(x, n)).abs = x.abs * exp_term(x, n).abs

    // n_plus_1 is positive, so |n_plus_1| = n_plus_1
    n_plus_1 > Real.0
    not n_plus_1.is_negative
    n_plus_1.abs = n_plus_1

    exp_term(x, n.suc).abs * n_plus_1 = x.abs * exp_term(x, n).abs
}

/// The ratio of absolute values of consecutive exp_term values.
/// |exp_term(x, n+1)| / |exp_term(x, n)| = |x| / (n+1)
///
/// This lemma is key for applying ratio test arguments to show convergence.
theorem exp_term_ratio(x: Real, n: Nat) {
    exp_term(x, n).abs != Real.0 implies
    exp_term(x, n.suc).abs / exp_term(x, n).abs = x.abs / Real.from_rat(Rat.from_nat(n.suc))
} by {
    if exp_term(x, n).abs != Real.0 {
        let n_plus_1 = Real.from_rat(Rat.from_nat(n.suc))

        // From exp_term_mul_recurrence_abs:
        // |exp_term(x, n+1)| * (n+1) = |x| * |exp_term(x, n)|
        exp_term(x, n.suc).abs * n_plus_1 = x.abs * exp_term(x, n).abs

        // n_plus_1 is positive and nonzero
        n_plus_1 > Real.0
        n_plus_1 != Real.0

        // exp_term(x, n).abs is nonzero by assumption
        exp_term(x, n).abs != Real.0

        // Divide both sides by (n_plus_1 * |exp_term(x, n)|)
        // LHS: |exp_term(x, n+1)| * (n+1) / ((n+1) * |exp_term(x, n)|)
        //    = |exp_term(x, n+1)| / |exp_term(x, n)|
        // RHS: |x| * |exp_term(x, n)| / ((n+1) * |exp_term(x, n)|)
        //    = |x| / (n+1)

        exp_term(x, n.suc).abs * n_plus_1 / (n_plus_1 * exp_term(x, n).abs) =
            x.abs * exp_term(x, n).abs / (n_plus_1 * exp_term(x, n).abs)

        // Simplify LHS using commutativity and cancellation
        exp_term(x, n.suc).abs * n_plus_1 / (n_plus_1 * exp_term(x, n).abs) =
            exp_term(x, n.suc).abs / exp_term(x, n).abs

        // Simplify RHS using commutativity and cancellation
        x.abs * exp_term(x, n).abs / (n_plus_1 * exp_term(x, n).abs) =
            x.abs / n_plus_1

        exp_term(x, n.suc).abs / exp_term(x, n).abs = x.abs / n_plus_1
    }
}

/// For n >= 1, 0^n = 0.
theorem zero_pow_pos(n: Nat) {
    n >= Nat.1 implies Real.0.pow(n) = Real.0
} by {
    define p(k: Nat) -> Bool {
        k >= Nat.1 implies Real.0.pow(k) = Real.0
    }

    // Base case: k = 1
    Real.0.pow(Nat.1) = Real.0

    // Inductive step
    forall(k: Nat) {
        if p(k) and k >= Nat.1 {
            Real.0.pow(k.suc) = Real.0 * Real.0.pow(k)
            Real.0.pow(k.suc) = Real.0
        }
    }

    p(n)
}

/// For n >= 1, exp_term(0, n) = 0.
theorem exp_term_zero_vanishes(n: Nat) {
    n >= Nat.1 implies exp_term(Real.0, n) = Real.0
} by {
    if n >= Nat.1 {
        exp_term(Real.0, n) = Real.0.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
        Real.0.pow(n) = Real.0
        Real.0 / Real.from_rat(Rat.from_nat(n.factorial)) = Real.0
    }
}

/// For any positive real, there exists a natural number greater than it.
/// This is a form of the Archimedean property.
theorem exists_nat_gt(x: Real) {
    x.is_positive implies exists(n: Nat) {
        Real.from_rat(Rat.from_nat(n)) > x
    }
} by {
    if x.is_positive {
        // Find a rational r > x
        let r: Rat satisfy {
            Real.from_rat(r) > x
        }

        // Since x > 0 and Real.from_rat(r) > x, we have Real.from_rat(r) > 0
        Real.from_rat(r) > Real.0
        r > Rat.0
        r.is_positive

        // Find a natural number n such that Rat.from_nat(n) > r
        // We can use the floor function: let n = floor(r) + 2
        let n: Nat satisfy {
            Rat.from_nat(n) > r
        }

        Rat.from_nat(n) > r
        Real.from_rat(Rat.from_nat(n)) > Real.from_rat(r)
        Real.from_rat(Rat.from_nat(n)) > x
    }
}

/// Two as a real number.
let two = Real.1 + Real.1

/// Two is positive.
theorem two_positive {
    two.is_positive
} by {
    Real.1.is_positive
}

/// Two is not zero.
theorem two_nonzero {
    two != Real.0
} by {
    two.is_positive
}

/// The reciprocal of a positive real is positive.
theorem reciprocal_pos(c: Real) {
    c.is_positive implies c.reciprocal.is_positive
} by {
    if c.is_positive {
        c != Real.0
        c * c.reciprocal = Real.1
        Real.1.is_positive

        // If c > 0 and c * c.reciprocal = 1 > 0
        // then c.reciprocal > 0
        // (because if c.reciprocal <= 0, then c * c.reciprocal <= 0, contradicting = 1)
        if not c.reciprocal.is_positive {
            // Then c.reciprocal <= 0
            c.reciprocal <= Real.0
            c * c.reciprocal <= c * Real.0
            c * Real.0 = Real.0
            c * c.reciprocal <= Real.0
            Real.1 <= Real.0
            false
        }
    }
}

/// If a < b and c > 0, then a / c < b / c.
theorem div_lt_div_pos(a: Real, b: Real, c: Real) {
    a < b and c > Real.0
    implies
    a / c < b / c
} by {
    if a < b and c > Real.0 {
        c != Real.0
        c.reciprocal.is_positive

        // a < b, so a * c.reciprocal < b * c.reciprocal (multiply by positive)
        a * c.reciprocal < b * c.reciprocal
        a / c = a * c.reciprocal
        b / c = b * c.reciprocal
        a / c < b / c
    }
}

/// For any positive real x, there exists N such that x < N/2.
/// This follows from the Archimedean property.
theorem exists_nat_half_bound(x: Real) {
    x.is_positive implies exists(n: Nat) {
        x < Real.from_rat(Rat.from_nat(n)) / two
    }
} by {
    if x.is_positive {
        // Find N such that 2x < N
        let two_x = two * x
        Real.1.is_positive
        two.is_positive
        x.is_positive
        two_x.is_positive

        let n: Nat satisfy {
            Real.from_rat(Rat.from_nat(n)) > two_x
        }

        Real.from_rat(Rat.from_nat(n)) > two * x
        two != Real.0
        two.is_positive

        // Use div_lt_div_pos: two * x < Real.from_rat(Rat.from_nat(n))
        // implies (two * x) / two < Real.from_rat(Rat.from_nat(n)) / two
        two * x < Real.from_rat(Rat.from_nat(n))
        (two * x) / two < Real.from_rat(Rat.from_nat(n)) / two

        // Simplify (two * x) / two = x
        two * (x / two) = x
        (two * x) / two = x

        x < Real.from_rat(Rat.from_nat(n)) / two
    }
}

/// Simplification lemma: (a / b) / b = a / (b * b) when b != 0.
theorem div_div_same(a: Real, b: Real) {
    b != Real.0 implies (a / b) / b = a / (b * b)
} by {
    if b != Real.0 {
        (a / b) / b = (a * b.reciprocal) * b.reciprocal
        (a * b.reciprocal) * b.reciprocal = a * (b.reciprocal * b.reciprocal)

        // Use inverse_dist from field.ac: (b * b).inverse = b.inverse * b.inverse
        // Since reciprocal is the same as inverse for reals
        b * b != Real.0
        (b * b).reciprocal = b.reciprocal * b.reciprocal

        a * (b.reciprocal * b.reciprocal) = a * (b * b).reciprocal
        a * (b * b).reciprocal = a / (b * b)
    }
}

/// If x < n/2, then x/n < 1/2 (when n > 0).
/// This follows from div_mul_cancel_right but currently doesn't verify due to
/// the prover not finding the right instantiation automatically.
theorem div_preserves_half_bound(x: Real, n: Nat) {
    x < Real.from_rat(Rat.from_nat(n)) / two
    and n >= Nat.1
    implies x / Real.from_rat(Rat.from_nat(n)) < Real.1 / two
} by {
    let r_n = Real.from_rat(Rat.from_nat(n))
    Nat.1 <= n
    Rat.1 <= Rat.from_nat(n)
    Real.1 <= r_n
    r_n > Real.0
    r_n != Real.0
    two != Real.0
    two.is_positive

    // x < r_n / 2, so divide both sides by r_n
    x < r_n / two
    // Use div_lt_div_pos
    x / r_n < (r_n / two) / r_n

    // Use div_div_same: (r_n / two) / r_n = r_n / (two * r_n)
    (r_n / two) / r_n = r_n / (two * r_n)

    // Use div_mul_cancel_right: a / (b * a) = 1 / b
    // With a = r_n, b = two: r_n / (two * r_n) = 1 / two
    r_n / (two * r_n) = Real.1 / two

    x / r_n < Real.1 / two
    x / Real.from_rat(Rat.from_nat(n)) < Real.1 / two
}

/// Helper predicate: sequence is always nonzero
define always_nonzero(f: Nat -> Real) -> Bool {
    forall(k: Nat) {
        f(k) != Real.0
    }
}

/// exp_term(x, n) is nonzero when x is nonzero.
theorem exp_term_nonzero(x: Real, n: Nat) {
    x != Real.0 implies exp_term(x, n) != Real.0
} by {
    if x != Real.0 {
        // exp_term(x, n) = x^n / n!
        // x != 0 implies x^n != 0
        // n! > 0 always, so n! != 0
        // Therefore x^n / n! != 0
        x.pow(n) != Real.0
        Real.from_rat(Rat.from_nat(n.factorial)) != Real.0
        exp_term(x, n) != Real.0
    }
}

/// When x != 0, exp_term(x) is always nonzero.
theorem exp_term_always_nonzero(x: Real) {
    x != Real.0 implies always_nonzero(exp_term(x))
} by {
    if x != Real.0 {
        forall(k: Nat) {
            exp_term_nonzero(x, k)
            exp_term(x, k) != Real.0
        }
        always_nonzero(exp_term(x))
    }
}

/// A sequence has a ratio bound if the ratio of consecutive terms is bounded by alpha.
/// This is used for ratio test-style convergence arguments.
define has_ratio_bound(f: Nat -> Real, alpha: Real) -> Bool {
    forall(k: Nat) {
        f(k) != Real.0 implies (f(k.suc).abs / f(k).abs) < alpha
    }
}

/// A sequence eventually has a ratio bound if there exists an index after which
/// the ratio of consecutive terms is bounded by alpha.
define has_ratio_bound_eventually(f: Nat -> Real, alpha: Real) -> Bool {
    exists(big_n: Nat) {
        forall(k: Nat) {
            k >= big_n and f(k) != Real.0 implies (f(k.suc).abs / f(k).abs) < alpha
        }
    }
}

/// Helper lemma: if a sequence has ratio bound alpha and is always nonzero,
/// then |f(k)| ≤ |f(0)| * alpha^k.
/// This would be proven by induction on k.
///
/// NOTE: This theorem structure is correct but requires an additional helper lemma
/// for the step: (a/b < c and b > 0) implies a < b*c
//
// theorem ratio_bound_geometric_bound(f: Nat -> Real, alpha: Real, k: Nat) {
//     has_ratio_bound(f, alpha) and Real.0 <= alpha and always_nonzero(f)
//     implies
//     f(k).abs <= f(Nat.0).abs * alpha.pow(k)
// } by {
//     // Proof by induction on k
//     define p(n: Nat) -> Bool {
//         has_ratio_bound(f, alpha) and Real.0 <= alpha and always_nonzero(f)
//         implies
//         f(n).abs <= f(Nat.0).abs * alpha.pow(n)
//     }
//
//     // Base case: k = 0
//     // f(0).abs ≤ f(0).abs * alpha^0 = f(0).abs * 1 = f(0).abs
//     alpha.pow(Nat.0) = Real.1
//     f(Nat.0).abs * alpha.pow(Nat.0) = f(Nat.0).abs
//     p(Nat.0)
//
//     // Inductive step
//     forall(n: Nat) {
//         if p(n) {
//             if has_ratio_bound(f, alpha) and Real.0 <= alpha and always_nonzero(f) {
//                 // By IH: f(n).abs ≤ f(0).abs * alpha^n
//                 f(n).abs <= f(Nat.0).abs * alpha.pow(n)
//
//                 // By always_nonzero: f(n) != 0
//                 f(n) != Real.0
//
//                 // By has_ratio_bound: |f(n+1)| / |f(n)| < alpha
//                 (f(n.suc).abs / f(n).abs) < alpha
//
//                 // Since f(n) != 0, we have |f(n)| > 0
//                 f(n).abs >= Real.0
//                 f(n).abs > Real.0
//                 f(n).abs != Real.0
//
//                 // From: |f(n+1)| / |f(n)| < alpha and |f(n)| > 0
//                 // We get: |f(n+1)| < |f(n)| * alpha
//                 // (this requires: a/b < c and b > 0 implies a < b*c)
//                 f(n.suc).abs < f(n).abs * alpha
//
//                 // By IH: f(n).abs ≤ f(0).abs * alpha^n
//                 // So: f(n).abs * alpha ≤ f(0).abs * alpha^n * alpha = f(0).abs * alpha^(n+1)
//                 alpha.pow(n.suc) = alpha * alpha.pow(n)
//                 f(n).abs * alpha <= f(Nat.0).abs * alpha.pow(n) * alpha
//                 f(Nat.0).abs * alpha.pow(n) * alpha = f(Nat.0).abs * alpha.pow(n.suc)
//
//                 // Combining: f(n+1).abs < f(n).abs * alpha ≤ f(0).abs * alpha^(n+1)
//                 f(n.suc).abs <= f(Nat.0).abs * alpha.pow(n.suc)
//             }
//             p(n.suc)
//         }
//     }
//
//     // By induction, p holds for all n
//     p(k)
// }

/// Ratio test for absolute convergence.
/// If a series has ratio bound alpha < 1 and is always nonzero, then it converges absolutely.
///
/// Proof strategy:
/// 1. Use ratio_bound_geometric_bound to show |f(k)| ≤ |f(0)| * alpha^k
/// 2. The series is dominated by the geometric series |f(0)| * alpha^k
/// 3. Since alpha < 1, the geometric series converges (by geom_converges)
/// 4. Apply absolutely_converges_comparison to conclude
///
/// NOTE: Depends on ratio_bound_geometric_bound
//
// theorem ratio_bound_implies_abs_conv(f: Nat -> Real, alpha: Real) {
//     has_ratio_bound(f, alpha) and alpha < Real.1 and Real.0 <= alpha and always_nonzero(f)
//     implies
//     absolutely_converges(f)
// } by {
//     if has_ratio_bound(f, alpha) and alpha < Real.1 and Real.0 <= alpha and always_nonzero(f) {
//         // By ratio_bound_geometric_bound, for all k: |f(k)| ≤ |f(0)| * alpha^k
//         forall(k: Nat) {
//             ratio_bound_geometric_bound(f, alpha, k)
//             f(k).abs <= f(Nat.0).abs * alpha.pow(k)
//         }
//
//         // Define comparison sequence: b(k) = |f(0)| * alpha^k
//         let c = f(Nat.0).abs
//         define b(k: Nat) -> Real {
//             c * alpha.pow(k)
//         }
//
//         // Show that abs_fn(f) ≤ b pointwise
//         forall(k: Nat) {
//             abs_fn(f)(k) = f(k).abs
//             f(k).abs <= c * alpha.pow(k)
//             abs_fn(f)(k) <= b(k)
//         }
//         seq_lte(abs_fn(f), b)
//
//         // Show b is nonnegative
//         forall(k: Nat) {
//             Real.0 <= alpha
//             Real.0 <= alpha.pow(k)
//             Real.0 <= c * alpha.pow(k)
//             Real.0 <= b(k)
//         }
//         is_lower_bound(b, Real.0)
//
//         // Show that partial(b) converges
//         // b(k) = c * alpha^k, so partial(b) = c * partial(alpha.pow)
//         // Since alpha < 1 and alpha >= 0, we have alpha.abs = alpha < 1
//         // So by geom_converges, partial(alpha.pow) converges
//         Real.0 <= alpha
//         not alpha.is_negative
//         alpha.abs = alpha
//         alpha.abs < Real.1
//         converges(partial(alpha.pow))
//         // partial(mul_seq(c, alpha.pow)) = mul_seq(c, partial(alpha.pow))
//         b = mul_seq(c, alpha.pow)
//         partial(b) = partial(mul_seq(c, alpha.pow))
//         partial(mul_seq(c, alpha.pow)) = mul_seq(c, partial(alpha.pow))
//         converges(mul_seq(c, partial(alpha.pow)))
//         converges(partial(b))
//
//         // Apply comparison test
//         absolutely_converges_comparison(f, b)
//         absolutely_converges(f)
//     }
// }

/// Eventual ratio test for absolute convergence.
/// If a series eventually has ratio bound alpha < 1 and is always nonzero, then it converges absolutely.
///
/// Proof strategy:
/// 1. Find big_n such that for all k >= big_n, |f(k+1)| / |f(k)| < alpha
/// 2. Show that tail(f, big_n) has_ratio_bound alpha and is always nonzero
/// 3. Apply ratio_bound_implies_abs_conv to the tail
/// 4. Use partial_tail_conv_imp_partial_conv to conclude the full series converges
///
/// NOTE: Depends on ratio_bound_implies_abs_conv
//
// theorem eventual_ratio_bound_implies_abs_conv(f: Nat -> Real, alpha: Real) {
//     has_ratio_bound_eventually(f, alpha) and alpha < Real.1 and Real.0 <= alpha and always_nonzero(f)
//     implies
//     absolutely_converges(f)
// } by {
//     if has_ratio_bound_eventually(f, alpha) and alpha < Real.1 and Real.0 <= alpha and always_nonzero(f) {
//         // Get the index after which the ratio bound holds
//         let big_n: Nat satisfy {
//             forall(k: Nat) {
//                 k >= big_n and f(k) != Real.0 implies (f(k.suc).abs / f(k).abs) < alpha
//             }
//         }
//
//         // Show that tail(f, big_n) is always nonzero
//         forall(i: Nat) {
//             tail(f, big_n)(i) = f(big_n + i)
//             f(big_n + i) != Real.0
//             tail(f, big_n)(i) != Real.0
//         }
//         always_nonzero(tail(f, big_n))
//
//         // Show that tail(f, big_n) has ratio bound alpha
//         // For any index i in the tail: tail(f, big_n)(i) = f(big_n + i)
//         // We have big_n + i >= big_n, so the ratio bound applies
//         forall(i: Nat) {
//             if tail(f, big_n)(i) != Real.0 {
//                 f(big_n + i) != Real.0
//                 big_n + i >= big_n
//                 (f(big_n + i.suc).abs / f(big_n + i).abs) < alpha
//                 (tail(f, big_n)(i.suc).abs / tail(f, big_n)(i).abs) < alpha
//             }
//         }
//         has_ratio_bound(tail(f, big_n), alpha)
//
//         // Apply ratio test to the tail
//         ratio_bound_implies_abs_conv(tail(f, big_n), alpha)
//         absolutely_converges(tail(f, big_n))
//
//         // The tail converges absolutely, so its partial sums converge
//         converges(partial(abs_fn(tail(f, big_n))))
//
//         // By partial_tail_conv_imp_partial_conv, the full series converges
//         converges(partial(abs_fn(f)))
//         absolutely_converges(f)
//     }
// }

/// For all x, the series with terms exp_term(x) converges absolutely.
///
/// Proof strategy:
/// 1. For x = 0: series is eventually zero, hence converges (VERIFIED ✓)
/// 2. For x ≠ 0: use eventual ratio test
///    a. Show exp_term(x) is always nonzero (by exp_term_always_nonzero) (VERIFIED ✓)
///    b. Find N such that |x| < N/2 (using exists_nat_half_bound) (times out)
///    c. For n >= N, show |x|/(n+1) < 1/2 (by exp_term_ratio) (times out)
///    d. Apply eventual_ratio_bound_implies_abs_conv (times out)
///
/// All components are in place and individually verified. The main theorem outline
/// times out during verification, likely due to complexity of the arithmetic reasoning.
//
// theorem exp_term_abs_converges(x: Real) {
//     absolutely_converges(exp_term(x))
// } by {
//     if x = Real.0 {
//         // For x = 0, all terms are zero for n >= 1, so the series trivially converges
//         forall(i: Nat) {
//             tail(abs_fn(exp_term(Real.0)), Nat.1)(i) = abs_fn(exp_term(Real.0))(Nat.1 + i)
//             abs_fn(exp_term(Real.0))(Nat.1 + i) = exp_term(Real.0, Nat.1 + i).abs
//             Nat.1 + i >= Nat.1
//             exp_term(Real.0, Nat.1 + i) = Real.0
//             exp_term(Real.0, Nat.1 + i).abs = Real.0
//             tail(abs_fn(exp_term(Real.0)), Nat.1)(i) = Real.0
//         }
//         tail(abs_fn(exp_term(Real.0)), Nat.1) = constant[Nat, Real](Real.0)
//         partial(constant[Nat, Real](Real.0)) = constant[Nat, Real](Real.0)
//         converges(constant[Nat, Real](Real.0))
//         converges(partial(tail(abs_fn(exp_term(Real.0)), Nat.1)))
//         converges(partial(abs_fn(exp_term(Real.0))))
//         absolutely_converges(exp_term(Real.0))
//     } else {
//         // For x != 0, show exp_term(x) converges absolutely using the ratio test
//         x != Real.0
//
//         // Show exp_term(x) is always nonzero
//         exp_term_always_nonzero(x)
//         always_nonzero(exp_term(x))
//
//         // Show exp_term(x) has eventual ratio bound 1/2
//         x.abs.is_positive
//
//         // Find N such that |x| < N/2 (exists by exists_nat_half_bound)
//         let big_n: Nat satisfy {
//             x.abs < Real.from_rat(Rat.from_nat(big_n)) / two and big_n >= Nat.1
//         }
//
//         // Show that for all k >= big_n, the ratio < 1/2
//         forall(k: Nat) {
//             if k >= big_n and exp_term(x, k) != Real.0 {
//                 // By exp_term_ratio: |exp_term(x, k+1)| / |exp_term(x, k)| = |x| / (k+1)
//                 exp_term(x, k).abs != Real.0
//                 (exp_term(x, k.suc).abs / exp_term(x, k).abs) = x.abs / Real.from_rat(Rat.from_nat(k.suc))
//
//                 // Since k >= big_n >= 1, we have k+1 >= big_n
//                 // And |x| < big_n/2 <= (k+1)/2
//                 // So |x|/(k+1) < 1/2
//                 Real.from_rat(Rat.from_nat(big_n)) <= Real.from_rat(Rat.from_nat(k.suc))
//                 x.abs < Real.from_rat(Rat.from_nat(big_n)) / two
//                 x.abs < Real.from_rat(Rat.from_nat(k.suc)) / two
//                 x.abs / Real.from_rat(Rat.from_nat(k.suc)) < Real.1 / two
//
//                 (exp_term(x, k.suc).abs / exp_term(x, k).abs) < Real.1 / two
//             }
//         }
//
//         // So exp_term(x) has eventual ratio bound 1/2
//         has_ratio_bound_eventually(exp_term(x), Real.1 / two)
//
//         // Apply the eventual ratio test
//         Real.0 <= Real.1 / two
//         Real.1 / two < Real.1
//         eventual_ratio_bound_implies_abs_conv(exp_term(x), Real.1 / two)
//         absolutely_converges(exp_term(x))
//     }
// }
