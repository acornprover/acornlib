from nat import Nat
from int import Int
from rat import Rat
from real.real_field import Real
from real.real_ring import converges, limit, mul_abs
from real.real_base import abs_from_rat
from real.abs_conv import absolutely_converges, abs_fn
from real.real_series import seq_lte, abs_pow
from list import partial

numerals Real
numerals Nat

/// The nth term in the Taylor series expansion of e^x.
/// For a real number x and natural number n, this returns x^n / n!
define exp_term(x: Real, n: Nat) -> Real {
    x.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
}

// Helper lemmas for working with exp_term

/// Factorial is positive for all n.
theorem factorial_pos(n: Nat) {
    Real.from_rat(Rat.from_nat(n.factorial)) > Real.0
} by {
    // 1 <= n.factorial for all n
    // So Rat.1 <= Rat.from_nat(n.factorial)
    // And Real.1 <= Real.from_rat(Rat.from_nat(n.factorial))
    // Therefore Real.from_rat(Rat.from_nat(n.factorial)) > Real.0
    Nat.1 <= n.factorial
    Rat.1 <= Rat.from_nat(n.factorial)
    Real.from_rat(Rat.1) <= Real.from_rat(Rat.from_nat(n.factorial))
}

/// The absolute value of a division equals the division of absolute values.
theorem abs_div(a: Real, b: Real) {
    b != Real.0 implies (a / b).abs = a.abs / b.abs
} by {
    // a / b = a * b.reciprocal
    // |a / b| = |a * b.reciprocal| = |a| * |b.reciprocal| by mul_abs
    // Need to show |b.reciprocal| = |b|.reciprocal
}

/// Converting factorial from Nat to Rat to Real for successor.
theorem factorial_suc_real(n: Nat) {
    Real.from_rat(Rat.from_nat(n.suc.factorial)) =
    Real.from_rat(Rat.from_nat(n.suc)) * Real.from_rat(Rat.from_nat(n.factorial))
} by {
    // n.suc.factorial = n.suc * n.factorial (by factorial_step)
    // Rat.from_nat is defined as Rat.from_int âˆ˜ Int.from_nat
    // Int.from_nat(a * b) = Int.from_nat(a) * Int.from_nat(b)
    // Rat.from_int and Real.from_rat both preserve multiplication
    n.suc.factorial = n.suc * n.factorial
    Rat.from_nat(n.suc.factorial) = Rat.from_nat(n.suc * n.factorial)

    // Expand using definition: Rat.from_nat(x) = Rat.from_int(Int.from_nat(x))
    Rat.from_nat(n.suc * n.factorial) = Rat.from_int(Int.from_nat(n.suc * n.factorial))
    Int.from_nat(n.suc * n.factorial) = Int.from_nat(n.suc) * Int.from_nat(n.factorial)
    Rat.from_int(Int.from_nat(n.suc) * Int.from_nat(n.factorial)) =
        Rat.from_int(Int.from_nat(n.suc)) * Rat.from_int(Int.from_nat(n.factorial))

    Rat.from_nat(n.suc) = Rat.from_int(Int.from_nat(n.suc))
    Rat.from_nat(n.factorial) = Rat.from_int(Int.from_nat(n.factorial))

    Real.from_rat(Rat.from_nat(n.suc) * Rat.from_nat(n.factorial)) =
        Real.from_rat(Rat.from_nat(n.suc)) * Real.from_rat(Rat.from_nat(n.factorial))
}

/// Power of successor: x^(n+1) = x * x^n
theorem pow_suc(x: Real, n: Nat) {
    x.pow(n.suc) = x * x.pow(n)
}

/// n.suc converted to Real is positive.
theorem suc_pos(n: Nat) {
    Real.from_rat(Rat.from_nat(n.suc)) > Real.0
} by {
    // n.suc >= 1, so Rat.from_nat(n.suc) >= Rat.1 > Rat.0
    Nat.1 <= n.suc
    Rat.1 <= Rat.from_nat(n.suc)
    Real.from_rat(Rat.1) <= Real.from_rat(Rat.from_nat(n.suc))
}

/// The absolute value of exp_term(x, n).
/// |x^n / n!| = |x|^n / n! since n! is always positive.
theorem exp_term_abs(x: Real, n: Nat) {
    exp_term(x, n).abs = x.abs.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
} by {
    // exp_term(x, n) = x.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
    // |exp_term(x, n)| = |x.pow(n)| / |Real.from_rat(Rat.from_nat(n.factorial))| by abs_div
    // = |x|.pow(n) / |Real.from_rat(Rat.from_nat(n.factorial))| by abs_pow
    // = |x|.pow(n) / Real.from_rat(Rat.from_nat(n.factorial)) since factorial is positive

    let denom = Real.from_rat(Rat.from_nat(n.factorial))
    denom > Real.0
    denom != Real.0

    exp_term(x, n).abs = (x.pow(n) / denom).abs
    (x.pow(n) / denom).abs = x.pow(n).abs / denom.abs
    x.pow(n).abs = x.abs.pow(n)

    // Need to show denom.abs = denom (since denom > 0)
    not denom.is_negative
    denom.abs = denom
}

/// The ratio of absolute values of consecutive exp_term values.
/// |exp_term(x, n+1)| / |exp_term(x, n)| = |x| / (n+1)
///
/// This lemma is key for applying ratio test arguments to show convergence.
/// The proof is complete in principle but requires additional field division lemmas.
// theorem exp_term_ratio(x: Real, n: Nat) {
//     exp_term(x, n) != Real.0 implies
//     exp_term(x, n.suc).abs / exp_term(x, n).abs = x.abs / Real.from_rat(Rat.from_nat(n.suc))
// } by {
//     exp_term(x, n.suc).abs = x.abs.pow(n.suc) / Real.from_rat(Rat.from_nat(n.suc.factorial))
//     exp_term(x, n).abs = x.abs.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
//
//     // Use pow_suc: x.abs.pow(n.suc) = x.abs * x.abs.pow(n)
//     x.abs.pow(n.suc) = x.abs * x.abs.pow(n)
//
//     // Use factorial_suc_real
//     Real.from_rat(Rat.from_nat(n.suc.factorial)) =
//         Real.from_rat(Rat.from_nat(n.suc)) * Real.from_rat(Rat.from_nat(n.factorial))
//
//     let f_n = Real.from_rat(Rat.from_nat(n.factorial))
//     let n_plus_1 = Real.from_rat(Rat.from_nat(n.suc))
//
//     // Establish positivity
//     f_n > Real.0
//     f_n != Real.0
//     n_plus_1 > Real.0
//     n_plus_1 != Real.0
//
//     // Substitute into the formulas:
//     exp_term(x, n.suc).abs = (x.abs * x.abs.pow(n)) / (n_plus_1 * f_n)
//     exp_term(x, n).abs = x.abs.pow(n) / f_n
//
//     // Now compute the ratio:
//     // [(x.abs * x.abs.pow(n)) / (n_plus_1 * f_n)] / [x.abs.pow(n) / f_n]
//     // = [(x.abs * x.abs.pow(n)) / (n_plus_1 * f_n)] * [f_n / x.abs.pow(n)]
//     // = [x.abs * x.abs.pow(n) * f_n] / [n_plus_1 * f_n * x.abs.pow(n)]
//     // = x.abs / n_plus_1  (canceling x.abs.pow(n) and f_n from numerator and denominator)
//
//     // Requires lemma: (a * b) / (c * d) / (b / d) = a / c when b, d != 0
// }

/// For all x, the series with terms exp_term(x) converges absolutely.
///
/// Proof strategy:
/// 1. For any x, choose N such that |x| < N (using archimedean property)
/// 2. For n >= 2N, we have |x|/(n+1) <= |x|/n < N/n <= 1/2
/// 3. By exp_term_ratio, the ratio of consecutive terms is < 1/2 for large n
/// 4. This means the tail of the series is dominated by a geometric series with ratio 1/2
/// 5. By comparison_test, the series converges absolutely
///
/// This proof requires additional lemmas about:
/// - Archimedean property of reals
/// - Comparison with tails of geometric series
/// - Properties of factorial growth
// theorem exp_term_abs_converges(x: Real) {
//     absolutely_converges(exp_term(x))
// } by {
//     // For the case x = 0, the series is trivially convergent (all terms are 0 after the first)
//     if x = Real.0 {
//         // exp_term(Real.0, n) = Real.0 for all n >= 1
//         absolutely_converges(exp_term(x))
//     } else {
//         // For x != 0, use the ratio test argument outlined above
//         // This requires substantial development of helper lemmas
//     }
// }
