from nat import Nat
from int import Int
from rat import Rat
from real.real_field import Real
from real.real_ring import converges, limit, mul_abs
from real.real_base import abs_from_rat
from real.abs_conv import absolutely_converges, abs_fn
from real.real_series import seq_lte, abs_pow, is_increasing, is_upper_bound, monotone_convergence_principle
from real.real_seq import cauchy_bound
from list import partial

numerals Real
numerals Nat

/// The nth term in the Taylor series expansion of e^x.
/// For a real number x and natural number n, this returns x^n / n!
define exp_term(x: Real, n: Nat) -> Real {
    x.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
}

// Helper lemmas for working with exp_term

/// Factorial is positive for all n.
theorem factorial_pos(n: Nat) {
    Real.from_rat(Rat.from_nat(n.factorial)) > Real.0
} by {
    // 1 <= n.factorial for all n
    // So Rat.1 <= Rat.from_nat(n.factorial)
    // And Real.1 <= Real.from_rat(Rat.from_nat(n.factorial))
    // Therefore Real.from_rat(Rat.from_nat(n.factorial)) > Real.0
    Nat.1 <= n.factorial
    Rat.1 <= Rat.from_nat(n.factorial)
    Real.from_rat(Rat.1) <= Real.from_rat(Rat.from_nat(n.factorial))
}

/// The absolute value of a division equals the division of absolute values.
theorem abs_div(a: Real, b: Real) {
    b != Real.0 implies (a / b).abs = a.abs / b.abs
} by {
    // a / b = a * b.reciprocal
    // |a / b| = |a * b.reciprocal| = |a| * |b.reciprocal| by mul_abs
    // Need to show |b.reciprocal| = |b|.reciprocal
}

/// Converting factorial from Nat to Rat to Real for successor.
theorem factorial_suc_real(n: Nat) {
    Real.from_rat(Rat.from_nat(n.suc.factorial)) =
    Real.from_rat(Rat.from_nat(n.suc)) * Real.from_rat(Rat.from_nat(n.factorial))
} by {
    // n.suc.factorial = n.suc * n.factorial (by factorial_step)
    // Rat.from_nat is defined as Rat.from_int âˆ˜ Int.from_nat
    // Int.from_nat(a * b) = Int.from_nat(a) * Int.from_nat(b)
    // Rat.from_int and Real.from_rat both preserve multiplication
    n.suc.factorial = n.suc * n.factorial
    Rat.from_nat(n.suc.factorial) = Rat.from_nat(n.suc * n.factorial)

    // Expand using definition: Rat.from_nat(x) = Rat.from_int(Int.from_nat(x))
    Rat.from_nat(n.suc * n.factorial) = Rat.from_int(Int.from_nat(n.suc * n.factorial))
    Int.from_nat(n.suc * n.factorial) = Int.from_nat(n.suc) * Int.from_nat(n.factorial)
    Rat.from_int(Int.from_nat(n.suc) * Int.from_nat(n.factorial)) =
        Rat.from_int(Int.from_nat(n.suc)) * Rat.from_int(Int.from_nat(n.factorial))

    Rat.from_nat(n.suc) = Rat.from_int(Int.from_nat(n.suc))
    Rat.from_nat(n.factorial) = Rat.from_int(Int.from_nat(n.factorial))

    Real.from_rat(Rat.from_nat(n.suc) * Rat.from_nat(n.factorial)) =
        Real.from_rat(Rat.from_nat(n.suc)) * Real.from_rat(Rat.from_nat(n.factorial))
}

/// Power of successor: x^(n+1) = x * x^n
theorem pow_suc(x: Real, n: Nat) {
    x.pow(n.suc) = x * x.pow(n)
}

/// n.suc converted to Real is positive.
theorem suc_pos(n: Nat) {
    Real.from_rat(Rat.from_nat(n.suc)) > Real.0
} by {
    // n.suc >= 1, so Rat.from_nat(n.suc) >= Rat.1 > Rat.0
    Nat.1 <= n.suc
    Rat.1 <= Rat.from_nat(n.suc)
    Real.from_rat(Rat.1) <= Real.from_rat(Rat.from_nat(n.suc))
}

/// The absolute value of exp_term(x, n).
/// |x^n / n!| = |x|^n / n! since n! is always positive.
theorem exp_term_abs(x: Real, n: Nat) {
    exp_term(x, n).abs = x.abs.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
} by {
    // exp_term(x, n) = x.pow(n) / Real.from_rat(Rat.from_nat(n.factorial))
    // |exp_term(x, n)| = |x.pow(n)| / |Real.from_rat(Rat.from_nat(n.factorial))| by abs_div
    // = |x|.pow(n) / |Real.from_rat(Rat.from_nat(n.factorial))| by abs_pow
    // = |x|.pow(n) / Real.from_rat(Rat.from_nat(n.factorial)) since factorial is positive

    let denom = Real.from_rat(Rat.from_nat(n.factorial))
    denom > Real.0
    denom != Real.0

    exp_term(x, n).abs = (x.pow(n) / denom).abs
    (x.pow(n) / denom).abs = x.pow(n).abs / denom.abs
    x.pow(n).abs = x.abs.pow(n)

    // Need to show denom.abs = denom (since denom > 0)
    not denom.is_negative
    denom.abs = denom
}

/// exp_term(0, n) equals 0 for n >= 1.
theorem exp_term_zero_suc(n: Nat) {
    exp_term(Real.0, n.suc) = Real.0
} by {
    // 0^(n+1) = 0 for any n
    Real.0.pow(n.suc) = Real.0
    exp_term(Real.0, n.suc) = Real.0 / Real.from_rat(Rat.from_nat(n.suc.factorial))
}

/// Absolute value of exp_term(0, n) for n >= 1.
theorem exp_term_zero_abs_suc(n: Nat) {
    abs_fn(exp_term(Real.0))(n.suc) = Real.0
} by {
    exp_term_zero_suc(n)
    abs_fn(exp_term(Real.0))(n.suc) = exp_term(Real.0, n.suc).abs
    Real.0.abs = Real.0
}

/// exp_term(0, 0) equals 1.
theorem exp_term_zero_zero {
    exp_term(Real.0, Nat.0) = Real.1
} by {
    Real.0.pow(Nat.0) = Real.1
    Nat.0.factorial = Nat.1
    Rat.from_nat(Nat.1) = Rat.1
    Real.from_rat(Rat.1) = Real.1
    exp_term(Real.0, Nat.0) = Real.1 / Real.1
}

/// Absolute value of exp_term(0, 0) equals 1.
theorem exp_term_zero_abs_zero {
    abs_fn(exp_term(Real.0))(Nat.0) = Real.1
} by {
    exp_term_zero_zero
    abs_fn(exp_term(Real.0))(Nat.0) = exp_term(Real.0, Nat.0).abs
    Real.1.abs = Real.1
}

/// Partial sum of abs_fn(exp_term(0)) equals 1 for n >= 1.
theorem partial_exp_term_zero_suc(n: Nat) {
    partial(abs_fn(exp_term(Real.0)), n.suc) = Real.1
} by {
    define p(m: Nat) -> Bool {
        partial(abs_fn(exp_term(Real.0)), m.suc) = Real.1
    }

    // Base case: partial for n = 1
    partial(abs_fn(exp_term(Real.0)), Nat.1) = abs_fn(exp_term(Real.0))(Nat.0)
    exp_term_zero_abs_zero
    abs_fn(exp_term(Real.0))(Nat.0) = Real.1
    p(Nat.0)

    // Inductive step
    forall(m: Nat) {
        if p(m) {
            partial(abs_fn(exp_term(Real.0)), m.suc.suc) =
                partial(abs_fn(exp_term(Real.0)), m.suc) + abs_fn(exp_term(Real.0))(m.suc)
            exp_term_zero_abs_suc(m)
            abs_fn(exp_term(Real.0))(m.suc) = Real.0
            partial(abs_fn(exp_term(Real.0)), m.suc.suc) = Real.1 + Real.0
            p(m.suc)
        }
    }
}

/// The partial sums of abs_fn(exp_term(0)) converge.
theorem exp_term_zero_partial_converges {
    converges(partial(abs_fn(exp_term(Real.0))))
} by {
    // For eps > 0, we need to find n such that for all i, j >= n,
    // |partial(..., i) - partial(..., j)| < eps
    // Since partial(..., k) = 1 for all k >= 1, we can use n = 1

    let p_seq = partial(abs_fn(exp_term(Real.0)))

    forall(eps: Real) {
        if eps.is_positive {
            // Witness: n = 1
            // For all i, j >= 1, partial(..., i) = partial(..., j) = 1
            forall(i: Nat, j: Nat) {
                if Nat.1 <= i and Nat.1 <= j {
                    // Since i >= 1, we have i = m.suc for some m
                    let m: Nat satisfy { i = m.suc }
                    partial_exp_term_zero_suc(m)
                    p_seq(i) = Real.1

                    // Similarly for j
                    let k: Nat satisfy { j = k.suc }
                    partial_exp_term_zero_suc(k)
                    p_seq(j) = Real.1

                    // Now they're equal, so distance is 0 < eps
                    p_seq(i).is_close(p_seq(j), eps)
                }
            }

            cauchy_bound(p_seq, Nat.1, eps)
        }
    }

    converges(p_seq)
}

/// For all x, the series with terms exp_term(x) converges absolutely.
///
/// We prove this by showing that partial sums of |exp_term(x, n)| converge.
/// For x = 0, the terms are 0 after the first, so partial sums stabilize at 1.
/// For x != 0, the factorial in the denominator grows much faster than any power,
/// causing the terms to decrease to 0, and the series to converge.
///
/// Current status:
/// - x = 0 case: COMPLETE
/// - x != 0 case: TODO - requires the following helper lemmas:
///   1. For any real x, there exists N such that for n >= N, |x|/(n+1) < 1/2
///      (This uses the Archimedean property: factorials grow unboundedly)
///   2. Geometric series convergence: if |r| < 1, then sum of r^n converges
///   3. Comparison test application: if |exp_term(x,n)| <= M * (1/2)^n for large n,
///      then the series converges by comparison with a geometric series
///   4. Field division lemmas to prove exp_term_ratio
theorem exp_term_abs_converges(x: Real) {
    absolutely_converges(exp_term(x))
} by {
    // For the case x = 0, the series is trivially convergent (all terms are 0 after the first)
    if x = Real.0 {
        exp_term_zero_partial_converges
        converges(partial(abs_fn(exp_term(Real.0))))
        absolutely_converges(exp_term(x))
    } else {
        // For x != 0, we use the monotone convergence principle
        // partial(abs_fn(exp_term(x))) is increasing (all terms non-negative)
        // and bounded (factorial grows faster than any power)

        // Strategy: Show that partial sums are bounded
        // Key insight: |x|^n / n! decreases to 0 as n -> infinity
        // because factorial grows faster than any exponential

        // TODO: Prove boundedness of partial sums
        // This requires showing that the series converges, which is circular without
        // more machinery. Need to develop:
        // - Factorial growth lemmas (n! > (n/e)^n or similar bounds)
        // - Ratio test for series convergence
        // - Or use comparison with a known convergent series

        absolutely_converges(exp_term(x))
    }
}
