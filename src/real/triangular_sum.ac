from nat import Nat
from list import List, partial
from add_semigroup import add_fn
from real.real_series import Real
from real.rectangular_sum import nat_to_real, nonneg_fn_2, is_upper_bound_fn_2, is_lower_bound_fn_2, lte_fn_2, const_fn_2, add_fn_2, sub_fn_2, scalar_mul_fn_2

numerals Real
numerals Nat

/// This file defines triangular sums and proves theorems about them.
/// A triangular sum sums f(i, j) over all pairs where i + j < n.

/// Bounded difference: computes max(0, n - i) in a way that's always defined.
define bounded_diff(n: Nat, i: Nat) -> Nat {
    match n {
        Nat.0 {
            Nat.0
        }
        Nat.suc(n_pred) {
            match i {
                Nat.0 {
                    n
                }
                Nat.suc(i_pred) {
                    bounded_diff(n_pred, i_pred)
                }
            }
        }
    }
}

/// Sum of f(i, j) for j < bounded_diff(n, i), which gives j where i + j < n.
define tri_row_sum(f: (Nat, Nat) -> Real, n: Nat, i: Nat) -> Real {
    partial(f(i), bounded_diff(n, i))
}

/// The triangular sum of f over pairs (i, j) where i + j < n.
/// Computes sum_{i+j < n} f(i, j).
define triangular_sum(f: (Nat, Nat) -> Real, n: Nat) -> Real {
    partial(tri_row_sum(f, n), n)
}

/// Triangular sum of zero is zero.
theorem triangular_sum_zero(f: (Nat, Nat) -> Real) {
    triangular_sum(f, Nat.0) = Real.0
}

/// Bounded difference basic properties.
theorem bounded_diff_zero(i: Nat) {
    bounded_diff(Nat.0, i) = Nat.0
}

theorem bounded_diff_suc_zero(n: Nat) {
    bounded_diff(n.suc, Nat.0) = n.suc
}

theorem bounded_diff_suc_suc(n: Nat, i: Nat) {
    bounded_diff(n.suc, i.suc) = bounded_diff(n, i)
}

/// Triangular sum is nonnegative for nonnegative functions.
theorem triangular_sum_nonneg(f: (Nat, Nat) -> Real, n: Nat) {
    nonneg_fn_2(f)
    implies
    triangular_sum(f, n) >= Real.0
} by {
    define p(k: Nat) -> Bool {
        nonneg_fn_2(f)
        implies
        triangular_sum(f, k) >= Real.0
    }

    p(Nat.0)

    forall(k: Nat) {
        if p(k) {
            if nonneg_fn_2(f) {
                // Prove tri_row_sum is nonneg for all i
                forall(i: Nat) {
                    // Prove partial(f(i), m) >= 0 for any m
                    define s(m: Nat) -> Bool {
                        partial(f(i), m) >= Real.0
                    }

                    s(Nat.0)

                    forall(m: Nat) {
                        if s(m) {
                            f(i, m) >= Real.0
                            partial(f(i), m.suc) = partial(f(i), m) + f(i, m)
                            Real.0 + Real.0 <= partial(f(i), m) + f(i, m)
                            partial(f(i), m.suc) >= Real.0
                            s(m.suc)
                        }
                    }

                    tri_row_sum(f, k.suc, i) = partial(f(i), bounded_diff(k.suc, i))
                    tri_row_sum(f, k.suc, i) >= Real.0
                }

                // Now prove triangular_sum(f, k.suc) >= 0
                define t(m: Nat) -> Bool {
                    partial(tri_row_sum(f, k.suc), m) >= Real.0
                }

                t(Nat.0)

                forall(m: Nat) {
                    if t(m) {
                        tri_row_sum(f, k.suc, m) >= Real.0
                        partial(tri_row_sum(f, k.suc), m.suc) = partial(tri_row_sum(f, k.suc), m) + tri_row_sum(f, k.suc, m)
                        Real.0 + Real.0 <= partial(tri_row_sum(f, k.suc), m) + tri_row_sum(f, k.suc, m)
                        partial(tri_row_sum(f, k.suc), m.suc) >= Real.0
                        t(m.suc)
                    }
                }

                triangular_sum(f, k.suc) = partial(tri_row_sum(f, k.suc), k.suc)
                triangular_sum(f, k.suc) >= Real.0
            }
            p(k.suc)
        }
    }
}

// /// If f <= g pointwise, then their triangular sums satisfy the same inequality.
// /// TODO: This proof needs explicit lemmas about how tri_row_sum behaves across different n values.
// theorem triangular_sum_monotone(f: (Nat, Nat) -> Real, g: (Nat, Nat) -> Real, n: Nat) {
//     lte_fn_2(f, g)
//     implies
//     triangular_sum(f, n) <= triangular_sum(g, n)
// }

// /// Triangular sum is additive in the function.
// /// TODO: This proof needs explicit lemmas about how tri_row_sum behaves.
// theorem triangular_sum_add(f: (Nat, Nat) -> Real, g: (Nat, Nat) -> Real, n: Nat) {
//     triangular_sum(add_fn_2(f, g), n)
//     =
//     triangular_sum(f, n) + triangular_sum(g, n)
// }

// /// Scaling a triangular sum.
// /// TODO: This proof needs explicit lemmas about how tri_row_sum behaves.
// theorem triangular_sum_scale(c: Real, f: (Nat, Nat) -> Real, n: Nat) {
//     triangular_sum(scalar_mul_fn_2(c, f), n)
//     =
//     c * triangular_sum(f, n)
// }

// /// Triangular sum of a constant function.
// /// The formula would be: triangular_sum(const_fn_2(c), n) = c * n * (n+1) / 2
// /// This counts the number of lattice points (i, j) where i + j < n.
// /// TODO: Prove this once division is available in the Real type.
// theorem triangular_sum_const(c: Real, n: Nat) {
//     triangular_sum(const_fn_2(c), n) = c * nat_to_real(n) * nat_to_real(n.suc) / (Real.1 + Real.1)
// }

// /// Triangular sums of a bounded function are bounded.
// /// TODO: Requires triangular_sum_monotone.
// theorem triangular_sum_upper_bound(f: (Nat, Nat) -> Real, bound: Real, n: Nat) {
//     nonneg_fn_2(f) and is_upper_bound_fn_2(f, bound)
//     implies
//     triangular_sum(f, n) <= triangular_sum(const_fn_2(bound), n)
// }

// /// Triangular sum is distributive over subtraction.
// /// TODO: Requires triangular_sum_add and triangular_sum_scale.
// theorem triangular_sum_sub(f: (Nat, Nat) -> Real, g: (Nat, Nat) -> Real, n: Nat) {
//     triangular_sum(sub_fn_2(f, g), n)
//     =
//     triangular_sum(f, n) - triangular_sum(g, n)
// }

// /// Triangular sum over increasing dimensions is monotone for nonnegative functions.
// /// TODO: Requires explicit lemmas about how tri_row_sum changes with n.
// theorem triangular_sum_increasing(f: (Nat, Nat) -> Real, n: Nat) {
//     nonneg_fn_2(f)
//     implies
//     triangular_sum(f, n) <= triangular_sum(f, n.suc)
// }
