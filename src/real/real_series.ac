from util import compose
from nat import Nat
from rat import Rat
from list import partial, sum, map, List
from list.list_sum import map_add, sum_add, partial_scalar_mul
from semigroup import mul_fn
from real.real_set import Real
from real.real_seq import cauchy_bound, tail_bound, add_seq, neg_rat_seq, converges_imp_converges_to, eventual_ub, eventual_lb, lt_converges_to_imp_lb, gt_converges_to_imp_ub, eventual_eq, eq_converges
from real.real_ring import converges, converges_to, limit, lift_seq
from real.real_base import lte_add_right

numerals Real

// This file defines infinite series and proves theorems about them.

attributes Real {
    // Placeholder to let other modules import Real from here.
}

// seq_lte is whether every element of the sequence is lte.
define seq_lte(a: Nat -> Real, b: Nat -> Real) -> Bool {
    forall(n: Nat) {
        a(n) <= b(n)
    }
}

/// Product function for double sums.
/// Creates the outer product of two sequences: prod_fn(a, b)(i, j) = a(i) * b(j).
define prod_fn(a: Nat -> Real, b: Nat -> Real) -> ((Nat, Nat) -> Real) {
    function(i: Nat, j: Nat) { a(i) * b(j) }
}

theorem partial_suc(a: Nat -> Real, n: Nat) {
    partial(a, n.suc) = partial(a, n) + a(n)
} by {
    // Simplify the left hand side.
}

// Theorem: If seq_lte(a, b), then their partials also obey seq_lte.
theorem partial_seq_lte(a: Nat -> Real, b: Nat -> Real) {
    seq_lte(a, b) implies seq_lte(partial(a), partial(b))
} by {
    // Define a predicate for our induction
    define p(n: Nat) -> Bool {
        partial(a)(n) <= partial(b)(n)
    }

    p(Nat.0)

    // Inductive step
    forall(n: Nat) {
        if p(n) {
            partial(a, n) + a(n) <= partial(b, n) + b(n)
            p(n.suc)
        }
    }

    // By induction, p holds for all n
}

// This definition of increasing is not strict.
// It includes less-than-or-equal.
define is_increasing(a: Nat -> Real) -> Bool {
    forall(n: Nat) {
        a(n) <= a(n.suc)
    }
}

theorem distant_increasing(a: Nat -> Real, m: Nat, n: Nat) {
    is_increasing(a) and m <= n implies a(m) <= a(n)
} by {
    // Define a predicate for our induction
    define p(k: Nat) -> Bool {
        forall(j: Nat) {
            j + k <= n implies a(j) <= a(j + k)
        }
    }

    // Base case: k = 0
    p(Nat.0)

    // Inductive step: if p(k) holds, prove p(k.suc)
    forall(k: Nat) {
        if p(k) {
            forall(j: Nat) {
                if j + k.suc <= n {
                    // This means j+k+1 <= n, which means j+k <= n-1 < n

                    // Apply p(k) to get a(j) <= a(j+k)
                    j + k.suc = (j + k).suc
                    j + k <= n or n < j + k
                    not n < j + k or n < (j + k).suc
                    not j + k.suc <= n or not n < j + k.suc
                    j + k <= n
                    a(j) <= a(j + k)

                    // Apply the definition of is_increasing to the point j+k

                    // Combine the inequalities
                    a(j) <= a(j + k.suc)
                }
            }
            p(k.suc)
        }
    }

    // By induction, p holds for all k
    forall(k: Nat) {
        p(k)
    }

    // Apply the predicate with j=m, k=n-m
    if m <= n {
        let k: Nat satisfy { m + k = n }
    }
}

define is_upper_bound(a: Nat -> Real, b: Real) -> Bool {
    forall(n: Nat) {
        a(n) <= b
    }
}

define is_least_upper_bound(a: Nat -> Real, l: Real) -> Bool {
    is_upper_bound(a, l) and forall(x: Real) {
        x < l implies not is_upper_bound(a, x)
    }
}

define is_lower_bound(a: Nat -> Real, b: Real) -> Bool {
    forall(n: Nat) {
        b <= a(n)
    }
}

// Theorem: If a sequence is increasing and converges, then its limit is an upper bound
theorem increasing_convergent_bounded_by_limit(a: Nat -> Real) {
    is_increasing(a) and converges(a)
    implies is_upper_bound(a, limit(a))
} by {
    // We'll prove that for any n, a(n) <= limit(a)
    forall(n: Nat) {
        // Suppose for contradiction that a(n) > limit(a)
        if a(n) > limit(a) {
            limit(a) < a(n)

            // Find a value that's between limit(a) and a(n)
            let ub: Real satisfy {
                limit(a) < ub and ub < a(n)
            }

            // Since the sequence converges to limit(a), there must be a point
            // after which all sequence values are < ub
            let eps = ub - limit(a)

            // By the definition of convergence, find a point where the sequence
            // is within eps of the limit for all indices beyond that point
            let (big_n: Nat) satisfy {
                forall(i: Nat) {
                    big_n <= i implies a(i).is_close(limit(a), eps)
                }
            }

            // Since a(n) > ub, we know n can't be >= big_n (or a(n) would be within eps of limit(a))
            // So either n < big_n or we have a contradiction
            // Case 1: n < big_n
            if n < big_n {
                // Since sequence is increasing, a(n) <= a(big_n)

                // But since a(big_n) is within eps of limit(a), we have a(big_n) < ub
                // Being close means the absolute difference is < eps
                // For real numbers, if they're close and one is less than another plus epsilon
                // then the first is less than the second plus epsilon
                // And since eps = ub - limit(a), we have limit(a) + eps = ub
                limit(a) + eps = ub
                a(big_n) < ub

                // So a(n) <= a(big_n) < ub, contradicting our assumption that a(n) > ub
                n <= big_n
                a(n) <= a(big_n)
                ub < a(big_n)
                ub < ub
                false
            } else {
                // Case 2: n >= big_n
                // Then a(n) is within eps of limit(a)
                // Being close means the absolute difference is < eps
                // For real numbers, if they're close and one is less than another plus epsilon
                // then the first is less than the second plus epsilon
                // And since eps = ub - limit(a), we have limit(a) + eps = ub
                limit(a) + eps = ub
                a(n) < ub

                // Contradicting our assumption that a(n) > ub
                false
            }

            // Either way, we get a contradiction, so a(n) <= limit(a)
        }

        // Therefore, a(n) <= limit(a)
    }
}

define image(a: Nat -> Real, x: Real) -> Bool {
    exists(n: Nat) {
        a(n) = x
    }
}

theorem ub_imp_image_ub(a: Nat -> Real, b: Real) {
    is_upper_bound(a, b)
    implies b.is_set_upper_bound(image(a))
}

// If there's an upper bound, there's a least upper bound.
theorem ub_imp_lub(a: Nat -> Real, b: Real) {
    is_upper_bound(a, b) implies exists(c: Real) {
        is_least_upper_bound(a, c)
    }
} by {
    let c: Real satisfy {
        c.is_set_least_upper_bound(image(a))
    }
    c.is_set_upper_bound(image(a))
    forall(n: Nat) {
        image(a, a(n))
        a(n) <= c
    }
    is_upper_bound(a, c)
    forall(x: Real) {
        if x < c {
            if is_upper_bound(a, x) {
                x.is_set_upper_bound(image(a))
                c <= x
                x < c = c > x
                not c <= x or not c > x
            }
            not is_upper_bound(a, x)
        }
    }
    is_least_upper_bound(a, c)
}

// The monotone convergence principle states that any increasing sequence
// that is bounded above converges
theorem monotone_convergence_principle(a: Nat -> Real, b: Real) {
    is_increasing(a) and is_upper_bound(a, b) implies converges(a)
} by {
    let l: Real satisfy {
        is_least_upper_bound(a, l)
    }

    forall(eps: Real) {
        if eps.is_positive {
            // Find epsilon/2 for triangle inequality
            let eps2: Real satisfy {
                eps2.is_positive and eps2 + eps2 < eps
            }

            // Since l is the least upper bound, l-eps2 is not an upper bound
            let x = l - eps2
            x < l

            // If x is not an upper bound, there exists some n such that a(n) > x
            let n: Nat satisfy {
                not a(n) <= x
            }
            // We know a(n) > x = l - eps2

            // For all indices i,j ≥ n, prove they're within epsilon of each other
            forall(i: Nat, j: Nat) {
                if n <= i and n <= j {
                    a(i) <= l
                    a(i) < l + eps2
                    // Show l - eps2 < a(i) via increasing sequence
                    a(n) <= a(i)
                    a(i) <= x or a(i) > x
                    x < a(i) = a(i) > x
                    l - eps2 < a(i)
                    a(i).is_close(l, eps2)
                    (a(i) - l).abs < eps2 = a(i).is_close(l, eps2)
                    (a(i) - l).abs < eps2
                    a(j) <= l
                    a(j) < l + eps2
                    // Show l - eps2 < a(j) via increasing sequence
                    a(n) <= a(j)
                    a(j) <= x or a(j) > x
                    x < a(j) = a(j) > x
                    l - eps2 < a(j)
                    a(j).is_close(l, eps2)
                    (a(j) - l).abs < eps2 = a(j).is_close(l, eps2)
                    (a(j) - l).abs < eps2
                    (a(i) - a(j)).abs < eps2 + eps2
                    a(i).is_close(a(j), eps)
                }
            }

            // We've proven that for all i,j ≥ n,
            // a(i) and a(j) are within epsilon of each other.
            // This is exactly the definition of cauchy_condition
            cauchy_bound(a, n, eps)
        }
    }
}

theorem nonneg_partial_increasing(a: Nat -> Real) {
    is_lower_bound(a, Real.0) implies is_increasing(partial(a))
} by {
    forall(n: Nat) {
        if is_lower_bound(a, Real.0) {
            Real.0 <= a(n)
            partial(a, n) + Real.0 = partial(a, n)
            partial(a, n) + Real.0 <= partial(a, n) + a(n)
            partial(a, n) + a(n) = partial(a, n.suc)
            partial(a, n) <= partial(a, n.suc)
        }
    }
}

/// Partial sums are monotone for nonnegative sequences.
theorem partial_monotone(a: Nat -> Real, n: Nat) {
    is_lower_bound(a, Real.0) implies partial(a, n) <= partial(a, n.suc)
}

theorem nonneg_partial_bounded_above(a: Nat -> Real) {
    is_lower_bound(a, Real.0) and converges(partial(a))
    implies is_upper_bound(partial(a), limit(partial(a)))
}

theorem seq_lte_ub(a: Nat -> Real, b: Nat -> Real, ub: Real) {
    seq_lte(a, b) and is_upper_bound(b, ub)
    implies is_upper_bound(a, ub)
} by {
    forall(n: Nat) {
        if seq_lte(a, b) and is_upper_bound(b, ub) {
            a(n) <= b(n)
            b(n) <= ub
            a(n) <= ub
        }
    }
}

/// If two sequences satisfy a <= b pointwise and both converge, their limits preserve the order.
theorem seq_lte_preserves_limit(a: Nat -> Real, b: Nat -> Real) {
    seq_lte(a, b) and converges(a) and converges(b)
    implies limit(a) <= limit(b)
} by {
    if seq_lte(a, b) and converges(a) and converges(b) {
        // Proof by contradiction
        if limit(a) > limit(b) {
            // Find a rational strictly between the two limits
            let r: Rat satisfy {
                limit(a) > Real.from_rat(r) and Real.from_rat(r) > limit(b)
            }

            let r_real = Real.from_rat(r)

            // Get convergence-to statements
            converges_imp_converges_to(a)
            converges_imp_converges_to(b)

            // Since limit(b) < r_real and b converges to limit(b),
            // eventually b(n) <= r_real (by gt_converges_to_imp_ub)
            r_real > limit(b)
            gt_converges_to_imp_ub(b, r_real, limit(b))
            eventual_ub(b, r_real)

            let n1: Nat satisfy {
                forall(i: Nat) {
                    n1 <= i implies b(i) <= r_real
                }
            }

            // Since limit(a) > r_real and a converges to limit(a),
            // eventually a(n) >= r_real (by lt_converges_to_imp_lb)
            r_real < limit(a)
            lt_converges_to_imp_lb(a, r_real, limit(a))
            eventual_lb(a, r_real)

            let n2: Nat satisfy {
                forall(i: Nat) {
                    n2 <= i implies a(i) >= r_real
                }
            }

            // Take any n >= max(n1, n2)
            let n = n1.max(n2)
            n1 <= n
            n2 <= n

            // Then a(n) >= r_real and b(n) <= r_real
            a(n) >= r_real
            b(n) <= r_real

            // We also know a(n) <= b(n) from seq_lte
            a(n) <= b(n)

            // Now use that limit(a) > r_real.
            // Since a converges to limit(a) and r_real < limit(a),
            // we can get a contradiction by showing a(n) is strictly > r_real
            // for large enough n.

            let eps_a = limit(a) - r_real
            eps_a.is_positive

            let eps_a_half: Real satisfy {
                eps_a_half.is_positive and eps_a_half + eps_a_half < eps_a
            }

            // Eventually a(n) is within eps_a_half of limit(a)
            let n3: Nat satisfy {
                forall(i: Nat) {
                    n3 <= i implies a(i).is_close(limit(a), eps_a_half)
                }
            }

            // For i >= max(n, n3):
            let nn = n.max(n3)
            n <= nn
            n3 <= nn

            a(nn).is_close(limit(a), eps_a_half)
            // From is_close, we get a(nn) > limit(a) - eps_a_half
            limit(a) - eps_a_half < a(nn)

            // Now: limit(a) = r_real + eps_a
            limit(a) = r_real + eps_a

            // So: limit(a) - eps_a_half < a(nn)
            limit(a) - eps_a_half < a(nn)

            // Since eps_a_half + eps_a_half < eps_a:
            eps_a_half + eps_a_half < eps_a

            // And eps_a = limit(a) - r_real:
            eps_a = limit(a) - r_real

            // We have: eps_a_half + eps_a_half < limit(a) - r_real
            eps_a_half + eps_a_half < limit(a) - r_real

            // This implies: r_real + eps_a_half < limit(a) - eps_a_half
            eps_a - (eps_a_half + eps_a_half) = eps_a - eps_a_half - eps_a_half
            limit(a) - (r_real + eps_a_half) = limit(a) - r_real - eps_a_half
            limit(a) - eps_a_half - (r_real + eps_a_half) = limit(a) - (r_real + eps_a_half) - eps_a_half
            (eps_a - (eps_a_half + eps_a_half)).is_positive
            (limit(a) - eps_a_half - (r_real + eps_a_half)).is_positive
            r_real + eps_a_half < limit(a) - eps_a_half

            // Since eps_a_half.is_positive: r_real < r_real + eps_a_half
            r_real < r_real + eps_a_half

            // By transitivity: r_real < limit(a) - eps_a_half
            r_real < limit(a) - eps_a_half
            limit(a) - eps_a_half < a(nn)
            r_real < a(nn)

            // But we also have a(nn) <= b(nn) <= r_real (since nn >= n)
            a(nn) <= b(nn)
            b(nn) <= r_real
            a(nn) <= r_real

            // So a(nn) <= r_real and r_real < a(nn), which is a contradiction
            false
        }

        // Therefore limit(a) <= limit(b)
    }
}

theorem comparison_test(a: Nat -> Real, b: Nat -> Real) {
    is_lower_bound(a, Real.0)
    and seq_lte(a, b)
    and converges(partial(b))
    implies converges(partial(a))
} by {
    if is_lower_bound(a, Real.0) and seq_lte(a, b) and converges(partial(b)) {
        // b is also nonnegative since a <= b and a >= 0
        forall(n: Nat) {
            Real.0 <= a(n)
            a(n) <= b(n)
            Real.0 <= b(n)
        }
        is_lower_bound(b, Real.0)
        // Partial sums of a are increasing
        is_increasing(partial(a))
        // Partial sums satisfy a <= b pointwise
        seq_lte(partial(a), partial(b))
        // b's partial sums are bounded by limit(partial(b))
        is_upper_bound(partial(b), limit(partial(b)))
        // So a's partial sums are also bounded
        is_upper_bound(partial(a), limit(partial(b)))
        // Increasing and bounded implies convergent
        converges(partial(a))
    }
}

define mul_seq(a: Real, b: Nat -> Real, n: Nat) -> Real {
    a * b(n)
}

theorem const_converges(a: Real) {
    converges(constant[Nat, Real](a))
} by {
    forall(n: Nat) {
        constant(a, n) = a
    }
    eventual_eq(constant[Nat, Real](a), a)
}

theorem const_limit(a: Real) {
    limit(constant[Nat, Real](a)) = a
}

theorem const_converges_to(a: Real) {
    converges_to(constant[Nat, Real](a), a)
}

theorem mul_seq_zero(a: Nat -> Real) {
    mul_seq(Real.0, a) = constant[Nat, Real](Real.0)
}

theorem mul_seq_converges_to(a: Real, b: Nat -> Real) {
    converges(b) implies converges_to(mul_seq(a, b), a * limit(b))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            let eps2: Real satisfy {
                eps2.is_positive and a.abs * eps2 < eps
            }
            let n: Nat satisfy {
                tail_bound(b, limit(b), n, eps2)
            }
            forall(i: Nat) {
                if n <= i {
                    a.abs * (b(i) - limit(b)).abs <= a.abs * eps2
                    mul_seq(a, b, i) = a * b(i)
                    a * b(i) - a * limit(b) = a * (b(i) - limit(b))
                    a.abs * (b(i) - limit(b)).abs = (a * (b(i) - limit(b))).abs
                    (a * (b(i) - limit(b))).abs < eps
                    (mul_seq(a, b, i) - a * limit(b)).abs < eps
                    (mul_seq(a, b, i) - a * limit(b)).abs < eps = mul_seq(a, b, i).is_close(a * limit(b), eps)
                    mul_seq(a, b)(i).is_close(a * limit(b), eps)
                }
            }
            tail_bound(mul_seq(a, b), a * limit(b), n, eps)
        }
    }
}

theorem mul_seq_one(a: Nat -> Real) {
    mul_seq(Real.1, a) = a
}

theorem mul_seq_neg_one_converges_converse(a: Nat -> Real) {
    converges(mul_seq(-Real.1, a)) implies converges(a)
} by {
    converges(mul_seq(-Real.1, mul_seq(-Real.1, a)))
    mul_seq(-Real.1, mul_seq(-Real.1, a)) = mul_seq((-Real.1) * -Real.1, a)
    mul_seq(Real.1, a) = a
}

theorem mul_seq_comm(a: Real, b: Real, c: Nat -> Real) {
    mul_seq(a, mul_seq(b, c)) = mul_seq(b, mul_seq(a, c))
} by {
    forall(n: Nat) {
        mul_seq(a, mul_seq(b, c), n) = a * mul_seq(b, c, n)
        mul_seq(b, c, n) = b * c(n)
        mul_seq(b, mul_seq(a, c), n) = b * mul_seq(a, c, n)
        mul_seq(a, c, n) = a * c(n)
        a * (b * c(n)) = a * b * c(n)
        b * (a * c(n)) = b * a * c(n)
        b * a = a * b
        mul_seq(a, mul_seq(b, c))(n) = mul_seq(b, mul_seq(a, c))(n)
    }
}

theorem mul_seq_combine(a: Real, b: Real, c: Nat -> Real) {
    mul_seq(a * b, c) = mul_seq(a, mul_seq(b, c))
}

theorem converges_mul_seq(a: Real, b: Nat -> Real) {
    converges(b) implies converges(mul_seq(a, b))
}

// Maybe it would have been better to not define partial this way.
theorem partial_zero(a: Nat -> Real) {
    partial(a, Nat.0) = Real.0
}

/// If all terms before index m are zero, then the partial sum is zero.
theorem partial_all_zeros(g: Nat -> Real, m: Nat) {
    (forall(j: Nat) { j < m implies g(j) = Real.0 })
    implies
    partial(g, m) = Real.0
} by {
    define p(k: Nat) -> Bool {
        (forall(j: Nat) { j < k implies g(j) = Real.0 })
        implies
        partial(g, k) = Real.0
    }

    // Base case

    // Inductive step
    forall(k: Nat) {
        if p(k) {
            if forall(j: Nat) { j < k.suc implies g(j) = Real.0 } {
                // g(j) = 0 for all j < k
                k < k.suc
                g(k) = Real.0

                // By IH: partial(g, k) = 0
                partial(g, k) = Real.0

                // Therefore partial(g, k.suc) = 0 + 0 = 0
                partial(g, k) + g(k) = partial(g, k.suc)
                partial(g, k) + Real.0 = partial(g, k)
                partial(g, k.suc) = Real.0
            }
            p(k.suc)
        }
    }

    p(m)
}

theorem partial_add_seq_comm(a: Nat -> Real, b: Nat -> Real) {
    partial(add_seq(a, b)) = add_seq(partial(a), partial(b))
} by {
    // Define a predicate for induction on n
    define p(n: Nat) -> Bool {
        partial(add_seq(a, b), n) = add_seq(partial(a), partial(b))(n)
    }

    // Base case: n = 0
    partial(add_seq(a, b), Nat.0) = Real.0
    partial(a, Nat.0) + partial(b, Nat.0) = add_seq(partial(a), partial(b), Nat.0)
    add_seq(partial(a), partial(b), Nat.0) = Real.0
    p(Nat.0)

    // Inductive step
    forall(n: Nat) {
        if p(n) {
            // By the induction hypothesis
            add_seq(partial(a), partial(b), n) = partial(add_seq(a, b), n)

            // Now we need to prove for n.suc
            a(n) + b(n) = add_seq(a, b, n)
            partial(a, n) + partial(b, n) = add_seq(partial(a), partial(b), n)
            partial(a, n.suc) + partial(b, n.suc) = add_seq(partial(a), partial(b), n.suc)
            partial(add_seq(a, b), n) + add_seq(a, b, n) = partial(add_seq(a, b), n.suc)

            // Therefore
            partial(add_seq(a, b), n.suc) = add_seq(partial(a), partial(b))(n.suc)
        }
    }
}

theorem partial_mul_seq_comm(a: Real, b: Nat -> Real) {
    partial(mul_seq(a, b)) = mul_seq(a, partial(b))
} by {
    // Show the sequences are pointwise equal
    forall(n: Nat) {
        mul_seq(a, b, n) = a * b(n)
        mul_fn(a, b, n) = a * b(n)
        mul_seq(a, b)(n) = mul_fn(a, b)(n)
    }
    mul_seq(a, b) = mul_fn(a, b)
    forall(n: Nat) {
        a * partial(b, n) = partial(mul_fn(a, b), n)
        mul_seq(a, partial(b), n) = a * partial(b, n)
        partial(mul_seq(a, b), n) = partial(mul_fn(a, b), n)
        partial(mul_seq(a, b), n) = mul_seq(a, partial(b), n)
    }
}

/// Scalar multiplication on the right of a partial sum.
theorem partial_mul_scalar_right(a: Nat -> Real, b: Real, n: Nat) {
    partial(a, n) * b = sum(map(n.range, mul_fn(b, a)))
} by {
    partial_scalar_mul(b, a, n)
}

define tail[T](a: Nat -> T, n: Nat, i: Nat) -> T {
    a(n + i)
}

theorem tail_zero[T](a: Nat -> T) {
    tail(a, Nat.0) = a
}

// Two different ways of adding the first m items, and the next n.
theorem partial_tail(a: Nat -> Real, m: Nat, n: Nat) {
    partial(a, m + n) = partial(a, m) + partial(tail(a, m), n)
} by {
    // Define a predicate for induction on n
    define p(k: Nat) -> Bool {
        partial(a, m + k) = partial(a, m) + partial(tail(a, m), k)
    }

    // Base case: n = 0
    p(Nat.0)

    // Inductive step
    forall(k: Nat) {
        if p(k) {
            // By the induction hypothesis

            // Now prove for k.suc
            // First, simplify the left side

            // Substitute using induction hypothesis

            // For the right side

            // Combine with partial(a, m)

            // By associativity

            // Therefore
            partial(a, m + k.suc) = partial(a, m) + partial(tail(a, m), k.suc)
        }
    }
}

theorem partial_tail_sub(a: Nat -> Real, m: Nat, n: Nat) {
    partial(tail(a, m), n) = partial(a, m + n) - partial(a, m)
}

let const_seq = constant[Nat, Real]

theorem const_seq_n(a: Real, n: Nat) {
    const_seq(a)(n) = a
} by {
    const_seq(a) = constant[Nat, Real](a)
}

// The sequence-operations version of partial_tail.
// Partial and tail don't quite commute, there's an additive shift.
theorem tail_partial(a: Nat -> Real, n: Nat) {
    tail(partial(a), n) = add_seq(partial(tail(a, n)), const_seq(partial(a, n)))
}

theorem partial_tail_rewrite(a: Nat -> Real, n: Nat) {
    partial(tail(a, n)) = add_seq(tail(partial(a), n), const_seq(-partial(a, n)))
}

theorem tail_converges_to(a: Nat -> Real, n: Nat) {
    converges(a) implies
    converges_to(tail(a, n), limit(a))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            let n1: Nat satisfy {
                tail_bound(a, limit(a), n1, eps)
            }
            let n2: Nat satisfy {
                n <= n2 and n1 <= n2
            }

            forall(i: Nat) {
                if n2 <= i {
                    i <= i + n
                    n2 <= i + n
                    n1 <= i + n
                    tail(a, n)(i) = a(n + i)
                    i + n = n + i
                    tail(a, n)(i).is_close(limit(a), eps)
                }
            }

            tail_bound(tail(a, n), limit(a), n2, eps)
        }
    }

    // By the definition of converges_to, we've proven that tail(a, n) converges to limit(a)
}

theorem tail_imp_converges_to(a: Nat -> Real, n: Nat) {
    converges(tail(a, n)) implies
    converges_to(a, limit(tail(a, n)))
} by {
    forall(eps: Real) {
        if eps.is_positive {
            let n1: Nat satisfy {
                tail_bound(tail(a, n), limit(tail(a, n)), n1, eps)
            }
            let n2 = n + n1

            forall(i: Nat) {
                if n2 <= i {
                    let d: Nat satisfy {
                        n + n1 + d = i
                    }
                    tail(a, n)(n1 + d).is_close(limit(tail(a, n)), eps)
                    a(i).is_close(limit(tail(a, n)), eps)
                }
            }

            tail_bound(a, limit(tail(a, n)), n2, eps)
        }
    }
}

// Maybe we could just use tail_converges_to to prove this,
// along with sequence ops, and it would be simpler.
theorem tail_partial_converges(a: Nat -> Real, k: Nat) {
    converges(partial(a)) implies
    converges_to(partial(tail(a, k)), limit(partial(a)) - partial(a, k))
} by {
    let target = limit(partial(a)) - partial(a, k)
    forall(eps: Real) {
        if eps.is_positive {
            let n: Nat satisfy {
                tail_bound(partial(a), limit(partial(a)), n, eps)
            }
            forall(i: Nat) {
                if n <= i {
                    i <= i + k
                    n <= i + k
                    i + k = k + i
                    partial(a, k) + limit(partial(a)) - partial(a, k) = limit(partial(a))
                    partial(a, k + i).is_close(partial(a, k) + limit(partial(a)) - partial(a, k), eps)
                    partial(a, k) + partial(tail(a, k), i) = partial(a, k + i)
                    partial(a, k) + partial(tail(a, k), i) - partial(a, k) = partial(a, k) - partial(a, k) + partial(tail(a, k), i)
                    partial(a, k) + partial(tail(a, k), i) - (partial(a, k) + target) = partial(a, k) + partial(tail(a, k), i) - partial(a, k) - target
                    partial(a, k) + target = partial(a, k) + limit(partial(a)) - partial(a, k)
                    (partial(a, k) + partial(tail(a, k), i) - partial(a, k)).is_close(target, eps)
                    partial(tail(a, k), i).is_close(target, eps)
                }
            }
            tail_bound(partial(tail(a, k)), target, n, eps)
        }
    }
}

theorem converges_const_seq(a: Real) {
    converges(const_seq(a))
}

theorem add_seq_converges(a: Nat -> Real, b: Nat -> Real) {
    converges(a) and converges(b) implies converges(add_seq(a, b))
}

define neg_seq(a: Nat -> Real) -> (Nat -> Real) {
    mul_seq(-Real.1, a)
}

theorem neg_seq_neg_seq(a: Nat -> Real) {
    neg_seq(neg_seq(a)) = a
} by {
    forall(n: Nat) {
        mul_seq(-Real.1, a)(n) = -Real.1 * a(n)
        -Real.1 * a(n) = -a(n)
        mul_seq(-Real.1, neg_seq(a))(n) = -Real.1 * neg_seq(a)(n)
        -Real.1 * neg_seq(a)(n) = -neg_seq(a)(n)
        -neg_seq(a)(n) = --a(n)
        --a(n) = a(n)
        neg_seq(neg_seq(a))(n) = a(n)
    }
}

theorem neg_seq_lifts(a: Nat -> Rat) {
    neg_seq(lift_seq(a)) = lift_seq(neg_rat_seq(a))
}

theorem neg_seq_cancels(a: Nat -> Real, b: Nat -> Real) {
    add_seq(add_seq(a, b), neg_seq(b)) = a
} by {
    forall(i: Nat) {
        add_seq(a, b, i) - b(i) = a(i)
        add_seq(add_seq(a, b), neg_seq(b))(i) = add_seq(a, b)(i) + neg_seq(b)(i)
        neg_seq(b)(i) = mul_seq(-Real.1, b)(i)
        mul_seq(-Real.1, b)(i) = -Real.1 * b(i)
        add_seq(a, b)(i) + -b(i) = add_seq(a, b)(i) - b(i)
        add_seq(add_seq(a, b), neg_seq(b))(i) = a(i)
    }
}

theorem neg_seq_converges_to(a: Nat -> Real) {
    converges(a) implies converges_to(neg_seq(a), -limit(a))
} by {
    neg_seq(a) = mul_seq(-Real.1, a)
}

theorem neg_seq_converges(a: Nat -> Real) {
    converges(a) implies converges(neg_seq(a))
}

theorem neg_seq_converges_converse(a: Nat -> Real) {
    converges(neg_seq(a)) implies converges(a)
} by {
    neg_seq(neg_seq(a)) = a
}

theorem conv_add_imp_conv_right(a: Nat -> Real, b: Nat -> Real) {
    converges(add_seq(a, b)) and converges(a) implies converges(b)
} by {
    add_seq(a, b) = add_seq(b, a)
    add_seq(add_seq(a, b), neg_seq(a)) = b
}

theorem conv_add_imp_conv_left(a: Nat -> Real, b: Nat -> Real) {
    converges(add_seq(a, b)) and converges(b) implies converges(a)
} by {
    add_seq(a, b) = add_seq(b, a)
}

theorem partial_tail_conv_imp_partial_conv(a: Nat -> Real, n: Nat) {
    converges(partial(tail(a, n))) implies converges(partial(a))
} by {
    partial(tail(a, n)) = add_seq(tail(partial(a), n), const_seq(-partial(a, n)))
    converges(const_seq(-partial(a, n)))
    converges(tail(partial(a), n))
    converges_to(partial(a), limit(tail(partial(a), n)))
}

theorem triangle_ineq(a: Real, b: Real) {
    (a + b).abs <= a.abs + b.abs
} by {
    if (a + b).is_negative {

        // Show -a + -b <= a.abs + b.abs
        -a + -b <= -a + b.abs

        -a + b.abs <= a.abs + b.abs

        (a + b).abs <= a.abs + b.abs
    } else {

        a + b.abs <= a.abs + b.abs

    }
}

theorem sum_abs_le_abs_sum(items: List[Real]) {
    sum(items).abs <= sum(map(items, Real.abs))
} by {
    define p(xs: List[Real]) -> Bool {
        sum(xs).abs <= sum(map(xs, Real.abs))
    }

    // Base case
    sum(List.nil[Real]).abs <= sum(List.nil[Real]).abs
    map(List.nil[Real], Real.abs) = List.nil[Real]
    sum(List.nil[Real]).abs <= sum(map(List.nil[Real], Real.abs))
    p(List.nil)

    // Inductive step
    forall(head: Real, rest: List[Real]) {
        if p(rest) {
            head.abs + sum(rest).abs <= head.abs + sum(map(rest, Real.abs))
            (head + sum(rest)).abs <= head.abs + sum(rest).abs
            (head + sum(rest)).abs <= head.abs + sum(map(rest, Real.abs))
            head + sum(rest) = sum(List.cons(head, rest))
            List.cons(head.abs, map(rest, Real.abs)) = map(List.cons(head, rest), Real.abs)
            head.abs + sum(map(rest, Real.abs)) = sum(List.cons(head.abs, map(rest, Real.abs)))
            sum(List.cons(head, rest)).abs <= sum(map(List.cons(head, rest), Real.abs))
            p(List.cons(head, rest))
        }
    }
}

// Maybe we also want the abs version.
theorem diff_partial(a: Nat -> Real, m: Nat, n: Nat) {
    m <= n implies
    partial(a, n) - partial(a, m) = sum(map(m.until(n), a))
} by {
    m.range + m.until(n) = n.range
    map(m.range, a) + map(m.until(n), a) = map(m.range + m.until(n), a)
    sum(map(m.range, a)) + sum(map(m.until(n), a)) = sum(map(m.range, a) + map(m.until(n), a))
    sum(map(m.until(n), a)) + sum(map(m.range, a)) = sum(map(m.range, a)) + sum(map(m.until(n), a))
    sum(map(n.range, a)) - sum(map(m.range, a)) = sum(map(m.until(n), a))
}

// Prove diff_partial first so that we can simplify partial closeness.
theorem abs_conv_imp_conv(a: Nat -> Real) {
    converges(partial(compose(Real.abs, a)))
    implies
    converges(partial(a))
} by {
    let p = partial(a)
    let q = partial(compose(Real.abs, a))
    forall(eps: Real) {
        if eps.is_positive {
            let n: Nat satisfy {
                cauchy_bound(q, n, eps)
            }
            forall(i: Nat, j: Nat) {
                if n <= i and n <= j {
                    if i <= j {
                        q(j) - q(i) = sum(map(map(i.until(j), a), Real.abs))
                        partial(a, j) - partial(a, i) = sum(map(i.until(j), a))
                        sum(map(i.until(j), a)).abs <= sum(map(map(i.until(j), a), Real.abs))
                        q(j) - q(i) <= (q(j) - q(i)).abs
                        (p(j) - p(i)).abs <= (q(j) - q(i)).abs
                        (p(j) - p(i)).abs < eps
                        p(i).is_close(p(j), eps)
                    } else {
                        partial(compose(Real.abs, a), i) - partial(compose(Real.abs, a), j) = sum(map(j.until(i), compose(Real.abs, a)))
                        sum(map(j.until(i), a)).abs <= q(i) - q(j)
                        partial(a, i) - partial(a, j) = sum(map(j.until(i), a))
                        (p(i) - p(j)).abs <= (q(i) - q(j)).abs
                        q(i).is_close(q(j), eps)
                        (q(i) - q(j)).abs < eps
                        (p(i) - p(j)).abs < eps
                        p(i).is_close(p(j), eps)
                    }
                }
            }
            cauchy_bound(partial(a), n, eps)
        }
    }
}

/// If a series converges, its terms converge to zero.
theorem series_conv_imp_term_vanishes(a: Nat -> Real) {
    converges(partial(a)) implies converges_to(a, Real.0)
} by {
    let p = partial(a)
    forall(eps: Real) {
        if eps.is_positive {
            let n: Nat satisfy {
                cauchy_bound(p, n, eps)
            }
            forall(i: Nat) {
                if n <= i {
                    p(i).is_close(p(i.suc), eps)
                    p(i.suc) = p(i) + a(i)
                    p(i.suc) - p(i) = a(i)
                    (p(i.suc) - p(i)).abs < eps
                    a(i).abs < eps
                    a(i).is_close(Real.0, eps)
                }
            }
            tail_bound(a, Real.0, n, eps)
        }
    }
}

theorem pow_nonneg(r: Real, n: Nat) {
    0 <= r implies 0 <= r.pow(n)
} by {
    // Proof by induction
    define p(k: Nat) -> Bool {
        0 <= r.pow(k)
    }
    r.pow(Nat.0) = Real.1
    Real.1 * Real.1 = Real.1
    Real.1 * Real.1 >= Real.0
    Real.0 <= Real.1
    p(Nat.0)
    forall(k: Nat) {
        if p(k) {
            Real.0 <= r.pow(k)
            not r.is_negative
            not r.pow(k).is_negative
            r * r.pow(k) = r.pow(k.suc)
            0 <= r.pow(k.suc)
        }
    }
}

theorem pos_geom_indirect_upper_bound(r: Real, n: Nat) {
    0 <= r and r < 1 implies
    partial(r.pow, n) * (1 - r) <= 1
} by {
    (r + -Real.1) * sum(map(n.range, r.pow)) = r.pow(n) + -Real.1
    Real.1 + -r = Real.1 - r
    --r = r
    sum(map(n.range, r.pow)) * (Real.1 - r) = (Real.1 - r) * sum(map(n.range, r.pow))
    Real.1 + -r.pow(n) = Real.1 - r.pow(n)
    --r.pow(n) = r.pow(n)
    sum(map(n.range, r.pow)) * (1 - r) = 1 - r.pow(n)
    let x = r.pow(n)
    0 + (1 - x) <= x + (1 - x)
    sum(map(n.range, r.pow)) * (1 - r) <= 1
}

theorem pos_mul_eq_pos(a: Real, b: Real) {
    a.is_positive and (a * b).is_positive implies b.is_positive
} by {
    a.abs = a
    (a * b).abs = a * b
    a.abs * b.abs = (a * b).abs
    a * b.abs = a * b
    if (-b).is_negative {
        b.is_positive
    } else {
        (-b).abs = -b
        (--b).abs = (-b).abs
        --b = b
        b.abs = -b
        a * -b = -(a * b)
        (a * b).is_negative
    }
}

theorem exists_large_mul(a: Real, b: Real) {
    a.is_positive and b.is_positive implies exists(c: Real) {
        a < b * c
    }
} by {
    let ra: Rat satisfy {
        a < Real.from_rat(ra)
    }
    Real.from_rat(ra).is_positive
    ra.is_positive
    let rb: Rat satisfy {
        rb.is_positive and Real.from_rat(rb) < b
    }
    let rc = ra / rb
    ra = rb * rc
    Real.from_rat(rb) * Real.from_rat(rc) < b * Real.from_rat(rc)
}

define nonneg_seq(a: Nat -> Real) -> Bool {
    forall(n: Nat) {
        not a(n).is_negative
    }
}

theorem nonneg_imp_partial_increasing(a: Nat -> Real) {
    nonneg_seq(a) implies is_increasing(partial(a))
}

theorem increasing_from_nonneg_start(a: Nat -> Real) {
    not a(Nat.0).is_negative and is_increasing(a) implies nonneg_seq(a)
} by {
    forall(n: Nat) {
        Nat.0 <= n
        Nat.0 <= Nat.0 + n
        Nat.0 + n = n
        a(Nat.0) <= a(n)
        not a(n).is_negative
    }
}

theorem nonneg_partial_nonneg(a: Nat -> Real) {
    nonneg_seq(a) implies
    nonneg_seq(partial(a))
}

/// Partial sums of nonnegative sequences are nonnegative.
theorem partial_nonneg(f: Nat -> Real, n: Nat) {
    is_lower_bound(f, Real.0) implies partial(f, n) >= Real.0
} by {

    define p(m: Nat) -> Bool {
        is_lower_bound(f, Real.0) implies partial(f, m) >= Real.0
    }

    p(Nat.0)

    forall(m: Nat) {
        if p(m) {
            if is_lower_bound(f, Real.0) {
                map_add(m.range, List.singleton(m), f)
                sum_add(map(m.range, f), List.singleton(f(m)))

                lte_add_right(Real.0, partial(f, m), f(m))
                Real.0 <= partial(f, m) + f(m)
                partial(f, m) + f(m) = partial(f, m.suc)
                partial(f, m.suc) >= Real.0
            }
            p(m.suc)
        }
    }

    p(n)
}

theorem nonneg_pow(r: Real) {
    0 <= r implies nonneg_seq(r.pow)
}

theorem pos_geom_has_upper_bound(r: Real) {
    0 <= r and r < 1 implies
    exists(ub: Real) {
        is_upper_bound(partial(r.pow), ub)
    }
} by {
    (1 - r).is_positive
    1.is_positive
    let ub: Real satisfy {
        1 < ub * (1 - r)
    }
    ub.is_positive
    forall(n: Nat) {
        partial(r.pow, n) * (1 - r) * ub <= ub
        nonneg_seq(partial(r.pow))
        partial(r.pow, n) * 1 <= partial(r.pow, n) * ((1 - r) * ub)
        partial(r.pow, n) <= ub
    }
}

theorem pos_geom_converges(r: Real) {
    0 <= r and r < 1 implies converges(partial(r.pow))
}

theorem abs_pow(r: Real, n: Nat) {
    r.abs.pow(n) = r.pow(n).abs
} by {
    // Proof by induction on n
    define p(k: Nat) -> Bool {
        r.abs.pow(k) = r.pow(k).abs
    }

    // Base case: n = 0
    r.abs.pow(Nat.0) = Real.1
    r.pow(Nat.0) = Real.1
    Real.1.is_positive
    Real.1.abs = Real.1
    r.abs.pow(Nat.0) = r.pow(Nat.0).abs

    // Inductive step
    forall(k: Nat) {
        if p(k) {
            // Induction hypothesis: r.abs.pow(k) = r.pow(k).abs

            // Need to prove: r.abs.pow(k.suc) = r.pow(k.suc).abs
            r.abs.pow(k.suc) = r.pow(k.suc).abs
        }
    }

    // By induction, p holds for all k
    p(n)
}

theorem abs_geom_comm(r: Real) {
    compose(Real.abs, r.pow) = r.abs.pow
}

theorem geom_converges(r: Real) {
    r.abs < 1 implies converges(partial(r.pow))
} by {
    partial(r.abs.pow) = partial(compose(Real.abs, r.pow))
}

theorem partial_tail_decomp(a: Nat -> Real, m: Nat) {
    converges(partial(a)) implies
    limit(partial(a)) = partial(a, m) + limit(partial(tail(a, m)))
} by {
    converges_to(partial(tail(a, m)), limit(partial(a)) - partial(a, m))
    converges(partial(tail(a, m)))
    converges_to(partial(tail(a, m)), limit(partial(tail(a, m))))
    limit(partial(tail(a, m))) = limit(partial(a)) - partial(a, m)
}

theorem pow_tail(r: Real) {
    tail(r.pow, Nat.1) = mul_seq(r, r.pow)
}

theorem partial_one(a: Nat -> Real) {
    partial(a, Nat.1) = a(Nat.0)
}

theorem geom_series_no_div(r: Real) {
    r.abs < 1 implies
    1 + r * limit(partial(r.pow)) = limit(partial(r.pow))
} by {
    partial(r.pow, Nat.1) = Real.1
    let t = tail(r.pow, Nat.1)
    partial(tail(r.pow, Nat.1)) = partial(mul_seq(r, r.pow))
    partial(mul_seq(r, r.pow)) = mul_seq(r, partial(r.pow))
    converges(partial(r.pow))
    converges(mul_seq(r, partial(r.pow)))
    limit(partial(mul_seq(r, r.pow))) = r * limit(partial(r.pow))
}

/// Delta function: returns v if k = a, and 0 otherwise.
define delta(v: Real, a: Nat, k: Nat) -> Real {
    if k = a {
        v
    } else {
        Real.0
    }
}

/// For indices less than a, delta is zero.
theorem delta_before(v: Real, a: Nat, k: Nat) {
    k < a implies delta(v, a, k) = Real.0
} by {
    if k < a {
        k != a
        delta(v, a, k) = Real.0
    }
}

/// At index a, delta returns v.
theorem delta_at(v: Real, a: Nat) {
    delta(v, a, a) = v
} by {
    a = a
    delta(v, a, a) = v
}

/// For indices greater than a, delta is zero.
theorem delta_after(v: Real, a: Nat, k: Nat) {
    k > a implies delta(v, a, k) = Real.0
} by {
    if k > a {
        k != a
        delta(v, a, k) = Real.0
    }
}

/// Delta as a sequence function.
define delta_seq(v: Real, a: Nat) -> (Nat -> Real) {
    function(k: Nat) {
        delta(v, a, k)
    }
}

/// Partial sums of delta before reaching a.
theorem partial_delta_before(v: Real, a: Nat, n: Nat) {
    n <= a implies partial(delta_seq(v, a), n) = Real.0
} by {
    define p(m: Nat) -> Bool {
        m <= a implies partial(delta_seq(v, a), m) = Real.0
    }

    // Base case: n = 0
    p(Nat.0)

    // Inductive step
    forall(m: Nat) {
        if p(m) {
            if m.suc <= a {
                // By IH: partial(delta_seq(v, a), m) = 0
                partial(delta_seq(v, a), m) = Real.0

                // Also m < a, so delta(v, a, m) = 0
                m < m.suc
                m.suc <= a
                m < a
                delta(v, a, m) = Real.0
                delta_seq(v, a)(m) = Real.0

                // Therefore partial(delta_seq(v, a), m.suc) = 0 + 0 = 0
                partial(delta_seq(v, a), m.suc) = partial(delta_seq(v, a), m) + delta_seq(v, a)(m)
                partial(delta_seq(v, a), m.suc) = Real.0
            }
            p(m.suc)
        }
    }

    p(n)
}

/// Partial sums of delta at or after a equal v.
theorem partial_delta_at_or_after(v: Real, a: Nat, n: Nat) {
    a < n implies partial(delta_seq(v, a), n) = v
} by {
    if a < n {
        // We can write n = a.suc + k for some k
        let k: Nat satisfy {
            a.suc + k = n
        }

        // partial(delta_seq(v, a), a.suc + k)
        // = partial(delta_seq(v, a), a.suc) + partial(tail(delta_seq(v, a), a.suc), k)
        partial(delta_seq(v, a), a.suc + k) = partial(delta_seq(v, a), a.suc) + partial(tail(delta_seq(v, a), a.suc), k)

        // partial(delta_seq(v, a), a.suc) = partial(delta_seq(v, a), a) + delta(v, a, a)
        partial(delta_seq(v, a), a.suc) = partial(delta_seq(v, a), a) + delta_seq(v, a)(a)
        delta_seq(v, a)(a) = delta(v, a, a)

        // partial(delta_seq(v, a), a) = 0 (by partial_delta_before)
        a <= a
        partial(delta_seq(v, a), a) = Real.0

        // delta(v, a, a) = v
        delta(v, a, a) = v

        // So partial(delta_seq(v, a), a.suc) = 0 + v = v
        partial(delta_seq(v, a), a.suc) = v

        // For the tail: all elements are 0
        forall(j: Nat) {
            tail(delta_seq(v, a), a.suc)(j) = delta_seq(v, a)(a.suc + j)
            delta_seq(v, a)(a.suc + j) = delta(v, a, a.suc + j)
            a.suc + j > a
            delta(v, a, a.suc + j) = Real.0
            tail(delta_seq(v, a), a.suc)(j) = Real.0
        }

        // So partial(tail(delta_seq(v, a), a.suc), k) = 0
        partial(tail(delta_seq(v, a), a.suc), k) = Real.0

        // Therefore partial(delta_seq(v, a), n) = v + 0 = v
        partial(delta_seq(v, a), n) = v
    }
}

/// The partial sums of delta converge to v.
theorem delta_partial_converges(v: Real, a: Nat) {
    converges_to(partial(delta_seq(v, a)), v)
} by {
    // For all n > a, partial(delta_seq(v, a), n) = v
    // So the tail starting from a.suc is the constant sequence v
    forall(i: Nat) {
        a < a.suc + i
        partial(delta_seq(v, a), a.suc + i) = v
        tail(partial(delta_seq(v, a)), a.suc)(i) = partial(delta_seq(v, a))(a.suc + i)
        partial(delta_seq(v, a))(a.suc + i) = partial(delta_seq(v, a), a.suc + i)
        tail(partial(delta_seq(v, a)), a.suc)(i) = v
    }

    tail(partial(delta_seq(v, a)), a.suc) = constant[Nat, Real](v)
    const_converges_to(v)
    converges_to(constant[Nat, Real](v), v)
    converges_to(tail(partial(delta_seq(v, a)), a.suc), v)
    converges_to(partial(delta_seq(v, a)), v)
}

/// Helper: absolute value of delta equals delta of absolute value.
theorem delta_abs_commute(v: Real, a: Nat, k: Nat) {
    delta(v, a, k).abs = delta(v.abs, a, k)
} by {
    if k = a {
        delta(v, a, k) = v
        delta(v.abs, a, k) = v.abs
        delta(v, a, k).abs = delta(v.abs, a, k)
    }
    if k != a {
        delta(v, a, k) = Real.0
        delta(v.abs, a, k) = Real.0
        delta(v, a, k).abs = delta(v.abs, a, k)
    }
}

/// The partial sums of delta absolutely converge.
theorem delta_absolutely_converges(v: Real, a: Nat) {
    converges(partial(compose(Real.abs, delta_seq(v, a))))
} by {
    // Show that compose(Real.abs, delta_seq(v, a)) = delta_seq(v.abs, a)
    forall(k: Nat) {
        compose(Real.abs, delta_seq(v, a))(k) = delta_seq(v, a)(k).abs
        delta_seq(v, a)(k) = delta(v, a, k)
        delta_seq(v, a)(k).abs = delta(v, a, k).abs
        delta(v, a, k).abs = delta(v.abs, a, k)
        delta(v.abs, a, k) = delta_seq(v.abs, a)(k)
        compose(Real.abs, delta_seq(v, a))(k) = delta_seq(v.abs, a)(k)
    }
    compose(Real.abs, delta_seq(v, a)) = delta_seq(v.abs, a)

    // We've proven that delta_partial_converges, so:
    converges_to(partial(delta_seq(v.abs, a)), v.abs)
    converges(partial(delta_seq(v.abs, a)))
    converges(partial(compose(Real.abs, delta_seq(v, a))))
}