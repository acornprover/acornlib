from util import constant, compose
from nat import Nat
from list import partial, sum, map, List
from list.list_functional import reverse, reverse_get_idx
from list.list_sum import map_range, list_extensionality, scalar_mul
from option import Option
from real.real_ring import Real
from semigroup import mul_fn
from add_semigroup import add_fn

numerals Real

// This file defines the Cauchy product of two series and proves theorems about it.

attributes Real {
    // Placeholder to let other modules import Real from here.
}

/// The coefficient function for the Cauchy product at index n.
/// For a fixed n, this returns a function mapping k to a(k) * b(n-k).
define cauchy_coefficient(a: Nat -> Real, b: Nat -> Real, n: Nat) -> (Nat -> Real) {
    function(k: Nat) { a(k) * b(n - k) }
}

/// The Cauchy product of two sequences at index n.
/// This computes âˆ‘_{k=0}^{n} a(k) * b(n-k).
define cauchy_product(a: Nat -> Real, b: Nat -> Real, n: Nat) -> Real {
    sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// The sequence of Cauchy products.
define cauchy_seq(a: Nat -> Real, b: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { cauchy_product(a, b, n) }
}

theorem cauchy_product_zero(a: Nat -> Real, b: Nat -> Real) {
    cauchy_product(a, b, Nat.0) = a(Nat.0) * b(Nat.0)
} by {
    let mapped = map(Nat.1.range, function(k: Nat) { a(k) * b(Nat.0 - k) })
}

/// If we map a list with a function that always returns zero, the sum is zero.
theorem sum_map_zero[T](items: List[T], f: T -> Real) {
    (forall(x: T) { f(x) = Real.0 })
    implies
    sum(map(items, f)) = Real.0
} by {
    define p(xs: List[T]) -> Bool {
        (forall(x: T) { f(x) = Real.0 })
        implies
        sum(map(xs, f)) = Real.0
    }

    // Base case: empty list
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if forall(x: T) { f(x) = Real.0 } {
            }
            p(List.cons(head, tail))
        }
    }
}

/// If a is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_left(b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n)(k) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)
}

/// If a is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_left_fn(b: Nat -> Real, n: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n) = constant[Nat, Real](Real.0)
} by {
    let a = constant[Nat, Real](Real.0)
}

/// If b is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_right(a: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n)(k) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
}

/// If b is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_right_fn(a: Nat -> Real, n: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n) = constant[Nat, Real](Real.0)
} by {
    let b = constant[Nat, Real](Real.0)
}

/// Helper lemma: reverse of mapped range with cauchy_coefficient equals mapped range with swapped coefficients.
theorem cauchy_reverse_map_eq(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    reverse(map(n.suc.range, cauchy_coefficient(a, b, n))) =
    map(n.suc.range, cauchy_coefficient(b, a, n))
} by {
    let left_list = reverse(map(n.suc.range, cauchy_coefficient(a, b, n)))
    let right_list = map(n.suc.range, cauchy_coefficient(b, a, n))

    left_list.length = right_list.length

    forall(idx: Nat) {
        if idx < left_list.length {
            idx < n.suc

            let mapped = map(n.suc.range, cauchy_coefficient(a, b, n))
            reverse_get_idx(mapped, idx)

            n - idx <= n

            map_range(n.suc, n - idx, cauchy_coefficient(a, b, n))
            mapped.get_idx(n - idx) = Option.some(cauchy_coefficient(a, b, n)(n - idx))

            n - (n - idx) = idx

            map_range(n.suc, idx, cauchy_coefficient(b, a, n))

            left_list.get_idx(idx) = right_list.get_idx(idx)
        }
    }

    list_extensionality(left_list, right_list)
}

/// Cauchy product is commutative.
theorem cauchy_product_comm(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, b, n) = cauchy_product(b, a, n)
} by {
    cauchy_reverse_map_eq(a, b, n)
}

/// Cauchy product with a zero sequence on the left.
theorem cauchy_product_zero_left(b: Nat -> Real, n: Nat) {
    cauchy_product(constant[Nat, Real](Real.0), b, n) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)

    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0
}

/// Cauchy product with a zero sequence on the right.
theorem cauchy_product_zero_right(a: Nat -> Real, n: Nat) {
    cauchy_product(a, constant[Nat, Real](Real.0), n) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
}

/// Helper lemma: cauchy_coefficient distributes scalar multiplication in the first argument.
theorem cauchy_coefficient_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(mul_fn(c, a), b, n)(k) = c * cauchy_coefficient(a, b, n)(k)
}

/// Linearity in the first argument: scalar multiplication factors out.
theorem cauchy_product_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(mul_fn(c, a), b, n) = c * cauchy_product(a, b, n)
} by {
    cauchy_coefficient(mul_fn(c, a), b, n) = compose(scalar_mul(c), cauchy_coefficient(a, b, n))

    sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c))) = c * sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// Helper lemma: cauchy_coefficient distributes scalar multiplication in the second argument.
theorem cauchy_coefficient_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, mul_fn(c, b), n)(k) = c * cauchy_coefficient(a, b, n)(k)
}

/// Linearity in the second argument: scalar multiplication factors out.
theorem cauchy_product_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, mul_fn(c, b), n) = c * cauchy_product(a, b, n)
}

/// Helper lemma: cauchy_coefficient distributes addition in the first argument.
theorem cauchy_coefficient_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(add_fn(a, aa), b, n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
} by {
    a(k) * b(n - k) + aa(k) * b(n - k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
}

/// Distributivity in the first argument: addition distributes through the Cauchy product.
theorem cauchy_product_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(add_fn(a, aa), b, n) = cauchy_product(a, b, n) + cauchy_product(aa, b, n)
} by {
    cauchy_coefficient(add_fn(a, aa), b, n) = add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n))
}

/// Helper lemma: cauchy_coefficient distributes addition in the second argument.
theorem cauchy_coefficient_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, add_fn(b, bb), n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
} by {
    a(k) * b(n - k) + a(k) * bb(n - k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
}

/// Distributivity in the second argument: addition distributes through the Cauchy product.
theorem cauchy_product_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat) {
    cauchy_product(a, add_fn(b, bb), n) = cauchy_product(a, b, n) + cauchy_product(a, bb, n)
}

/// Partial sum of Cauchy product with zero sequence on the left is zero.
theorem partial_cauchy_zero_left(b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(constant[Nat, Real](Real.0), b), n) = Real.0
} by {
    cauchy_seq(constant[Nat, Real](Real.0), b) = constant[Nat, Real](Real.0)
}

/// Partial sum of Cauchy product with zero sequence on the right is zero.
theorem partial_cauchy_zero_right(a: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, constant[Nat, Real](Real.0)), n) = Real.0
} by {
    cauchy_seq(a, constant[Nat, Real](Real.0)) = constant[Nat, Real](Real.0)
}

/// Partial sum distributes over addition in the first argument.
theorem partial_cauchy_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(add_fn(a, aa), b), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(aa, b), n)
}

/// Partial sum distributes over addition in the second argument.
theorem partial_cauchy_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, add_fn(b, bb)), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(a, bb), n)
}

/// Scalar multiplication factors out of partial sum in the first argument.
theorem partial_cauchy_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(mul_fn(c, a), b), n) = c * partial(cauchy_seq(a, b), n)
}

/// Scalar multiplication factors out of partial sum in the second argument.
theorem partial_cauchy_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, mul_fn(c, b)), n) = c * partial(cauchy_seq(a, b), n)
}