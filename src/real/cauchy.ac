from util import constant, compose
from nat import Nat
from rat import Rat
from list import partial, sum, map, List
from list.list_functional import reverse, sum_reverse, reverse_get_idx
from list.list_sum import map_range, list_extensionality, sum_scalar_mul, map_sum_add, scalar_mul
from option import Option
from real.real_ring import Real, converges, converges_to, limit, lift_seq
from real.real_series import seq_lte, is_lower_bound, add_seq, mul_seq
from real.real_base import lte_add_left, lte_add_right, lte_trans
from semigroup import mul_fn
from add_semigroup import add_fn
from add_comm_monoid import AddCommMonoid

numerals Real

// This file defines the Cauchy product of two series and proves theorems about it.

attributes Real {
    // Placeholder to let other modules import Real from here.
}

/// The coefficient function for the Cauchy product at index n.
/// For a fixed n, this returns a function mapping k to a(k) * b(n-k).
define cauchy_coefficient(a: Nat -> Real, b: Nat -> Real, n: Nat) -> (Nat -> Real) {
    function(k: Nat) { a(k) * b(n - k) }
}

/// The Cauchy product of two sequences at index n.
/// This computes ∑_{k=0}^{n} a(k) * b(n-k).
define cauchy_product(a: Nat -> Real, b: Nat -> Real, n: Nat) -> Real {
    sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// The sequence of Cauchy products.
define cauchy_seq(a: Nat -> Real, b: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { cauchy_product(a, b, n) }
}

theorem cauchy_product_zero(a: Nat -> Real, b: Nat -> Real) {
    cauchy_product(a, b, Nat.0) = a(Nat.0) * b(Nat.0)
} by {
    Nat.0.suc = Nat.1
    Nat.1.range = List.singleton(Nat.0)
    let mapped = map(Nat.1.range, function(k: Nat) { a(k) * b(Nat.0 - k) })
    Nat.0 - Nat.0 = Nat.0
    mapped = List.singleton(a(Nat.0) * b(Nat.0))
    sum(mapped) = a(Nat.0) * b(Nat.0)
}

/// If we map a list with a function that always returns zero, the sum is zero.
theorem sum_map_zero[T](items: List[T], f: T -> Real) {
    (forall(x: T) { f(x) = Real.0 })
    implies
    sum(map(items, f)) = Real.0
} by {
    define p(xs: List[T]) -> Bool {
        (forall(x: T) { f(x) = Real.0 })
        implies
        sum(map(xs, f)) = Real.0
    }

    // Base case: empty list
    map(List.nil[T], f) = List.nil[Real]
    sum(List.nil[Real]) = Real.0
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if forall(x: T) { f(x) = Real.0 } {
                // Apply the hypothesis to tail
                sum(map(tail, f)) = Real.0

                // Now work on the cons case
                map(List.cons(head, tail), f) = List.cons(f(head), map(tail, f))
                sum(List.cons(f(head), map(tail, f))) = f(head) + sum(map(tail, f))
                f(head) = Real.0
                sum(List.cons(f(head), map(tail, f))) = Real.0 + Real.0
                sum(List.cons(f(head), map(tail, f))) = Real.0
                sum(map(List.cons(head, tail), f)) = Real.0
            }
            p(List.cons(head, tail))
        }
    }
}

/// If a is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_left(b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n)(k) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    a(k) = Real.0
    Real.0 * b(n - k) = Real.0
}

/// If a is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_left_fn(b: Nat -> Real, n: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n) = constant[Nat, Real](Real.0)
} by {
    let a = constant[Nat, Real](Real.0)
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
}

/// If b is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_right(a: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n)(k) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    b(n - k) = Real.0
    a(k) * Real.0 = Real.0
}

/// If b is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_right_fn(a: Nat -> Real, n: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n) = constant[Nat, Real](Real.0)
} by {
    let b = constant[Nat, Real](Real.0)
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
}

/// Helper lemma: reverse of mapped range with cauchy_coefficient equals mapped range with swapped coefficients.
theorem cauchy_reverse_map_eq(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    reverse(map(n.suc.range, cauchy_coefficient(a, b, n))) =
    map(n.suc.range, cauchy_coefficient(b, a, n))
} by {
    let left_list = reverse(map(n.suc.range, cauchy_coefficient(a, b, n)))
    let right_list = map(n.suc.range, cauchy_coefficient(b, a, n))

    // Both lists have the same length
    left_list.length = map(n.suc.range, cauchy_coefficient(a, b, n)).length
    map(n.suc.range, cauchy_coefficient(a, b, n)).length = n.suc.range.length
    n.suc.range.length = n.suc
    right_list.length = map(n.suc.range, cauchy_coefficient(b, a, n)).length
    map(n.suc.range, cauchy_coefficient(b, a, n)).length = n.suc.range.length
    left_list.length = right_list.length

    // Show they agree at every index
    forall(idx: Nat) {
        if idx < left_list.length {
            // idx < n.suc
            idx < n.suc

            // Element of left_list at idx using reverse_get_idx
            let mapped = map(n.suc.range, cauchy_coefficient(a, b, n))
            reverse_get_idx(mapped, idx)
            mapped.length = n.suc
            left_list.get_idx(idx) = mapped.get_idx(mapped.length - Nat.1 - idx)

            // mapped.length - 1 - idx = n - idx
            mapped.length - Nat.1 - idx = n - idx

            // Show n - idx < n.suc
            n - idx <= n
            n < n.suc
            n - idx < n.suc

            // Apply map_range with cauchy_coefficient
            map_range(n.suc, n - idx, cauchy_coefficient(a, b, n))
            mapped.get_idx(n - idx) = Option.some(cauchy_coefficient(a, b, n)(n - idx))

            // Expand cauchy_coefficient
            cauchy_coefficient(a, b, n)(n - idx) = a(n - idx) * b(n - (n - idx))
            n - (n - idx) = idx
            cauchy_coefficient(a, b, n)(n - idx) = a(n - idx) * b(idx)

            left_list.get_idx(idx) = Option.some(a(n - idx) * b(idx))

            // By commutativity
            a(n - idx) * b(idx) = b(idx) * a(n - idx)

            // Element of right_list at idx
            map_range(n.suc, idx, cauchy_coefficient(b, a, n))
            right_list.get_idx(idx) = Option.some(cauchy_coefficient(b, a, n)(idx))

            // Expand cauchy_coefficient
            cauchy_coefficient(b, a, n)(idx) = b(idx) * a(n - idx)

            // Therefore they're equal
            left_list.get_idx(idx) = Option.some(b(idx) * a(n - idx))
            left_list.get_idx(idx) = right_list.get_idx(idx)
        }
    }

    // Apply list extensionality
    list_extensionality(left_list, right_list)
    left_list = right_list
}

/// Cauchy product is commutative.
theorem cauchy_product_comm(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, b, n) = cauchy_product(b, a, n)
} by {
    // Expand definitions
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(b, a, n) = sum(map(n.suc.range, cauchy_coefficient(b, a, n)))

    // Use sum_reverse
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = sum(reverse(map(n.suc.range, cauchy_coefficient(a, b, n))))

    // Use helper lemma
    cauchy_reverse_map_eq(a, b, n)
    reverse(map(n.suc.range, cauchy_coefficient(a, b, n))) = map(n.suc.range, cauchy_coefficient(b, a, n))

    // Combine
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = sum(map(n.suc.range, cauchy_coefficient(b, a, n)))
}

/// Cauchy product with a zero sequence on the left.
theorem cauchy_product_zero_left(b: Nat -> Real, n: Nat) {
    cauchy_product(constant[Nat, Real](Real.0), b, n) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)

    // Show that cauchy_coefficient equals the constant zero function
    cauchy_coefficient(a, b, n) = constant[Nat, Real](Real.0)

    // Therefore every application returns zero
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
    }

    // Apply sum_map_zero
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0

    // This is the definition of cauchy_product
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(a, b, n) = Real.0
}

/// Cauchy product with a zero sequence on the right.
theorem cauchy_product_zero_right(a: Nat -> Real, n: Nat) {
    cauchy_product(a, constant[Nat, Real](Real.0), n) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)

    // Show that cauchy_coefficient equals the constant zero function
    cauchy_coefficient(a, b, n) = constant[Nat, Real](Real.0)

    // Therefore every application returns zero
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
    }

    // Apply sum_map_zero
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0

    // This is the definition of cauchy_product
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(a, b, n) = Real.0
}

/// Helper lemma: cauchy_coefficient distributes scalar multiplication in the first argument.
theorem cauchy_coefficient_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(mul_fn(c, a), b, n)(k) = c * cauchy_coefficient(a, b, n)(k)
} by {
    // Expand cauchy_coefficient definition
    cauchy_coefficient(mul_fn(c, a), b, n)(k) = mul_fn(c, a)(k) * b(n - k)
    mul_fn(c, a)(k) = c * a(k)
    cauchy_coefficient(mul_fn(c, a), b, n)(k) = (c * a(k)) * b(n - k)

    // Use associativity
    (c * a(k)) * b(n - k) = c * (a(k) * b(n - k))

    // Recognize the right side as the original coefficient
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    c * (a(k) * b(n - k)) = c * cauchy_coefficient(a, b, n)(k)
}

/// Linearity in the first argument: scalar multiplication factors out.
theorem cauchy_product_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(mul_fn(c, a), b, n) = c * cauchy_product(a, b, n)
} by {
    // Expand cauchy_product definitions
    cauchy_product(mul_fn(c, a), b, n) = sum(map(n.suc.range, cauchy_coefficient(mul_fn(c, a), b, n)))
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))

    // Show that the coefficient functions are related by scalar multiplication
    forall(k: Nat) {
        cauchy_coefficient(mul_fn(c, a), b, n)(k) = c * cauchy_coefficient(a, b, n)(k)
        scalar_mul(c)(cauchy_coefficient(a, b, n)(k)) = c * cauchy_coefficient(a, b, n)(k)
    }

    // The two functions are equal
    cauchy_coefficient(mul_fn(c, a), b, n) = compose(scalar_mul(c), cauchy_coefficient(a, b, n))

    // Use sum_scalar_mul to factor out the constant
    sum(map(n.suc.range, cauchy_coefficient(mul_fn(c, a), b, n))) = sum(map(n.suc.range, compose(scalar_mul(c), cauchy_coefficient(a, b, n))))
    sum(map(n.suc.range, compose(scalar_mul(c), cauchy_coefficient(a, b, n)))) = sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c)))
    sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c))) = c * sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// Helper lemma: cauchy_coefficient distributes scalar multiplication in the second argument.
theorem cauchy_coefficient_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, mul_fn(c, b), n)(k) = c * cauchy_coefficient(a, b, n)(k)
} by {
    // Expand cauchy_coefficient definition
    cauchy_coefficient(a, mul_fn(c, b), n)(k) = a(k) * mul_fn(c, b)(n - k)
    mul_fn(c, b)(n - k) = c * b(n - k)
    cauchy_coefficient(a, mul_fn(c, b), n)(k) = a(k) * (c * b(n - k))

    // Use associativity and commutativity
    a(k) * (c * b(n - k)) = a(k) * (b(n - k) * c)
    a(k) * (b(n - k) * c) = (a(k) * b(n - k)) * c
    (a(k) * b(n - k)) * c = c * (a(k) * b(n - k))

    // Recognize the right side as the original coefficient
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    c * (a(k) * b(n - k)) = c * cauchy_coefficient(a, b, n)(k)
}

/// Linearity in the second argument: scalar multiplication factors out.
theorem cauchy_product_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, mul_fn(c, b), n) = c * cauchy_product(a, b, n)
} by {
    // Expand cauchy_product definitions
    cauchy_product(a, mul_fn(c, b), n) = sum(map(n.suc.range, cauchy_coefficient(a, mul_fn(c, b), n)))
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))

    // Show that the coefficient functions are related by scalar multiplication
    forall(k: Nat) {
        cauchy_coefficient(a, mul_fn(c, b), n)(k) = c * cauchy_coefficient(a, b, n)(k)
        scalar_mul(c)(cauchy_coefficient(a, b, n)(k)) = c * cauchy_coefficient(a, b, n)(k)
    }

    // The two functions are equal
    cauchy_coefficient(a, mul_fn(c, b), n) = compose(scalar_mul(c), cauchy_coefficient(a, b, n))

    // Use sum_scalar_mul to factor out the constant
    sum(map(n.suc.range, cauchy_coefficient(a, mul_fn(c, b), n))) = sum(map(n.suc.range, compose(scalar_mul(c), cauchy_coefficient(a, b, n))))
    sum(map(n.suc.range, compose(scalar_mul(c), cauchy_coefficient(a, b, n)))) = sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c)))
    sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c))) = c * sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// Helper lemma: cauchy_coefficient distributes addition in the first argument.
theorem cauchy_coefficient_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(add_fn(a, aa), b, n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
} by {
    // Expand cauchy_coefficient definition
    cauchy_coefficient(add_fn(a, aa), b, n)(k) = add_fn(a, aa)(k) * b(n - k)
    add_fn(a, aa)(k) = a(k) + aa(k)
    cauchy_coefficient(add_fn(a, aa), b, n)(k) = (a(k) + aa(k)) * b(n - k)

    // Use distributivity
    (a(k) + aa(k)) * b(n - k) = a(k) * b(n - k) + aa(k) * b(n - k)

    // Recognize the right side as the sum of coefficients
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    cauchy_coefficient(aa, b, n)(k) = aa(k) * b(n - k)
    a(k) * b(n - k) + aa(k) * b(n - k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
}

/// Distributivity in the first argument: addition distributes through the Cauchy product.
theorem cauchy_product_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(add_fn(a, aa), b, n) = cauchy_product(a, b, n) + cauchy_product(aa, b, n)
} by {
    // Expand cauchy_product definitions
    cauchy_product(add_fn(a, aa), b, n) = sum(map(n.suc.range, cauchy_coefficient(add_fn(a, aa), b, n)))
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(aa, b, n) = sum(map(n.suc.range, cauchy_coefficient(aa, b, n)))

    // Show that the coefficient functions are related by addition
    forall(k: Nat) {
        cauchy_coefficient(add_fn(a, aa), b, n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
        add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n))(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
    }

    // The two functions are equal
    cauchy_coefficient(add_fn(a, aa), b, n) = add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n))

    // Use map_sum_add to split the sum
    sum(map(n.suc.range, cauchy_coefficient(add_fn(a, aa), b, n))) = sum(map(n.suc.range, add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n))))
    sum(map(n.suc.range, add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n)))) = sum(map(n.suc.range, cauchy_coefficient(a, b, n))) + sum(map(n.suc.range, cauchy_coefficient(aa, b, n)))
}

/// Helper lemma: cauchy_coefficient distributes addition in the second argument.
theorem cauchy_coefficient_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, add_fn(b, bb), n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
} by {
    // Expand cauchy_coefficient definition
    cauchy_coefficient(a, add_fn(b, bb), n)(k) = a(k) * add_fn(b, bb)(n - k)
    add_fn(b, bb)(n - k) = b(n - k) + bb(n - k)
    cauchy_coefficient(a, add_fn(b, bb), n)(k) = a(k) * (b(n - k) + bb(n - k))

    // Use distributivity
    a(k) * (b(n - k) + bb(n - k)) = a(k) * b(n - k) + a(k) * bb(n - k)

    // Recognize the right side as the sum of coefficients
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    cauchy_coefficient(a, bb, n)(k) = a(k) * bb(n - k)
    a(k) * b(n - k) + a(k) * bb(n - k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
}

/// Distributivity in the second argument: addition distributes through the Cauchy product.
theorem cauchy_product_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat) {
    cauchy_product(a, add_fn(b, bb), n) = cauchy_product(a, b, n) + cauchy_product(a, bb, n)
} by {
    // Expand cauchy_product definitions
    cauchy_product(a, add_fn(b, bb), n) = sum(map(n.suc.range, cauchy_coefficient(a, add_fn(b, bb), n)))
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(a, bb, n) = sum(map(n.suc.range, cauchy_coefficient(a, bb, n)))

    // Show that the coefficient functions are related by addition
    forall(k: Nat) {
        cauchy_coefficient(a, add_fn(b, bb), n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
        add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(a, bb, n))(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
    }

    // The two functions are equal
    cauchy_coefficient(a, add_fn(b, bb), n) = add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(a, bb, n))

    // Use map_sum_add to split the sum
    sum(map(n.suc.range, cauchy_coefficient(a, add_fn(b, bb), n))) = sum(map(n.suc.range, add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(a, bb, n))))
    sum(map(n.suc.range, add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(a, bb, n)))) = sum(map(n.suc.range, cauchy_coefficient(a, b, n))) + sum(map(n.suc.range, cauchy_coefficient(a, bb, n)))
}

/// Partial sum of Cauchy product with zero sequence on the left is zero.
theorem partial_cauchy_zero_left(b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(constant[Nat, Real](Real.0), b), n) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)
    let c = cauchy_seq(a, b)

    // Show that cauchy_seq(a, b) is the constant zero function
    forall(k: Nat) {
        c(k) = cauchy_product(a, b, k)
        cauchy_product(a, b, k) = Real.0
        c(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
    c = constant[Nat, Real](Real.0)

    // Partial sum of constant zero is zero
    partial(c, n) = sum(map(n.range, c))
    partial(c, n) = sum(map(n.range, constant[Nat, Real](Real.0)))

    forall(k: Nat) {
        constant[Nat, Real](Real.0)(k) = Real.0
    }

    sum(map(n.range, constant[Nat, Real](Real.0))) = Real.0
    partial(c, n) = Real.0
}

/// Partial sum of Cauchy product with zero sequence on the right is zero.
theorem partial_cauchy_zero_right(a: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, constant[Nat, Real](Real.0)), n) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
    let c = cauchy_seq(a, b)

    // Show that cauchy_seq(a, b) is the constant zero function
    forall(k: Nat) {
        c(k) = cauchy_product(a, b, k)
        cauchy_product(a, b, k) = Real.0
        c(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
    c = constant[Nat, Real](Real.0)

    // Partial sum of constant zero is zero
    partial(c, n) = sum(map(n.range, c))
    partial(c, n) = sum(map(n.range, constant[Nat, Real](Real.0)))

    forall(k: Nat) {
        constant[Nat, Real](Real.0)(k) = Real.0
    }

    sum(map(n.range, constant[Nat, Real](Real.0))) = Real.0
    partial(c, n) = Real.0
}

/// Partial sum distributes over addition in the first argument.
theorem partial_cauchy_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(add_fn(a, aa), b), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(aa, b), n)
} by {
    // Show that cauchy_seq distributes over addition
    forall(k: Nat) {
        cauchy_seq(add_fn(a, aa), b)(k) = cauchy_product(add_fn(a, aa), b, k)
        cauchy_product(add_fn(a, aa), b, k) = cauchy_product(a, b, k) + cauchy_product(aa, b, k)
        cauchy_seq(a, b)(k) = cauchy_product(a, b, k)
        cauchy_seq(aa, b)(k) = cauchy_product(aa, b, k)
        cauchy_seq(add_fn(a, aa), b)(k) = cauchy_seq(a, b)(k) + cauchy_seq(aa, b)(k)
        add_fn(cauchy_seq(a, b), cauchy_seq(aa, b))(k) = cauchy_seq(a, b)(k) + cauchy_seq(aa, b)(k)
    }

    // Therefore the sequences are equal
    cauchy_seq(add_fn(a, aa), b) = add_fn(cauchy_seq(a, b), cauchy_seq(aa, b))

    // Use partial_add to distribute the partial sum
    partial(cauchy_seq(add_fn(a, aa), b), n) = partial(add_fn(cauchy_seq(a, b), cauchy_seq(aa, b)), n)
    partial(add_fn(cauchy_seq(a, b), cauchy_seq(aa, b)), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(aa, b), n)
}

/// Partial sum distributes over addition in the second argument.
theorem partial_cauchy_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, add_fn(b, bb)), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(a, bb), n)
} by {
    // Show that cauchy_seq distributes over addition
    forall(k: Nat) {
        cauchy_seq(a, add_fn(b, bb))(k) = cauchy_product(a, add_fn(b, bb), k)
        cauchy_product(a, add_fn(b, bb), k) = cauchy_product(a, b, k) + cauchy_product(a, bb, k)
        cauchy_seq(a, b)(k) = cauchy_product(a, b, k)
        cauchy_seq(a, bb)(k) = cauchy_product(a, bb, k)
        cauchy_seq(a, add_fn(b, bb))(k) = cauchy_seq(a, b)(k) + cauchy_seq(a, bb)(k)
        add_fn(cauchy_seq(a, b), cauchy_seq(a, bb))(k) = cauchy_seq(a, b)(k) + cauchy_seq(a, bb)(k)
    }

    // Therefore the sequences are equal
    cauchy_seq(a, add_fn(b, bb)) = add_fn(cauchy_seq(a, b), cauchy_seq(a, bb))

    // Use partial_add to distribute the partial sum
    partial(cauchy_seq(a, add_fn(b, bb)), n) = partial(add_fn(cauchy_seq(a, b), cauchy_seq(a, bb)), n)
    partial(add_fn(cauchy_seq(a, b), cauchy_seq(a, bb)), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(a, bb), n)
}

/// Scalar multiplication factors out of partial sum in the first argument.
theorem partial_cauchy_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(mul_fn(c, a), b), n) = c * partial(cauchy_seq(a, b), n)
} by {
    // Show that cauchy_seq factors out scalar multiplication
    forall(k: Nat) {
        cauchy_seq(mul_fn(c, a), b)(k) = cauchy_product(mul_fn(c, a), b, k)
        cauchy_product(mul_fn(c, a), b, k) = c * cauchy_product(a, b, k)
        cauchy_seq(a, b)(k) = cauchy_product(a, b, k)
        cauchy_seq(mul_fn(c, a), b)(k) = c * cauchy_seq(a, b)(k)
        mul_fn(c, cauchy_seq(a, b))(k) = c * cauchy_seq(a, b)(k)
    }

    // Therefore the sequences are equal
    cauchy_seq(mul_fn(c, a), b) = mul_fn(c, cauchy_seq(a, b))

    // Use partial_scalar_mul to factor out the constant
    partial(cauchy_seq(mul_fn(c, a), b), n) = partial(mul_fn(c, cauchy_seq(a, b)), n)
    partial(mul_fn(c, cauchy_seq(a, b)), n) = c * partial(cauchy_seq(a, b), n)
}

/// Scalar multiplication factors out of partial sum in the second argument.
theorem partial_cauchy_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, mul_fn(c, b)), n) = c * partial(cauchy_seq(a, b), n)
} by {
    // Show that cauchy_seq factors out scalar multiplication
    forall(k: Nat) {
        cauchy_seq(a, mul_fn(c, b))(k) = cauchy_product(a, mul_fn(c, b), k)
        cauchy_product(a, mul_fn(c, b), k) = c * cauchy_product(a, b, k)
        cauchy_seq(a, b)(k) = cauchy_product(a, b, k)
        cauchy_seq(a, mul_fn(c, b))(k) = c * cauchy_seq(a, b)(k)
        mul_fn(c, cauchy_seq(a, b))(k) = c * cauchy_seq(a, b)(k)
    }

    // Therefore the sequences are equal
    cauchy_seq(a, mul_fn(c, b)) = mul_fn(c, cauchy_seq(a, b))

    // Use partial_scalar_mul to factor out the constant
    partial(cauchy_seq(a, mul_fn(c, b)), n) = partial(mul_fn(c, cauchy_seq(a, b)), n)
    partial(mul_fn(c, cauchy_seq(a, b)), n) = c * partial(cauchy_seq(a, b), n)
}

// ============================================================================
// Absolute Convergence Infrastructure
// ============================================================================

/// The absolute value of each element in a sequence.
/// For a sequence a, this returns the sequence n ↦ |a(n)|.
define abs_fn(a: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { a(n).abs }
}

/// A series converges absolutely if the series of absolute values converges.
define absolutely_converges(a: Nat -> Real) -> Bool {
    converges(partial(abs_fn(a)))
}

/// The absolute value of any element in the constant zero sequence is zero.
theorem abs_fn_zero(n: Nat) {
    abs_fn(constant[Nat, Real](Real.0))(n) = Real.0
} by {
    abs_fn(constant[Nat, Real](Real.0))(n) = constant[Nat, Real](Real.0)(n).abs
    constant[Nat, Real](Real.0)(n) = Real.0
    Real.0.abs = Real.0
}

/// The absolute value of any element in a sequence is nonnegative.
theorem abs_fn_nonneg(a: Nat -> Real, n: Nat) {
    abs_fn(a)(n) >= Real.0
} by {
    abs_fn(a)(n) = a(n).abs
    a(n).abs >= Real.0
}

/// Absolute value commutes with scalar multiplication (up to taking abs of scalar).
theorem abs_fn_scalar_mul(c: Real, a: Nat -> Real, n: Nat) {
    abs_fn(mul_fn(c, a))(n) = c.abs * abs_fn(a)(n)
} by {
    abs_fn(mul_fn(c, a))(n) = mul_fn(c, a)(n).abs
    mul_fn(c, a)(n) = c * a(n)
    (c * a(n)).abs = c.abs * a(n).abs
    abs_fn(a)(n) = a(n).abs
    c.abs * a(n).abs = c.abs * abs_fn(a)(n)
}

/// abs_fn is equivalent to composing with Real.abs.
theorem abs_fn_eq_compose(a: Nat -> Real, n: Nat) {
    abs_fn(a)(n) = compose(Real.abs, a)(n)
} by {
    abs_fn(a)(n) = a(n).abs
    compose(Real.abs, a)(n) = Real.abs(a(n))
    Real.abs(a(n)) = a(n).abs
}

/// Absolute convergence implies convergence (alternate formulation).
/// This connects our definition to the existing theorem in real_series.ac.
theorem absolutely_converges_imp_converges(a: Nat -> Real) {
    absolutely_converges(a) implies converges(partial(a))
} by {
    from real.real_series import abs_conv_imp_conv

    if absolutely_converges(a) {
        // By definition, absolutely_converges(a) means converges(partial(abs_fn(a)))
        converges(partial(abs_fn(a)))

        // Show that abs_fn(a) = compose(Real.abs, a)
        forall(n: Nat) {
            abs_fn(a)(n) = compose(Real.abs, a)(n)
        }
        abs_fn(a) = compose(Real.abs, a)

        // Therefore converges(partial(compose(Real.abs, a)))
        partial(abs_fn(a)) = partial(compose(Real.abs, a))
        converges(partial(compose(Real.abs, a)))

        // Apply abs_conv_imp_conv
        abs_conv_imp_conv(a)
        converges(partial(a))
    }
}

/// Absolute convergence is preserved under scalar multiplication.
theorem absolutely_converges_scalar_mul(c: Real, a: Nat -> Real) {
    absolutely_converges(a) implies absolutely_converges(mul_fn(c, a))
} by {
    from real.real_series import converges_mul_seq

    if absolutely_converges(a) {
        converges(partial(abs_fn(a)))

        // Show that abs_fn(mul_fn(c, a)) relates to abs_fn(a)
        forall(n: Nat) {
            abs_fn(mul_fn(c, a))(n) = c.abs * abs_fn(a)(n)
            mul_fn(c.abs, abs_fn(a))(n) = c.abs * abs_fn(a)(n)
        }
        abs_fn(mul_fn(c, a)) = mul_fn(c.abs, abs_fn(a))

        // Therefore partial(abs_fn(mul_fn(c, a))) = c.abs * partial(abs_fn(a))
        partial(abs_fn(mul_fn(c, a))) = partial(mul_fn(c.abs, abs_fn(a)))
        partial(mul_fn(c.abs, abs_fn(a))) = mul_fn(c.abs, partial(abs_fn(a)))

        // Show that mul_fn and mul_seq are equal for our purposes
        forall(n: Nat) {
            mul_fn(c.abs, partial(abs_fn(a)))(n) = c.abs * partial(abs_fn(a))(n)
            mul_seq(c.abs, partial(abs_fn(a)))(n) = c.abs * partial(abs_fn(a))(n)
        }
        mul_fn(c.abs, partial(abs_fn(a))) = mul_seq(c.abs, partial(abs_fn(a)))

        // If partial(abs_fn(a)) converges, so does c.abs * partial(abs_fn(a))
        converges_mul_seq(c.abs, partial(abs_fn(a)))
        converges(mul_seq(c.abs, partial(abs_fn(a))))
        converges(mul_fn(c.abs, partial(abs_fn(a))))
        converges(partial(abs_fn(mul_fn(c, a))))
        absolutely_converges(mul_fn(c, a))
    }
}

/// Absolute convergence is preserved under addition of sequences.
theorem absolutely_converges_add(a: Nat -> Real, b: Nat -> Real) {
    absolutely_converges(a) and absolutely_converges(b)
    implies
    absolutely_converges(add_fn(a, b))
} by {
    from real.real_series import add_seq_converges, comparison_test

    if absolutely_converges(a) and absolutely_converges(b) {
        converges(partial(abs_fn(a)))
        converges(partial(abs_fn(b)))

        // For all n: |a(n) + b(n)| <= |a(n)| + |b(n)| by triangle inequality
        forall(n: Nat) {
            (a(n) + b(n)).abs <= a(n).abs + b(n).abs
            add_fn(a, b)(n) = a(n) + b(n)
            abs_fn(add_fn(a, b))(n) = add_fn(a, b)(n).abs
            abs_fn(add_fn(a, b))(n) <= a(n).abs + b(n).abs
            abs_fn(add_fn(a, b))(n) <= abs_fn(a)(n) + abs_fn(b)(n)
            abs_fn(add_fn(a, b))(n) <= add_fn(abs_fn(a), abs_fn(b))(n)
        }

        // Therefore seq_lte holds
        seq_lte(abs_fn(add_fn(a, b)), add_fn(abs_fn(a), abs_fn(b)))

        // abs_fn always produces nonnegative values
        forall(n: Nat) {
            abs_fn(add_fn(a, b))(n) >= Real.0
        }
        is_lower_bound(abs_fn(add_fn(a, b)), Real.0)

        // add_fn distributes over partial
        partial(add_fn(abs_fn(a), abs_fn(b))) = add_fn(partial(abs_fn(a)), partial(abs_fn(b)))

        // Show that add_fn and add_seq are equal for our purposes
        forall(n: Nat) {
            add_fn(partial(abs_fn(a)), partial(abs_fn(b)))(n) = partial(abs_fn(a))(n) + partial(abs_fn(b))(n)
            add_seq(partial(abs_fn(a)), partial(abs_fn(b)))(n) = partial(abs_fn(a))(n) + partial(abs_fn(b))(n)
        }
        add_fn(partial(abs_fn(a)), partial(abs_fn(b))) = add_seq(partial(abs_fn(a)), partial(abs_fn(b)))

        // If both converge, their sum converges
        add_seq_converges(partial(abs_fn(a)), partial(abs_fn(b)))
        converges(add_seq(partial(abs_fn(a)), partial(abs_fn(b))))
        converges(add_fn(partial(abs_fn(a)), partial(abs_fn(b))))
        converges(partial(add_fn(abs_fn(a), abs_fn(b))))

        // Apply comparison test
        comparison_test(abs_fn(add_fn(a, b)), add_fn(abs_fn(a), abs_fn(b)))
        converges(partial(abs_fn(add_fn(a, b))))
        absolutely_converges(add_fn(a, b))
    }
}

/// Tail bound for absolutely convergent series.
/// If a series converges absolutely, then tail sums can be made arbitrarily small.
/// For any ε > 0, there exists N such that for all n, m ≥ N with n ≤ m,
/// the sum of |a(k)| from k=n to k=m-1 is less than ε.
theorem abs_conv_tail_bound(a: Nat -> Real, eps: Real) {
    absolutely_converges(a) and eps.is_positive
    implies
    exists(big_n: Nat) {
        forall(n: Nat, m: Nat) {
            big_n <= n and n <= m
            implies
            partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps
        }
    }
} by {
    from real.real_seq import cauchy_bound
    from real.real_series import distant_increasing, nonneg_imp_partial_increasing, is_increasing

    if absolutely_converges(a) and eps.is_positive {
        // absolutely_converges(a) means converges(partial(abs_fn(a)))
        converges(partial(abs_fn(a)))

        // Use the Cauchy criterion to get an N
        let big_n: Nat satisfy {
            cauchy_bound(partial(abs_fn(a)), big_n, eps)
        }

        forall(n: Nat, m: Nat) {
            if big_n <= n and n <= m {
                // By Cauchy criterion, the partial sums are close
                cauchy_bound(partial(abs_fn(a)), big_n, eps)
                partial(abs_fn(a))(n).is_close(partial(abs_fn(a))(m), eps)

                // Since abs_fn is nonnegative, partial sums are increasing
                forall(k: Nat) {
                    abs_fn(a)(k) >= Real.0
                }
                is_lower_bound(abs_fn(a), Real.0)
                nonneg_imp_partial_increasing(abs_fn(a))
                is_increasing(partial(abs_fn(a)))

                // When n <= m, the partial sums satisfy this ordering
                distant_increasing(partial(abs_fn(a)), n, m)
                partial(abs_fn(a))(n) <= partial(abs_fn(a))(m)

                // is_close is symmetric, so we also have
                partial(abs_fn(a))(m).is_close(partial(abs_fn(a))(n), eps)

                // Rewrite using function application notation
                partial(abs_fn(a), n) = partial(abs_fn(a))(n)
                partial(abs_fn(a), m) = partial(abs_fn(a))(m)
                partial(abs_fn(a), m).is_close(partial(abs_fn(a), n), eps)

                // This means the absolute difference is less than eps
                (partial(abs_fn(a), m) - partial(abs_fn(a), n)).abs < eps

                // Since partial is increasing and n <= m, we know partial(abs_fn(a), n) <= partial(abs_fn(a), m)
                // Therefore the difference partial(abs_fn(a), m) - partial(abs_fn(a), n) is non-negative
                // When a difference is non-negative, x - y >= 0, then (x - y).abs = x - y
                // So (partial(abs_fn(a), m) - partial(abs_fn(a), n)).abs = partial(abs_fn(a), m) - partial(abs_fn(a), n)
                partial(abs_fn(a), n) <= partial(abs_fn(a), m)
                partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps
            }
        }
    }
}

// ============================================================================
// Cauchy Product Convergence (Mertens' Theorem)
// ============================================================================

/// Triangle inequality for sums: the absolute value of a sum is at most the sum of absolute values.
theorem sum_triangle_ineq(items: List[Real]) {
    (sum(items)).abs <= sum(map(items, Real.abs))
} by {
    from real.real_series import triangle_ineq

    // Proof by induction on list structure
    define p(xs: List[Real]) -> Bool {
        (sum(xs)).abs <= sum(map(xs, Real.abs))
    }

    // Base case: empty list
    sum(List.nil[Real]) = Real.0
    Real.0.abs = Real.0
    map(List.nil[Real], Real.abs) = List.nil[Real]
    sum(List.nil[Real]) = Real.0
    p(List.nil[Real])

    // Inductive step
    forall(head: Real, tail: List[Real]) {
        if p(tail) {
            // Assume: (sum(tail)).abs <= sum(map(tail, Real.abs))
            (sum(tail)).abs <= sum(map(tail, Real.abs))

            // Show for cons(head, tail)
            sum(List.cons(head, tail)) = head + sum(tail)
            (head + sum(tail)).abs <= head.abs + (sum(tail)).abs

            // Use inductive hypothesis
            head.abs + (sum(tail)).abs <= head.abs + sum(map(tail, Real.abs))

            // Show that right side equals sum(map(cons(head, tail), Real.abs))
            map(List.cons(head, tail), Real.abs) = List.cons(head.abs, map(tail, Real.abs))
            sum(List.cons(head.abs, map(tail, Real.abs))) = head.abs + sum(map(tail, Real.abs))

            // Combine
            (sum(List.cons(head, tail))).abs <= sum(map(List.cons(head, tail), Real.abs))
            p(List.cons(head, tail))
        }
    }

    p(items)
}

/// Pointwise less-than-or-equal for functions from Nat to Real.
define lte_fn(f: Nat -> Real, g: Nat -> Real) -> Bool {
    forall(k: Nat) { f(k) <= g(k) }
}

/// Helper: sum(map(n.range, f)) <= sum(map(n.range, g)) when f <= g pointwise.
/// Uses existing partial_seq_lte infrastructure.
theorem sum_map_range_le(n: Nat, f: Nat -> Real, g: Nat -> Real) {
    lte_fn(f, g) implies sum(map(n.range, f)) <= sum(map(n.range, g))
} by {
    from real.real_series import partial_seq_lte

    if lte_fn(f, g) {
        // lte_fn(f, g) is the same as seq_lte(f, g)
        lte_fn(f, g)
        forall(k: Nat) { f(k) <= g(k) }
        seq_lte(f, g)

        // Apply partial_seq_lte
        partial_seq_lte(f, g)
        seq_lte(partial(f), partial(g))
        forall(k: Nat) { partial(f)(k) <= partial(g)(k) }

        // partial(f, n) = sum(map(n.range, f)) by definition
        partial(f, n) = sum(map(n.range, f))
        partial(g, n) = sum(map(n.range, g))

        // Therefore
        partial(f)(n) <= partial(g)(n)
        sum(map(n.range, f)) <= sum(map(n.range, g))
    }
}

/// The absolute value of a Cauchy product coefficient is bounded by the
/// corresponding coefficient of the Cauchy product of absolute values.
theorem cauchy_coefficient_abs_bound(a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    (cauchy_coefficient(a, b, n)(k)).abs <= cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k)
} by {
    // Expand definitions
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    (a(k) * b(n - k)).abs = a(k).abs * b(n - k).abs

    // Expand the right side
    cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k) = abs_fn(a)(k) * abs_fn(b)(n - k)
    abs_fn(a)(k) = a(k).abs
    abs_fn(b)(n - k) = b(n - k).abs
    cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k) = a(k).abs * b(n - k).abs
}

/// The absolute value of the Cauchy product is bounded by the Cauchy product of absolute values.
theorem cauchy_product_abs_bound(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    (cauchy_product(a, b, n)).abs <= cauchy_product(abs_fn(a), abs_fn(b), n)
} by {
    // Expand definition of cauchy_product
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(abs_fn(a), abs_fn(b), n) = sum(map(n.suc.range, cauchy_coefficient(abs_fn(a), abs_fn(b), n)))

    // Apply triangle inequality: |sum(...)| <= sum(|...|)
    sum_triangle_ineq(map(n.suc.range, cauchy_coefficient(a, b, n)))
    (sum(map(n.suc.range, cauchy_coefficient(a, b, n)))).abs <= sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), Real.abs))

    // Use map composition
    from list.list_sum import map_map
    map_map(n.suc.range, cauchy_coefficient(a, b, n), Real.abs)
    map(map(n.suc.range, cauchy_coefficient(a, b, n)), Real.abs) = map(n.suc.range, compose(Real.abs, cauchy_coefficient(a, b, n)))

    // For each coefficient, the absolute value is bounded
    forall(k: Nat) {
        cauchy_coefficient_abs_bound(a, b, n, k)
        (cauchy_coefficient(a, b, n)(k)).abs <= cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k)
        compose(Real.abs, cauchy_coefficient(a, b, n))(k) = Real.abs(cauchy_coefficient(a, b, n)(k))
        compose(Real.abs, cauchy_coefficient(a, b, n))(k) = (cauchy_coefficient(a, b, n)(k)).abs
        compose(Real.abs, cauchy_coefficient(a, b, n))(k) <= cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k)
    }
    lte_fn(compose(Real.abs, cauchy_coefficient(a, b, n)), cauchy_coefficient(abs_fn(a), abs_fn(b), n))

    // Apply sum_map_range_le
    sum_map_range_le(n.suc, compose(Real.abs, cauchy_coefficient(a, b, n)), cauchy_coefficient(abs_fn(a), abs_fn(b), n))
    sum(map(n.suc.range, compose(Real.abs, cauchy_coefficient(a, b, n)))) <= sum(map(n.suc.range, cauchy_coefficient(abs_fn(a), abs_fn(b), n)))

    // Combine by transitivity
    (cauchy_product(a, b, n)).abs <= cauchy_product(abs_fn(a), abs_fn(b), n)
}

/// Partial sum at index 0 is 0.
theorem partial_zero[A: AddCommMonoid](f: Nat -> A) {
    partial(f, Nat.0) = A.0
} by {
    partial(f, Nat.0) = sum(map(Nat.0.range, f))
    Nat.0.range = List.nil[Nat]
    map(List.nil[Nat], f) = List.nil[A]
    sum(List.nil[A]) = A.0
}

/// Partial sums of nonnegative sequences are nonnegative.
theorem partial_nonneg(f: Nat -> Real, n: Nat) {
    is_lower_bound(f, Real.0) implies partial(f, n) >= Real.0
} by {
    from list.list_sum import map_add, sum_add

    define p(m: Nat) -> Bool {
        is_lower_bound(f, Real.0) implies partial(f, m) >= Real.0
    }

    // Base case: n = 0
    if is_lower_bound(f, Real.0) {
        partial_zero(f)
        partial(f, Nat.0) = Real.0
        partial(f, Nat.0) >= Real.0
    }
    p(Nat.0)

    // Inductive step
    forall(m: Nat) {
        if p(m) {
            if is_lower_bound(f, Real.0) {
                // By IH
                p(m)
                partial(f, m) >= Real.0

                // Show f(m) >= 0
                is_lower_bound(f, Real.0)
                f(m) >= Real.0

                // Expand partial(f, m.suc)
                m.suc.range = m.range + List.singleton(m)
                map_add(m.range, List.singleton(m), f)
                map(m.suc.range, f) = map(m.range, f) + List.singleton(f(m))
                sum_add(map(m.range, f), List.singleton(f(m)))
                sum(map(m.suc.range, f)) = sum(map(m.range, f)) + f(m)
                partial(f, m.suc) = sum(map(m.suc.range, f))
                partial(f, m) = sum(map(m.range, f))
                partial(f, m.suc) = partial(f, m) + f(m)

                // Both terms are nonnegative, so the sum is nonnegative
                // partial(f, m) >= 0, so partial(f, m) + f(m) >= 0 + f(m) = f(m) >= 0
                lte_add_right(Real.0, partial(f, m), f(m))
                Real.0 + f(m) <= partial(f, m) + f(m)
                Real.0 + f(m) = f(m)
                f(m) <= partial(f, m) + f(m)
                Real.0 <= f(m)
                Real.0 <= partial(f, m) + f(m)
                partial(f, m.suc) >= Real.0
            }
            p(m.suc)
        }
    }

    p(n)
}

/// Product of nonnegative numbers is nonnegative.
theorem mul_nonneg(a: Real, b: Real) {
    a >= Real.0 and b >= Real.0 implies a * b >= Real.0
} by {
    if a >= Real.0 and b >= Real.0 {
        // Case 1: a = 0
        if a = Real.0 {
            a * b = Real.0 * b
            Real.0 * b = Real.0
            a * b = Real.0
            a * b >= Real.0
        }

        // Case 2: b = 0
        if b = Real.0 {
            a * b = a * Real.0
            a * Real.0 = Real.0
            a * b = Real.0
            a * b >= Real.0
        }

        // Case 3: a > 0 and b > 0
        if a > Real.0 and b > Real.0 {
            from real.real_ring import mul_pos_pos
            mul_pos_pos(a, b)
            (a * b).is_positive
            a * b > Real.0
            a * b >= Real.0
        }

        // At least one of these cases holds
        a * b >= Real.0
    }
}

/// Scalar multiplication on the right of a partial sum.
theorem partial_mul_scalar_right(a: Nat -> Real, b: Real, n: Nat) {
    partial(a, n) * b = sum(map(n.range, mul_fn(b, a)))
} by {
    from list.list_sum import partial_scalar_mul

    // Use commutativity to swap the order
    partial(a, n) * b = b * partial(a, n)

    // Apply the left scalar multiplication theorem
    partial_scalar_mul(b, a, n)
    b * partial(a, n) = partial(mul_fn(b, a), n)

    // Expand the definition of partial
    partial(mul_fn(b, a), n) = sum(map(n.range, mul_fn(b, a)))

    partial(a, n) * b = sum(map(n.range, mul_fn(b, a)))
}

/// Helper: compute the sum of row i in a double sum.
/// This avoids nested lambdas by making all parameters explicit.
define row_sum(m: Nat, f: (Nat, Nat) -> Real, i: Nat) -> Real {
    sum(map(m.range, f(i)))
}

/// Helper: get the value at column j for row i.
/// This extracts f(i, j) in a way that can be partially applied.
define col_val(f: (Nat, Nat) -> Real, j: Nat, i: Nat) -> Real {
    f(i, j)
}

/// Double sum: sum over pairs (i, j) where i ∈ [0, n) and j ∈ [0, m).
/// This computes ∑_{i=0}^{n-1} ∑_{j=0}^{m-1} f(i, j).
/// Using a named helper function instead of nested lambdas to help Acorn's normalizer.
define double_sum(n: Nat, m: Nat, f: (Nat, Nat) -> Real) -> Real {
    sum(map(n.range, row_sum(m, f)))
}

/// Test: Can we just expand the double_sum definition?
/// This should be trivially true since it's literally the definition.
theorem double_sum_expands(n: Nat, m: Nat, f: (Nat, Nat) -> Real) {
    double_sum(n, m, f) = sum(map(n.range, row_sum(m, f)))
} by {
    // This is literally just the definition
}

/// Expanding double_sum by adding a column: when we increment the column count,
/// we get the old double_sum plus the sum over the new column.
theorem double_sum_col_expand(n: Nat, m: Nat, f: (Nat, Nat) -> Real) {
    double_sum(n, m.suc, f) = double_sum(n, m, f) + sum(map(n.range, col_val(f, m)))
} by {
    from list.list_sum import map_add, sum_add

    // For each i, row_sum(m.suc, f, i) = row_sum(m, f, i) + f(i, m)
    forall(i: Nat) {
        m.suc.range = m.range + List.singleton(m)
        map_add(m.range, List.singleton(m), f(i))
        sum_add(map(m.range, f(i)), List.singleton(f(i, m)))
        row_sum(m.suc, f, i) = row_sum(m, f, i) + f(i, m)
    }

    // Apply map_sum_add
    map_sum_add(n.range, row_sum(m, f), col_val(f, m))
    sum(map(n.range, row_sum(m, f))) + sum(map(n.range, col_val(f, m))) = sum(map(n.range, add_fn(row_sum(m, f), col_val(f, m))))

    // Connect add_fn to row_sum(m.suc)
    forall(i: Nat) {
        add_fn(row_sum(m, f), col_val(f, m))(i) = row_sum(m, f, i) + col_val(f, m, i)
        col_val(f, m, i) = f(i, m)
        add_fn(row_sum(m, f), col_val(f, m))(i) = row_sum(m, f, i) + f(i, m)
        add_fn(row_sum(m, f), col_val(f, m))(i) = row_sum(m.suc, f, i)
    }

    sum(map(n.range, add_fn(row_sum(m, f), col_val(f, m)))) = sum(map(n.range, row_sum(m.suc, f)))

    double_sum(n, m.suc, f) = double_sum(n, m, f) + sum(map(n.range, col_val(f, m)))
}

/// Helper: get the value at row i for column j.
/// This extracts f(i, j) as a function of j for a fixed i.
define row_val(f: (Nat, Nat) -> Real, i: Nat) -> (Nat -> Real) {
    function(j: Nat) { f(i, j) }
}

/// Expanding double_sum by adding a row: when we increment the row count,
/// we get the old double_sum plus the sum over the new row.
theorem double_sum_row_expand(n: Nat, m: Nat, f: (Nat, Nat) -> Real) {
    double_sum(n.suc, m, f) = double_sum(n, m, f) + sum(map(m.range, row_val(f, n)))
} by {
    from list.list_sum import map_add, sum_add

    // Expand the definition of double_sum
    double_sum(n.suc, m, f) = sum(map(n.suc.range, row_sum(m, f)))
    double_sum(n, m, f) = sum(map(n.range, row_sum(m, f)))

    // Expand n.suc.range
    n.suc.range = n.range + List.singleton(n)
    map_add(n.range, List.singleton(n), row_sum(m, f))
    map(n.suc.range, row_sum(m, f)) = map(n.range, row_sum(m, f)) + map(List.singleton(n), row_sum(m, f))

    // Evaluate map on singleton
    map(List.singleton(n), row_sum(m, f)) = List.singleton(row_sum(m, f, n))
    row_sum(m, f, n) = sum(map(m.range, f(n)))

    // Show that f(n) = row_val(f, n)
    forall(j: Nat) {
        f(n)(j) = f(n, j)
        row_val(f, n)(j) = f(n, j)
    }
    f(n) = row_val(f, n)
    row_sum(m, f, n) = sum(map(m.range, row_val(f, n)))

    // Combine using sum_add
    map(n.suc.range, row_sum(m, f)) = map(n.range, row_sum(m, f)) + List.singleton(sum(map(m.range, row_val(f, n))))
    sum_add(map(n.range, row_sum(m, f)), List.singleton(sum(map(m.range, row_val(f, n)))))
    sum(map(n.suc.range, row_sum(m, f))) = sum(map(n.range, row_sum(m, f))) + sum(map(m.range, row_val(f, n)))

    double_sum(n.suc, m, f) = double_sum(n, m, f) + sum(map(m.range, row_val(f, n)))
}

/// Helper: scalar multiplication distributes into a sum.
/// For a constant c: c * ∑ᵢ b(i) = ∑ᵢ (c * b(i))
theorem scalar_mul_sum(c: Real, b: Nat -> Real, n: Nat) {
    c * sum(map(n.range, b)) = sum(map(n.range, mul_fn(c, b)))
} by {
    // Use commutativity and existing infrastructure
    sum(map(n.range, b)) = partial(b, n)
    c * sum(map(n.range, b)) = c * partial(b, n)

    // Apply partial_mul_scalar_right
    partial_mul_scalar_right(b, c, n)
    partial(b, n) * c = sum(map(n.range, mul_fn(c, b)))
    c * partial(b, n) = partial(b, n) * c
    c * partial(b, n) = sum(map(n.range, mul_fn(c, b)))

    c * sum(map(n.range, b)) = sum(map(n.range, mul_fn(c, b)))
}

/// Helper: product function for double sums.
define prod_fn(a: Nat -> Real, b: Nat -> Real) -> ((Nat, Nat) -> Real) {
    function(i: Nat, j: Nat) { a(i) * b(j) }
}

/// Product of two partial sums equals a double sum over the product.
/// This is the key lemma for expanding (∑aᵢ)(∑bⱼ) into ∑ᵢ∑ⱼ aᵢbⱼ.
theorem partial_product_as_double_sum(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(a, n) * partial(b, n) = double_sum(n, n, prod_fn(a, b))
} by {
    from list.list_sum import map_add, sum_add

    define p(m: Nat) -> Bool {
        partial(a, m) * partial(b, m) = double_sum(m, m, prod_fn(a, b))
    }

    // Base case: m = 0
    partial_zero(a)
    partial(a, Nat.0) = Real.0
    partial_zero(b)
    partial(b, Nat.0) = Real.0
    partial(a, Nat.0) * partial(b, Nat.0) = Real.0 * Real.0
    Real.0 * Real.0 = Real.0
    partial(a, Nat.0) * partial(b, Nat.0) = Real.0

    // double_sum(0, 0, ...) = sum(map(0.range, ...)) = sum(nil) = 0
    Nat.0.range = List.nil[Nat]
    double_sum_expands(Nat.0, Nat.0, prod_fn(a, b))
    double_sum(Nat.0, Nat.0, prod_fn(a, b)) = sum(map(Nat.0.range, row_sum(Nat.0, prod_fn(a, b))))
    map(Nat.0.range, row_sum(Nat.0, prod_fn(a, b))) = List.nil[Real]
    sum(List.nil[Real]) = Real.0
    double_sum(Nat.0, Nat.0, prod_fn(a, b)) = Real.0

    // Combine to show p(Nat.0)
    partial(a, Nat.0) * partial(b, Nat.0) = double_sum(Nat.0, Nat.0, prod_fn(a, b))
    p(Nat.0)

    // Inductive step: if p(m), then p(m.suc)
    forall(m: Nat) {
        if p(m) {
            // Induction hypothesis
            p(m)
            partial(a, m) * partial(b, m) = double_sum(m, m, prod_fn(a, b))

            // Expand partial(a, m.suc)
            m.suc.range = m.range + List.singleton(m)
            map_add(m.range, List.singleton(m), a)
            map(m.suc.range, a) = map(m.range, a) + List.singleton(a(m))
            sum_add(map(m.range, a), List.singleton(a(m)))
            sum(map(m.suc.range, a)) = sum(map(m.range, a)) + a(m)
            partial(a, m.suc) = partial(a, m) + a(m)

            // Expand partial(b, m.suc)
            map_add(m.range, List.singleton(m), b)
            map(m.suc.range, b) = map(m.range, b) + List.singleton(b(m))
            sum_add(map(m.range, b), List.singleton(b(m)))
            sum(map(m.suc.range, b)) = sum(map(m.range, b)) + b(m)
            partial(b, m.suc) = partial(b, m) + b(m)

            // Expand the product
            partial(a, m.suc) * partial(b, m.suc) = (partial(a, m) + a(m)) * (partial(b, m) + b(m))
            (partial(a, m) + a(m)) * (partial(b, m) + b(m)) = partial(a, m) * partial(b, m) + partial(a, m) * b(m) + a(m) * partial(b, m) + a(m) * b(m)

            // Apply IH to first term
            partial(a, m.suc) * partial(b, m.suc) = double_sum(m, m, prod_fn(a, b)) + partial(a, m) * b(m) + a(m) * partial(b, m) + a(m) * b(m)

            // Expand partial(a, m) * b(m) = sum over i in [0,m) of a(i) * b(m)
            scalar_mul_sum(b(m), a, m)
            b(m) * sum(map(m.range, a)) = sum(map(m.range, mul_fn(b(m), a)))
            forall(i: Nat) {
                mul_fn(b(m), a)(i) = b(m) * a(i)
                b(m) * a(i) = a(i) * b(m)
            }
            sum(map(m.range, a)) * b(m) = b(m) * sum(map(m.range, a))
            sum(map(m.range, a)) * b(m) = sum(map(m.range, mul_fn(b(m), a)))
            partial(a, m) * b(m) = sum(map(m.range, mul_fn(b(m), a)))

            // Similarly: a(m) * partial(b, m) = sum over j in [0,m) of a(m) * b(j)
            scalar_mul_sum(a(m), b, m)
            a(m) * sum(map(m.range, b)) = sum(map(m.range, mul_fn(a(m), b)))
            a(m) * partial(b, m) = sum(map(m.range, mul_fn(a(m), b)))

            // Now expand double_sum(m.suc, m.suc, ...) using row and column expansion
            double_sum_row_expand(m, m.suc, prod_fn(a, b))
            double_sum(m.suc, m.suc, prod_fn(a, b)) = double_sum(m, m.suc, prod_fn(a, b)) + sum(map(m.suc.range, row_val(prod_fn(a, b), m)))

            double_sum_col_expand(m, m, prod_fn(a, b))
            double_sum(m, m.suc, prod_fn(a, b)) = double_sum(m, m, prod_fn(a, b)) + sum(map(m.range, col_val(prod_fn(a, b), m)))

            // Combine the expansions
            double_sum(m.suc, m.suc, prod_fn(a, b)) = double_sum(m, m, prod_fn(a, b)) + sum(map(m.range, col_val(prod_fn(a, b), m))) + sum(map(m.suc.range, row_val(prod_fn(a, b), m)))

            // Expand sum(map(m.suc.range, row_val(..., m)))
            m.suc.range = m.range + List.singleton(m)
            map_add(m.range, List.singleton(m), row_val(prod_fn(a, b), m))
            map(m.suc.range, row_val(prod_fn(a, b), m)) = map(m.range, row_val(prod_fn(a, b), m)) + List.singleton(row_val(prod_fn(a, b), m)(m))
            sum_add(map(m.range, row_val(prod_fn(a, b), m)), List.singleton(row_val(prod_fn(a, b), m)(m)))
            sum(map(m.suc.range, row_val(prod_fn(a, b), m))) = sum(map(m.range, row_val(prod_fn(a, b), m))) + row_val(prod_fn(a, b), m)(m)

            // Evaluate row_val(..., m)(m)
            row_val(prod_fn(a, b), m)(m) = prod_fn(a, b)(m, m)
            prod_fn(a, b)(m, m) = a(m) * b(m)

            double_sum(m.suc, m.suc, prod_fn(a, b)) = double_sum(m, m, prod_fn(a, b)) + sum(map(m.range, col_val(prod_fn(a, b), m))) + sum(map(m.range, row_val(prod_fn(a, b), m))) + a(m) * b(m)

            // Show col_val(..., m)(idx) = a(idx) * b(m) = mul_fn(b(m), a)(idx)
            forall(idx: Nat) {
                col_val(prod_fn(a, b), m)(idx) = prod_fn(a, b)(idx, m)
                prod_fn(a, b)(idx, m) = a(idx) * b(m)
                mul_fn(b(m), a)(idx) = b(m) * a(idx)
                b(m) * a(idx) = a(idx) * b(m)
                col_val(prod_fn(a, b), m)(idx) = mul_fn(b(m), a)(idx)
            }
            col_val(prod_fn(a, b), m) = mul_fn(b(m), a)
            sum(map(m.range, col_val(prod_fn(a, b), m))) = sum(map(m.range, mul_fn(b(m), a)))

            // Show row_val(..., m)(idx) = a(m) * b(idx) = mul_fn(a(m), b)(idx)
            forall(idx: Nat) {
                row_val(prod_fn(a, b), m)(idx) = prod_fn(a, b)(m, idx)
                prod_fn(a, b)(m, idx) = a(m) * b(idx)
                mul_fn(a(m), b)(idx) = a(m) * b(idx)
                row_val(prod_fn(a, b), m)(idx) = mul_fn(a(m), b)(idx)
            }
            row_val(prod_fn(a, b), m) = mul_fn(a(m), b)
            sum(map(m.range, row_val(prod_fn(a, b), m))) = sum(map(m.range, mul_fn(a(m), b)))

            // Combine
            double_sum(m.suc, m.suc, prod_fn(a, b)) = double_sum(m, m, prod_fn(a, b)) + sum(map(m.range, mul_fn(b(m), a))) + sum(map(m.range, mul_fn(a(m), b))) + a(m) * b(m)
            double_sum(m.suc, m.suc, prod_fn(a, b)) = double_sum(m, m, prod_fn(a, b)) + partial(a, m) * b(m) + a(m) * partial(b, m) + a(m) * b(m)
            partial(a, m.suc) * partial(b, m.suc) = double_sum(m.suc, m.suc, prod_fn(a, b))

            // This shows p(m.suc)
            p(m.suc)
        }
    }

    p(n)
}

/// Helper: indicator function for whether a pair (i,j) appears in Cauchy product up to n.
/// Returns 1 if i + j < n, otherwise 0.
define cauchy_indicator(n: Nat, i: Nat, j: Nat) -> Real {
    if i + j < n { Real.1 } else { Real.0 }
}

// ============================================================================
// Foundation Lemmas for Cauchy Product Convergence
// ============================================================================

/// Multiplication is monotone for nonnegative reals.
/// If a ≤ c and b ≤ d with all nonnegative, then a*b ≤ c*d.
theorem mul_le_mul_nonneg(a: Real, b: Real, c: Real, d: Real) {
    a >= Real.0 and b >= Real.0 and c >= Real.0 and d >= Real.0 and a <= c and b <= d
    implies
    a * b <= c * d
} by {
    from real.real_ring import lte_mul_nonneg_right, lte_mul_nonneg_left

    if a >= Real.0 and b >= Real.0 and c >= Real.0 and d >= Real.0 and a <= c and b <= d {
        // Strategy: a*b <= c*b <= c*d by transitivity

        // Step 1: a*b <= c*b (using a <= c and b >= 0)
        not b.is_negative
        lte_mul_nonneg_right(a, c, b)
        a * b <= c * b

        // Step 2: c*b <= c*d (using b <= d and c >= 0)
        not c.is_negative
        lte_mul_nonneg_left(b, d, c)
        c * b <= c * d

        // Step 3: By transitivity
        a * b <= c * d
    }
}

/// Partial sums are monotone for nonnegative sequences.
/// For nonnegative sequences, partial(a, n) <= partial(a, n.suc).
theorem partial_monotone(a: Nat -> Real, n: Nat) {
    is_lower_bound(a, Real.0) implies partial(a, n) <= partial(a, n.suc)
} by {
    from real.real_series import nonneg_imp_partial_increasing, is_increasing

    if is_lower_bound(a, Real.0) {
        // Use existing theorem that partial sums of nonnegative sequences are increasing
        nonneg_imp_partial_increasing(a)
        is_increasing(partial(a))

        // is_increasing means for all m, partial(a)(m) <= partial(a)(m.suc)
        partial(a)(n) <= partial(a)(n.suc)

        // Rewrite using function application notation
        partial(a, n) = partial(a)(n)
        partial(a, n.suc) = partial(a)(n.suc)
        partial(a, n) <= partial(a, n.suc)
    }
}

/// Helper: Adding a nonnegative term doesn't decrease a sum.
theorem add_nonneg_preserves_lte(x: Real, y: Real) {
    y >= Real.0 implies x <= x + y
} by {
    if y >= Real.0 {
        x = x + Real.0
        x + Real.0 <= x + y
        x <= x + y
    }
}

/// Helper: Extending a double sum row-wise with nonnegative terms doesn't decrease the sum.
theorem double_sum_row_monotone(n: Nat, m: Nat, f: (Nat, Nat) -> Real) {
    (forall(i: Nat, j: Nat) { f(i, j) >= Real.0 })
    implies
    double_sum(n, m, f) <= double_sum(n.suc, m, f)
} by {
    from real.real_series import nonneg_imp_partial_increasing, distant_increasing, is_increasing

    if forall(i: Nat, j: Nat) { f(i, j) >= Real.0 } {
        // Use double_sum_row_expand
        double_sum_row_expand(n, m, f)
        double_sum(n.suc, m, f) = double_sum(n, m, f) + sum(map(m.range, row_val(f, n)))

        // The added row terms are nonnegative
        forall(j: Nat) {
            row_val(f, n)(j) = f(n, j)
            f(n, j) >= Real.0
            row_val(f, n)(j) >= Real.0
        }

        // Therefore row_val(f, n) is lower bounded by 0
        is_lower_bound(row_val(f, n), Real.0)

        // Sum of nonnegative terms is nonnegative
        nonneg_imp_partial_increasing(row_val(f, n))
        is_increasing(partial(row_val(f, n)))

        // partial(row_val(f, n), Nat.0) = Real.0
        partial(row_val(f, n), Nat.0) = Real.0

        // By distant_increasing: partial(..., Nat.0) <= partial(..., m)
        Nat.0 <= m
        distant_increasing(partial(row_val(f, n)), Nat.0, m)
        partial(row_val(f, n), Nat.0) <= partial(row_val(f, n), m)
        Real.0 <= partial(row_val(f, n), m)

        // sum(map(m.range, row_val(f, n))) = partial(row_val(f, n), m)
        partial(row_val(f, n), m) = sum(map(m.range, row_val(f, n)))
        sum(map(m.range, row_val(f, n))) >= Real.0

        // Therefore adding it preserves <=
        add_nonneg_preserves_lte(double_sum(n, m, f), sum(map(m.range, row_val(f, n))))
        double_sum(n, m, f) <= double_sum(n, m, f) + sum(map(m.range, row_val(f, n)))
        double_sum(n, m, f) <= double_sum(n.suc, m, f)
    }
}

/// Helper: Extending a double sum column-wise with nonnegative terms doesn't decrease the sum.
theorem double_sum_col_monotone(n: Nat, m: Nat, f: (Nat, Nat) -> Real) {
    (forall(i: Nat, j: Nat) { f(i, j) >= Real.0 })
    implies
    double_sum(n, m, f) <= double_sum(n, m.suc, f)
} by {
    from real.real_series import nonneg_imp_partial_increasing, distant_increasing, is_increasing

    if forall(i: Nat, j: Nat) { f(i, j) >= Real.0 } {
        // Use double_sum_col_expand
        double_sum_col_expand(n, m, f)
        double_sum(n, m.suc, f) = double_sum(n, m, f) + sum(map(n.range, col_val(f, m)))

        // The added column terms are nonnegative
        forall(i: Nat) {
            col_val(f, m)(i) = f(i, m)
            f(i, m) >= Real.0
            col_val(f, m)(i) >= Real.0
        }

        // Therefore col_val(f, m) is lower bounded by 0
        is_lower_bound(col_val(f, m), Real.0)

        // Sum of nonnegative terms is nonnegative
        nonneg_imp_partial_increasing(col_val(f, m))
        is_increasing(partial(col_val(f, m)))

        // partial(col_val(f, m), Nat.0) = Real.0
        partial(col_val(f, m), Nat.0) = Real.0

        // By distant_increasing: partial(..., Nat.0) <= partial(..., n)
        Nat.0 <= n
        distant_increasing(partial(col_val(f, m)), Nat.0, n)
        partial(col_val(f, m), Nat.0) <= partial(col_val(f, m), n)
        Real.0 <= partial(col_val(f, m), n)

        // sum(map(n.range, col_val(f, m))) = partial(col_val(f, m), n)
        partial(col_val(f, m), n) = sum(map(n.range, col_val(f, m)))
        sum(map(n.range, col_val(f, m))) >= Real.0

        // Therefore adding it preserves <=
        add_nonneg_preserves_lte(double_sum(n, m, f), sum(map(n.range, col_val(f, m))))
        double_sum(n, m, f) <= double_sum(n, m, f) + sum(map(n.range, col_val(f, m)))
        double_sum(n, m, f) <= double_sum(n, m.suc, f)
    }
}

/// Helper: Indicator for diagonal elements in a double sum.
/// Returns 1 if i + j = m, otherwise 0.
define diagonal_indicator(m: Nat, i: Nat, j: Nat) -> Real {
    if i + j = m { Real.1 } else { Real.0 }
}

/// Helper: Each term in cauchy_coefficient is equal to a specific product term.
theorem cauchy_term_equals_prod(a: Nat -> Real, b: Nat -> Real, m: Nat, k: Nat) {
    k <= m implies cauchy_coefficient(a, b, m)(k) = a(k) * b(m - k)
} by {
    if k <= m {
        cauchy_coefficient(a, b, m)(k) = a(k) * b(m - k)
    }
}

/// Helper: All cauchy_coefficient terms are nonnegative when a and b are nonnegative.
theorem cauchy_coefficient_nonneg(a: Nat -> Real, b: Nat -> Real, m: Nat, k: Nat) {
    is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
    implies
    cauchy_coefficient(a, b, m)(k) >= Real.0
} by {
    if is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0) {
        cauchy_coefficient(a, b, m)(k) = a(k) * b(m - k)
        a(k) >= Real.0
        b(m - k) >= Real.0
        a(k) * b(m - k) >= Real.0
        cauchy_coefficient(a, b, m)(k) >= Real.0
    }
}

// ============================================================================
// Conditional Sum Infrastructure for Subset Sum Inequalities
// ============================================================================

/// Helper: decompose a sum into two parts based on a predicate.
/// The first part sums f(x) where pred(x) is true, the second where pred(x) is false.
define cond_part(f: Nat -> Real, pred: Nat -> Bool, x: Nat) -> Real {
    if pred(x) { f(x) } else { Real.0 }
}

define comp_part(f: Nat -> Real, pred: Nat -> Bool, x: Nat) -> Real {
    if pred(x) { Real.0 } else { f(x) }
}

/// For nonnegative f, conditional sum is bounded by full sum (single variable case).
///
/// This is the key lemma for subset sum inequalities: if we sum f only where
/// a predicate is true, the result is at most the full sum of f.
theorem sum_cond_le_sum_1d(f: Nat -> Real, pred: Nat -> Bool, n: Nat) {
    (forall(x: Nat) { f(x) >= Real.0 })
    implies
    sum(map(n.range, cond_part(f, pred))) <= sum(map(n.range, f))
} by {
    from real.real_series import nonneg_imp_partial_increasing, is_increasing, distant_increasing
    from real.real_base import lte_trans_eq

    if forall(x: Nat) { f(x) >= Real.0 } {
        // Strategy: Decompose f = cond_part + comp_part, show comp_part >= 0,
        // then cond_part <= cond_part + comp_part = f

        // Show decomposition: f(x) = cond_part(f, pred, x) + comp_part(f, pred, x)
        forall(x: Nat) {
            if pred(x) {
                cond_part(f, pred, x) = f(x)
                comp_part(f, pred, x) = Real.0
                cond_part(f, pred, x) + comp_part(f, pred, x) = f(x) + Real.0
                f(x) + Real.0 = f(x)
                add_fn(cond_part(f, pred), comp_part(f, pred))(x) = f(x)
            } else {
                cond_part(f, pred, x) = Real.0
                comp_part(f, pred, x) = f(x)
                cond_part(f, pred, x) + comp_part(f, pred, x) = Real.0 + f(x)
                Real.0 + f(x) = f(x)
                add_fn(cond_part(f, pred), comp_part(f, pred))(x) = f(x)
            }
        }

        // Apply map_sum_add to lift decomposition to sums
        map_sum_add(n.range, cond_part(f, pred), comp_part(f, pred))
        let sum_cond = sum(map(n.range, cond_part(f, pred)))
        let sum_comp = sum(map(n.range, comp_part(f, pred)))
        sum_cond + sum_comp = sum(map(n.range, add_fn(cond_part(f, pred), comp_part(f, pred))))
        sum(map(n.range, add_fn(cond_part(f, pred), comp_part(f, pred)))) = sum(map(n.range, f))
        sum_cond + sum_comp = sum(map(n.range, f))

        // Show comp_part is nonnegative
        forall(x: Nat) {
            if pred(x) {
                comp_part(f, pred, x) = Real.0
                comp_part(f, pred, x) >= Real.0
            } else {
                comp_part(f, pred, x) = f(x)
                f(x) >= Real.0
                comp_part(f, pred, x) >= Real.0
            }
        }

        // Therefore sum_comp >= 0
        nonneg_imp_partial_increasing(comp_part(f, pred))
        is_increasing(partial(comp_part(f, pred)))
        partial(comp_part(f, pred), Nat.0) = Real.0
        Nat.0 <= n
        distant_increasing(partial(comp_part(f, pred)), Nat.0, n)
        partial(comp_part(f, pred), Nat.0) <= partial(comp_part(f, pred), n)
        Real.0 <= partial(comp_part(f, pred), n)
        sum_comp = partial(comp_part(f, pred), n)
        sum_comp >= Real.0

        // Final step: sum_cond <= sum_cond + sum_comp = sum(f), therefore sum_cond <= sum(f)
        add_nonneg_preserves_lte(sum_cond, sum_comp)
        sum_cond <= sum_cond + sum_comp

        // We have: sum_cond + sum_comp = sum(f)
        let sum_f = sum(map(n.range, f))
        sum_cond + sum_comp = sum_f

        // Apply transitivity: sum_cond <= sum_cond + sum_comp and sum_cond + sum_comp = sum_f
        lte_trans_eq(sum_cond, sum_cond + sum_comp, sum_f)
        sum_cond <= sum_f

        // Therefore
        sum(map(n.range, cond_part(f, pred))) <= sum(map(n.range, f))
    }
}

/// Helper: Conditional product for diagonal elements.
/// Returns a(i)*b(j) if i+j=m, otherwise 0.
define diag_cond_prod(a: Nat -> Real, b: Nat -> Real, m: Nat, i: Nat, j: Nat) -> Real {
    if i + j = m { a(i) * b(j) } else { Real.0 }
}

/// Helper: For a fixed row i, the conditional product in column j.
define row_cond_prod(a: Nat -> Real, b: Nat -> Real, m: Nat, i: Nat) -> (Nat -> Real) {
    function(j: Nat) { diag_cond_prod(a, b, m, i, j) }
}

/// Helper: For a fixed row i and diagonal m, sum over columns conditionally.
/// This computes sum_{j: i+j=m} a(i)*b(j), which is just a(i)*b(m-i) when i <= m.
define diag_row_contrib(a: Nat -> Real, b: Nat -> Real, m: Nat, i: Nat) -> Real {
    sum(map(m.suc.range, function(j: Nat) { diag_cond_prod(a, b, m, i, j) }))
}

/// Helper: Partial sum of constant zero function is zero.
theorem partial_all_zeros(g: Nat -> Real, m: Nat) {
    (forall(j: Nat) { j < m implies g(j) = Real.0 })
    implies
    partial(g, m) = Real.0
} by {
    define p(k: Nat) -> Bool {
        (forall(j: Nat) { j < k implies g(j) = Real.0 })
        implies
        partial(g, k) = Real.0
    }

    // Base case
    partial(g, Nat.0) = Real.0
    p(Nat.0)

    // Inductive step
    forall(k: Nat) {
        if p(k) {
            if forall(j: Nat) { j < k.suc implies g(j) = Real.0 } {
                // g(j) = 0 for all j < k
                forall(j: Nat) {
                    if j < k {
                        j < k.suc
                        g(j) = Real.0
                    }
                }

                // By IH: partial(g, k) = 0
                p(k)
                partial(g, k) = Real.0

                // Also g(k) = 0
                k < k.suc
                g(k) = Real.0

                // Therefore partial(g, k.suc) = 0 + 0 = 0
                partial(g, k.suc) = partial(g, k) + g(k)
                partial(g, k.suc) = Real.0 + Real.0
                partial(g, k.suc) = Real.0
            }
            p(k.suc)
        }
    }

    p(m)
}

/// Helper lemma: Sum of a function that equals a constant at one index and zero elsewhere.
/// If g(j) = c when j = k, and g(j) = 0 otherwise, then sum(g, n) = c (when k < n).
theorem sum_singleton(g: Nat -> Real, c: Real, k: Nat, n: Nat) {
    k < n and
    g(k) = c and
    (forall(j: Nat) { j < n and j != k implies g(j) = Real.0 })
    implies
    partial(g, n) = c
} by {
    if k < n and g(k) = c and (forall(j: Nat) { j < n and j != k implies g(j) = Real.0 }) {
        // Step 1: Show partial(g, k) = 0
        forall(j: Nat) {
            if j < k {
                j < n
                j != k
                g(j) = Real.0
            }
        }
        partial_all_zeros(g, k)
        partial(g, k) = Real.0

        // Step 2: Show partial(g, k.suc) = c
        partial(g, k.suc) = partial(g, k) + g(k)
        partial(g, k.suc) = Real.0 + c
        partial(g, k.suc) = c

        // Step 3: Extend from k.suc to n by induction on the distance
        // Define predicate in terms of distance d, where m = k.suc + d
        define q(d: Nat) -> Bool {
            (forall(j: Nat) { k < j and j < k.suc + d implies g(j) = Real.0 })
            implies
            partial(g, k.suc + d) = c
        }

        // Base case: d = 0
        // Then k.suc + 0 = k.suc, and partial(g, k.suc) = c (proven above)
        k.suc + Nat.0 = k.suc
        partial(g, k.suc + Nat.0) = c
        q(Nat.0)

        // Inductive step: if q(d), then q(d.suc)
        forall(d: Nat) {
            if q(d) {
                if forall(j: Nat) { k < j and j < k.suc + d.suc implies g(j) = Real.0 } {
                    // Split: j < k.suc + d or j = k.suc + d
                    forall(j: Nat) {
                        if k < j and j < k.suc + d {
                            j < k.suc + d.suc
                            g(j) = Real.0
                        }
                    }

                    // Apply IH
                    q(d)
                    partial(g, k.suc + d) = c

                    // Show g(k.suc + d) = 0
                    // We have k < k.suc + d (since d >= 0)
                    // And k.suc + d < k.suc + d.suc
                    // So g(k.suc + d) = 0
                    k.suc + d < k.suc + d.suc
                    k < k.suc + d
                    g(k.suc + d) = Real.0

                    // Therefore partial(g, k.suc + d.suc) = c
                    partial(g, k.suc + d.suc) = partial(g, k.suc + d) + g(k.suc + d)
                    partial(g, k.suc + d.suc) = c + Real.0
                    partial(g, k.suc + d.suc) = c
                }
                q(d.suc)
            }
        }

        // Now apply q to the distance (n - k.suc)
        // Since k < n, we have k.suc <= n, so there exists d where n = k.suc + d
        k < n
        let d: Nat satisfy { k.suc + d = n }

        // We know g(j) = 0 for all k < j < n
        forall(j: Nat) {
            if k < j and j < n {
                j < n
                j != k
                g(j) = Real.0
            }
        }

        q(d)
        partial(g, k.suc + d) = c
        partial(g, n) = c
    }
}

/// Lemma: Sum of conditional where exactly one index satisfies predicate.
/// When pred(k) holds and is the unique satisfier in [0,n), sum of cond_part equals f(k).
theorem sum_cond_unique(f: Nat -> Real, pred: Nat -> Bool, n: Nat, k: Nat) {
    k < n and
    pred(k) and
    (forall(j: Nat) { j < n and j != k implies not pred(j) })
    implies
    sum(map(n.range, cond_part(f, pred))) = f(k)
} by {
    from list.list_sum import partial_pointwise_eq

    if k < n and pred(k) and (forall(j: Nat) { j < n and j != k implies not pred(j) }) {
        // Define a simpler function that's f(k) at index k, 0 elsewhere
        define singleton_fn(j: Nat) -> Real {
            if j = k { f(k) } else { Real.0 }
        }

        // Show cond_part(f, pred) = singleton_fn pointwise
        forall(j: Nat) {
            if j < n {
                if j = k {
                    pred(j)
                    cond_part(f, pred, j) = f(j)
                    f(j) = f(k)
                    cond_part(f, pred, j) = f(k)
                    singleton_fn(j) = f(k)
                    cond_part(f, pred, j) = singleton_fn(j)
                } else {
                    j < n
                    j != k
                    not pred(j)
                    cond_part(f, pred, j) = Real.0
                    singleton_fn(j) = Real.0
                    cond_part(f, pred, j) = singleton_fn(j)
                }
            }
        }

        // By pointwise equality, their sums are equal
        partial_pointwise_eq(cond_part(f, pred), singleton_fn, n)
        sum(map(n.range, cond_part(f, pred))) = sum(map(n.range, singleton_fn))

        // Now show sum(map(n.range, singleton_fn)) = f(k)
        // Proof by induction

        // First, prove that partial(singleton_fn, k) = Real.0
        // (all terms before k are zero)

        // Use the sum_singleton helper lemma
        // We have: singleton_fn(k) = f(k) and singleton_fn(j) = 0 for j != k
        singleton_fn(k) = f(k)
        forall(j: Nat) {
            if j < n and j != k {
                j != k
                singleton_fn(j) = Real.0
            }
        }

        // Apply sum_singleton
        sum_singleton(singleton_fn, f(k), k, n)
        partial(singleton_fn, n) = f(k)
        sum(map(n.range, singleton_fn)) = f(k)
        sum(map(n.range, cond_part(f, pred))) = f(k)
    }
}

/// Lemma: For each row i <= m, the diagonal contribution equals a(i)*b(m-i).
/// In row i, only column j=m-i satisfies i+j=m, so only that term is non-zero.
theorem diag_row_contrib_eq(a: Nat -> Real, b: Nat -> Real, m: Nat, i: Nat) {
    i <= m implies diag_row_contrib(a, b, m, i) = a(i) * b(m - i)
} by {
    from list.list_sum import partial_pointwise_eq

    if i <= m {
        // Define the predicate: j satisfies the diagonal condition i+j=m
        define is_diag(j: Nat) -> Bool {
            i + j = m
        }

        // Define the function: product a(i)*b(j) if on diagonal, else 0
        define diag_fn(j: Nat) -> Real {
            if i + j = m { a(i) * b(j) } else { Real.0 }
        }

        // Show diag_fn = cond_part(prod_fn(a,b)(i), is_diag)
        forall(j: Nat) {
            prod_fn(a, b)(i)(j) = a(i) * b(j)
            if i + j = m {
                is_diag(j)
                cond_part(prod_fn(a, b)(i), is_diag, j) = prod_fn(a, b)(i)(j)
                cond_part(prod_fn(a, b)(i), is_diag, j) = a(i) * b(j)
                diag_fn(j) = a(i) * b(j)
                cond_part(prod_fn(a, b)(i), is_diag, j) = diag_fn(j)
            } else {
                not is_diag(j)
                cond_part(prod_fn(a, b)(i), is_diag, j) = Real.0
                diag_fn(j) = Real.0
                cond_part(prod_fn(a, b)(i), is_diag, j) = diag_fn(j)
            }
        }

        // Show diag_cond_prod(a,b,m,i,j) = diag_fn(j)
        forall(j: Nat) {
            if i + j = m {
                diag_cond_prod(a, b, m, i, j) = a(i) * b(j)
                diag_fn(j) = a(i) * b(j)
                diag_cond_prod(a, b, m, i, j) = diag_fn(j)
            } else {
                diag_cond_prod(a, b, m, i, j) = Real.0
                diag_fn(j) = Real.0
                diag_cond_prod(a, b, m, i, j) = diag_fn(j)
            }
        }

        // Therefore their sums are equal
        partial_pointwise_eq(function(j: Nat) { diag_cond_prod(a, b, m, i, j) }, diag_fn, m.suc)
        sum(map(m.suc.range, function(j: Nat) { diag_cond_prod(a, b, m, i, j) })) = sum(map(m.suc.range, diag_fn))
        diag_row_contrib(a, b, m, i) = sum(map(m.suc.range, diag_fn))

        // Now show that exactly one j satisfies i+j=m when i <= m
        // That j is m-i, and we have m-i < m.suc
        i <= m
        let j_unique: Nat satisfy { j_unique + i = m }
        j_unique = m - i
        i + j_unique = m
        is_diag(j_unique)
        j_unique <= m
        j_unique < m.suc

        // Show uniqueness: no other j < m.suc satisfies i+j=m
        forall(j: Nat) {
            if j < m.suc and j != j_unique {
                if i + j = m {
                    i + j_unique = m
                    i + j = i + j_unique
                    j = j_unique
                    false
                }
                not (i + j = m)
                not is_diag(j)
            }
        }

        // Apply sum_cond_unique
        sum_cond_unique(prod_fn(a, b)(i), is_diag, m.suc, j_unique)
        sum(map(m.suc.range, cond_part(prod_fn(a, b)(i), is_diag))) = prod_fn(a, b)(i)(j_unique)

        // Connect through diag_fn
        sum(map(m.suc.range, diag_fn)) = sum(map(m.suc.range, cond_part(prod_fn(a, b)(i), is_diag)))
        sum(map(m.suc.range, diag_fn)) = prod_fn(a, b)(i)(j_unique)
        diag_row_contrib(a, b, m, i) = prod_fn(a, b)(i)(j_unique)

        // Simplify
        prod_fn(a, b)(i)(j_unique) = a(i) * b(j_unique)
        j_unique = m - i
        b(j_unique) = b(m - i)
        prod_fn(a, b)(i)(j_unique) = a(i) * b(m - i)
        diag_row_contrib(a, b, m, i) = a(i) * b(m - i)
    }
}

/// Lemma: Cauchy product equals sum over rows of diagonal contributions.
/// This shows that cauchy_product(a,b,m) = sum_{i=0}^m diag_row_contrib(a,b,m,i).
theorem cauchy_as_diag_double_sum(a: Nat -> Real, b: Nat -> Real, m: Nat) {
    cauchy_product(a, b, m) = sum(map(m.suc.range, function(i: Nat) { diag_row_contrib(a, b, m, i) }))
} by {
    from list.list_sum import partial_pointwise_eq

    // Show that cauchy_coefficient and diag_row_contrib are pointwise equal
    forall(i: Nat) {
        if i < m.suc {
            i <= m
            diag_row_contrib_eq(a, b, m, i)
            diag_row_contrib(a, b, m, i) = a(i) * b(m - i)
            cauchy_coefficient(a, b, m)(i) = a(i) * b(m - i)
            cauchy_coefficient(a, b, m)(i) = diag_row_contrib(a, b, m, i)
        }
    }

    // Apply pointwise equality to conclude sums are equal
    partial_pointwise_eq(cauchy_coefficient(a, b, m), function(i: Nat) { diag_row_contrib(a, b, m, i) }, m.suc)
    sum(map(m.suc.range, cauchy_coefficient(a, b, m))) = sum(map(m.suc.range, function(i: Nat) { diag_row_contrib(a, b, m, i) }))
    cauchy_product(a, b, m) = sum(map(m.suc.range, function(i: Nat) { diag_row_contrib(a, b, m, i) }))
}

/// Adding two inequalities preserves the inequality.
/// If a ≤ b and c ≤ d, then a + c ≤ b + d.
theorem add_lte_add(a: Real, b: Real, c: Real, d: Real) {
    a <= b and c <= d implies a + c <= b + d
} by {
    if a <= b and c <= d {
        lte_add_right(a, b, c)
        a + c <= b + c
        lte_add_left(c, d, b)
        b + c <= b + d
        lte_trans(a + c, b + c, b + d)
        a + c <= b + d
    }
}

/// Sum monotonicity: if f(i) ≤ g(i) for all i in range, then sum(f) ≤ sum(g).
theorem partial_lte_partial(f: Nat -> Real, g: Nat -> Real, n: Nat) {
    (forall(i: Nat) { i < n implies f(i) <= g(i) })
    implies
    partial(f, n) <= partial(g, n)
} by {
    // Prove by induction on n
    define p(m: Nat) -> Bool {
        (forall(i: Nat) { i < m implies f(i) <= g(i) }) implies partial(f, m) <= partial(g, m)
    }

    // Base case: m = 0
    partial(f, Nat.0) = Real.0
    partial(g, Nat.0) = Real.0
    partial(f, Nat.0) <= partial(g, Nat.0)
    p(Nat.0)

    // Inductive step: p(m) implies p(m.suc)
    forall(m: Nat) {
        if p(m) {
            if forall(i: Nat) { i < m.suc implies f(i) <= g(i) } {
                // Split the range [0, m.suc) into [0, m) and {m}
                forall(i: Nat) {
                    if i < m {
                        i < m.suc
                        f(i) <= g(i)
                    }
                }

                // Apply induction hypothesis to get partial(f, m) <= partial(g, m)
                p(m)
                partial(f, m) <= partial(g, m)

                // Now handle the m-th element
                m < m.suc
                f(m) <= g(m)

                // Use partial_split_last to expand
                partial(f, m.suc) = partial(f, m) + f(m)
                partial(g, m.suc) = partial(g, m) + g(m)

                // Since partial(f, m) <= partial(g, m) and f(m) <= g(m), we have:
                // partial(f, m) + f(m) <= partial(g, m) + g(m)
                partial(f, m) <= partial(g, m)
                f(m) <= g(m)
                add_lte_add(partial(f, m), partial(g, m), f(m), g(m))
                partial(f, m) + f(m) <= partial(g, m) + g(m)
                partial(f, m.suc) <= partial(g, m.suc)
            }
            p(m.suc)
        }
    }

    // Apply induction to conclude p(n)
    p(n)
}

/// Pointwise comparison for double sums: if f(i,j) <= g(i,j) for all i < n and j < m,
/// then double_sum(n, m, f) <= double_sum(n, m, g).
theorem double_sum_pointwise_le(n: Nat, m: Nat, f: (Nat, Nat) -> Real, g: (Nat, Nat) -> Real) {
    (forall(i: Nat, j: Nat) { i < n and j < m implies f(i, j) <= g(i, j) })
    implies
    double_sum(n, m, f) <= double_sum(n, m, g)
} by {
    if forall(i: Nat, j: Nat) { i < n and j < m implies f(i, j) <= g(i, j) } {
        // Strategy: Show that each row sum satisfies row_sum(m, f, i) <= row_sum(m, g, i)
        // Then apply partial_lte_partial to conclude the result.

        // First, show that for each i < n, the row sums satisfy row_sum(m, f, i) <= row_sum(m, g, i)
        forall(i: Nat) {
            if i < n {
                // For this fixed i, we have forall j < m: f(i, j) <= g(i, j)
                forall(j: Nat) {
                    if j < m {
                        f(i, j) <= g(i, j)
                    }
                }

                // Define the row functions
                row_val(f, i) = function(j: Nat) { f(i, j) }
                row_val(g, i) = function(j: Nat) { g(i, j) }

                // Show that row_val(f, i) <= row_val(g, i) for all j < m
                forall(j: Nat) {
                    row_val(f, i)(j) = f(i, j)
                    row_val(g, i)(j) = g(i, j)
                    if j < m {
                        row_val(f, i)(j) <= row_val(g, i)(j)
                    }
                }

                // Apply partial_lte_partial to get the sum inequality
                partial_lte_partial(row_val(f, i), row_val(g, i), m)
                partial(row_val(f, i), m) <= partial(row_val(g, i), m)

                // Since partial(h, m) = sum(map(m.range, h)), we have:
                partial(row_val(f, i), m) = sum(map(m.range, row_val(f, i)))
                partial(row_val(g, i), m) = sum(map(m.range, row_val(g, i)))
                sum(map(m.range, row_val(f, i))) <= sum(map(m.range, row_val(g, i)))

                // By definition, row_sum(m, f, i) = sum(map(m.range, row_val(f, i)))
                row_sum(m, f, i) = sum(map(m.range, row_val(f, i)))
                row_sum(m, g, i) = sum(map(m.range, row_val(g, i)))
                row_sum(m, f, i) <= row_sum(m, g, i)
            }
        }

        // Now we have: forall i < n, row_sum(m, f, i) <= row_sum(m, g, i)
        // Define helper functions for the row sums
        define f_rows(i: Nat) -> Real { row_sum(m, f, i) }
        define g_rows(i: Nat) -> Real { row_sum(m, g, i) }

        forall(i: Nat) {
            f_rows(i) = row_sum(m, f, i)
            g_rows(i) = row_sum(m, g, i)
            if i < n {
                f_rows(i) <= g_rows(i)
            }
        }

        // Apply partial_lte_partial to get the sum inequality for rows
        partial_lte_partial(f_rows, g_rows, n)
        partial(f_rows, n) <= partial(g_rows, n)

        // Since partial(h, n) = sum(map(n.range, h)), we have:
        partial(f_rows, n) = sum(map(n.range, f_rows))
        partial(g_rows, n) = sum(map(n.range, g_rows))
        sum(map(n.range, f_rows)) <= sum(map(n.range, g_rows))

        // By definition of double_sum
        double_sum_expands(n, m, f)
        double_sum(n, m, f) = sum(map(n.range, function(i: Nat) { row_sum(m, f, i) }))
        double_sum_expands(n, m, g)
        double_sum(n, m, g) = sum(map(n.range, function(i: Nat) { row_sum(m, g, i) }))

        // The functions are pointwise equal to our helper functions
        forall(k: Nat) {
            function(i: Nat) { row_sum(m, f, i) }(k) = row_sum(m, f, k)
            row_sum(m, f, k) = f_rows(k)
            function(i: Nat) { row_sum(m, f, i) }(k) = f_rows(k)

            function(i: Nat) { row_sum(m, g, i) }(k) = row_sum(m, g, k)
            row_sum(m, g, k) = g_rows(k)
            function(i: Nat) { row_sum(m, g, i) }(k) = g_rows(k)
        }

        // By pointwise equality, the sums are equal
        from list.list_sum import partial_pointwise_eq
        partial_pointwise_eq(function(i: Nat) { row_sum(m, f, i) }, f_rows, n)
        sum(map(n.range, function(i: Nat) { row_sum(m, f, i) })) = sum(map(n.range, f_rows))
        partial_pointwise_eq(function(i: Nat) { row_sum(m, g, i) }, g_rows, n)
        sum(map(n.range, function(i: Nat) { row_sum(m, g, i) })) = sum(map(n.range, g_rows))

        // Combine everything
        double_sum(n, m, f) = sum(map(n.range, f_rows))
        double_sum(n, m, g) = sum(map(n.range, g_rows))
        sum(map(n.range, f_rows)) <= sum(map(n.range, g_rows))
        double_sum(n, m, f) <= double_sum(n, m, g)
    }
}

/// Double sum distributes over pointwise addition of functions.
/// If h(i,j) = f(i,j) + g(i,j) for all i, j, then double_sum(n, m, h) = double_sum(n, m, f) + double_sum(n, m, g).
theorem double_sum_pointwise_add(n: Nat, m: Nat, f: (Nat, Nat) -> Real, g: (Nat, Nat) -> Real, h: (Nat, Nat) -> Real) {
    (forall(i: Nat, j: Nat) { h(i, j) = f(i, j) + g(i, j) })
    implies
    double_sum(n, m, h) = double_sum(n, m, f) + double_sum(n, m, g)
} by {
    from list.list_sum import partial_pointwise_eq

    if forall(i: Nat, j: Nat) { h(i, j) = f(i, j) + g(i, j) } {
        // For each row i, show row_sum(m, h, i) = row_sum(m, f, i) + row_sum(m, g, i)
        forall(i: Nat) {
            // Define row functions
            define h_row(j: Nat) -> Real { h(i, j) }
            define f_row(j: Nat) -> Real { f(i, j) }
            define g_row(j: Nat) -> Real { g(i, j) }

            // Show pointwise equality for this row
            forall(j: Nat) {
                h_row(j) = h(i, j)
                h(i, j) = f(i, j) + g(i, j)
                f_row(j) = f(i, j)
                g_row(j) = g(i, j)
                h_row(j) = f_row(j) + g_row(j)
            }

            // Apply map_sum_add to this row
            map_sum_add(m.range, f_row, g_row)
            sum(map(m.range, f_row)) + sum(map(m.range, g_row)) = sum(map(m.range, add_fn(f_row, g_row)))

            // Show add_fn(f_row, g_row) equals h_row
            forall(j: Nat) {
                add_fn(f_row, g_row)(j) = f_row(j) + g_row(j)
                f_row(j) + g_row(j) = h_row(j)
                add_fn(f_row, g_row)(j) = h_row(j)
            }

            partial_pointwise_eq(add_fn(f_row, g_row), h_row, m)
            sum(map(m.range, add_fn(f_row, g_row))) = sum(map(m.range, h_row))

            // Therefore row sums add
            row_sum(m, f, i) = sum(map(m.range, row_val(f, i)))
            row_sum(m, g, i) = sum(map(m.range, row_val(g, i)))
            row_sum(m, h, i) = sum(map(m.range, row_val(h, i)))

            forall(j: Nat) {
                row_val(f, i)(j) = f(i, j)
                f(i, j) = f_row(j)
                row_val(f, i)(j) = f_row(j)
            }
            partial_pointwise_eq(row_val(f, i), f_row, m)
            sum(map(m.range, row_val(f, i))) = sum(map(m.range, f_row))

            forall(j: Nat) {
                row_val(g, i)(j) = g(i, j)
                g(i, j) = g_row(j)
                row_val(g, i)(j) = g_row(j)
            }
            partial_pointwise_eq(row_val(g, i), g_row, m)
            sum(map(m.range, row_val(g, i))) = sum(map(m.range, g_row))

            forall(j: Nat) {
                row_val(h, i)(j) = h(i, j)
                h(i, j) = h_row(j)
                row_val(h, i)(j) = h_row(j)
            }
            partial_pointwise_eq(row_val(h, i), h_row, m)
            sum(map(m.range, row_val(h, i))) = sum(map(m.range, h_row))

            row_sum(m, f, i) + row_sum(m, g, i) = sum(map(m.range, f_row)) + sum(map(m.range, g_row))
            sum(map(m.range, f_row)) + sum(map(m.range, g_row)) = sum(map(m.range, h_row))
            row_sum(m, h, i) = row_sum(m, f, i) + row_sum(m, g, i)
        }

        // Now apply map_sum_add to the outer sum
        map_sum_add(n.range, row_sum(m, f), row_sum(m, g))
        sum(map(n.range, row_sum(m, f))) + sum(map(n.range, row_sum(m, g))) = sum(map(n.range, add_fn(row_sum(m, f), row_sum(m, g))))

        // Show add_fn(row_sum(m, f), row_sum(m, g)) equals row_sum(m, h)
        forall(i: Nat) {
            add_fn(row_sum(m, f), row_sum(m, g))(i) = row_sum(m, f, i) + row_sum(m, g, i)
            row_sum(m, f, i) + row_sum(m, g, i) = row_sum(m, h, i)
            add_fn(row_sum(m, f), row_sum(m, g))(i) = row_sum(m, h, i)
        }

        partial_pointwise_eq(add_fn(row_sum(m, f), row_sum(m, g)), row_sum(m, h), n)
        sum(map(n.range, add_fn(row_sum(m, f), row_sum(m, g)))) = sum(map(n.range, row_sum(m, h)))

        // Expand double_sums
        double_sum_expands(n, m, f)
        double_sum(n, m, f) = sum(map(n.range, row_sum(m, f)))
        double_sum_expands(n, m, g)
        double_sum(n, m, g) = sum(map(n.range, row_sum(m, g)))
        double_sum_expands(n, m, h)
        double_sum(n, m, h) = sum(map(n.range, row_sum(m, h)))

        // Combine
        double_sum(n, m, f) + double_sum(n, m, g) = sum(map(n.range, row_sum(m, f))) + sum(map(n.range, row_sum(m, g)))
        sum(map(n.range, row_sum(m, f))) + sum(map(n.range, row_sum(m, g))) = sum(map(n.range, row_sum(m, h)))
        double_sum(n, m, h) = sum(map(n.range, row_sum(m, h)))
        double_sum(n, m, h) = double_sum(n, m, f) + double_sum(n, m, g)
    }
}

/// Helper: Value at position i along diagonal k
define diagonal_val(f: (Nat, Nat) -> Real, k: Nat, i: Nat) -> Real {
    f(i, k - i)
}

/// Helper: Sum along a single diagonal k, where j = k - i.
/// For diagonal k, sum f(i, k-i) for i from 0 to k.
define diagonal_sum(f: (Nat, Nat) -> Real, k: Nat) -> Real {
    sum(map(k.suc.range, diagonal_val(f, k)))
}

/// Helper: Indicator for the triangular region i + j < n.
define triangle_region(n: Nat, i: Nat, j: Nat) -> Real {
    if i + j < n { Real.1 } else { Real.0 }
}

/// Helper: Product restricted to triangular region.
define triangle_fn(f: (Nat, Nat) -> Real, n: Nat, i: Nat, j: Nat) -> Real {
    if i + j < n { f(i, j) } else { Real.0 }
}

/// Helper function: diagonal indicator.
define diag_indicator(f: (Nat, Nat) -> Real, m: Nat, i: Nat, j: Nat) -> Real {
    if i + j = m { f(i, j) } else { Real.0 }
}

/// Helper: diagonal_sum expressed as a double_sum over a diagonal indicator.
/// The key insight: In row i, only column j=m-i contributes, giving f(i, m-i).
/// Therefore double_sum reduces to sum_{i=0}^m f(i, m-i) = diagonal_sum(f, m).
theorem diagonal_as_double_sum(f: (Nat, Nat) -> Real, m: Nat) {
    diagonal_sum(f, m) = double_sum(m.suc, m.suc, diag_indicator(f, m))
} by {
    from list.list_sum import partial_pointwise_eq

    // Use the diagonal function
    define diag_fn(i: Nat, j: Nat) -> Real {
        diag_indicator(f, m, i, j)
    }

    // RHS: double_sum(m.suc, m.suc, diag_fn) = sum_{i=0}^m row_sum(m.suc, diag_fn, i)
    double_sum_expands(m.suc, m.suc, diag_fn)
    double_sum(m.suc, m.suc, diag_fn) = sum(map(m.suc.range, function(i: Nat) { row_sum(m.suc, diag_fn, i) }))

    // Now show that for each i < m.suc, row_sum(m.suc, diag_fn, i) = f(i, m-i)
    forall(i: Nat) {
        if i < m.suc {
            i <= m

            // Define the row function for this i
            define row_i(j: Nat) -> Real {
                diag_fn(i, j)
            }

            // Show that row_i has exactly one non-zero term at j = m-i
            forall(j: Nat) {
                row_i(j) = diag_fn(i, j)
                if j = m - i {
                    // At j = m-i, we have i+j = i + (m-i) = m
                    i + (m - i) = m
                    i + j = m
                    diag_fn(i, j) = f(i, j)
                    row_i(j) = f(i, j)
                    f(i, j) = f(i, m - i)
                    row_i(j) = f(i, m - i)
                } else {
                    // At j != m-i, we have i+j != m
                    if i + j = m {
                        // Then j = m - i, contradiction
                        j = m - i
                    }
                    not (i + j = m)
                    diag_fn(i, j) = Real.0
                    row_i(j) = Real.0
                }
            }

            // Now row_i(m-i) = f(i, m-i) and row_i(j) = 0 for j != m-i
            // We need m-i < m.suc
            m - i <= m
            m < m.suc
            m - i < m.suc

            // Explicitly state preconditions for sum_singleton
            row_i(m - i) = f(i, m - i)

            forall(j: Nat) {
                if j < m.suc and j != m - i {
                    row_i(j) = Real.0
                }
            }

            // Apply sum_singleton: this proves partial(row_i, m.suc) = f(i, m - i)
            sum_singleton(row_i, f(i, m - i), m - i, m.suc)

            // row_sum(m.suc, diag_fn, i) = sum(map(m.suc.range, row_val(diag_fn, i)))
            row_sum(m.suc, diag_fn, i) = sum(map(m.suc.range, row_val(diag_fn, i)))

            // row_val(diag_fn, i)(j) = diag_fn(i, j) = row_i(j)
            forall(j: Nat) {
                row_val(diag_fn, i)(j) = diag_fn(i, j)
                diag_fn(i, j) = row_i(j)
                row_val(diag_fn, i)(j) = row_i(j)
            }

            // By pointwise equality
            partial_pointwise_eq(row_val(diag_fn, i), row_i, m.suc)
            sum(map(m.suc.range, row_val(diag_fn, i))) = sum(map(m.suc.range, row_i))

            sum(map(m.suc.range, row_i)) = partial(row_i, m.suc)

            // From sum_singleton, we have partial(row_i, m.suc) = f(i, m - i)
            row_sum(m.suc, diag_fn, i) = partial(row_i, m.suc)
            partial(row_i, m.suc) = f(i, m - i)
            row_sum(m.suc, diag_fn, i) = f(i, m - i)
        }
    }

    // Now both sides are sum_{i=0}^m f(i, m-i)
    // LHS function: function(i) { f(i, m-i) }
    // RHS function: function(i) { row_sum(m.suc, diag_fn, i) }
    // These are pointwise equal

    forall(k: Nat) {
        if k < m.suc {
            function(i: Nat) { f(i, m - i) }(k) = f(k, m - k)
            function(i: Nat) { row_sum(m.suc, diag_fn, i) }(k) = row_sum(m.suc, diag_fn, k)
            row_sum(m.suc, diag_fn, k) = f(k, m - k)
            function(i: Nat) { row_sum(m.suc, diag_fn, i) }(k) = function(i: Nat) { f(i, m - i) }(k)
        }
    }

    partial_pointwise_eq(function(i: Nat) { f(i, m - i) }, function(i: Nat) { row_sum(m.suc, diag_fn, i) }, m.suc)
    sum(map(m.suc.range, function(i: Nat) { f(i, m - i) })) = sum(map(m.suc.range, function(i: Nat) { row_sum(m.suc, diag_fn, i) }))

    // From line 2158, we have double_sum(m.suc, m.suc, diag_fn) = sum(map(..., row_sum(...)))
    double_sum(m.suc, m.suc, diag_fn) = sum(map(m.suc.range, function(i: Nat) { row_sum(m.suc, diag_fn, i) }))

    // By transitivity with line 2249
    sum(map(m.suc.range, function(i: Nat) { f(i, m - i) })) = sum(map(m.suc.range, function(i: Nat) { row_sum(m.suc, diag_fn, i) }))
    sum(map(m.suc.range, function(i: Nat) { row_sum(m.suc, diag_fn, i) })) = double_sum(m.suc, m.suc, diag_fn)
    sum(map(m.suc.range, function(i: Nat) { f(i, m - i) })) = double_sum(m.suc, m.suc, diag_fn)

    // By transitivity: we have sum(...f(i, m-i)...) = double_sum
    sum(map(m.suc.range, function(i: Nat) { f(i, m - i) })) = double_sum(m.suc, m.suc, diag_fn)

    // Show that function(i) { f(i, m-i) } equals diagonal_val(f, m) pointwise
    forall(j: Nat) {
        function(i: Nat) { f(i, m - i) }(j) = f(j, m - j)
        diagonal_val(f, m, j) = f(j, m - j)
        function(i: Nat) { f(i, m - i) }(j) = diagonal_val(f, m, j)
    }

    partial_pointwise_eq(function(i: Nat) { f(i, m - i) }, diagonal_val(f, m), m.suc)
    sum(map(m.suc.range, function(i: Nat) { f(i, m - i) })) = sum(map(m.suc.range, diagonal_val(f, m)))

    // By definition, diagonal_sum(f, m) = sum(map(m.suc.range, diagonal_val(f, m)))
    sum(map(m.suc.range, diagonal_val(f, m))) = double_sum(m.suc, m.suc, diag_fn)
    diagonal_sum(f, m) = sum(map(m.suc.range, diagonal_val(f, m)))
    diagonal_sum(f, m) = double_sum(m.suc, m.suc, diag_fn)

    // diag_fn(i, j) = diag_indicator(f, m, i, j), so double_sum(m.suc, m.suc, diag_fn) = double_sum(m.suc, m.suc, diag_indicator(f, m))
    forall(i: Nat, j: Nat) {
        diag_fn(i, j) = diag_indicator(f, m, i, j)
    }
    double_sum(m.suc, m.suc, diag_indicator(f, m)) = double_sum(m.suc, m.suc, diag_fn)
    double_sum(m.suc, m.suc, diag_fn) = diagonal_sum(f, m)
    diagonal_sum(f, m) = double_sum(m.suc, m.suc, diag_indicator(f, m))
}

/// Key lemma: Expanding double_sum with triangle restriction adds exactly one diagonal.
/// When going from (m, m) to (m+1, m+1) with triangle_fn restriction,
/// the new terms are exactly those on diagonal m (where i+j = m).
theorem double_sum_triangle_expand(f: (Nat, Nat) -> Real, m: Nat) {
    double_sum(m.suc, m.suc, triangle_fn(f, m.suc))
    =
    double_sum(m, m, triangle_fn(f, m)) + diagonal_sum(f, m)
} by {
    // Key insight: triangle_fn(f, m.suc) decomposes as triangle_fn(f, m) + diag_indicator(f, m)
    // For any i, j:
    // - If i+j < m: triangle_fn(f, m.suc, i, j) = f(i,j) and triangle_fn(f, m, i, j) = f(i,j), diag_indicator = 0
    // - If i+j = m: triangle_fn(f, m.suc, i, j) = f(i,j) and triangle_fn(f, m, i, j) = 0, diag_indicator = f(i,j)
    // - If i+j >= m.suc: all three are 0

    // Prove pointwise decomposition
    forall(i: Nat, j: Nat) {
        if i + j < m {
            // In this case: i+j < m < m.suc
            i + j < m.suc
            triangle_fn(f, m.suc, i, j) = f(i, j)
            triangle_fn(f, m, i, j) = f(i, j)

            not (i + j = m)
            diag_indicator(f, m, i, j) = Real.0

            triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j) = f(i, j) + Real.0
            f(i, j) + Real.0 = f(i, j)
            triangle_fn(f, m.suc, i, j) = triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j)
        }

        if i + j = m {
            // In this case: i+j = m < m.suc
            i + j < m.suc
            triangle_fn(f, m.suc, i, j) = f(i, j)

            not (i + j < m)
            triangle_fn(f, m, i, j) = Real.0

            diag_indicator(f, m, i, j) = f(i, j)

            triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j) = Real.0 + f(i, j)
            Real.0 + f(i, j) = f(i, j)
            triangle_fn(f, m.suc, i, j) = triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j)
        }

        if i + j >= m.suc {
            // All three functions are 0
            not (i + j < m.suc)
            triangle_fn(f, m.suc, i, j) = Real.0

            not (i + j < m)
            triangle_fn(f, m, i, j) = Real.0

            not (i + j = m)
            diag_indicator(f, m, i, j) = Real.0

            triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j) = Real.0 + Real.0
            Real.0 + Real.0 = Real.0
            triangle_fn(f, m.suc, i, j) = triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j)
        }

        // One of the three cases must hold
        if not (i + j < m) and not (i + j = m) and not (i + j >= m.suc) {
            // This is impossible: must have either i+j < m, i+j = m, or i+j >= m.suc
            i + j < m or i + j = m or i + j >= m.suc
        }

        triangle_fn(f, m.suc, i, j) = triangle_fn(f, m, i, j) + diag_indicator(f, m, i, j)
    }

    // Apply double_sum_pointwise_add
    double_sum_pointwise_add(m.suc, m.suc, triangle_fn(f, m), diag_indicator(f, m), triangle_fn(f, m.suc))
    double_sum(m.suc, m.suc, triangle_fn(f, m.suc)) = double_sum(m.suc, m.suc, triangle_fn(f, m)) + double_sum(m.suc, m.suc, diag_indicator(f, m))

    // Use diagonal_as_double_sum
    diagonal_as_double_sum(f, m)
    diagonal_sum(f, m) = double_sum(m.suc, m.suc, diag_indicator(f, m))

    // So far we have: double_sum(m.suc, m.suc, triangle_fn(f, m.suc)) = double_sum(m.suc, m.suc, triangle_fn(f, m)) + diagonal_sum(f, m)
    // But we need: double_sum(m.suc, m.suc, triangle_fn(f, m.suc)) = double_sum(m, m, triangle_fn(f, m)) + diagonal_sum(f, m)
    // So we need to show double_sum(m.suc, m.suc, triangle_fn(f, m)) = double_sum(m, m, triangle_fn(f, m))

    // This is true because triangle_fn(f, m, i, j) = 0 whenever i+j >= m
    // So the extra row (i=m) and column (j=m) contribute 0

    // For the row i=m: show that triangle_fn(f, m)(m) is the zero function
    forall(j: Nat) {
        if j < m.suc {
            m + j >= m
            not (m + j < m)
            triangle_fn(f, m, m, j) = Real.0
            triangle_fn(f, m)(m, j) = Real.0
        }
    }

    forall(j: Nat) {
        if j < m.suc {
            triangle_fn(f, m)(m)(j) = triangle_fn(f, m)(m, j)
            triangle_fn(f, m)(m, j) = Real.0
            triangle_fn(f, m)(m)(j) = Real.0
        }
    }

    // Apply partial_all_zeros
    partial_all_zeros(triangle_fn(f, m)(m), m.suc)
    sum(map(m.suc.range, triangle_fn(f, m)(m))) = partial(triangle_fn(f, m)(m), m.suc)
    partial(triangle_fn(f, m)(m), m.suc) = Real.0
    sum(map(m.suc.range, triangle_fn(f, m)(m))) = Real.0

    // By definition of row_sum
    row_sum(m.suc, triangle_fn(f, m), m) = sum(map(m.suc.range, triangle_fn(f, m)(m)))
    row_sum(m.suc, triangle_fn(f, m), m) = Real.0

    // Now expand double_sum(m.suc, m.suc, triangle_fn(f, m)) using row expansion
    double_sum_row_expand(m, m.suc, triangle_fn(f, m))
    double_sum(m.suc, m.suc, triangle_fn(f, m)) = double_sum(m, m.suc, triangle_fn(f, m)) + sum(map(m.suc.range, row_val(triangle_fn(f, m), m)))

    // Show row_val(triangle_fn(f, m), m) = triangle_fn(f, m)(m) pointwise
    forall(j: Nat) {
        row_val(triangle_fn(f, m), m)(j) = triangle_fn(f, m)(m, j)
        triangle_fn(f, m)(m, j) = triangle_fn(f, m)(m)(j)
        row_val(triangle_fn(f, m), m)(j) = triangle_fn(f, m)(m)(j)
    }

    from list.list_sum import partial_pointwise_eq
    partial_pointwise_eq(row_val(triangle_fn(f, m), m), triangle_fn(f, m)(m), m.suc)
    sum(map(m.suc.range, row_val(triangle_fn(f, m), m))) = sum(map(m.suc.range, triangle_fn(f, m)(m)))
    sum(map(m.suc.range, triangle_fn(f, m)(m))) = Real.0
    sum(map(m.suc.range, row_val(triangle_fn(f, m), m))) = Real.0
    double_sum(m.suc, m.suc, triangle_fn(f, m)) = double_sum(m, m.suc, triangle_fn(f, m)) + Real.0
    double_sum(m, m.suc, triangle_fn(f, m)) + Real.0 = double_sum(m, m.suc, triangle_fn(f, m))
    double_sum(m.suc, m.suc, triangle_fn(f, m)) = double_sum(m, m.suc, triangle_fn(f, m))

    // Similarly for column j=m:
    forall(i: Nat) {
        if i < m {
            i + m >= m
            not (i + m < m)
            triangle_fn(f, m, i, m) = Real.0
            col_val(triangle_fn(f, m), m)(i) = triangle_fn(f, m, i, m)
            col_val(triangle_fn(f, m), m)(i) = Real.0
        }
    }

    partial_all_zeros(col_val(triangle_fn(f, m), m), m)
    sum(map(m.range, col_val(triangle_fn(f, m), m))) = partial(col_val(triangle_fn(f, m), m), m)
    partial(col_val(triangle_fn(f, m), m), m) = Real.0
    sum(map(m.range, col_val(triangle_fn(f, m), m))) = Real.0

    double_sum_col_expand(m, m, triangle_fn(f, m))
    double_sum(m, m.suc, triangle_fn(f, m)) = double_sum(m, m, triangle_fn(f, m)) + sum(map(m.range, col_val(triangle_fn(f, m), m)))
    sum(map(m.range, col_val(triangle_fn(f, m), m))) = Real.0
    double_sum(m, m.suc, triangle_fn(f, m)) = double_sum(m, m, triangle_fn(f, m)) + Real.0
    double_sum(m, m, triangle_fn(f, m)) + Real.0 = double_sum(m, m, triangle_fn(f, m))
    double_sum(m, m.suc, triangle_fn(f, m)) = double_sum(m, m, triangle_fn(f, m))

    // Combine
    double_sum(m.suc, m.suc, triangle_fn(f, m)) = double_sum(m, m.suc, triangle_fn(f, m))
    double_sum(m, m.suc, triangle_fn(f, m)) = double_sum(m, m, triangle_fn(f, m))
    double_sum(m.suc, m.suc, triangle_fn(f, m)) = double_sum(m, m, triangle_fn(f, m))

    // Final result
    double_sum(m.suc, m.suc, triangle_fn(f, m.suc)) = double_sum(m.suc, m.suc, triangle_fn(f, m)) + diagonal_sum(f, m)
    double_sum(m.suc, m.suc, triangle_fn(f, m)) = double_sum(m, m, triangle_fn(f, m))
    double_sum(m.suc, m.suc, triangle_fn(f, m.suc)) = double_sum(m, m, triangle_fn(f, m)) + diagonal_sum(f, m)
}

/// Finite double sum exchange for triangular regions (discrete Fubini).
/// Summing along diagonals equals summing over the triangular region.
/// LHS: sum over diagonals k, then over i ≤ k (where j = k-i)
/// RHS: sum over all (i,j) in the triangle i+j < n
theorem finite_double_sum_exchange(f: (Nat, Nat) -> Real, n: Nat) {
    sum(map(n.range, diagonal_sum(f)))
    =
    double_sum(n, n, triangle_fn(f, n))
} by {
    from list.list_sum import map_add, sum_add

    // Induction on n
    define p(k: Nat) -> Bool {
        sum(map(k.range, diagonal_sum(f))) = double_sum(k, k, triangle_fn(f, k))
    }

    // Base case: k = 0
    Nat.0.range = List.nil
    sum(map(Nat.0.range, diagonal_sum(f))) = sum(List.nil[Real])
    sum(List.nil[Real]) = Real.0

    double_sum_expands(Nat.0, Nat.0, triangle_fn(f, Nat.0))
    double_sum(Nat.0, Nat.0, triangle_fn(f, Nat.0)) = sum(map(Nat.0.range, row_sum(Nat.0, triangle_fn(f, Nat.0))))
    sum(map(Nat.0.range, row_sum(Nat.0, triangle_fn(f, Nat.0)))) = sum(List.nil[Real])
    sum(List.nil[Real]) = Real.0
    double_sum(Nat.0, Nat.0, triangle_fn(f, Nat.0)) = Real.0

    sum(map(Nat.0.range, diagonal_sum(f))) = double_sum(Nat.0, Nat.0, triangle_fn(f, Nat.0))
    p(Nat.0)

    // Inductive step
    forall(k: Nat) {
        if p(k) {
            // Assume: sum(map(k.range, diagonal_sum(f))) = double_sum(k, k, triangle_fn(f, k))
            // Need to prove: sum(map(k.suc.range, diagonal_sum(f))) = double_sum(k.suc, k.suc, triangle_fn(f, k.suc))

            // LHS: Expand k.suc.range
            k.suc.range = k.range + List.singleton(k)
            map_add(k.range, List.singleton(k), diagonal_sum(f))
            map(k.suc.range, diagonal_sum(f)) = map(k.range, diagonal_sum(f)) + map(List.singleton(k), diagonal_sum(f))

            map(List.singleton(k), diagonal_sum(f)) = List.singleton(diagonal_sum(f, k))
            map(k.suc.range, diagonal_sum(f)) = map(k.range, diagonal_sum(f)) + List.singleton(diagonal_sum(f, k))

            sum_add(map(k.range, diagonal_sum(f)), List.singleton(diagonal_sum(f, k)))
            sum(map(k.suc.range, diagonal_sum(f))) = sum(map(k.range, diagonal_sum(f))) + sum(List.singleton(diagonal_sum(f, k)))

            sum(List.singleton(diagonal_sum(f, k))) = diagonal_sum(f, k)
            sum(map(k.suc.range, diagonal_sum(f))) = sum(map(k.range, diagonal_sum(f))) + diagonal_sum(f, k)

            // RHS: Use double_sum_triangle_expand
            double_sum_triangle_expand(f, k)
            double_sum(k.suc, k.suc, triangle_fn(f, k.suc)) = double_sum(k, k, triangle_fn(f, k)) + diagonal_sum(f, k)

            // By IH
            sum(map(k.range, diagonal_sum(f))) = double_sum(k, k, triangle_fn(f, k))

            // Combine
            sum(map(k.suc.range, diagonal_sum(f))) = sum(map(k.range, diagonal_sum(f))) + diagonal_sum(f, k)
            sum(map(k.range, diagonal_sum(f))) + diagonal_sum(f, k) = double_sum(k, k, triangle_fn(f, k)) + diagonal_sum(f, k)
            double_sum(k.suc, k.suc, triangle_fn(f, k.suc)) = double_sum(k, k, triangle_fn(f, k)) + diagonal_sum(f, k)
            sum(map(k.suc.range, diagonal_sum(f))) = double_sum(k.suc, k.suc, triangle_fn(f, k.suc))

            p(k.suc)
        }
    }

    // By induction, p(k) holds for all k, including n
    p(n)
}

/// For nonnegative sequences a and b, the Cauchy product up to m
/// is bounded by the double sum (full product of partial sums).
/// This is the key inequality: ∑_{i+j=m} a(i)b(j) <= ∑_{i,j≤m} a(i)b(j).
theorem double_sum_diagonal_bound(a: Nat -> Real, b: Nat -> Real, m: Nat) {
    is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
    implies
    cauchy_product(a, b, m) <= double_sum(m.suc, m.suc, prod_fn(a, b))
} by {
    from list.list_sum import partial_pointwise_eq

    if is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0) {
        // Express Cauchy product as sum of diagonal contributions
        cauchy_as_diag_double_sum(a, b, m)
        cauchy_product(a, b, m) = sum(map(m.suc.range, function(i: Nat) { diag_row_contrib(a, b, m, i) }))

        // Show each diagonal contribution is bounded by its full row sum
        // For each row i, diag_row_contrib(a,b,m,i) is a conditional sum
        forall(i: Nat) {
            if i < m.suc {
                i <= m

                // Define the predicate for this row
                define is_diag_i(j: Nat) -> Bool {
                    i + j = m
                }

                // Show diag_row_contrib equals conditional sum
                diag_row_contrib(a, b, m, i) = sum(map(m.suc.range, function(j: Nat) { diag_cond_prod(a, b, m, i, j) }))

                // Show diag_cond_prod = cond_part(prod_fn(a,b)(i), is_diag_i)
                forall(j: Nat) {
                    prod_fn(a, b)(i)(j) = a(i) * b(j)
                    if i + j = m {
                        is_diag_i(j)
                        diag_cond_prod(a, b, m, i, j) = a(i) * b(j)
                        cond_part(prod_fn(a, b)(i), is_diag_i, j) = prod_fn(a, b)(i)(j)
                        cond_part(prod_fn(a, b)(i), is_diag_i, j) = a(i) * b(j)
                        diag_cond_prod(a, b, m, i, j) = cond_part(prod_fn(a, b)(i), is_diag_i, j)
                    } else {
                        not is_diag_i(j)
                        diag_cond_prod(a, b, m, i, j) = Real.0
                        cond_part(prod_fn(a, b)(i), is_diag_i, j) = Real.0
                        diag_cond_prod(a, b, m, i, j) = cond_part(prod_fn(a, b)(i), is_diag_i, j)
                    }
                }

                // Apply partial_pointwise_eq
                partial_pointwise_eq(function(j: Nat) { diag_cond_prod(a, b, m, i, j) }, cond_part(prod_fn(a, b)(i), is_diag_i), m.suc)
                sum(map(m.suc.range, function(j: Nat) { diag_cond_prod(a, b, m, i, j) })) = sum(map(m.suc.range, cond_part(prod_fn(a, b)(i), is_diag_i)))
                diag_row_contrib(a, b, m, i) = sum(map(m.suc.range, cond_part(prod_fn(a, b)(i), is_diag_i)))

                // Show prod_fn(a,b)(i) is nonnegative
                forall(j: Nat) {
                    a(i) >= Real.0
                    b(j) >= Real.0
                    mul_le_mul_nonneg(a(i), b(j), Real.0, Real.0)
                    a(i) * b(j) >= Real.0
                    prod_fn(a, b)(i)(j) >= Real.0
                }

                // Apply sum_cond_le_sum_1d
                sum_cond_le_sum_1d(prod_fn(a, b)(i), is_diag_i, m.suc)
                sum(map(m.suc.range, cond_part(prod_fn(a, b)(i), is_diag_i))) <= sum(map(m.suc.range, prod_fn(a, b)(i)))

                // Conclude this row inequality
                diag_row_contrib(a, b, m, i) <= sum(map(m.suc.range, prod_fn(a, b)(i)))
                diag_row_contrib(a, b, m, i) <= row_sum(m.suc, prod_fn(a, b), i)
            }
        }

        // Now lift the row-wise inequalities to the full sum
        // We have: forall i < m.suc. diag_row_contrib(a,b,m,i) <= row_sum(m.suc, prod_fn(a,b), i)
        // Therefore: sum(diag_row_contrib) <= sum(row_sum) = double_sum

        // Apply partial_lte_partial
        partial_lte_partial(function(i: Nat) { diag_row_contrib(a, b, m, i) }, row_sum(m.suc, prod_fn(a, b)), m.suc)
        partial(function(i: Nat) { diag_row_contrib(a, b, m, i) }, m.suc) <= partial(row_sum(m.suc, prod_fn(a, b)), m.suc)
        sum(map(m.suc.range, function(i: Nat) { diag_row_contrib(a, b, m, i) })) <= sum(map(m.suc.range, row_sum(m.suc, prod_fn(a, b))))

        // Connect to double_sum
        double_sum_row_expand(m.suc, m.suc, prod_fn(a, b))
        double_sum(m.suc, m.suc, prod_fn(a, b)) = sum(map(m.suc.range, row_sum(m.suc, prod_fn(a, b))))

        sum(map(m.suc.range, function(i: Nat) { diag_row_contrib(a, b, m, i) })) <= double_sum(m.suc, m.suc, prod_fn(a, b))
        cauchy_product(a, b, m) <= double_sum(m.suc, m.suc, prod_fn(a, b))
    }
}

// ///
// /// We prove this using partial_product_as_double_sum which shows that
// /// partial(a,m.suc) * partial(b,m.suc) = double_sum(m.suc, m.suc, prod_fn(a,b)).
// /// Each term in cauchy_product appears in the double_sum, and since all terms are nonnegative,
// /// the Cauchy product (a subset of terms) is bounded by the double_sum (all terms).
// ///
// /// The mathematical argument relies on the fact that for nonnegative sequences:
// /// Each cauchy_product term a(i)*b(m-i) appears in the expansion of ∑a(i) * ∑b(j),
// /// and the expansion contains additional nonnegative terms, so cauchy_product <= product of sums.
// ///
// /// STATUS: Blocked - Requires explicit proof that diagonal terms ⊆ full grid terms.
// /// The missing piece is showing: ∑_{i+j=m} a(i)b(j) <= ∑_{i,j≤m} a(i)b(j) for nonnegative a,b.
// /// This is mathematically obvious but needs formal infrastructure for subset sums.
// theorem double_sum_diagonal_bound(a: Nat -> Real, b: Nat -> Real, m: Nat) {
//     is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
//     implies
//     cauchy_product(a, b, m) <= double_sum(m.suc, m.suc, prod_fn(a, b))
// } by {
//     if is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0) {
//         // Use partial_product_as_double_sum to relate double_sum to product of partials
//         partial_product_as_double_sum(a, b, m.suc)
//         partial(a, m.suc) * partial(b, m.suc) = double_sum(m.suc, m.suc, prod_fn(a, b))
//
//         // Show partial sums are nonnegative
//         partial_nonneg(a, m.suc)
//         partial(a, m.suc) >= Real.0
//         partial_nonneg(b, m.suc)
//         partial(b, m.suc) >= Real.0
//
//         // Show cauchy_product is nonnegative
//         forall(k: Nat) {
//             cauchy_coefficient_nonneg(a, b, m, k)
//             cauchy_coefficient(a, b, m)(k) >= Real.0
//         }
//         is_lower_bound(cauchy_coefficient(a, b, m), Real.0)
//         partial_nonneg(cauchy_coefficient(a, b, m), m.suc)
//         sum(map(m.suc.range, cauchy_coefficient(a, b, m))) >= Real.0
//         cauchy_product(a, b, m) >= Real.0
//
//         // The key missing step: For nonnegative a, b we have
//         // cauchy_product(a,b,m) = ∑_{i+j=m} a(i)b(j) <= ∑_{i,j∈[0,m]} a(i)b(j) = (∑a(i))(∑b(j))
//         //
//         // This would require proving that the diagonal terms are a subset of all grid terms.
//         cauchy_product(a, b, m) <= partial(a, m.suc) * partial(b, m.suc)
//
//         // Combine with the equality from partial_product_as_double_sum
//         cauchy_product(a, b, m) <= double_sum(m.suc, m.suc, prod_fn(a, b))
//     }
// }

// TODO: These theorems require more infrastructure to prove completely.
// They are mathematically sound but need detailed subset sum or filtering lemmas.

// /// Helper: Each individual cauchy_product term can be bounded.
// /// For nonnegative a, b: cauchy_product(a,b,m) ≤ partial(a,m.suc) * partial(b,m.suc)
// ///
// /// Mathematical argument: cauchy_product sums a(k)*b(m-k) for k∈[0,m].
// /// Each such term appears in the double_sum expansion of partial(a,m.suc)*partial(b,m.suc)
// /// since k<m.suc and m-k<m.suc. The double_sum contains these plus additional nonnegative terms.
// theorem cauchy_term_bound(a: Nat -> Real, b: Nat -> Real, m: Nat) {
//     is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
//     implies
//     cauchy_product(a, b, m) <= partial(a, m.suc) * partial(b, m.suc)
// } by {
//     // Requires: Formal subset sum lemma
//     sorry
// }

// /// Helper to express the triangular region: sums a(i)*b(j) where i+j < n.
// define triangle_product(a: Nat -> Real, b: Nat -> Real, n: Nat, i: Nat, j: Nat) -> Real {
//     if i + j < n { a(i) * b(j) } else { Real.0 }
// }

// /// Lemma: partial(cauchy_seq(a, b), n) equals the double sum over the triangular region.
// /// TODO: This proof requires machinery for changing summation order.
// theorem partial_cauchy_as_triangle(a: Nat -> Real, b: Nat -> Real, n: Nat) {
//     partial(cauchy_seq(a, b), n) = double_sum(n, n, triangle_product(a, b, n))
// } by {
//     // Strategy:
//     // LHS = sum_{k=0}^{n-1} sum_{i=0}^{k} a(i)*b(k-i) (summing over k, then i)
//     // RHS = sum_{i=0}^{n-1} sum_{j=0}^{n-1} [i+j<n ? a(i)*b(j) : 0] (summing over i, then j)
//     // Both represent the same triangular set {(i,j) : i+j < n}, just in different order.
//     // Requires: Lemmas about Fubini/summation exchange for finite sums.
//     // DEFERRED: Need summation exchange infrastructure.
// }

// /// Helper: Cauchy product partial sums of nonnegative sequences are bounded by product of partial sums.
// /// For nonnegative sequences a and b:
// /// ∑_{k=0}^{n-1} (∑_{i=0}^{k} a_i * b_{k-i}) ≤ (∑_{i=0}^{n-1} a_i) * (∑_{j=0}^{n-1} b_j)
// ///
// /// The partial sum of the Cauchy sequence sums over all terms a(i)*b(j) where i+j < n (a triangular region).
// /// The product of partial sums sums over all terms a(i)*b(j) where i < n and j < n (a square region).
// /// Since the triangle is contained in the square and all terms are nonnegative, the result follows.
// theorem cauchy_partial_product_bound(a: Nat -> Real, b: Nat -> Real, n: Nat) {
//     is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
//     implies
//     partial(cauchy_seq(a, b), n) <= partial(a, n) * partial(b, n)
// } by {
//     if is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0) {
//         // Key insight: For all i, j with i+j < n, we have both i < n and j < n.
//         // Therefore triangle_product(a, b, n, i, j) <= prod_fn(a, b)(i)(j) when i < n and j < n.

//         forall(i: Nat, j: Nat) {
//             if i < n and j < n {
//                 if i + j < n {
//                     // When i+j < n, triangle_product equals the actual product
//                     triangle_product(a, b, n, i, j) = a(i) * b(j)
//                     prod_fn(a, b)(i)(j) = a(i) * b(j)
//                     triangle_product(a, b, n, i, j) = prod_fn(a, b)(i)(j)
//                 } else {
//                     // When i+j >= n, triangle_product is 0, which is <= the nonnegative product
//                     triangle_product(a, b, n, i, j) = Real.0
//                     prod_fn(a, b)(i)(j) = a(i) * b(j)

//                     // Both a(i) and b(j) are nonnegative
//                     is_lower_bound(a, Real.0)
//                     Real.0 <= a(i)
//                     is_lower_bound(b, Real.0)
//                     Real.0 <= b(j)
//                     mul_nonneg(a(i), b(j))
//                     Real.0 <= a(i) * b(j)
//                     Real.0 <= prod_fn(a, b)(i)(j)
//                     triangle_product(a, b, n, i, j) <= prod_fn(a, b)(i)(j)
//                 }
//                 triangle_product(a, b, n, i, j) <= prod_fn(a, b)(i)(j)
//             }
//         }

//         // TODO: Use pointwise comparison to conclude double_sum(n, n, triangle_product(a, b, n)) <= double_sum(n, n, prod_fn(a, b))
//         // TODO: Then use partial_cauchy_as_triangle and partial_product_as_double_sum

//         sorry
//     }
// }

// /// Mertens' Theorem: The Cauchy product of two absolutely convergent series converges absolutely.
// /// This is the key result needed to prove e^x * e^y = e^(x+y).
// theorem cauchy_product_abs_converges(a: Nat -> Real, b: Nat -> Real) {
//     absolutely_converges(a) and absolutely_converges(b)
//     implies
//     absolutely_converges(cauchy_seq(a, b))
// } by {
//     from real.real_series import comparison_test, monotone_convergence_principle, nonneg_partial_increasing

//     if absolutely_converges(a) and absolutely_converges(b) {
//         // Strategy: Show that partial(abs_fn(cauchy_seq(a, b))) is bounded and increasing

//         // First, note that abs_fn(cauchy_seq(a, b)) is bounded by cauchy_seq(abs_fn(a), abs_fn(b))
//         forall(n: Nat) {
//             // |cauchy_seq(a, b)(n)| = |cauchy_product(a, b, n)| <= cauchy_product(abs_fn(a), abs_fn(b), n)
//             cauchy_product_abs_bound(a, b, n)
//             abs(cauchy_product(a, b, n)) <= cauchy_product(abs_fn(a), abs_fn(b), n)
//             cauchy_seq(a, b)(n) = cauchy_product(a, b, n)
//             abs(cauchy_seq(a, b)(n)) <= cauchy_product(abs_fn(a), abs_fn(b), n)
//             abs_fn(cauchy_seq(a, b))(n) = abs(cauchy_seq(a, b)(n))
//             cauchy_seq(abs_fn(a), abs_fn(b))(n) = cauchy_product(abs_fn(a), abs_fn(b), n)
//             abs_fn(cauchy_seq(a, b))(n) <= cauchy_seq(abs_fn(a), abs_fn(b))(n)
//         }

//         // Therefore: forall n, abs_fn(cauchy_seq(a, b))(n) <= cauchy_seq(abs_fn(a), abs_fn(b))(n)
//         seq_lte(abs_fn(cauchy_seq(a, b)), cauchy_seq(abs_fn(a), abs_fn(b)))

//         // By partial_seq_lte: partial(abs_fn(cauchy_seq(a, b))) <= partial(cauchy_seq(abs_fn(a), abs_fn(b)))
//         forall(n: Nat) {
//             partial_lte_partial(abs_fn(cauchy_seq(a, b)), cauchy_seq(abs_fn(a), abs_fn(b)), n)
//             partial(abs_fn(cauchy_seq(a, b)), n) <= partial(cauchy_seq(abs_fn(a), abs_fn(b)), n)
//         }

//         // Now use cauchy_partial_product_bound on abs_fn(a) and abs_fn(b)
//         // abs_fn(a) and abs_fn(b) are nonnegative
//         forall(n: Nat) {
//             abs_fn_nonneg(a, n)
//             abs_fn(a)(n) >= Real.0
//             abs_fn_nonneg(b, n)
//             abs_fn(b)(n) >= Real.0
//         }
//         is_lower_bound(abs_fn(a), Real.0)
//         is_lower_bound(abs_fn(b), Real.0)

//         forall(n: Nat) {
//             // Apply cauchy_partial_product_bound
//             cauchy_partial_product_bound(abs_fn(a), abs_fn(b), n)
//             partial(cauchy_seq(abs_fn(a), abs_fn(b)), n) <= partial(abs_fn(a), n) * partial(abs_fn(b), n)

//             // Since absolutely_converges(a), we have converges(partial(abs_fn(a)))
//             // So partial(abs_fn(a), n) <= limit(partial(abs_fn(a)))
//             absolutely_converges(a)
//             converges(partial(abs_fn(a)))

//             absolutely_converges(b)
//             converges(partial(abs_fn(b)))

//             // Both partial(abs_fn(a)) and partial(abs_fn(b)) are bounded
//             // Let L_a = limit(partial(abs_fn(a))) and L_b = limit(partial(abs_fn(b)))
//             // Then partial(abs_fn(a), n) <= L_a and partial(abs_fn(b), n) <= L_b
//             // So partial(abs_fn(a), n) * partial(abs_fn(b), n) <= L_a * L_b
//         }

//         // Therefore, partial(cauchy_seq(abs_fn(a), abs_fn(b))) is bounded above
//         // By transitivity: partial(abs_fn(cauchy_seq(a, b)), n) <= partial(abs_fn(a), n) * partial(abs_fn(b), n)

//         // Since partial(abs_fn(cauchy_seq(a, b))) is increasing (being a partial sum of nonnegative terms)
//         // and bounded above, it converges by monotone_convergence_principle

//         // abs_fn(cauchy_seq(a, b)) is nonnegative
//         forall(n: Nat) {
//             abs_fn_nonneg(cauchy_seq(a, b), n)
//             abs_fn(cauchy_seq(a, b))(n) >= Real.0
//         }
//         is_lower_bound(abs_fn(cauchy_seq(a, b)), Real.0)

//         // Therefore partial(abs_fn(cauchy_seq(a, b))) is increasing
//         forall(n: Nat) {
//             nonneg_partial_increasing(abs_fn(cauchy_seq(a, b)), n)
//         }

//         // TODO: Show that partial(abs_fn(cauchy_seq(a, b))) is bounded above
//         // Then apply monotone_convergence_principle

//         sorry
//     }
// }
