from util import constant, compose
from nat import Nat
from rat import Rat
from list import partial, sum, map, List
from list.list_functional import reverse, sum_reverse, reverse_get_idx
from list.list_sum import map_range, list_extensionality
from option import Option
from real.real_ring import Real, converges, converges_to, limit, lift_seq

numerals Real

// This file defines the Cauchy product of two series and proves theorems about it.

attributes Real {
    // Placeholder to let other modules import Real from here.
}

/// The coefficient function for the Cauchy product at index n.
/// For a fixed n, this returns a function mapping k to a(k) * b(n-k).
define cauchy_coefficient(a: Nat -> Real, b: Nat -> Real, n: Nat) -> (Nat -> Real) {
    function(k: Nat) { a(k) * b(n - k) }
}

/// The Cauchy product of two sequences at index n.
/// This computes âˆ‘_{k=0}^{n} a(k) * b(n-k).
define cauchy_product(a: Nat -> Real, b: Nat -> Real, n: Nat) -> Real {
    sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// The sequence of Cauchy products.
define cauchy_seq(a: Nat -> Real, b: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { cauchy_product(a, b, n) }
}

theorem cauchy_product_zero(a: Nat -> Real, b: Nat -> Real) {
    cauchy_product(a, b, Nat.0) = a(Nat.0) * b(Nat.0)
} by {
    Nat.0.suc = Nat.1
    Nat.1.range = List.singleton(Nat.0)
    let mapped = map(Nat.1.range, function(k: Nat) { a(k) * b(Nat.0 - k) })
    Nat.0 - Nat.0 = Nat.0
    mapped = List.singleton(a(Nat.0) * b(Nat.0))
    sum(mapped) = a(Nat.0) * b(Nat.0)
}

/// If we map a list with a function that always returns zero, the sum is zero.
theorem sum_map_zero[T](items: List[T], f: T -> Real) {
    (forall(x: T) { f(x) = Real.0 })
    implies
    sum(map(items, f)) = Real.0
} by {
    define p(xs: List[T]) -> Bool {
        (forall(x: T) { f(x) = Real.0 })
        implies
        sum(map(xs, f)) = Real.0
    }

    // Base case: empty list
    map(List.nil[T], f) = List.nil[Real]
    sum(List.nil[Real]) = Real.0
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if forall(x: T) { f(x) = Real.0 } {
                // Apply the hypothesis to tail
                sum(map(tail, f)) = Real.0

                // Now work on the cons case
                map(List.cons(head, tail), f) = List.cons(f(head), map(tail, f))
                sum(List.cons(f(head), map(tail, f))) = f(head) + sum(map(tail, f))
                f(head) = Real.0
                sum(List.cons(f(head), map(tail, f))) = Real.0 + Real.0
                sum(List.cons(f(head), map(tail, f))) = Real.0
                sum(map(List.cons(head, tail), f)) = Real.0
            }
            p(List.cons(head, tail))
        }
    }
}

/// If a is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_left(b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n)(k) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    a(k) = Real.0
    Real.0 * b(n - k) = Real.0
}

/// If a is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_left_fn(b: Nat -> Real, n: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n) = constant[Nat, Real](Real.0)
} by {
    let a = constant[Nat, Real](Real.0)
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
}

/// If b is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_right(a: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n)(k) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    b(n - k) = Real.0
    a(k) * Real.0 = Real.0
}

/// If b is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_right_fn(a: Nat -> Real, n: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n) = constant[Nat, Real](Real.0)
} by {
    let b = constant[Nat, Real](Real.0)
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
}

/// Helper lemma: reverse of mapped range with cauchy_coefficient equals mapped range with swapped coefficients.
theorem cauchy_reverse_map_eq(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    reverse(map(n.suc.range, cauchy_coefficient(a, b, n))) =
    map(n.suc.range, cauchy_coefficient(b, a, n))
} by {
    let left_list = reverse(map(n.suc.range, cauchy_coefficient(a, b, n)))
    let right_list = map(n.suc.range, cauchy_coefficient(b, a, n))

    // Both lists have the same length
    left_list.length = map(n.suc.range, cauchy_coefficient(a, b, n)).length
    map(n.suc.range, cauchy_coefficient(a, b, n)).length = n.suc.range.length
    n.suc.range.length = n.suc
    right_list.length = map(n.suc.range, cauchy_coefficient(b, a, n)).length
    map(n.suc.range, cauchy_coefficient(b, a, n)).length = n.suc.range.length
    left_list.length = right_list.length

    // Show they agree at every index
    forall(idx: Nat) {
        if idx < left_list.length {
            // idx < n.suc
            idx < n.suc

            // Element of left_list at idx using reverse_get_idx
            let mapped = map(n.suc.range, cauchy_coefficient(a, b, n))
            reverse_get_idx(mapped, idx)
            mapped.length = n.suc
            left_list.get_idx(idx) = mapped.get_idx(mapped.length - Nat.1 - idx)

            // mapped.length - 1 - idx = n - idx
            mapped.length - Nat.1 - idx = n - idx

            // Show n - idx < n.suc
            n - idx <= n
            n < n.suc
            n - idx < n.suc

            // Apply map_range with cauchy_coefficient
            map_range(n.suc, n - idx, cauchy_coefficient(a, b, n))
            mapped.get_idx(n - idx) = Option.some(cauchy_coefficient(a, b, n)(n - idx))

            // Expand cauchy_coefficient
            cauchy_coefficient(a, b, n)(n - idx) = a(n - idx) * b(n - (n - idx))
            n - (n - idx) = idx
            cauchy_coefficient(a, b, n)(n - idx) = a(n - idx) * b(idx)

            left_list.get_idx(idx) = Option.some(a(n - idx) * b(idx))

            // By commutativity
            a(n - idx) * b(idx) = b(idx) * a(n - idx)

            // Element of right_list at idx
            map_range(n.suc, idx, cauchy_coefficient(b, a, n))
            right_list.get_idx(idx) = Option.some(cauchy_coefficient(b, a, n)(idx))

            // Expand cauchy_coefficient
            cauchy_coefficient(b, a, n)(idx) = b(idx) * a(n - idx)

            // Therefore they're equal
            left_list.get_idx(idx) = Option.some(b(idx) * a(n - idx))
            left_list.get_idx(idx) = right_list.get_idx(idx)
        }
    }

    // Apply list extensionality
    list_extensionality(left_list, right_list)
    left_list = right_list
}

/// Cauchy product is commutative.
theorem cauchy_product_comm(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, b, n) = cauchy_product(b, a, n)
} by {
    // Expand definitions
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(b, a, n) = sum(map(n.suc.range, cauchy_coefficient(b, a, n)))

    // Use sum_reverse
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = sum(reverse(map(n.suc.range, cauchy_coefficient(a, b, n))))

    // Use helper lemma
    cauchy_reverse_map_eq(a, b, n)
    reverse(map(n.suc.range, cauchy_coefficient(a, b, n))) = map(n.suc.range, cauchy_coefficient(b, a, n))

    // Combine
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = sum(map(n.suc.range, cauchy_coefficient(b, a, n)))
}

/// Cauchy product with a zero sequence on the left.
theorem cauchy_product_zero_left(b: Nat -> Real, n: Nat) {
    cauchy_product(constant[Nat, Real](Real.0), b, n) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)

    // Show that cauchy_coefficient equals the constant zero function
    cauchy_coefficient(a, b, n) = constant[Nat, Real](Real.0)

    // Therefore every application returns zero
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
    }

    // Apply sum_map_zero
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0

    // This is the definition of cauchy_product
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(a, b, n) = Real.0
}

/// Cauchy product with a zero sequence on the right.
theorem cauchy_product_zero_right(a: Nat -> Real, n: Nat) {
    cauchy_product(a, constant[Nat, Real](Real.0), n) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)

    // Show that cauchy_coefficient equals the constant zero function
    cauchy_coefficient(a, b, n) = constant[Nat, Real](Real.0)

    // Therefore every application returns zero
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
    }

    // Apply sum_map_zero
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0

    // This is the definition of cauchy_product
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(a, b, n) = Real.0
}
