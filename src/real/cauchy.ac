from util import constant, compose
from nat import Nat
from list import partial, sum, map, List
from list.list_functional import reverse, reverse_get_idx
from list.list_sum import map_range, list_extensionality, scalar_mul
from option import Option
from real.real_ring import Real
from semigroup import mul_fn
from add_semigroup import add_fn

numerals Real

// This file defines the Cauchy product of two series and proves theorems about it.

attributes Real {
    // Placeholder to let other modules import Real from here.
}

/// The coefficient function for the Cauchy product at index n.
/// For a fixed n, this returns a function mapping k to a(k) * b(n-k).
define cauchy_coefficient(a: Nat -> Real, b: Nat -> Real, n: Nat) -> (Nat -> Real) {
    function(k: Nat) { a(k) * b(n - k) }
}

/// The Cauchy product of two sequences at index n.
/// This computes ∑_{k=0}^{n} a(k) * b(n-k).
define cauchy_product(a: Nat -> Real, b: Nat -> Real, n: Nat) -> Real {
    sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// The sequence of Cauchy products.
define cauchy_seq(a: Nat -> Real, b: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { cauchy_product(a, b, n) }
}

theorem cauchy_product_zero(a: Nat -> Real, b: Nat -> Real) {
    cauchy_product(a, b, Nat.0) = a(Nat.0) * b(Nat.0)
} by {
    let mapped = map(Nat.1.range, function(k: Nat) { a(k) * b(Nat.0 - k) })
}

/// If we map a list with a function that always returns zero, the sum is zero.
theorem sum_map_zero[T](items: List[T], f: T -> Real) {
    (forall(x: T) { f(x) = Real.0 })
    implies
    sum(map(items, f)) = Real.0
} by {
    define p(xs: List[T]) -> Bool {
        (forall(x: T) { f(x) = Real.0 })
        implies
        sum(map(xs, f)) = Real.0
    }

    // Base case: empty list
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if forall(x: T) { f(x) = Real.0 } {
            }
            p(List.cons(head, tail))
        }
    }
}

/// If a is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_left(b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n)(k) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)
}

/// If a is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_left_fn(b: Nat -> Real, n: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n) = constant[Nat, Real](Real.0)
} by {
    let a = constant[Nat, Real](Real.0)
}

/// If b is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_right(a: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n)(k) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
}

/// If b is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_right_fn(a: Nat -> Real, n: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n) = constant[Nat, Real](Real.0)
} by {
    let b = constant[Nat, Real](Real.0)
}

/// Helper lemma: reverse of mapped range with cauchy_coefficient equals mapped range with swapped coefficients.
theorem cauchy_reverse_map_eq(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    reverse(map(n.suc.range, cauchy_coefficient(a, b, n))) =
    map(n.suc.range, cauchy_coefficient(b, a, n))
} by {
    let left_list = reverse(map(n.suc.range, cauchy_coefficient(a, b, n)))
    let right_list = map(n.suc.range, cauchy_coefficient(b, a, n))

    left_list.length = right_list.length

    forall(idx: Nat) {
        if idx < left_list.length {
            idx < n.suc

            let mapped = map(n.suc.range, cauchy_coefficient(a, b, n))
            reverse_get_idx(mapped, idx)

            n - idx <= n

            map_range(n.suc, n - idx, cauchy_coefficient(a, b, n))
            mapped.get_idx(n - idx) = Option.some(cauchy_coefficient(a, b, n)(n - idx))

            n - (n - idx) = idx

            map_range(n.suc, idx, cauchy_coefficient(b, a, n))

            left_list.get_idx(idx) = right_list.get_idx(idx)
        }
    }

    list_extensionality(left_list, right_list)
}

/// Cauchy product is commutative.
theorem cauchy_product_comm(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, b, n) = cauchy_product(b, a, n)
} by {
    cauchy_reverse_map_eq(a, b, n)
}

/// Cauchy product with a zero sequence on the left.
theorem cauchy_product_zero_left(b: Nat -> Real, n: Nat) {
    cauchy_product(constant[Nat, Real](Real.0), b, n) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)

    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0
}

/// Cauchy product with a zero sequence on the right.
theorem cauchy_product_zero_right(a: Nat -> Real, n: Nat) {
    cauchy_product(a, constant[Nat, Real](Real.0), n) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
}

/// Helper lemma: cauchy_coefficient distributes scalar multiplication in the first argument.
theorem cauchy_coefficient_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(mul_fn(c, a), b, n)(k) = c * cauchy_coefficient(a, b, n)(k)
}

/// Linearity in the first argument: scalar multiplication factors out.
theorem cauchy_product_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(mul_fn(c, a), b, n) = c * cauchy_product(a, b, n)
} by {
    cauchy_coefficient(mul_fn(c, a), b, n) = compose(scalar_mul(c), cauchy_coefficient(a, b, n))

    sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c))) = c * sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// Helper lemma: cauchy_coefficient distributes scalar multiplication in the second argument.
theorem cauchy_coefficient_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, mul_fn(c, b), n)(k) = c * cauchy_coefficient(a, b, n)(k)
}

/// Linearity in the second argument: scalar multiplication factors out.
theorem cauchy_product_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, mul_fn(c, b), n) = c * cauchy_product(a, b, n)
}

/// Helper lemma: cauchy_coefficient distributes addition in the first argument.
theorem cauchy_coefficient_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(add_fn(a, aa), b, n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
} by {
    a(k) * b(n - k) + aa(k) * b(n - k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
}

/// Distributivity in the first argument: addition distributes through the Cauchy product.
theorem cauchy_product_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(add_fn(a, aa), b, n) = cauchy_product(a, b, n) + cauchy_product(aa, b, n)
} by {
    cauchy_coefficient(add_fn(a, aa), b, n) = add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n))
}

/// Helper lemma: cauchy_coefficient distributes addition in the second argument.
theorem cauchy_coefficient_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, add_fn(b, bb), n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
} by {
    a(k) * b(n - k) + a(k) * bb(n - k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
}

/// Distributivity in the second argument: addition distributes through the Cauchy product.
theorem cauchy_product_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat) {
    cauchy_product(a, add_fn(b, bb), n) = cauchy_product(a, b, n) + cauchy_product(a, bb, n)
}

/// Partial sum of Cauchy product with zero sequence on the left is zero.
theorem partial_cauchy_zero_left(b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(constant[Nat, Real](Real.0), b), n) = Real.0
} by {
    cauchy_seq(constant[Nat, Real](Real.0), b) = constant[Nat, Real](Real.0)
}

/// Partial sum of Cauchy product with zero sequence on the right is zero.
theorem partial_cauchy_zero_right(a: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, constant[Nat, Real](Real.0)), n) = Real.0
} by {
    cauchy_seq(a, constant[Nat, Real](Real.0)) = constant[Nat, Real](Real.0)
}

/// Partial sum distributes over addition in the first argument.
theorem partial_cauchy_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(add_fn(a, aa), b), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(aa, b), n)
}

/// Partial sum distributes over addition in the second argument.
theorem partial_cauchy_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, add_fn(b, bb)), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(a, bb), n)
}

/// Scalar multiplication factors out of partial sum in the first argument.
theorem partial_cauchy_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(mul_fn(c, a), b), n) = c * partial(cauchy_seq(a, b), n)
}

/// Scalar multiplication factors out of partial sum in the second argument.
theorem partial_cauchy_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, mul_fn(c, b)), n) = c * partial(cauchy_seq(a, b), n)
}

// Import additional definitions for the Cauchy product theorem
from real.rectangular_sum import rectangular_sum, nonneg_fn_2, prod_fn, product_sum, product_sum_factors
from real.triangular_sum import triangular_sum, diagonal, diagonal_sum, triangular_sum_step
from real.double_sum import double_sum, double_sum_converges, abs_fn_2
from real.abs_conv import absolutely_converges, abs_fn
from real.real_seq import converges, converges_to, limit

/// The Cauchy coefficient equals the diagonal function.
theorem cauchy_coefficient_eq_diagonal(a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, b, n)(k) = diagonal(prod_fn(a, b), n, k)
}

/// The Cauchy product equals a diagonal sum.
/// This shows that cauchy_product(a, b, n) = sum_{i=0}^n a(i) * b(n - i).
theorem cauchy_product_eq_diagonal(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, b, n) = diagonal_sum(prod_fn(a, b), n)
} by {
    // Both are defined as sums over the same function
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    diagonal_sum(prod_fn(a, b), n) = partial(diagonal(prod_fn(a, b), n), n.suc)
    partial(diagonal(prod_fn(a, b), n), n.suc) = sum(map(n.suc.range, diagonal(prod_fn(a, b), n)))

    // Show the functions are equal
    forall(k: Nat) {
        cauchy_coefficient_eq_diagonal(a, b, n, k)
        cauchy_coefficient(a, b, n)(k) = diagonal(prod_fn(a, b), n, k)
    }
    cauchy_coefficient(a, b, n) = diagonal(prod_fn(a, b), n)
}

/// The Cauchy product as a triangular sum.
/// For a fixed K, this computes the sum of all products a(i) * b(j) where i + j <= K.
define cauchy_triangular(a: Nat -> Real, b: Nat -> Real, k: Nat) -> Real {
    triangular_sum(prod_fn(a, b), k.suc)
}

/// The Cauchy product partial sum equals the triangular sum.
/// This shows that sum_{i=0}^k cauchy_product(a, b, i) = sum_{m+n<=k} a(m) * b(n).
theorem cauchy_product_eq_triangular(a: Nat -> Real, b: Nat -> Real, k: Nat) {
    partial(cauchy_seq(a, b), k.suc) = cauchy_triangular(a, b, k)
} by {
    // Use the fact that triangular_sum extends by diagonal_sum
    // and cauchy_product equals diagonal_sum

    cauchy_triangular(a, b, k) = triangular_sum(prod_fn(a, b), k.suc)

    // Prove by induction on k
    define p(n: Nat) -> Bool {
        partial(cauchy_seq(a, b), n.suc) = triangular_sum(prod_fn(a, b), n.suc)
    }

    // Base case: n = 0
    cauchy_seq(a, b, Nat.0) = cauchy_product(a, b, Nat.0)
    partial(cauchy_seq(a, b), Nat.1) = Real.0 + cauchy_seq(a, b, Nat.0)
    partial(cauchy_seq(a, b), Nat.1) = cauchy_product(a, b, Nat.0)

    cauchy_product_eq_diagonal(a, b, Nat.0)
    cauchy_product(a, b, Nat.0) = diagonal_sum(prod_fn(a, b), Nat.0)

    // triangular_sum(prod_fn(a, b), 1) = triangular_sum(..., 0) + diagonal_sum(..., 0)
    triangular_sum_step(prod_fn(a, b), Nat.0)
    triangular_sum(prod_fn(a, b), Nat.1) = triangular_sum(prod_fn(a, b), Nat.0) + diagonal_sum(prod_fn(a, b), Nat.0)
    triangular_sum(prod_fn(a, b), Nat.0) = Real.0
    triangular_sum(prod_fn(a, b), Nat.1) = diagonal_sum(prod_fn(a, b), Nat.0)

    partial(cauchy_seq(a, b), Nat.1) = triangular_sum(prod_fn(a, b), Nat.1)
    p(Nat.0)

    // Inductive step
    forall(n: Nat) {
        if p(n) {
            // IH: partial(cauchy_seq(a, b), n.suc) = triangular_sum(prod_fn(a, b), n.suc)
            // Want: partial(cauchy_seq(a, b), n.suc.suc) = triangular_sum(prod_fn(a, b), n.suc.suc)

            partial(cauchy_seq(a, b), n.suc.suc) = partial(cauchy_seq(a, b), n.suc) + cauchy_seq(a, b, n.suc)
            cauchy_seq(a, b, n.suc) = cauchy_product(a, b, n.suc)

            cauchy_product_eq_diagonal(a, b, n.suc)
            cauchy_product(a, b, n.suc) = diagonal_sum(prod_fn(a, b), n.suc)

            partial(cauchy_seq(a, b), n.suc.suc) = partial(cauchy_seq(a, b), n.suc) + diagonal_sum(prod_fn(a, b), n.suc)
            partial(cauchy_seq(a, b), n.suc.suc) = triangular_sum(prod_fn(a, b), n.suc) + diagonal_sum(prod_fn(a, b), n.suc)

            triangular_sum_step(prod_fn(a, b), n.suc)
            triangular_sum(prod_fn(a, b), n.suc.suc) = triangular_sum(prod_fn(a, b), n.suc) + diagonal_sum(prod_fn(a, b), n.suc)

            partial(cauchy_seq(a, b), n.suc.suc) = triangular_sum(prod_fn(a, b), n.suc.suc)
            p(n.suc)
        }
    }

    p(k)
    partial(cauchy_seq(a, b), k.suc) = triangular_sum(prod_fn(a, b), k.suc)
}

from real.triangular_sum import triangular_sum_converges_to_double_sum
from real.double_limit import doubly_increasing, double_image_is_supremum, double_is_upper_bound, doubly_increasing_bounded_converges, double_image, double_converges
from real.real_series import increasing_convergent_bounded_by_limit, is_increasing, is_upper_bound, nonneg_seq, nonneg_imp_partial_increasing, partial_nonneg
from real.double_sum import rectangular_sum_doubly_increasing
from real.real_seq import converges_to_imp_converges, converges_imp_converges_to

/// The absolute value of the product function equals the product of absolute values.
theorem abs_prod_fn(a: Nat -> Real, b: Nat -> Real, m: Nat, n: Nat) {
    abs_fn_2(prod_fn(a, b), m, n) = abs_fn(a, m) * abs_fn(b, n)
}

/// Rectangular sum of absolute product equals product of absolute partial sums.
theorem rectangular_abs_product(a: Nat -> Real, b: Nat -> Real, m: Nat, n: Nat) {
    rectangular_sum(abs_fn_2(prod_fn(a, b)), m, n) = partial(abs_fn(a), m) * partial(abs_fn(b), n)
} by {
    // abs_fn_2(prod_fn(a, b)) = prod_fn(abs_fn(a), abs_fn(b))
    forall(i: Nat, j: Nat) {
        abs_prod_fn(a, b, i, j)
        abs_fn_2(prod_fn(a, b), i, j) = abs_fn(a, i) * abs_fn(b, j)
        prod_fn(abs_fn(a), abs_fn(b), i, j) = abs_fn(a, i) * abs_fn(b, j)
        abs_fn_2(prod_fn(a, b), i, j) = prod_fn(abs_fn(a), abs_fn(b), i, j)
    }
    abs_fn_2(prod_fn(a, b)) = prod_fn(abs_fn(a), abs_fn(b))

    rectangular_sum(abs_fn_2(prod_fn(a, b)), m, n) = rectangular_sum(prod_fn(abs_fn(a), abs_fn(b)), m, n)
    rectangular_sum(prod_fn(abs_fn(a), abs_fn(b)), m, n) = product_sum(abs_fn(a), abs_fn(b), m, n)
    product_sum_factors(abs_fn(a), abs_fn(b), m, n)
    product_sum(abs_fn(a), abs_fn(b), m, n) = partial(abs_fn(a), m) * partial(abs_fn(b), n)
}

// TODO: Complete the absolute convergence theorem for product series.
// The proof is nearly complete - all the key steps are proven except for showing
// that limit(partial(abs_fn(a))) * limit(partial(abs_fn(b))) is the *least* upper bound.
//
// Proof outline (steps 1-5 are proven above):
// 1. abs_fn_2(prod_fn(a, b)) is nonnegative ✓
// 2. rectangular_sum is doubly increasing ✓
// 3. rectangular_sum equals product of partial sums ✓
// 4. partial sums are bounded by limits ✓
// 5. rectangular sums bounded by limit_a * limit_b ✓
// 6. Need: Show supremum = limit_a * limit_b (least upper bound property)
//    - Use limit_prod_seq: prod_seq(partial(abs_fn(a)), partial(abs_fn(b))) → limit_a * limit_b
//    - Show that rectangular_sum values get arbitrarily close to this limit
//    - This requires a lemma about 2D sequences vs diagonal sequences
// 7. Apply doubly_increasing_bounded_converges
//
// theorem product_abs_convergent(a: Nat -> Real, b: Nat -> Real) {
//     absolutely_converges(a) and absolutely_converges(b)
//     implies
//     double_sum_converges(abs_fn_2(prod_fn(a, b)))
// }