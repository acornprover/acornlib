from util import constant, compose
from nat import Nat
from nat.nat_base import add_comm, add_sub, lt_add_left, lte_imp_not_lt, lt_imp_lt_suc, lt_suc
from list import partial, sum, map, List
from list.list_functional import reverse, sum_reverse, reverse_get_idx
from list.list_sum import map_range, list_extensionality, sum_scalar_mul, map_sum_add, scalar_mul, map_map, map_add, sum_add
from option import Option
from real.real_ring import Real, converges, converges_to, limit, lift_seq, zero_lte_imp_non_neg, real_mul_comm, lte_mul_nonneg_right, mul_zero_right, mul_neg_one_left
from real.real_seq import limit_add_seq, converges_imp_converges_to, converges_to_imp_converges, converges_to_unique, abs_lt_imp_close_to_zero, tail_bound
from real.real_series import seq_lte, is_lower_bound, add_seq, mul_seq, const_converges, const_limit, neg_seq, mul_seq_converges_to
from real.limits import vanishes, abs_seq, abs_abs
from real.real_base import lte_add_left, lte_add_right, lte_trans, sub_moves_sides, add_zero_left, add_zero_right, add_assoc, add_neg_eq_zero, neg_neg, abs_neg
from semigroup import mul_fn
from add_semigroup import add_fn
from real.double_sum import double_sum, row_sum, row_val, double_sum_expands, double_sum_row_expand, prod_fn, partial_product_as_double_sum
from real.double_sum import mul_nonneg, mul_le_mul_nonneg, cond_part, diag_cond_prod, diag_row_contrib, diag_row_contrib_eq, sum_cond_le_sum_1d
from real.double_sum import partial_lte_partial, double_sum_pointwise_le, double_sum_pointwise_add, diagonal_val, diagonal_sum, triangle_fn, finite_double_sum_exchange, partial_mul_scalar_right

numerals Real

// This file defines the Cauchy product of two series and proves theorems about it.

attributes Real {
    // Placeholder to let other modules import Real from here.
}

/// Evaluate the ith sequence in a family at index n.
define family_eval(f: Nat -> (Nat -> Real), i: Nat, n: Nat) -> Real {
    f(i)(n)
}

/// For a fixed n, view the family as a function of the index i.
define finite_sum_terms(f: Nat -> (Nat -> Real), n: Nat) -> (Nat -> Real) {
    function(i: Nat) { family_eval(f, i, n) }
}

/// Sum the first m sequences in the family at index n.
define finite_sum_value(f: Nat -> (Nat -> Real), m: Nat, n: Nat) -> Real {
    sum(map(m.range, finite_sum_terms(f, n)))
}

/// The sequence obtained by summing the first m sequences in the family.
define finite_sum_seq(f: Nat -> (Nat -> Real), m: Nat) -> (Nat -> Real) {
    function(n: Nat) { finite_sum_value(f, m, n) }
}

/// Summing zero sequences produces the zero sequence.
theorem finite_sum_value_zero(f: Nat -> (Nat -> Real), n: Nat) {
    finite_sum_value(f, Nat.0, n) = Real.0
} by {
    sum(List.nil[Real]) = Real.0
}

/// Splitting off the last sequence in the finite family turns the sum into an addition.
theorem finite_sum_value_suc(f: Nat -> (Nat -> Real), m: Nat, n: Nat) {
    finite_sum_value(f, m.suc, n) = finite_sum_value(f, m, n) + f(m)(n)
} by {
    let terms = finite_sum_terms(f, n)

    sum(map(List.singleton(m), terms)) = f(m)(n)

}

/// Successor sums agree pointwise with the addition of the previous sum and the extra term.
theorem finite_sum_seq_suc_eq_add(f: Nat -> (Nat -> Real), m: Nat, n: Nat) {
    finite_sum_seq(f, m.suc)(n) = add_seq(finite_sum_seq(f, m), f(m))(n)
}

/// The sum of two vanishing sequences also vanishes.
theorem add_seq_vanishes(a: Nat -> Real, b: Nat -> Real) {
    converges_to(a, Real.0) and converges_to(b, Real.0)
    implies
    converges_to(add_seq(a, b), Real.0)
} by {
    if converges_to(a, Real.0) and converges_to(b, Real.0) {
        converges_to_imp_converges(a, Real.0)
        converges_imp_converges_to(a)
        converges_to_unique(a, limit(a), Real.0)

        converges_to_imp_converges(b, Real.0)
        converges_imp_converges_to(b)
        converges_to_unique(b, limit(b), Real.0)

        limit_add_seq(a, b)
        add_zero_right(Real.0)
        converges_to(add_seq(a, b), Real.0)
    }
}

/// A finite sum of vanishing sequences also vanishes.
theorem finite_sum_vanishes(f: Nat -> (Nat -> Real), m: Nat) {
    (forall(i: Nat) { i < m implies converges_to(f(i), Real.0) })
    implies
    converges_to(finite_sum_seq(f, m), Real.0)
} by {
    define p(k: Nat) -> Bool {
        (forall(i: Nat) { i < k implies converges_to(f(i), Real.0) })
        implies
        converges_to(finite_sum_seq(f, k), Real.0)
    }

    // Base case: empty sum equals the zero sequence.
    if forall(i: Nat) { i < Nat.0 implies converges_to(f(i), Real.0) } {
        finite_sum_seq(f, Nat.0) = constant[Nat, Real](Real.0)
        converges_to(finite_sum_seq(f, Nat.0), Real.0)
    }

    // Inductive step: add the next vanishing sequence.
    forall(k: Nat) {
        if p(k) {
            if forall(i: Nat) { i < k.suc implies converges_to(f(i), Real.0) } {
                // Establish the hypothesis for the first k indices.

                lt_suc(k)

                add_seq_vanishes(finite_sum_seq(f, k), f(k))

                finite_sum_seq(f, k.suc) = add_seq(finite_sum_seq(f, k), f(k))
                converges_to(finite_sum_seq(f, k.suc), Real.0)
            }
            p(k.suc)
        }
    }

    p(m)
}

/// The coefficient function for the Cauchy product at index n.
/// For a fixed n, this returns a function mapping k to a(k) * b(n-k).
define cauchy_coefficient(a: Nat -> Real, b: Nat -> Real, n: Nat) -> (Nat -> Real) {
    function(k: Nat) { a(k) * b(n - k) }
}

/// The Cauchy product of two sequences at index n.
/// This computes ∑_{k=0}^{n} a(k) * b(n-k).
define cauchy_product(a: Nat -> Real, b: Nat -> Real, n: Nat) -> Real {
    sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// The sequence of Cauchy products.
define cauchy_seq(a: Nat -> Real, b: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { cauchy_product(a, b, n) }
}

/// Difference between two partial sums of the same series.
define partial_diff(f: Nat -> Real, m: Nat, n: Nat) -> Real {
    partial(f, n) - partial(f, m)
}

/// Difference between the limit of partial sums and the mth partial sum.
define tail_limit_diff(f: Nat -> Real, m: Nat) -> Real {
    limit(partial(f)) - partial(f, m)
}

/// Pointwise difference of two sequences.
define sub_seq(s: Nat -> Real, t: Nat -> Real, n: Nat) -> Real {
    s(n) - t(n)
}

/// Absolute value of the difference between two sequences.
define abs_diff_seq(s: Nat -> Real, t: Nat -> Real, n: Nat) -> Real {
    sub_seq(s, t, n).abs
}

/// Two sequences differ by a vanishing amount.
define vanishing_diff(s: Nat -> Real, t: Nat -> Real) -> Bool {
    vanishes(abs_diff_seq(s, t))
}

/// A sequence vanishes if and only if its absolute value sequence vanishes.
theorem vanishes_of_abs_seq(a: Nat -> Real) {
    vanishes(abs_seq(a))
    implies
    vanishes(a)
} by {
    if vanishes(abs_seq(a)) {
        // Extract convergence information for the absolute sequence.
        converges(abs_seq(a))
        limit(abs_seq(a)) = Real.0
        converges_imp_converges_to(abs_seq(a))
        converges_to_unique(abs_seq(a), limit(abs_seq(a)), Real.0)

        // Establish convergence of a by bounding its tail via the absolute sequence.
        forall(eps: Real) {
            if eps.is_positive {
                let n: Nat satisfy {
                    tail_bound(abs_seq(a), Real.0, n, eps)
                }
                forall(i: Nat) {
                    if n <= i {
                        abs_seq(a)(i).is_close(Real.0, eps)
                        abs_seq(a)(i).abs < eps
                        abs_abs(a(i))
                        abs_lt_imp_close_to_zero(a(i), eps)
                        a(i).is_close(Real.0, eps)
                    }
                }
                tail_bound(a, Real.0, n, eps)
            }
        }
        converges_to(a, Real.0)
        converges_to_imp_converges(a, Real.0)
        converges_imp_converges_to(a)
        converges_to_unique(a, limit(a), Real.0)
        vanishes(a)
    }
}

/// Taking negatives preserves the vanishing property.
theorem vanishes_neg_seq(a: Nat -> Real) {
    vanishes(a)
    implies
    vanishes(neg_seq(a))
} by {
    if vanishes(a) {
        // Negating a vanishing sequence still converges to zero.
        converges(a)
        limit(a) = Real.0
        mul_seq_converges_to(-Real.1, a)
        mul_zero_right(-Real.1)
        converges_to(neg_seq(a), Real.0)
        converges_to_imp_converges(neg_seq(a), Real.0)
        converges_imp_converges_to(neg_seq(a))
        converges_to_unique(neg_seq(a), limit(neg_seq(a)), Real.0)
        vanishes(neg_seq(a))
    }
}

/// Vanishing is preserved under pointwise equality.
theorem vanishes_congr_left(a: Nat -> Real, b: Nat -> Real) {
    a = b and vanishes(b)
    implies
    vanishes(a)
} by {
    if a = b and vanishes(b) {
        vanishes(a)
    }
}

/// Negating the difference sequence swaps the order of the arguments.
theorem neg_seq_sub_seq_eq(s: Nat -> Real, t: Nat -> Real) {
    neg_seq(sub_seq(s, t)) = sub_seq(t, s)
} by {
    forall(n: Nat) {
        // Show that the two differences sum to zero.
        let lhs = sub_seq(s, t, n)
        let rhs = sub_seq(t, s, n)

        lhs + rhs = (s(n) - t(n)) + (t(n) - s(n))
        add_assoc(s(n), -t(n), t(n) + -s(n))
        add_assoc(-t(n), t(n), -s(n))
        add_neg_eq_zero(-t(n))
        neg_neg(t(n))
        add_zero_right(s(n))
        add_neg_eq_zero(s(n))
        lhs + rhs = Real.0

        sub_moves_sides(rhs, lhs, Real.0)
        add_zero_left(-lhs)

        mul_neg_one_left(lhs)
        neg_seq(sub_seq(s, t))(n) = sub_seq(t, s, n)
    }
}

/// Absolute values of the raw difference equal the absolute difference sequence (original order).
theorem abs_seq_sub_seq_eq_abs_diff_left(s: Nat -> Real, t: Nat -> Real) {
    abs_seq(sub_seq(s, t)) = abs_diff_seq(s, t)
} by {
    forall(n: Nat) {
        abs_seq(sub_seq(s, t))(n) = sub_seq(s, t, n).abs
        abs_diff_seq(s, t, n) = sub_seq(s, t, n).abs
        abs_seq(sub_seq(s, t))(n) = abs_diff_seq(s, t, n)
    }
}

/// Absolute values of the reversed difference also equal the absolute difference sequence.
theorem abs_seq_sub_seq_eq_abs_diff_right(s: Nat -> Real, t: Nat -> Real) {
    abs_seq(sub_seq(t, s)) = abs_diff_seq(s, t)
} by {
    forall(n: Nat) {
        abs_diff_seq(s, t, n) = sub_seq(s, t, n).abs
        neg_seq_sub_seq_eq(s, t)
        neg_seq(sub_seq(s, t))(n) = sub_seq(t, s, n)
        mul_neg_one_left(sub_seq(s, t, n))
        sub_seq(t, s, n) = -sub_seq(s, t, n)
        abs_neg(sub_seq(s, t, n))
        abs_seq(sub_seq(t, s))(n) = sub_seq(t, s, n).abs
        abs_seq(sub_seq(t, s))(n) = abs_diff_seq(s, t, n)
    }
}

/// Absolute vanishing differences imply raw differences vanish.
theorem vanishing_diff_abs_eq(s: Nat -> Real, t: Nat -> Real) {
    vanishing_diff(s, t)
    implies
    vanishes(sub_seq(t, s))
} by {
    if vanishing_diff(s, t) {
        // Convert the vanishing absolute difference to raw vanishing for both orientations.
        abs_seq_sub_seq_eq_abs_diff_left(s, t)
        vanishes_congr_left(abs_seq(sub_seq(s, t)), abs_diff_seq(s, t))
        vanishes_of_abs_seq(sub_seq(s, t))

        abs_seq_sub_seq_eq_abs_diff_right(s, t)
        vanishes_congr_left(abs_seq(sub_seq(t, s)), abs_diff_seq(s, t))
        vanishes_of_abs_seq(sub_seq(t, s))
    }
}

/// Vanishing differences allow us to transfer limits across sequences.
theorem limit_preserved_by_vanishing_diff(s: Nat -> Real, t: Nat -> Real) {
    converges(s) and vanishing_diff(s, t)
    implies
    converges(t) and limit(s) = limit(t)
} by {
    if converges(s) and vanishing_diff(s, t) {
        let diff = sub_seq(t, s)

        converges(s)
        vanishing_diff_abs_eq(s, t)
        vanishes(diff)
        converges(diff)
        limit(diff) = Real.0

        forall(n: Nat) {
            add_seq(diff, s)(n) = diff(n) + s(n)
            diff(n) = sub_seq(t, s, n)
            sub_seq(t, s, n) = t(n) - s(n)
            add_assoc(t(n), -s(n), s(n))
            add_neg_eq_zero(s(n))
            add_zero_right(t(n))
            add_seq(diff, s)(n) = t(n)
        }
        add_seq(diff, s) = t

        limit_add_seq(diff, s)
        converges_to(add_seq(diff, s), limit(diff) + limit(s))
        converges_to(t, limit(diff) + limit(s))
        limit(diff) = Real.0
        add_zero_left(limit(s))
        converges_to(t, limit(s))
    }
}

theorem cauchy_product_zero(a: Nat -> Real, b: Nat -> Real) {
    cauchy_product(a, b, Nat.0) = a(Nat.0) * b(Nat.0)
} by {
    let mapped = map(Nat.1.range, function(k: Nat) { a(k) * b(Nat.0 - k) })
}

/// If we map a list with a function that always returns zero, the sum is zero.
theorem sum_map_zero[T](items: List[T], f: T -> Real) {
    (forall(x: T) { f(x) = Real.0 })
    implies
    sum(map(items, f)) = Real.0
} by {
    define p(xs: List[T]) -> Bool {
        (forall(x: T) { f(x) = Real.0 })
        implies
        sum(map(xs, f)) = Real.0
    }

    // Base case: empty list
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if forall(x: T) { f(x) = Real.0 } {
                // Apply the hypothesis to tail

                // Now work on the cons case
            }
            p(List.cons(head, tail))
        }
    }
}

/// If a is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_left(b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n)(k) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)
}

/// If a is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_left_fn(b: Nat -> Real, n: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n) = constant[Nat, Real](Real.0)
} by {
    let a = constant[Nat, Real](Real.0)
}

/// If b is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_right(a: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n)(k) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
}

/// If b is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_right_fn(a: Nat -> Real, n: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n) = constant[Nat, Real](Real.0)
} by {
    let b = constant[Nat, Real](Real.0)
}

/// Helper lemma: reverse of mapped range with cauchy_coefficient equals mapped range with swapped coefficients.
theorem cauchy_reverse_map_eq(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    reverse(map(n.suc.range, cauchy_coefficient(a, b, n))) =
    map(n.suc.range, cauchy_coefficient(b, a, n))
} by {
    let left_list = reverse(map(n.suc.range, cauchy_coefficient(a, b, n)))
    let right_list = map(n.suc.range, cauchy_coefficient(b, a, n))

    // Both lists have the same length
    left_list.length = right_list.length

    // Show they agree at every index
    forall(idx: Nat) {
        if idx < left_list.length {
            // idx < n.suc
            idx < n.suc

            // Element of left_list at idx using reverse_get_idx
            let mapped = map(n.suc.range, cauchy_coefficient(a, b, n))
            reverse_get_idx(mapped, idx)

            // mapped.length - 1 - idx = n - idx

            // Show n - idx < n.suc
            n - idx <= n

            // Apply map_range with cauchy_coefficient
            map_range(n.suc, n - idx, cauchy_coefficient(a, b, n))
            mapped.get_idx(n - idx) = Option.some(cauchy_coefficient(a, b, n)(n - idx))

            // Expand cauchy_coefficient
            n - (n - idx) = idx

            // By commutativity

            // Element of right_list at idx
            map_range(n.suc, idx, cauchy_coefficient(b, a, n))

            // Expand cauchy_coefficient

            // Therefore they're equal
            left_list.get_idx(idx) = right_list.get_idx(idx)
        }
    }

    // Apply list extensionality
    list_extensionality(left_list, right_list)
}

/// Cauchy product is commutative.
theorem cauchy_product_comm(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, b, n) = cauchy_product(b, a, n)
} by {
    // Expand definitions

    // Use sum_reverse

    // Use helper lemma
    cauchy_reverse_map_eq(a, b, n)

    // Combine
}

/// Cauchy product with a zero sequence on the left.
theorem cauchy_product_zero_left(b: Nat -> Real, n: Nat) {
    cauchy_product(constant[Nat, Real](Real.0), b, n) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)

    // Show that cauchy_coefficient equals the constant zero function

    // Therefore every application returns zero

    // Apply sum_map_zero
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0

    // This is the definition of cauchy_product
}

/// Cauchy product with a zero sequence on the right.
theorem cauchy_product_zero_right(a: Nat -> Real, n: Nat) {
    cauchy_product(a, constant[Nat, Real](Real.0), n) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)

    // Show that cauchy_coefficient equals the constant zero function

    // Therefore every application returns zero

    // Apply sum_map_zero

    // This is the definition of cauchy_product
}

/// Helper lemma: cauchy_coefficient distributes scalar multiplication in the first argument.
theorem cauchy_coefficient_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(mul_fn(c, a), b, n)(k) = c * cauchy_coefficient(a, b, n)(k)
} by {
    // Expand cauchy_coefficient definition

    // Use associativity

    // Recognize the right side as the original coefficient
}

/// Linearity in the first argument: scalar multiplication factors out.
theorem cauchy_product_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(mul_fn(c, a), b, n) = c * cauchy_product(a, b, n)
} by {
    // Expand cauchy_product definitions

    // Show that the coefficient functions are related by scalar multiplication

    // The two functions are equal
    cauchy_coefficient(mul_fn(c, a), b, n) = compose(scalar_mul(c), cauchy_coefficient(a, b, n))

    // Use sum_scalar_mul to factor out the constant
    sum(map(map(n.suc.range, cauchy_coefficient(a, b, n)), scalar_mul(c))) = c * sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// Helper lemma: cauchy_coefficient distributes scalar multiplication in the second argument.
theorem cauchy_coefficient_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, mul_fn(c, b), n)(k) = c * cauchy_coefficient(a, b, n)(k)
} by {
    // Expand cauchy_coefficient definition

    // Use associativity and commutativity

    // Recognize the right side as the original coefficient
}

/// Linearity in the second argument: scalar multiplication factors out.
theorem cauchy_product_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, mul_fn(c, b), n) = c * cauchy_product(a, b, n)
} by {
    // Expand cauchy_product definitions

    // Show that the coefficient functions are related by scalar multiplication

    // The two functions are equal

    // Use sum_scalar_mul to factor out the constant
}

/// Helper lemma: cauchy_coefficient distributes addition in the first argument.
theorem cauchy_coefficient_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(add_fn(a, aa), b, n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
} by {
    // Expand cauchy_coefficient definition

    // Use distributivity

    // Recognize the right side as the sum of coefficients
    a(k) * b(n - k) + aa(k) * b(n - k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(aa, b, n)(k)
}

/// Distributivity in the first argument: addition distributes through the Cauchy product.
theorem cauchy_product_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(add_fn(a, aa), b, n) = cauchy_product(a, b, n) + cauchy_product(aa, b, n)
} by {
    // Expand cauchy_product definitions

    // Show that the coefficient functions are related by addition

    // The two functions are equal
    cauchy_coefficient(add_fn(a, aa), b, n) = add_fn(cauchy_coefficient(a, b, n), cauchy_coefficient(aa, b, n))

    // Use map_sum_add to split the sum
}

/// Helper lemma: cauchy_coefficient distributes addition in the second argument.
theorem cauchy_coefficient_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, add_fn(b, bb), n)(k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
} by {
    // Expand cauchy_coefficient definition

    // Use distributivity

    // Recognize the right side as the sum of coefficients
    a(k) * b(n - k) + a(k) * bb(n - k) = cauchy_coefficient(a, b, n)(k) + cauchy_coefficient(a, bb, n)(k)
}

/// Distributivity in the second argument: addition distributes through the Cauchy product.
theorem cauchy_product_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat) {
    cauchy_product(a, add_fn(b, bb), n) = cauchy_product(a, b, n) + cauchy_product(a, bb, n)
} by {
    // Expand cauchy_product definitions

    // Show that the coefficient functions are related by addition

    // The two functions are equal

    // Use map_sum_add to split the sum
}

/// Partial sum of Cauchy product with zero sequence on the left is zero.
theorem partial_cauchy_zero_left(b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(constant[Nat, Real](Real.0), b), n) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)
    let c = cauchy_seq(a, b)

    // Show that cauchy_seq(a, b) is the constant zero function

    // Partial sum of constant zero is zero

}

/// Partial sum of Cauchy product with zero sequence on the right is zero.
theorem partial_cauchy_zero_right(a: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, constant[Nat, Real](Real.0)), n) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
    let c = cauchy_seq(a, b)

    // Show that cauchy_seq(a, b) is the constant zero function

    // Partial sum of constant zero is zero

}

/// Partial sum distributes over addition in the first argument.
theorem partial_cauchy_add_left(a: Nat -> Real, aa: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(add_fn(a, aa), b), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(aa, b), n)
} by {
    // Show that cauchy_seq distributes over addition

    // Therefore the sequences are equal

    // Use partial_add to distribute the partial sum
}

/// Partial sum distributes over addition in the second argument.
theorem partial_cauchy_add_right(a: Nat -> Real, b: Nat -> Real, bb: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, add_fn(b, bb)), n) = partial(cauchy_seq(a, b), n) + partial(cauchy_seq(a, bb), n)
} by {
    // Show that cauchy_seq distributes over addition

    // Therefore the sequences are equal

    // Use partial_add to distribute the partial sum
}

/// Scalar multiplication factors out of partial sum in the first argument.
theorem partial_cauchy_scalar_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(mul_fn(c, a), b), n) = c * partial(cauchy_seq(a, b), n)
} by {
    // Show that cauchy_seq factors out scalar multiplication

    // Therefore the sequences are equal

    // Use partial_scalar_mul to factor out the constant
}

/// Scalar multiplication factors out of partial sum in the second argument.
theorem partial_cauchy_scalar_right(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, mul_fn(c, b)), n) = c * partial(cauchy_seq(a, b), n)
} by {
    // Show that cauchy_seq factors out scalar multiplication

    // Therefore the sequences are equal

    // Use partial_scalar_mul to factor out the constant
}

// ============================================================================
// Absolute Convergence Infrastructure
// ============================================================================

/// The absolute value of each element in a sequence.
/// For a sequence a, this returns the sequence n ↦ |a(n)|.
define abs_fn(a: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { a(n).abs }
}


/// A series converges absolutely if the series of absolute values converges.
define absolutely_converges(a: Nat -> Real) -> Bool {
    converges(partial(abs_fn(a)))
}

/// The absolute value of any element in the constant zero sequence is zero.
theorem abs_fn_zero(n: Nat) {
    abs_fn(constant[Nat, Real](Real.0))(n) = Real.0
}

/// The absolute value of any element in a sequence is nonnegative.
theorem abs_fn_nonneg(a: Nat -> Real, n: Nat) {
    abs_fn(a)(n) >= Real.0
}

/// Absolute value commutes with scalar multiplication (up to taking abs of scalar).
theorem abs_fn_scalar_mul(c: Real, a: Nat -> Real, n: Nat) {
    abs_fn(mul_fn(c, a))(n) = c.abs * abs_fn(a)(n)
}

/// abs_fn is equivalent to composing with Real.abs.
theorem abs_fn_eq_compose(a: Nat -> Real, n: Nat) {
    abs_fn(a)(n) = compose(Real.abs, a)(n)
}

/// Absolute convergence implies convergence (alternate formulation).
/// This connects our definition to the existing theorem in real_series.ac.
theorem absolutely_converges_imp_converges(a: Nat -> Real) {
    absolutely_converges(a) implies converges(partial(a))
} by {
    from real.real_series import abs_conv_imp_conv

    if absolutely_converges(a) {
        // By definition, absolutely_converges(a) means converges(partial(abs_fn(a)))

        // Show that abs_fn(a) = compose(Real.abs, a)

        // Therefore converges(partial(compose(Real.abs, a)))
        partial(abs_fn(a)) = partial(compose(Real.abs, a))

        // Apply abs_conv_imp_conv
        abs_conv_imp_conv(a)
        converges(partial(a))
    }
}

/// Absolute convergence is preserved under scalar multiplication.
theorem absolutely_converges_scalar_mul(c: Real, a: Nat -> Real) {
    absolutely_converges(a) implies absolutely_converges(mul_fn(c, a))
} by {
    from real.real_series import converges_mul_seq

    if absolutely_converges(a) {

        // Show that abs_fn(mul_fn(c, a)) relates to abs_fn(a)

        // Therefore partial(abs_fn(mul_fn(c, a))) = c.abs * partial(abs_fn(a))
        partial(abs_fn(mul_fn(c, a))) = partial(mul_fn(c.abs, abs_fn(a)))
        partial(mul_fn(c.abs, abs_fn(a))) = mul_fn(c.abs, partial(abs_fn(a)))

        // Show that mul_fn and mul_seq are equal for our purposes
        mul_fn(c.abs, partial(abs_fn(a))) = mul_seq(c.abs, partial(abs_fn(a)))

        // If partial(abs_fn(a)) converges, so does c.abs * partial(abs_fn(a))
        converges_mul_seq(c.abs, partial(abs_fn(a)))
        absolutely_converges(mul_fn(c, a))
    }
}

/// Absolute convergence is preserved under addition of sequences.
theorem absolutely_converges_add(a: Nat -> Real, b: Nat -> Real) {
    absolutely_converges(a) and absolutely_converges(b)
    implies
    absolutely_converges(add_fn(a, b))
} by {
    from real.real_series import add_seq_converges, comparison_test

    if absolutely_converges(a) and absolutely_converges(b) {

        // For all n: |a(n) + b(n)| <= |a(n)| + |b(n)| by triangle inequality
        forall(n: Nat) {
            abs_fn(add_fn(a, b))(n) <= add_fn(abs_fn(a), abs_fn(b))(n)
        }

        // Therefore seq_lte holds

        // abs_fn always produces nonnegative values
        is_lower_bound(abs_fn(add_fn(a, b)), Real.0)

        // add_fn distributes over partial
        partial(add_fn(abs_fn(a), abs_fn(b))) = add_fn(partial(abs_fn(a)), partial(abs_fn(b)))

        // Show that add_fn and add_seq are equal for our purposes
        add_fn(partial(abs_fn(a)), partial(abs_fn(b))) = add_seq(partial(abs_fn(a)), partial(abs_fn(b)))

        // If both converge, their sum converges
        add_seq_converges(partial(abs_fn(a)), partial(abs_fn(b)))

        // Apply comparison test
        comparison_test(abs_fn(add_fn(a, b)), add_fn(abs_fn(a), abs_fn(b)))
        absolutely_converges(add_fn(a, b))
    }
}

/// Tail bound for absolutely convergent series.
/// If a series converges absolutely, then tail sums can be made arbitrarily small.
/// For any ε > 0, there exists N such that for all n, m ≥ N with n ≤ m,
/// the sum of |a(k)| from k=n to k=m-1 is less than ε.
/// For fixed m, the difference between partial sums converges to the tail limit difference.
theorem tail_diff_converges(a: Nat -> Real, m: Nat) {
    absolutely_converges(a)
    implies
    converges_to(partial_diff(abs_fn(a), m), tail_limit_diff(abs_fn(a), m))
} by {
    if absolutely_converges(a) {
        let lim = limit(partial(abs_fn(a)))

        // The partial sums of |a| converge by absolute convergence.
        converges(partial(abs_fn(a)))

        // The constant offset sequence also converges.
        const_converges(-partial(abs_fn(a), m))

        // Apply the limit addition rule to combine the sequences.
        limit_add_seq(partial(abs_fn(a)), constant[Nat, Real](-partial(abs_fn(a), m)))

        // Identify the limit of the constant sequence.
        const_limit(-partial(abs_fn(a), m))

        // Rewrite the target limit using the chosen name.
        tail_limit_diff(abs_fn(a), m) = lim - partial(abs_fn(a), m)

        // The limit addition theorem yields the desired limit.
        converges_to(add_seq(partial(abs_fn(a)), constant[Nat, Real](-partial(abs_fn(a), m))),
            tail_limit_diff(abs_fn(a), m))

        // Show that the combined sequence equals partial_diff(abs_fn(a), m).
        partial_diff(abs_fn(a), m) =
            add_seq(partial(abs_fn(a)), constant[Nat, Real](-partial(abs_fn(a), m)))

        converges_to(partial_diff(abs_fn(a), m), tail_limit_diff(abs_fn(a), m))
    }
}

theorem abs_conv_tail_bound(a: Nat -> Real, eps: Real) {
    absolutely_converges(a) and eps.is_positive
    implies
    exists(big_n: Nat) {
        forall(n: Nat, m: Nat) {
            big_n <= n and n <= m
            implies
            partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps
        }
    }
} by {
    from real.real_seq import cauchy_bound
    from real.real_series import distant_increasing, nonneg_imp_partial_increasing, is_increasing

    if absolutely_converges(a) and eps.is_positive {
        // absolutely_converges(a) means converges(partial(abs_fn(a)))

        // Use the Cauchy criterion to get an N
        let big_n: Nat satisfy {
            cauchy_bound(partial(abs_fn(a)), big_n, eps)
        }

        forall(n: Nat, m: Nat) {
            if big_n <= n and n <= m {
                // By Cauchy criterion, the partial sums are close

                // Since abs_fn is nonnegative, partial sums are increasing
                nonneg_imp_partial_increasing(abs_fn(a))

                // When n <= m, the partial sums satisfy this ordering
                distant_increasing(partial(abs_fn(a)), n, m)

                // is_close is symmetric, so we also have

                // Rewrite using function application notation

                // This means the absolute difference is less than eps

                // Since partial is increasing and n <= m, we know partial(abs_fn(a), n) <= partial(abs_fn(a), m)
                // Therefore the difference partial(abs_fn(a), m) - partial(abs_fn(a), n) is non-negative
                // When a difference is non-negative, x - y >= 0, then (x - y).abs = x - y
                // So (partial(abs_fn(a), m) - partial(abs_fn(a), n)).abs = partial(abs_fn(a), m) - partial(abs_fn(a), n)
                partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps
            }
        }
    }
}

// ============================================================================
// Cauchy Product Convergence (Mertens' Theorem)
// ============================================================================

/// Triangle inequality for sums: the absolute value of a sum is at most the sum of absolute values.
theorem sum_triangle_ineq(items: List[Real]) {
    (sum(items)).abs <= sum(map(items, Real.abs))
} by {
    from real.real_series import triangle_ineq

    // Proof by induction on list structure
    define p(xs: List[Real]) -> Bool {
        (sum(xs)).abs <= sum(map(xs, Real.abs))
    }

    // Base case: empty list

    // Inductive step

}

/// Pointwise less-than-or-equal for functions from Nat to Real.
define lte_fn(f: Nat -> Real, g: Nat -> Real) -> Bool {
    forall(k: Nat) { f(k) <= g(k) }
}

/// Helper: sum(map(n.range, f)) <= sum(map(n.range, g)) when f <= g pointwise.
/// Uses existing partial_seq_lte infrastructure.
theorem sum_map_range_le(n: Nat, f: Nat -> Real, g: Nat -> Real) {
    lte_fn(f, g) implies sum(map(n.range, f)) <= sum(map(n.range, g))
} by {
    from real.real_series import partial_seq_lte

}

/// The absolute value of a Cauchy product coefficient is bounded by the
/// corresponding coefficient of the Cauchy product of absolute values.
theorem cauchy_coefficient_abs_bound(a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    (cauchy_coefficient(a, b, n)(k)).abs <= cauchy_coefficient(abs_fn(a), abs_fn(b), n)(k)
} by {
    // Expand definitions

    // Expand the right side
}

/// The absolute value of the Cauchy product is bounded by the Cauchy product of absolute values.
theorem cauchy_product_abs_bound(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    (cauchy_product(a, b, n)).abs <= cauchy_product(abs_fn(a), abs_fn(b), n)
} by {
    // Expand definition of cauchy_product

    // Apply triangle inequality: |sum(...)| <= sum(|...|)
    sum_triangle_ineq(map(n.suc.range, cauchy_coefficient(a, b, n)))

    // Use map composition
    map_map(n.suc.range, cauchy_coefficient(a, b, n), Real.abs)

    // For each coefficient, the absolute value is bounded

    // Apply sum_map_range_le
    sum_map_range_le(n.suc, compose(Real.abs, cauchy_coefficient(a, b, n)), cauchy_coefficient(abs_fn(a), abs_fn(b), n))
    sum(map(n.suc.range, compose(Real.abs, cauchy_coefficient(a, b, n)))) <= sum(map(n.suc.range, cauchy_coefficient(abs_fn(a), abs_fn(b), n)))

    // Combine by transitivity
}

/// Helper: Each term in cauchy_coefficient is equal to a specific product term.
theorem cauchy_term_equals_prod(a: Nat -> Real, b: Nat -> Real, m: Nat, k: Nat) {
    k <= m implies cauchy_coefficient(a, b, m)(k) = a(k) * b(m - k)
} by {
    if k <= m {
    }
}

/// Helper: All cauchy_coefficient terms are nonnegative when a and b are nonnegative.
theorem cauchy_coefficient_nonneg(a: Nat -> Real, b: Nat -> Real, m: Nat, k: Nat) {
    is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
    implies
    cauchy_coefficient(a, b, m)(k) >= Real.0
} by {
    if is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0) {
    }
}

// ============================================================================
// Foundation Lemmas for Cauchy Product Convergence
// ============================================================================

/// Multiplication is monotone for nonnegative reals.
/// If a ≤ c and b ≤ d with all nonnegative, then a*b ≤ c*d.
/// Lemma: Cauchy product equals sum over rows of diagonal contributions.
/// This shows that cauchy_product(a,b,m) = sum_{i=0}^m diag_row_contrib(a,b,m,i).
theorem cauchy_as_diag_double_sum(a: Nat -> Real, b: Nat -> Real, m: Nat) {
    cauchy_product(a, b, m) = sum(map(m.suc.range, function(i: Nat) { diag_row_contrib(a, b, m, i) }))
} by {
    from list.list_sum import partial_pointwise_eq

    // Show that cauchy_coefficient and diag_row_contrib are pointwise equal

    // Apply pointwise equality to conclude sums are equal
    partial_pointwise_eq(cauchy_coefficient(a, b, m), function(i: Nat) { diag_row_contrib(a, b, m, i) }, m.suc)
    sum(map(m.suc.range, cauchy_coefficient(a, b, m))) = sum(map(m.suc.range, function(i: Nat) { diag_row_contrib(a, b, m, i) }))
}

theorem double_sum_diagonal_bound(a: Nat -> Real, b: Nat -> Real, m: Nat) {
    is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
    implies
    cauchy_product(a, b, m) <= double_sum(m.suc, m.suc, prod_fn(a, b))
} by {
    from list.list_sum import partial_pointwise_eq

    if is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0) {
        // Express Cauchy product as sum of diagonal contributions
        cauchy_as_diag_double_sum(a, b, m)

        // Show each diagonal contribution is bounded by its full row sum
        // For each row i, diag_row_contrib(a,b,m,i) is a conditional sum
        forall(i: Nat) {
            if i < m.suc {

                // Define the predicate for this row
                define is_diag_i(j: Nat) -> Bool {
                    i + j = m
                }

                // Show diag_row_contrib equals conditional sum

                // Show diag_cond_prod = cond_part(prod_fn(a,b)(i), is_diag_i)
                forall(j: Nat) {
                    if i + j = m {
                        cond_part(prod_fn(a, b)(i), is_diag_i, j) = a(i) * b(j)
                        diag_cond_prod(a, b, m, i, j) = cond_part(prod_fn(a, b)(i), is_diag_i, j)
                    } else {
                        diag_cond_prod(a, b, m, i, j) = cond_part(prod_fn(a, b)(i), is_diag_i, j)
                    }
                }

                // Apply partial_pointwise_eq
                partial_pointwise_eq(function(j: Nat) { diag_cond_prod(a, b, m, i, j) }, cond_part(prod_fn(a, b)(i), is_diag_i), m.suc)

                // Show prod_fn(a,b)(i) is nonnegative
                forall(j: Nat) {
                    b(j) >= Real.0
                    mul_le_mul_nonneg(a(i), b(j), Real.0, Real.0)
                    prod_fn(a, b)(i)(j) >= Real.0
                }

                // Apply sum_cond_le_sum_1d
                sum_cond_le_sum_1d(prod_fn(a, b)(i), is_diag_i, m.suc)

                // Conclude this row inequality
                diag_row_contrib(a, b, m, i) <= row_sum(m.suc, prod_fn(a, b), i)
            }
        }

        // Now lift the row-wise inequalities to the full sum
        // We have: forall i < m.suc. diag_row_contrib(a,b,m,i) <= row_sum(m.suc, prod_fn(a,b), i)
        // Therefore: sum(diag_row_contrib) <= sum(row_sum) = double_sum

        // Apply partial_lte_partial
        partial_lte_partial(function(i: Nat) { diag_row_contrib(a, b, m, i) }, row_sum(m.suc, prod_fn(a, b)), m.suc)

        // Connect to double_sum
        double_sum_row_expand(m.suc, m.suc, prod_fn(a, b))

        sum(map(m.suc.range, function(i: Nat) { diag_row_contrib(a, b, m, i) })) <= double_sum(m.suc, m.suc, prod_fn(a, b))
    }
}

// ///
// /// We prove this using partial_product_as_double_sum which shows that
// /// partial(a,m.suc) * partial(b,m.suc) = double_sum(m.suc, m.suc, prod_fn(a,b)).
// /// Each term in cauchy_product appears in the double_sum, and since all terms are nonnegative,
// /// the Cauchy product (a subset of terms) is bounded by the double_sum (all terms).
// ///
// /// The mathematical argument relies on the fact that for nonnegative sequences:
// /// Each cauchy_product term a(i)*b(m-i) appears in the expansion of ∑a(i) * ∑b(j),
// /// and the expansion contains additional nonnegative terms, so cauchy_product <= product of sums.
// ///
// /// STATUS: Blocked - Requires explicit proof that diagonal terms ⊆ full grid terms.
// /// The missing piece is showing: ∑_{i+j=m} a(i)b(j) <= ∑_{i,j≤m} a(i)b(j) for nonnegative a,b.
// /// This is mathematically obvious but needs formal infrastructure for subset sums.
// theorem double_sum_diagonal_bound(a: Nat -> Real, b: Nat -> Real, m: Nat) {
//     is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
//     implies
//     cauchy_product(a, b, m) <= double_sum(m.suc, m.suc, prod_fn(a, b))
// } by {
//     if is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0) {
//         // Use partial_product_as_double_sum to relate double_sum to product of partials
//         partial_product_as_double_sum(a, b, m.suc)
//         partial(a, m.suc) * partial(b, m.suc) = double_sum(m.suc, m.suc, prod_fn(a, b))
//
//         // Show partial sums are nonnegative
//         partial_nonneg(a, m.suc)
//         partial(a, m.suc) >= Real.0
//         partial_nonneg(b, m.suc)
//         partial(b, m.suc) >= Real.0
//
//         // Show cauchy_product is nonnegative
//         forall(k: Nat) {
//             cauchy_coefficient_nonneg(a, b, m, k)
//             cauchy_coefficient(a, b, m)(k) >= Real.0
//         }
//         is_lower_bound(cauchy_coefficient(a, b, m), Real.0)
//         partial_nonneg(cauchy_coefficient(a, b, m), m.suc)
//         sum(map(m.suc.range, cauchy_coefficient(a, b, m))) >= Real.0
//         cauchy_product(a, b, m) >= Real.0
//
//         // The key missing step: For nonnegative a, b we have
//         // cauchy_product(a,b,m) = ∑_{i+j=m} a(i)b(j) <= ∑_{i,j∈[0,m]} a(i)b(j) = (∑a(i))(∑b(j))
//         //
//         // This would require proving that the diagonal terms are a subset of all grid terms.
//         cauchy_product(a, b, m) <= partial(a, m.suc) * partial(b, m.suc)
//
//         // Combine with the equality from partial_product_as_double_sum
//         cauchy_product(a, b, m) <= double_sum(m.suc, m.suc, prod_fn(a, b))
//     }
// }

// TODO: These theorems require more infrastructure to prove completely.
// They are mathematically sound but need detailed subset sum or filtering lemmas.

// /// Helper: Each individual cauchy_product term can be bounded.
// /// For nonnegative a, b: cauchy_product(a,b,m) ≤ partial(a,m.suc) * partial(b,m.suc)
// ///
// /// Mathematical argument: cauchy_product sums a(k)*b(m-k) for k∈[0,m].
// /// Each such term appears in the double_sum expansion of partial(a,m.suc)*partial(b,m.suc)
// /// since k<m.suc and m-k<m.suc. The double_sum contains these plus additional nonnegative terms.
// theorem cauchy_term_bound(a: Nat -> Real, b: Nat -> Real, m: Nat) {
//     is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
//     implies
//     cauchy_product(a, b, m) <= partial(a, m.suc) * partial(b, m.suc)
// } by {
//     // Requires: Formal subset sum lemma
//     sorry
// }

/// Helper to express the triangular region: sums a(i)*b(j) where i+j < n.
define triangle_product(a: Nat -> Real, b: Nat -> Real, n: Nat, i: Nat, j: Nat) -> Real {
    if i + j < n { a(i) * b(j) } else { Real.0 }
}

/// Lemma: partial(cauchy_seq(a, b), n) equals the double sum over the triangular region.
/// This connects the Cauchy product (sum over diagonals) to a double sum (rectangular iteration).
theorem partial_cauchy_as_triangle(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(cauchy_seq(a, b), n) = double_sum(n, n, triangle_product(a, b, n))
} by {
    // LHS = sum_{k=0}^{n-1} cauchy_product(a, b, k)
    //     = sum_{k=0}^{n-1} sum_{i=0}^{k} a(i)*b(k-i)
    //     = sum_{k=0}^{n-1} diagonal_sum(prod_fn(a,b), k)

    // Show that cauchy_product(a, b, k) = diagonal_sum(prod_fn(a, b), k)
    forall(k: Nat) {
        // cauchy_product(a, b, k) = sum_{i=0}^{k} a(i)*b(k-i)

        // cauchy_coefficient(a, b, k, i) = a(i)*b(k-i)

        // diagonal_sum(prod_fn(a, b), k) = sum_{i=0}^{k} prod_fn(a,b)(i, k-i)

        // diagonal_val(prod_fn(a, b), k, i) = prod_fn(a, b)(i, k-i)

        from list.list_sum import partial_pointwise_eq
        partial_pointwise_eq(diagonal_val(prod_fn(a, b), k), cauchy_coefficient(a, b, k), k.suc)
        sum(map(k.suc.range, diagonal_val(prod_fn(a, b), k))) = sum(map(k.suc.range, cauchy_coefficient(a, b, k)))
    }

    // Therefore partial(cauchy_seq(a, b), n) = sum(map(n.range, diagonal_sum(prod_fn(a, b))))

    from list.list_sum import partial_pointwise_eq
    partial_pointwise_eq(cauchy_seq(a, b), diagonal_sum(prod_fn(a, b)), n)

    // Apply finite_double_sum_exchange
    finite_double_sum_exchange(prod_fn(a, b), n)

    // Show triangle_fn(prod_fn(a, b), n) = triangle_product(a, b, n)
    forall(i: Nat, j: Nat) {
        if i + j < n {
        } else {
            triangle_fn(prod_fn(a, b), n, i, j) = triangle_product(a, b, n, i, j)
        }
        triangle_fn(prod_fn(a, b), n, i, j) = triangle_product(a, b, n, i, j)
    }

    // Use pointwise equality to show double_sums are equal
    // Expand double_sums
    double_sum_expands(n, n, triangle_fn(prod_fn(a, b), n))

    double_sum_expands(n, n, triangle_product(a, b, n))

    // Show row_sum(n, triangle_fn(prod_fn(a, b), n), i) = row_sum(n, triangle_product(a, b, n), i) for all i
    forall(i: Nat) {
        // These are pointwise equal in j

        partial_pointwise_eq(triangle_fn(prod_fn(a, b), n)(i), triangle_product(a, b, n)(i), n)
        row_sum(n, triangle_fn(prod_fn(a, b), n), i) = row_sum(n, triangle_product(a, b, n), i)
    }

    partial_pointwise_eq(row_sum(n, triangle_fn(prod_fn(a, b), n)), row_sum(n, triangle_product(a, b, n)), n)

    // Conclude: LHS = RHS
    partial(cauchy_seq(a, b), n) = double_sum(n, n, triangle_fn(prod_fn(a, b), n))
}

/// Helper: Complementary region of the triangle where i + j >= n.
/// This captures the terms in the product of partial sums that are not part of the
/// Cauchy product partial sums at index n.
define tail_triangle_product(a: Nat -> Real, b: Nat -> Real, n: Nat, i: Nat, j: Nat) -> Real {
    if i + j < n { Real.0 } else { a(i) * b(j) }
}

/// Tail triangle double sum formed from the absolute values of a and b.
define tail_triangle_sum(a: Nat -> Real, b: Nat -> Real, n: Nat) -> Real {
    double_sum(n, n, tail_triangle_product(abs_fn(a), abs_fn(b), n))
}

/// Decompose the rectangular product region into triangle and tail components.
theorem prod_fn_triangle_tail_decomp(a: Nat -> Real, b: Nat -> Real, n: Nat, i: Nat, j: Nat) {
    prod_fn(a, b)(i, j) = triangle_product(a, b, n, i, j) + tail_triangle_product(a, b, n, i, j)
} by {
    if i + j < n {
        add_zero_right(a(i) * b(j))
    } else {
        add_zero_left(a(i) * b(j))
        prod_fn(a, b)(i, j) = triangle_product(a, b, n, i, j) + tail_triangle_product(a, b, n, i, j)
    }
}

/// Double sum over the tail region equals the difference between the full product
/// double sum and the triangular region.
theorem double_sum_tail_decomp(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    double_sum(n, n, tail_triangle_product(a, b, n)) =
        double_sum(n, n, prod_fn(a, b)) - double_sum(n, n, triangle_product(a, b, n))
} by {
    // Use pointwise decomposition of prod_fn into triangle + tail
    double_sum_pointwise_add(n, n, triangle_product(a, b, n), tail_triangle_product(a, b, n), prod_fn(a, b))

    sub_moves_sides(
        double_sum(n, n, tail_triangle_product(a, b, n)),
        double_sum(n, n, triangle_product(a, b, n)),
        double_sum(n, n, prod_fn(a, b)))
}

/// Express the difference between the product of partial sums and the partial sum of the
/// Cauchy product via the tail double sum.
theorem partial_product_minus_cauchy(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    partial(a, n) * partial(b, n) - partial(cauchy_seq(a, b), n) =
        double_sum(n, n, tail_triangle_product(a, b, n))
} by {
    partial_product_as_double_sum(a, b, n)

    partial_cauchy_as_triangle(a, b, n)

    double_sum_tail_decomp(a, b, n)

}

/// Absolute value of the tail contribution matches the tail built from absolute values.
theorem tail_triangle_abs_eq(a: Nat -> Real, b: Nat -> Real, n: Nat, i: Nat, j: Nat) {
    (tail_triangle_product(a, b, n, i, j)).abs = tail_triangle_product(abs_fn(a), abs_fn(b), n, i, j)
} by {
    if i + j < n {
    } else {
        tail_triangle_product(a, b, n, i, j).abs = tail_triangle_product(abs_fn(a), abs_fn(b), n, i, j)
    }
}

/// Tail triangle terms built from absolute values are nonnegative.
theorem tail_triangle_abs_nonneg(a: Nat -> Real, b: Nat -> Real, n: Nat, i: Nat, j: Nat) {
    tail_triangle_product(abs_fn(a), abs_fn(b), n, i, j) >= Real.0
} by {
    if i + j < n {
    } else {
        mul_nonneg(abs_fn(a)(i), abs_fn(b)(j))
    }
}

/// Each row sum built from |a| and |b| is nonnegative.
theorem row_sum_tail_triangle_abs_nonneg(a: Nat -> Real, b: Nat -> Real, n: Nat, i: Nat) {
    row_sum(n, tail_triangle_product(abs_fn(a), abs_fn(b), n), i) >= Real.0
} by {
    from real.double_sum import partial_nonneg

    define row(j: Nat) -> Real { tail_triangle_product(abs_fn(a), abs_fn(b), n, i, j) }

    partial_nonneg(row, n)
    partial(row, n) >= Real.0
}

/// Adding the same natural number on the left preserves ≤.
theorem nat_add_le_left(a: Nat, b: Nat, c: Nat) {
    b <= c implies a + b <= a + c
}

/// Helper: if i < n and j < n - i then i + j < n.
theorem tail_triangle_lt_of_lt_diff(n: Nat, i: Nat, j: Nat) {
    i < n and j < n - i implies i + j < n
} by {
    if i < n and j < n - i {

        add_sub(n, i)
        add_comm(i, n - i)

        lt_add_left(i, j, n - i)
        i + j < n
    }
}

/// Helper: if i < n and n - i <= j then i + j is not less than n.
theorem tail_triangle_not_lt_of_le_diff(n: Nat, i: Nat, j: Nat) {
    i < n and n - i <= j implies not (i + j < n)
} by {
    if i < n and n - i <= j {

        add_sub(n, i)
        add_comm(i, n - i)

        nat_add_le_left(i, n - i, j)
        lte_imp_not_lt(n, i + j)
    }
}

/// Helper: captures the |b(j)| contribution in a fixed tail triangle row.
define tail_triangle_row_indicator(b: Nat -> Real, n: Nat, i: Nat, j: Nat) -> Real {
    if i + j < n { Real.0 } else { abs_fn(b)(j) }
}

/// Factor |a(i)| out of a tail triangle entry built from absolute values.
theorem tail_triangle_abs_row_factor(a: Nat -> Real, b: Nat -> Real, n: Nat, i: Nat, j: Nat) {
    tail_triangle_product(abs_fn(a), abs_fn(b), n, i, j) =
        abs_fn(a)(i) * tail_triangle_row_indicator(b, n, i, j)
} by {
    if i + j < n {
    } else {
        tail_triangle_product(abs_fn(a), abs_fn(b), n, i, j) =
            abs_fn(a)(i) * tail_triangle_row_indicator(b, n, i, j)
}
}

/// Helper: captures the |b(j)| contribution inside the triangular region of a row.
define triangle_row_indicator(b: Nat -> Real, n: Nat, i: Nat, j: Nat) -> Real {
    if i + j < n { abs_fn(b)(j) } else { Real.0 }
}

/// On the triangle region the indicator agrees with |b(j)|.
theorem triangle_row_indicator_eq_abs(b: Nat -> Real, n: Nat, i: Nat, j: Nat) {
    i + j < n implies triangle_row_indicator(b, n, i, j) = abs_fn(b)(j)
} by {
    if i + j < n {
    }
}

/// Off the triangle region the indicator vanishes.
theorem triangle_row_indicator_zero(b: Nat -> Real, n: Nat, i: Nat, j: Nat) {
    not (i + j < n) implies triangle_row_indicator(b, n, i, j) = Real.0
} by {
    if not (i + j < n) {
    }
}

/// Split |b(j)| into triangular and tail row indicators.
theorem abs_row_indicator_split(b: Nat -> Real, n: Nat, i: Nat, j: Nat) {
    abs_fn(b)(j) = triangle_row_indicator(b, n, i, j) + tail_triangle_row_indicator(b, n, i, j)
} by {
    if i + j < n {
        add_zero_right(abs_fn(b)(j))
    } else {
        add_zero_left(abs_fn(b)(j))
        abs_fn(b)(j) = triangle_row_indicator(b, n, i, j) + tail_triangle_row_indicator(b, n, i, j)
    }
}

/// Decompose the partial sum of |b| into triangular and tail contributions for a fixed row.
theorem tail_triangle_indicator_partial_split(b: Nat -> Real, n: Nat, i: Nat) {
    partial(abs_fn(b), n) =
        partial(triangle_row_indicator(b, n, i), n) + partial(tail_triangle_row_indicator(b, n, i), n)
} by {
    define tri(col_idx: Nat) -> Real { triangle_row_indicator(b, n, i, col_idx) }
    define tail(col_idx: Nat) -> Real { tail_triangle_row_indicator(b, n, i, col_idx) }

    from list.list_sum import partial_pointwise_eq
    partial_pointwise_eq(tri, triangle_row_indicator(b, n, i), n)

    partial_pointwise_eq(tail, tail_triangle_row_indicator(b, n, i), n)

    partial_pointwise_eq(add_fn(tri, tail), abs_fn(b), n)

    from list.list_sum import partial_add
    partial_add(tri, tail, n)

}

/// Solve for the tail indicator partial sum in terms of |b| and the triangular indicator.
theorem tail_triangle_indicator_partial_eq_diff(b: Nat -> Real, n: Nat, i: Nat) {
    partial(tail_triangle_row_indicator(b, n, i), n) =
        partial(abs_fn(b), n) - partial(triangle_row_indicator(b, n, i), n)
} by {
    tail_triangle_indicator_partial_split(b, n, i)

    sub_moves_sides(partial(tail_triangle_row_indicator(b, n, i), n),
        partial(triangle_row_indicator(b, n, i), n), partial(abs_fn(b), n))
}

/// Row sums equal |a(i)| times the difference between |b| and the triangular contribution.
theorem tail_triangle_row_sum_abs_eq_abs_diff(seq_a: Nat -> Real, seq_b: Nat -> Real, bound: Nat, row_idx: Nat) {
    row_sum(bound, tail_triangle_product(abs_fn(seq_a), abs_fn(seq_b), bound), row_idx) =
        abs_fn(seq_a)(row_idx) * (
            partial(abs_fn(seq_b), bound) -
                partial(triangle_row_indicator(seq_b, bound, row_idx), bound))
} by {
    define row(col_idx: Nat) -> Real {
        tail_triangle_product(abs_fn(seq_a), abs_fn(seq_b), bound, row_idx, col_idx)
    }
    define indicator(col_idx: Nat) -> Real {
        tail_triangle_row_indicator(seq_b, bound, row_idx, col_idx)
    }
    define scaled(col_idx: Nat) -> Real {
        abs_fn(seq_a)(row_idx) * indicator(col_idx)
    }

    from list.list_sum import partial_pointwise_eq
    partial_pointwise_eq(row, scaled, bound)

    sum(map(bound.range, row)) = sum(map(bound.range, scaled))

    partial_mul_scalar_right(indicator, abs_fn(seq_a)(row_idx), bound)

    partial_pointwise_eq(mul_fn(abs_fn(seq_a)(row_idx), indicator), scaled, bound)

    partial(indicator, bound) * abs_fn(seq_a)(row_idx) =
        sum(map(bound.range, scaled))

    real_mul_comm(partial(indicator, bound), abs_fn(seq_a)(row_idx))

    tail_triangle_indicator_partial_eq_diff(seq_b, bound, row_idx)

}

/// The row indicator never exceeds |b(j)|.
theorem tail_triangle_row_indicator_le_abs(b: Nat -> Real, n: Nat, i: Nat, j: Nat) {
    tail_triangle_row_indicator(b, n, i, j) <= abs_fn(b)(j)
} by {
    if i + j < n {
        abs_fn_nonneg(b, j)
    } else {
        tail_triangle_row_indicator(b, n, i, j) <= abs_fn(b)(j)
    }
}

/// On the lower triangular region, the indicator is zero.
theorem tail_triangle_row_indicator_zero(b: Nat -> Real, n: Nat, i: Nat, j: Nat) {
    i + j < n implies tail_triangle_row_indicator(b, n, i, j) = Real.0
} by {
    if i + j < n {
    }
}

/// Past the diagonal threshold, the indicator is exactly |b(j)|.
theorem tail_triangle_row_indicator_ge_abs(b: Nat -> Real, n: Nat, i: Nat, j: Nat) {
    not (i + j < n) implies tail_triangle_row_indicator(b, n, i, j) = abs_fn(b)(j)
} by {
    if not (i + j < n) {
    }
}

/// Bound a row sum by |a(i)| times the partial sum of |b|.
theorem tail_triangle_row_sum_abs_le(a: Nat -> Real, b: Nat -> Real, n: Nat, i: Nat) {
    row_sum(n, tail_triangle_product(abs_fn(a), abs_fn(b), n), i) <= abs_fn(a)(i) * partial(abs_fn(b), n)
} by {
    define row(j: Nat) -> Real { tail_triangle_product(abs_fn(a), abs_fn(b), n, i, j) }
    define indicator(j: Nat) -> Real { tail_triangle_row_indicator(b, n, i, j) }

    from list.list_sum import partial_pointwise_eq
    partial_pointwise_eq(row, mul_fn(abs_fn(a)(i), indicator), n)

    partial_mul_scalar_right(indicator, abs_fn(a)(i), n)

    partial_lte_partial(indicator, abs_fn(b), n)

    abs_fn_nonneg(a, i)
    zero_lte_imp_non_neg(abs_fn(a)(i))
    lte_mul_nonneg_right(partial(indicator, n), partial(abs_fn(b), n), abs_fn(a)(i))
    partial(indicator, n) * abs_fn(a)(i) <= partial(abs_fn(b), n) * abs_fn(a)(i)

    real_mul_comm(partial(abs_fn(b), n), abs_fn(a)(i))

}

/// Bound the tail triangle double sum by the product of partial absolute sums.
theorem tail_triangle_double_sum_abs_le_partial_product(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    double_sum(n, n, tail_triangle_product(abs_fn(a), abs_fn(b), n)) <= partial(abs_fn(a), n) * partial(abs_fn(b), n)
} by {
    define rows(i: Nat) -> Real { row_sum(n, tail_triangle_product(abs_fn(a), abs_fn(b), n), i) }
    define bound(i: Nat) -> Real { abs_fn(a)(i) * partial(abs_fn(b), n) }

    partial_lte_partial(rows, bound, n)

    double_sum_expands(n, n, tail_triangle_product(abs_fn(a), abs_fn(b), n))

    from list.list_sum import partial_pointwise_eq
    partial_pointwise_eq(bound, mul_fn(partial(abs_fn(b), n), abs_fn(a)), n)
    sum(map(n.range, bound)) = sum(map(n.range, mul_fn(partial(abs_fn(b), n), abs_fn(a))))

    partial_mul_scalar_right(abs_fn(a), partial(abs_fn(b), n), n)

    double_sum(n, n, tail_triangle_product(abs_fn(a), abs_fn(b), n)) <= partial(abs_fn(a), n) * partial(abs_fn(b), n)
}

/// Bound the magnitude of the difference between product of partial sums and the partial
/// sums of the Cauchy product.
theorem partial_product_diff_abs_le(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    (partial(a, n) * partial(b, n) - partial(cauchy_seq(a, b), n)).abs <= double_sum(n, n, tail_triangle_product(abs_fn(a), abs_fn(b), n))
} by {
    partial_product_minus_cauchy(a, b, n)

    // Apply triangle inequality to the double sum representation.
    double_sum_expands(n, n, tail_triangle_product(a, b, n))

    // Bound each row sum using triangle inequality.
    forall(i: Nat) {
        define row(j: Nat) -> Real { tail_triangle_product(a, b, n, i, j) }
        define row_abs(j: Nat) -> Real { tail_triangle_product(abs_fn(a), abs_fn(b), n, i, j) }

        sum_triangle_ineq(map(n.range, row))

        map_map(n.range, row, Real.abs)

        from list.list_sum import partial_pointwise_eq
        partial_pointwise_eq(compose(Real.abs, row), row_abs, n)
        sum(map(n.range, compose(Real.abs, row))) = sum(map(n.range, row_abs))

        (row_sum(n, tail_triangle_product(a, b, n), i)).abs <= row_sum(n, tail_triangle_product(abs_fn(a), abs_fn(b), n), i)
    }

    // Apply sum_triangle_ineq again to combine row contributions.
    sum_triangle_ineq(map(n.range, row_sum(n, tail_triangle_product(a, b, n))))

    map_map(n.range, row_sum(n, tail_triangle_product(a, b, n)), Real.abs)

    sum_map_range_le(n,
        compose(Real.abs, row_sum(n, tail_triangle_product(a, b, n))),
        row_sum(n, tail_triangle_product(abs_fn(a), abs_fn(b), n)))

    sum(map(n.range, compose(Real.abs, row_sum(n, tail_triangle_product(a, b, n))))) <= sum(map(n.range, row_sum(n, tail_triangle_product(abs_fn(a), abs_fn(b), n))))

}

/// Helper: Cauchy product partial sums of nonnegative sequences are bounded by product of partial sums.
/// For nonnegative sequences a and b:
/// ∑_{k=0}^{n-1} (∑_{i=0}^{k} a_i * b_{k-i}) ≤ (∑_{i=0}^{n-1} a_i) * (∑_{j=0}^{n-1} b_j)
///
/// The partial sum of the Cauchy sequence sums over all terms a(i)*b(j) where i+j < n (a triangular region).
/// The product of partial sums sums over all terms a(i)*b(j) where i < n and j < n (a square region).
/// Since the triangle is contained in the square and all terms are nonnegative, the result follows.
theorem cauchy_partial_product_bound(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0)
    implies
    partial(cauchy_seq(a, b), n) <= partial(a, n) * partial(b, n)
} by {
    if is_lower_bound(a, Real.0) and is_lower_bound(b, Real.0) {
        // Key insight: For all i, j with i+j < n, we have both i < n and j < n.
        // Therefore triangle_product(a, b, n, i, j) <= prod_fn(a, b)(i)(j) when i < n and j < n.

        forall(i: Nat, j: Nat) {
            if i < n and j < n {
                if i + j < n {
                    // When i+j < n, triangle_product equals the actual product
                } else {
                    // When i+j >= n, triangle_product is 0, which is <= the nonnegative product

                    // Both a(i) and b(j) are nonnegative
                    mul_nonneg(a(i), b(j))
                    Real.0 <= a(i) * b(j)
                    triangle_product(a, b, n, i, j) <= prod_fn(a, b)(i)(j)
                }
            }
        }

        // Apply pointwise comparison to double sums
        double_sum_pointwise_le(n, n, triangle_product(a, b, n), prod_fn(a, b))

        // Use partial_cauchy_as_triangle
        partial_cauchy_as_triangle(a, b, n)

        // Use partial_product_as_double_sum
        partial_product_as_double_sum(a, b, n)

        // Combine
        double_sum(n, n, triangle_product(a, b, n)) <= double_sum(n, n, prod_fn(a, b))
    }
}

/// Mertens' Theorem: The Cauchy product of two absolutely convergent series converges absolutely.
/// This is the key result needed to prove e^x * e^y = e^(x+y).
theorem cauchy_product_abs_converges(a: Nat -> Real, b: Nat -> Real) {
    absolutely_converges(a) and absolutely_converges(b)
    implies
    absolutely_converges(cauchy_seq(a, b))
} by {
    from real.real_series import monotone_convergence_principle, nonneg_partial_increasing, increasing_convergent_bounded_by_limit, is_increasing, is_upper_bound

    if absolutely_converges(a) and absolutely_converges(b) {
        // abs_fn(a) and abs_fn(b) are nonnegative
        is_lower_bound(abs_fn(a), Real.0)

        // Get upper bounds from absolute convergence

        increasing_convergent_bounded_by_limit(partial(abs_fn(a)))

        forall(n: Nat) {
            nonneg_partial_increasing(abs_fn(b))
        }
        increasing_convergent_bounded_by_limit(partial(abs_fn(b)))

        // Show abs_fn(cauchy_seq(a, b)) is nonnegative and its partials are increasing

        forall(n: Nat) {
            nonneg_partial_increasing(abs_fn(cauchy_seq(a, b)))
        }

        // Show partial(abs_fn(cauchy_seq(a, b))) is bounded

        forall(n: Nat) {
            partial_lte_partial(abs_fn(cauchy_seq(a, b)), cauchy_seq(abs_fn(a), abs_fn(b)), n)

            cauchy_partial_product_bound(abs_fn(a), abs_fn(b), n)

            is_upper_bound(partial(abs_fn(a)), limit(partial(abs_fn(a))))
            is_upper_bound(partial(abs_fn(b)), limit(partial(abs_fn(b))))
            partial(abs_fn(b), n) <= limit(partial(abs_fn(b)))

            nonneg_partial_increasing(abs_fn(a))
            nonneg_partial_increasing(abs_fn(b))
            Real.0 <= partial(abs_fn(a), n)
            Real.0 <= partial(abs_fn(b), n)
            mul_le_mul_nonneg(partial(abs_fn(a), n), partial(abs_fn(b), n), limit(partial(abs_fn(a))), limit(partial(abs_fn(b))))

            partial(abs_fn(cauchy_seq(a, b)), n) <= partial(cauchy_seq(abs_fn(a), abs_fn(b)), n)
            partial(cauchy_seq(abs_fn(a), abs_fn(b)), n) <= partial(abs_fn(a), n) * partial(abs_fn(b), n)
            partial(abs_fn(a), n) * partial(abs_fn(b), n) <= limit(partial(abs_fn(a))) * limit(partial(abs_fn(b)))
            partial(abs_fn(cauchy_seq(a, b)), n) <= limit(partial(abs_fn(a))) * limit(partial(abs_fn(b)))
        }

        is_upper_bound(partial(abs_fn(cauchy_seq(a, b))), limit(partial(abs_fn(a))) * limit(partial(abs_fn(b))))

        // Apply monotone convergence principle
        monotone_convergence_principle(partial(abs_fn(cauchy_seq(a, b))), limit(partial(abs_fn(a))) * limit(partial(abs_fn(b))))
        absolutely_converges(cauchy_seq(a, b))
    }
}

/// The Cauchy product of two absolutely convergent series converges (not just absolutely).
theorem cauchy_seq_converges(a: Nat -> Real, b: Nat -> Real) {
    absolutely_converges(a) and absolutely_converges(b)
    implies
    converges(partial(cauchy_seq(a, b)))
}

/// Helper: For absolutely convergent series, partial sum differences with fixed offset vanish.
/// This is key for showing that individual tail triangle rows vanish as n increases.
theorem partial_diff_vanishes_fixed_offset(a: Nat -> Real, k: Nat, eps: Real) {
    absolutely_converges(a) and eps.is_positive
    implies
    exists(big_n: Nat) {
        forall(n: Nat) {
            big_n + k <= n
            implies
            (partial(abs_fn(a), n) - partial(abs_fn(a), n - k)).abs < eps
        }
    }
} by {
    if absolutely_converges(a) and eps.is_positive {
        // abs_fn(a) partial sums converge
        let lim = limit(partial(abs_fn(a)))

        // By convergence, both partial(abs_fn(a), n) and partial(abs_fn(a), n-k) approach lim
        // So their difference approaches 0

        // Use tail_bound to get big_n
        // Get eps_half such that eps_half + eps_half < eps
        let eps_half: Real satisfy {
            eps_half.is_positive and eps_half + eps_half < eps
        }

        let big_n: Nat satisfy {
            tail_bound(partial(abs_fn(a)), lim, big_n, eps_half)
        }

        forall(n: Nat) {
            if big_n + k <= n {
                // Prove n - k >= big_n from big_n + k <= n
                // This is basic arithmetic but needs explicit steps
                // From big_n + k <= n, we get k <= n
                // By add_sub: n - k + k = n
                add_sub(n, k)
                // By add_comm: k + (n - k) = n
                add_comm(k, n - k)
                k + (n - k) = n
                // Therefore big_n + k <= k + (n - k)
                // Which means big_n <= n - k
                big_n <= n - k

                // Both n and n-k are >= big_n, so both are close to lim

                // If x is close to lim within eps_half and y is close to lim within eps_half,
                // then |x - y| < eps_half + eps_half < eps by triangle inequality
                (partial(abs_fn(a), n) - lim).abs < eps_half
                (partial(abs_fn(a), n - k) - lim).abs < eps_half

                // Use triangle inequality
                from real.real_series import triangle_ineq
                from real.real_base import lte_lt_trans

                let x_diff = partial(abs_fn(a), n) - lim
                let y_diff = partial(abs_fn(a), n - k) - lim
                let diff = partial(abs_fn(a), n) - partial(abs_fn(a), n - k)

                // Show diff = x_diff - y_diff algebraically
                // diff = partial(abs_fn(a), n) - partial(abs_fn(a), n - k)
                //      = (partial(abs_fn(a), n) - lim) - (partial(abs_fn(a), n - k) - lim) + lim - lim
                //      = x_diff - y_diff
                partial(abs_fn(a), n - k) = y_diff + lim

                // Apply triangle inequality: |x - y| <= |x| + |-y| = |x| + |y|
                triangle_ineq(x_diff, -y_diff)

                // We know both are < eps_half

                // So their sum is < eps_half + eps_half
                // Use that if a < b and c < d, then a + c < b + d
                from real.real_base import add_lt_lt
                add_lt_lt(x_diff.abs, eps_half, y_diff.abs, eps_half)

                lte_lt_trans(diff.abs, x_diff.abs + y_diff.abs, eps_half + eps_half)
                diff.abs < eps_half + eps_half

                // eps_half + eps_half < eps
                lte_lt_trans(diff.abs, eps_half + eps_half, eps)

                (partial(abs_fn(a), n) - partial(abs_fn(a), n - k)).abs < eps
            }
        }
    }
}
