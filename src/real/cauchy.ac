from util import constant, compose
from nat import Nat
from rat import Rat
from list import partial, sum, map, List
from real.real_ring import Real, converges, converges_to, limit, lift_seq
from real.real_series import mul_seq, add_seq

numerals Real

// This file defines the Cauchy product of two series and proves theorems about it.

attributes Real {
    // Placeholder to let other modules import Real from here.
}

/// The coefficient function for the Cauchy product at index n.
/// For a fixed n, this returns a function mapping k to a(k) * b(n-k).
define cauchy_coefficient(a: Nat -> Real, b: Nat -> Real, n: Nat) -> (Nat -> Real) {
    function(k: Nat) { a(k) * b(n - k) }
}

/// The Cauchy product of two sequences at index n.
/// This computes ∑_{k=0}^{n} a(k) * b(n-k).
define cauchy_product(a: Nat -> Real, b: Nat -> Real, n: Nat) -> Real {
    sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// The sequence of Cauchy products.
define cauchy_seq(a: Nat -> Real, b: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { cauchy_product(a, b, n) }
}

theorem cauchy_product_zero(a: Nat -> Real, b: Nat -> Real) {
    cauchy_product(a, b, Nat.0) = a(Nat.0) * b(Nat.0)
} by {
    Nat.0.suc = Nat.1
    Nat.1.range = List.singleton(Nat.0)
    let mapped = map(Nat.1.range, function(k: Nat) { a(k) * b(Nat.0 - k) })
    Nat.0 - Nat.0 = Nat.0
    mapped = List.singleton(a(Nat.0) * b(Nat.0))
    sum(mapped) = a(Nat.0) * b(Nat.0)
}

/// If we map a list with a function that always returns zero, the sum is zero.
theorem sum_map_zero[T](items: List[T], f: T -> Real) {
    (forall(x: T) { f(x) = Real.0 })
    implies
    sum(map(items, f)) = Real.0
} by {
    define p(xs: List[T]) -> Bool {
        (forall(x: T) { f(x) = Real.0 })
        implies
        sum(map(xs, f)) = Real.0
    }

    // Base case: empty list
    map(List.nil[T], f) = List.nil[Real]
    sum(List.nil[Real]) = Real.0
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if forall(x: T) { f(x) = Real.0 } {
                // Apply the hypothesis to tail
                sum(map(tail, f)) = Real.0

                // Now work on the cons case
                map(List.cons(head, tail), f) = List.cons(f(head), map(tail, f))
                sum(List.cons(f(head), map(tail, f))) = f(head) + sum(map(tail, f))
                f(head) = Real.0
                sum(List.cons(f(head), map(tail, f))) = Real.0 + Real.0
                sum(List.cons(f(head), map(tail, f))) = Real.0
                sum(map(List.cons(head, tail), f)) = Real.0
            }
            p(List.cons(head, tail))
        }
    }
}

/// If a is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_left(b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n)(k) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    a(k) = Real.0
    Real.0 * b(n - k) = Real.0
}

/// If a is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_left_fn(b: Nat -> Real, n: Nat) {
    cauchy_coefficient(constant[Nat, Real](Real.0), b, n) = constant[Nat, Real](Real.0)
} by {
    let a = constant[Nat, Real](Real.0)
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
}

/// If b is the constant zero function, then cauchy_coefficient returns constant zero.
theorem cauchy_coefficient_zero_right(a: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n)(k) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
    b(n - k) = Real.0
    a(k) * Real.0 = Real.0
}

/// If b is constant zero, then cauchy_coefficient is the constant zero function.
theorem cauchy_coefficient_zero_right_fn(a: Nat -> Real, n: Nat) {
    cauchy_coefficient(a, constant[Nat, Real](Real.0), n) = constant[Nat, Real](Real.0)
} by {
    let b = constant[Nat, Real](Real.0)
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
        constant[Nat, Real](Real.0)(k) = Real.0
    }
}

// TODO: Prove commutativity of Cauchy product
// /// Cauchy product is symmetric.
// theorem cauchy_product_comm(a: Nat -> Real, b: Nat -> Real, n: Nat) {
//     cauchy_product(a, b, n) = cauchy_product(b, a, n)
// } by {
//     // The sum ∑_{k=0}^{n} a(k) * b(n-k) equals ∑_{k=0}^{n} b(k) * a(n-k)
//     // by substituting j = n - k
//     let left = sum(map(n.suc.range, function(k: Nat) { a(k) * b(n - k) }))
//     let right = sum(map(n.suc.range, function(k: Nat) { b(k) * a(n - k) }))
//     left = right
// }

/// Cauchy product with a zero sequence on the left.
theorem cauchy_product_zero_left(b: Nat -> Real, n: Nat) {
    cauchy_product(constant[Nat, Real](Real.0), b, n) = Real.0
} by {
    let a = constant[Nat, Real](Real.0)

    // Show that cauchy_coefficient equals the constant zero function
    cauchy_coefficient(a, b, n) = constant[Nat, Real](Real.0)

    // Therefore every application returns zero
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
    }

    // Apply sum_map_zero
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0

    // This is the definition of cauchy_product
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(a, b, n) = Real.0
}

/// Cauchy product with a zero sequence on the right.
theorem cauchy_product_zero_right(a: Nat -> Real, n: Nat) {
    cauchy_product(a, constant[Nat, Real](Real.0), n) = Real.0
} by {
    let b = constant[Nat, Real](Real.0)

    // Show that cauchy_coefficient equals the constant zero function
    cauchy_coefficient(a, b, n) = constant[Nat, Real](Real.0)

    // Therefore every application returns zero
    forall(k: Nat) {
        cauchy_coefficient(a, b, n)(k) = Real.0
    }

    // Apply sum_map_zero
    sum(map(n.suc.range, cauchy_coefficient(a, b, n))) = Real.0

    // This is the definition of cauchy_product
    cauchy_product(a, b, n) = sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
    cauchy_product(a, b, n) = Real.0
}

/// Cauchy coefficient distributes over scalar multiplication in the first argument.
theorem cauchy_coefficient_mul_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(mul_seq(c, a), b, n)(k) = c * cauchy_coefficient(a, b, n)(k)
} by {
    cauchy_coefficient(mul_seq(c, a), b, n)(k) = mul_seq(c, a)(k) * b(n - k)
    mul_seq(c, a)(k) = c * a(k)
    c * a(k) * b(n - k) = c * (a(k) * b(n - k))
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
}

/// Cauchy coefficient distributes over scalar multiplication in the second argument.
theorem cauchy_coefficient_mul_right(a: Nat -> Real, c: Real, b: Nat -> Real, n: Nat, k: Nat) {
    cauchy_coefficient(a, mul_seq(c, b), n)(k) = c * cauchy_coefficient(a, b, n)(k)
} by {
    cauchy_coefficient(a, mul_seq(c, b), n)(k) = a(k) * mul_seq(c, b)(n - k)
    mul_seq(c, b)(n - k) = c * b(n - k)
    a(k) * (c * b(n - k)) = c * (a(k) * b(n - k))
    cauchy_coefficient(a, b, n)(k) = a(k) * b(n - k)
}

/// If two functions agree pointwise with a scaling factor, their mapped results also scale.
theorem map_scalar_pointwise[T](items: List[T], f: T -> Real, g: T -> Real, c: Real) {
    (forall(x: T) { f(x) = c * g(x) })
    implies
    sum(map(items, f)) = c * sum(map(items, g))
} by {
    define p(xs: List[T]) -> Bool {
        (forall(x: T) { f(x) = c * g(x) })
        implies
        sum(map(xs, f)) = c * sum(map(xs, g))
    }

    // Base case
    sum(map(List.nil[T], f)) = Real.0
    sum(map(List.nil[T], g)) = Real.0
    c * Real.0 = Real.0
    p(List.nil)

    // Inductive step
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if forall(x: T) { f(x) = c * g(x) } {
                // Apply hypothesis to tail
                sum(map(tail, f)) = c * sum(map(tail, g))

                // Work on the cons case
                map(List.cons(head, tail), f) = List.cons(f(head), map(tail, f))
                sum(List.cons(f(head), map(tail, f))) = f(head) + sum(map(tail, f))
                f(head) = c * g(head)
                f(head) + sum(map(tail, f)) = c * g(head) + c * sum(map(tail, g))
                c * g(head) + c * sum(map(tail, g)) = c * (g(head) + sum(map(tail, g)))

                map(List.cons(head, tail), g) = List.cons(g(head), map(tail, g))
                sum(List.cons(g(head), map(tail, g))) = g(head) + sum(map(tail, g))
                c * (g(head) + sum(map(tail, g))) = c * sum(map(List.cons(head, tail), g))

                sum(map(List.cons(head, tail), f)) = c * sum(map(List.cons(head, tail), g))
            }
            p(List.cons(head, tail))
        }
    }
}

/// Scalar multiplication distributes over Cauchy product in the first argument.
theorem cauchy_product_mul_left(c: Real, a: Nat -> Real, b: Nat -> Real, n: Nat) {
    cauchy_product(mul_seq(c, a), b, n) = c * cauchy_product(a, b, n)
} by {
    // Show that every coefficient gets multiplied by c
    forall(k: Nat) {
        cauchy_coefficient(mul_seq(c, a), b, n)(k) = c * cauchy_coefficient(a, b, n)(k)
    }

    // Apply map_scalar_pointwise
    sum(map(n.suc.range, cauchy_coefficient(mul_seq(c, a), b, n))) = c * sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}

/// Scalar multiplication distributes over Cauchy product in the second argument.
theorem cauchy_product_mul_right(a: Nat -> Real, c: Real, b: Nat -> Real, n: Nat) {
    cauchy_product(a, mul_seq(c, b), n) = c * cauchy_product(a, b, n)
} by {
    // Show that every coefficient gets multiplied by c
    forall(k: Nat) {
        cauchy_coefficient(a, mul_seq(c, b), n)(k) = c * cauchy_coefficient(a, b, n)(k)
    }

    // Apply map_scalar_pointwise
    sum(map(n.suc.range, cauchy_coefficient(a, mul_seq(c, b), n))) = c * sum(map(n.suc.range, cauchy_coefficient(a, b, n)))
}
