/// Double limits for functions from (Nat, Nat) to Real.
from nat import Nat
from real.real_base import Real
from real.real_series import is_increasing
from util import flip

/// The condition that f is within eps of val for all indices beyond n.
define double_limit_condition(f: (Nat, Nat) -> Real, val: Real, n: Nat, eps: Real) -> Bool {
    forall(i: Nat, j: Nat) {
        n <= i and n <= j implies f(i, j).is_close(val, eps)
    }
}

/// f converges to val.
define double_converges_to(f: (Nat, Nat) -> Real, val: Real) -> Bool {
    forall(eps: Real) {
        eps.is_positive implies exists(n: Nat) {
            double_limit_condition(f, val, n, eps)
        }
    }
}

/// f converges to some value.
define double_converges(f: (Nat, Nat) -> Real) -> Bool {
    exists(val: Real) {
        double_converges_to(f, val)
    }
}

/// The limit of f. Only meaningful when f converges.
let double_limit(f: (Nat, Nat) -> Real) -> val: Real satisfy {
    double_converges(f) implies double_converges_to(f, val)
}

/// A function is doubly increasing when it is increasing in both arguments.
/// That is, f(i, j) <= f(i, j+1) and f(i, j) <= f(i+1, j) for all i, j.
define doubly_increasing(f: (Nat, Nat) -> Real) -> Bool {
    forall(i: Nat, j: Nat) {
        f(i, j) <= f(i, j.suc) and f(i, j) <= f(i.suc, j)
    }
}

/// If f is doubly increasing, then for any fixed first argument i,
/// the function j -> f(i, j) is increasing.
theorem doubly_increasing_right(f: (Nat, Nat) -> Real, i: Nat) {
    doubly_increasing(f) implies is_increasing(function(j: Nat) { f(i, j) })
} by {
    if doubly_increasing(f) {
        forall(j: Nat) {
            f(i, j) <= f(i, j.suc)
        }
    }
}

/// If f is doubly increasing, then for any fixed second argument j,
/// the function i -> f(i, j) is increasing.
theorem doubly_increasing_left(f: (Nat, Nat) -> Real, j: Nat) {
    doubly_increasing(f) implies is_increasing(function(i: Nat) { f(i, j) })
} by {
    if doubly_increasing(f) {
        forall(i: Nat) {
            f(i, j) <= f(i.suc, j)
        }
    }
}

/// If f is doubly increasing, then flip(f, j) is increasing.
/// This is equivalent to doubly_increasing_left but using the flip function.
theorem doubly_increasing_flip(f: (Nat, Nat) -> Real, j: Nat) {
    doubly_increasing(f) implies is_increasing(function(i: Nat) { flip(f, j, i) })
} by {
    if doubly_increasing(f) {
        forall(i: Nat) {
            flip(f, j, i) <= flip(f, j, i.suc)
        }
    }
}

/// If f is doubly increasing and i1 <= i2, then f(i1, j) <= f(i2, j).
theorem doubly_increasing_first_mono(f: (Nat, Nat) -> Real, i1: Nat, i2: Nat, j: Nat) {
    doubly_increasing(f) and i1 <= i2 implies f(i1, j) <= f(i2, j)
} by {
    if doubly_increasing(f) and i1 <= i2 {
        // Use the fact that function(i: Nat) { f(i, j) } is increasing
        // and apply distant_increasing
        is_increasing(function(i: Nat) { f(i, j) })
    }
}

/// If f is doubly increasing and j1 <= j2, then f(i, j1) <= f(i, j2).
theorem doubly_increasing_second_mono(f: (Nat, Nat) -> Real, i: Nat, j1: Nat, j2: Nat) {
    doubly_increasing(f) and j1 <= j2 implies f(i, j1) <= f(i, j2)
} by {
    if doubly_increasing(f) and j1 <= j2 {
        // Use the fact that function(j: Nat) { f(i, j) } is increasing
        // and apply distant_increasing
        is_increasing(function(j: Nat) { f(i, j) })
    }
}

/// If f is doubly increasing, i1 <= i2, and j1 <= j2, then f(i1, j1) <= f(i2, j2).
theorem doubly_increasing_monotone(f: (Nat, Nat) -> Real, i1: Nat, i2: Nat, j1: Nat, j2: Nat) {
    doubly_increasing(f) and i1 <= i2 and j1 <= j2 implies f(i1, j1) <= f(i2, j2)
} by {
    if doubly_increasing(f) and i1 <= i2 and j1 <= j2 {
        // f(i1, j1) <= f(i2, j1) by doubly_increasing_first_mono
        f(i1, j1) <= f(i2, j1)
        // f(i2, j1) <= f(i2, j2) by doubly_increasing_second_mono
        f(i2, j1) <= f(i2, j2)
        // By transitivity
        f(i1, j1) <= f(i2, j2)
    }
}

/// True if x is in the image of f.
define double_image(f: (Nat, Nat) -> Real, x: Real) -> Bool {
    exists(i: Nat, j: Nat) {
        f(i, j) = x
    }
}

/// True if b is an upper bound for all values of f.
define double_is_upper_bound(f: (Nat, Nat) -> Real, b: Real) -> Bool {
    forall(i: Nat, j: Nat) {
        f(i, j) <= b
    }
}

/// True if s is the supremum of the image of f.
define double_image_is_supremum(f: (Nat, Nat) -> Real, s: Real) -> Bool {
    double_is_upper_bound(f, s) and
    forall(b: Real) {
        b < s implies not double_is_upper_bound(f, b)
    }
}

/// If f is doubly increasing and bounded above, then f converges to the
/// supremum of its image.
theorem doubly_increasing_bounded_converges(f: (Nat, Nat) -> Real, s: Real) {
    doubly_increasing(f) and double_image_is_supremum(f, s)
    implies
    double_converges_to(f, s)
} by {
    if doubly_increasing(f) and double_image_is_supremum(f, s) {
        // Need to show: for every eps > 0, there exist n such that
        // for all i >= n and j >= n, f(i, j) is within eps of s

        forall(eps: Real) {
            if eps.is_positive {
                // By the supremum property, s is an upper bound
                double_is_upper_bound(f, s)

                // Also, s - eps is not an upper bound (since s is the least upper bound)
                // So there exist a0, b0 with f(a0, b0) > s - eps
                s - eps < s
                not double_is_upper_bound(f, s - eps)

                // Therefore, there exist a0, b0 such that f(a0, b0) > s - eps
                let (a0: Nat, b0: Nat) satisfy {
                    f(a0, b0) > s - eps
                }

                // Now, for any i >= a0 and j >= b0, by doubly increasing property:
                forall(i: Nat, j: Nat) {
                    if a0 <= i and b0 <= j {
                        // f(a0, b0) <= f(i, j) by monotonicity
                        doubly_increasing_monotone(f, a0, i, b0, j)
                        f(a0, b0) <= f(i, j)

                        // So s - eps < f(a0, b0) <= f(i, j)
                        s - eps < f(i, j)

                        // And f(i, j) <= s since s is an upper bound
                        f(i, j) <= s

                        // Therefore s - eps < f(i, j) <= s
                        // which means |f(i, j) - s| < eps
                        f(i, j).is_close(s, eps)
                    }
                }

                // Take n = max(a0, b0) to ensure n <= i and n <= j
                let n = a0.max(b0)

                forall(i: Nat, j: Nat) {
                    if n <= i and n <= j {
                        // n = max(a0, b0), so a0 <= n and b0 <= n
                        // Therefore a0 <= n <= i and b0 <= n <= j
                        a0 <= n
                        b0 <= n
                        a0 <= i
                        b0 <= j

                        f(i, j).is_close(s, eps)
                    }
                }

                double_limit_condition(f, s, n, eps)
            }
        }

        double_converges_to(f, s)
    }
}
