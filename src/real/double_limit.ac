/// Double limits for functions from (Nat, Nat) to Real.
from nat import Nat
from rat import Rat
from real.real_base import Real
from real.real_series import is_increasing, is_upper_bound, monotone_convergence_principle, seq_lte
from real.real_seq import converges, limit, converges_imp_converges_to, eventual_ub, eventual_lb, ub_imp_limit_lte, lt_converges_to_imp_lb, gt_converges_to_imp_ub
from real.rectangular_sum import is_upper_bound_fn_2
from util import flip

/// The condition that f is within eps of val for all indices beyond n.
define double_limit_condition(f: (Nat, Nat) -> Real, val: Real, n: Nat, eps: Real) -> Bool {
    forall(i: Nat, j: Nat) {
        n <= i and n <= j implies f(i, j).is_close(val, eps)
    }
}

/// f converges to val.
define double_converges_to(f: (Nat, Nat) -> Real, val: Real) -> Bool {
    forall(eps: Real) {
        eps.is_positive implies exists(n: Nat) {
            double_limit_condition(f, val, n, eps)
        }
    }
}

/// f converges to some value.
define double_converges(f: (Nat, Nat) -> Real) -> Bool {
    exists(val: Real) {
        double_converges_to(f, val)
    }
}

/// The limit of f. Only meaningful when f converges.
let double_limit(f: (Nat, Nat) -> Real) -> val: Real satisfy {
    double_converges(f) implies double_converges_to(f, val)
}

/// A function is doubly increasing when it is increasing in both arguments.
/// That is, f(i, j) <= f(i, j+1) and f(i, j) <= f(i+1, j) for all i, j.
define doubly_increasing(f: (Nat, Nat) -> Real) -> Bool {
    forall(i: Nat, j: Nat) {
        f(i, j) <= f(i, j.suc) and f(i, j) <= f(i.suc, j)
    }
}

/// If f is doubly increasing, then for any fixed first argument i,
/// the function j -> f(i, j) is increasing.
theorem doubly_increasing_right(f: (Nat, Nat) -> Real, i: Nat) {
    doubly_increasing(f) implies is_increasing(function(j: Nat) { f(i, j) })
} by {
    if doubly_increasing(f) {
        forall(j: Nat) {
            f(i, j) <= f(i, j.suc)
        }
    }
}

/// If f is doubly increasing, then for any fixed second argument j,
/// the function i -> f(i, j) is increasing.
theorem doubly_increasing_left(f: (Nat, Nat) -> Real, j: Nat) {
    doubly_increasing(f) implies is_increasing(function(i: Nat) { f(i, j) })
} by {
    if doubly_increasing(f) {
        forall(i: Nat) {
            f(i, j) <= f(i.suc, j)
        }
    }
}

/// If f is doubly increasing, then flip(f, j) is increasing.
/// This is equivalent to doubly_increasing_left but using the flip function.
theorem doubly_increasing_flip(f: (Nat, Nat) -> Real, j: Nat) {
    doubly_increasing(f) implies is_increasing(function(i: Nat) { flip(f, j, i) })
} by {
    if doubly_increasing(f) {
        forall(i: Nat) {
            flip(f, j, i) <= flip(f, j, i.suc)
        }
    }
}

/// If f is doubly increasing and i1 <= i2, then f(i1, j) <= f(i2, j).
theorem doubly_increasing_first_mono(f: (Nat, Nat) -> Real, i1: Nat, i2: Nat, j: Nat) {
    doubly_increasing(f) and i1 <= i2 implies f(i1, j) <= f(i2, j)
} by {
    if doubly_increasing(f) and i1 <= i2 {
        // Use the fact that function(i: Nat) { f(i, j) } is increasing
        // and apply distant_increasing
        is_increasing(function(i: Nat) { f(i, j) })
    }
}

/// If f is doubly increasing and j1 <= j2, then f(i, j1) <= f(i, j2).
theorem doubly_increasing_second_mono(f: (Nat, Nat) -> Real, i: Nat, j1: Nat, j2: Nat) {
    doubly_increasing(f) and j1 <= j2 implies f(i, j1) <= f(i, j2)
} by {
    if doubly_increasing(f) and j1 <= j2 {
        // Use the fact that function(j: Nat) { f(i, j) } is increasing
        // and apply distant_increasing
        is_increasing(function(j: Nat) { f(i, j) })
    }
}

/// If f is doubly increasing, i1 <= i2, and j1 <= j2, then f(i1, j1) <= f(i2, j2).
theorem doubly_increasing_monotone(f: (Nat, Nat) -> Real, i1: Nat, i2: Nat, j1: Nat, j2: Nat) {
    doubly_increasing(f) and i1 <= i2 and j1 <= j2 implies f(i1, j1) <= f(i2, j2)
} by {
    if doubly_increasing(f) and i1 <= i2 and j1 <= j2 {
        // f(i1, j1) <= f(i2, j1) by doubly_increasing_first_mono
        f(i1, j1) <= f(i2, j1)
        // f(i2, j1) <= f(i2, j2) by doubly_increasing_second_mono
        f(i2, j1) <= f(i2, j2)
        // By transitivity
        f(i1, j1) <= f(i2, j2)
    }
}

/// If two sequences satisfy a <= b pointwise and both converge, their limits preserve the order.
theorem seq_lte_preserves_limit(a: Nat -> Real, b: Nat -> Real) {
    seq_lte(a, b) and converges(a) and converges(b)
    implies limit(a) <= limit(b)
} by {
    if seq_lte(a, b) and converges(a) and converges(b) {
        // Proof by contradiction
        if limit(a) > limit(b) {
            // Find a rational strictly between the two limits
            let r: Rat satisfy {
                limit(a) > Real.from_rat(r) and Real.from_rat(r) > limit(b)
            }

            let r_real = Real.from_rat(r)

            // Get convergence-to statements
            converges_imp_converges_to(a)
            converges_imp_converges_to(b)

            // Since limit(b) < r_real and b converges to limit(b),
            // eventually b(n) < r_real (by gt_converges_to_imp_ub)
            r_real > limit(b)
            gt_converges_to_imp_ub(b, r_real, limit(b))
            eventual_ub(b, r_real)

            let n1: Nat satisfy {
                forall(i: Nat) {
                    n1 <= i implies b(i) <= r_real
                }
            }

            // Since limit(a) > r_real and a converges to limit(a),
            // eventually a(n) > r_real (by lt_converges_to_imp_lb)
            r_real < limit(a)
            lt_converges_to_imp_lb(a, r_real, limit(a))
            eventual_lb(a, r_real)

            let n2: Nat satisfy {
                forall(i: Nat) {
                    n2 <= i implies a(i) >= r_real
                }
            }

            // Take any n >= max(n1, n2)
            let n = n1.max(n2)
            n1 <= n
            n2 <= n

            // Then a(n) >= r_real and b(n) <= r_real
            a(n) >= r_real
            b(n) <= r_real

            // We also know a(n) <= b(n) from seq_lte
            a(n) <= b(n)

            // By transitivity: r_real <= a(n) <= b(n) <= r_real
            // This implies r_real <= a(n) and a(n) <= r_real
            // So a(n) = r_real

            // Similarly: b(n) = r_real

            // Now use that limit(a) > r_real.
            // Since a converges to limit(a) and r_real < limit(a),
            // we should not have a(n) = r_real for all large n.
            // More precisely, there should be infinitely many n where a(n) differs from r_real.

            // The issue is that eventual_lb only gives >=, not >.
            // But combined with convergence, if limit(a) > r_real,
            // then there exists eps = (limit(a) - r_real) / 2 > 0
            // such that eventually |a(n) - limit(a)| < eps
            // which means a(n) > limit(a) - eps = r_real + eps > r_real

            // Let me make this more explicit:
            let eps_a = limit(a) - r_real
            eps_a.is_positive

            let eps_a_half: Real satisfy {
                eps_a_half.is_positive and eps_a_half + eps_a_half < eps_a
            }

            // Eventually a(n) is within eps_a_half of limit(a)
            let n3: Nat satisfy {
                forall(i: Nat) {
                    n3 <= i implies a(i).is_close(limit(a), eps_a_half)
                }
            }

            // For i >= max(n, n3):
            let nn = n.max(n3)
            n <= nn
            n3 <= nn

            a(nn).is_close(limit(a), eps_a_half)
            // This means |a(nn) - limit(a)| < eps_a_half
            // From is_close, we get a(nn) > limit(a) - eps_a_half
            limit(a) - eps_a_half < a(nn)

            // Now: limit(a) = r_real + eps_a
            limit(a) = r_real + eps_a

            // So: r_real + eps_a - eps_a_half < a(nn)
            // Which simplifies to: limit(a) - eps_a_half < a(nn)
            limit(a) - eps_a_half < a(nn)

            // Now, since eps_a_half + eps_a_half < eps_a:
            eps_a_half + eps_a_half < eps_a

            // And eps_a = limit(a) - r_real:
            eps_a = limit(a) - r_real

            // We have: eps_a_half + eps_a_half < limit(a) - r_real
            eps_a_half + eps_a_half < limit(a) - r_real

            // Adding r_real to both sides: r_real + eps_a_half + eps_a_half < limit(a)
            // Subtracting eps_a_half from both sides: r_real + eps_a_half < limit(a) - eps_a_half
            r_real + eps_a_half < limit(a) - eps_a_half

            // Since eps_a_half.is_positive: r_real < r_real + eps_a_half
            r_real < r_real + eps_a_half

            // By transitivity: r_real < limit(a) - eps_a_half
            r_real < limit(a) - eps_a_half
            limit(a) - eps_a_half < a(nn)
            r_real < a(nn)

            // But we also have a(nn) <= b(nn) <= r_real (since nn >= n)
            a(nn) <= b(nn)
            b(nn) <= r_real
            a(nn) <= r_real

            // So a(nn) <= r_real and r_real < a(nn), which is a contradiction
            false
        }

        // Therefore limit(a) <= limit(b)
    }
}

/// Helper: for each i, define the limit of f(i, j) as j -> infinity
define row_limit(f: (Nat, Nat) -> Real, i: Nat) -> Real {
    limit(function(j: Nat) { f(i, j) })
}

// If f is doubly increasing and bounded above, then the double limit exists.
// This theorem is true but requires a more sophisticated proof approach.
// The challenge is showing uniform convergence: for all i, j >= N, f(i,j) is close to L.
//
// Proof outline:
// 1. For each i, the row j -> f(i, j) converges to some g(i) (by monotone convergence)
// 2. The sequence g is increasing and bounded, so g(i) -> L for some L
// 3. The difficulty: showing f(i,j) is uniformly close to L requires coordinating
//    convergence across both dimensions. The threshold n2 where f(i, j) gets close
//    to g(i) depends on i, so we can't directly find a uniform N.
//
// Possible approaches:
// - Use the diagonal: show f(n,n) -> L and use monotonicity
// - Prove a lemma about uniform convergence for doubly monotone sequences
// - Use a more careful epsilon argument with 3-way splits
//
// theorem doubly_increasing_bounded_converges(f: (Nat, Nat) -> Real, bound: Real) {
//     doubly_increasing(f) and is_upper_bound_fn_2(f, bound)
//     implies double_converges(f)
// }
