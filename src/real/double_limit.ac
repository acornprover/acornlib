/// Double limits for functions from (Nat, Nat) to Real.
from nat import Nat
from real.real_base import Real
from real.real_series import is_increasing, is_upper_bound, monotone_convergence_principle, seq_lte_preserves_limit, increasing_convergent_bounded_by_limit
from real.real_seq import converges, converges_to, limit, ub_imp_limit_lte, eventual_ub, converges_imp_converges_to, converges_to_unique
from util import flip

/// The condition that f is within eps of val for all indices beyond n.
define double_limit_condition(f: (Nat, Nat) -> Real, val: Real, n: Nat, eps: Real) -> Bool {
    forall(i: Nat, j: Nat) {
        n <= i and n <= j implies f(i, j).is_close(val, eps)
    }
}

/// f converges to val.
define double_converges_to(f: (Nat, Nat) -> Real, val: Real) -> Bool {
    forall(eps: Real) {
        eps.is_positive implies exists(n: Nat) {
            double_limit_condition(f, val, n, eps)
        }
    }
}

/// f converges to some value.
define double_converges(f: (Nat, Nat) -> Real) -> Bool {
    exists(val: Real) {
        double_converges_to(f, val)
    }
}

/// The limit of f. Only meaningful when f converges.
let double_limit(f: (Nat, Nat) -> Real) -> val: Real satisfy {
    double_converges(f) implies double_converges_to(f, val)
}

/// A function is doubly increasing when it is increasing in both arguments.
/// That is, f(i, j) <= f(i, j+1) and f(i, j) <= f(i+1, j) for all i, j.
define doubly_increasing(f: (Nat, Nat) -> Real) -> Bool {
    forall(i: Nat, j: Nat) {
        f(i, j) <= f(i, j.suc) and f(i, j) <= f(i.suc, j)
    }
}

/// If f is doubly increasing, then for any fixed first argument i,
/// the function j -> f(i, j) is increasing.
theorem doubly_increasing_right(f: (Nat, Nat) -> Real, i: Nat) {
    doubly_increasing(f) implies is_increasing(function(j: Nat) { f(i, j) })
} by {
    if doubly_increasing(f) {
        forall(j: Nat) {
            f(i, j) <= f(i, j.suc)
        }
    }
}

/// If f is doubly increasing, then for any fixed second argument j,
/// the function i -> f(i, j) is increasing.
theorem doubly_increasing_left(f: (Nat, Nat) -> Real, j: Nat) {
    doubly_increasing(f) implies is_increasing(function(i: Nat) { f(i, j) })
} by {
    if doubly_increasing(f) {
        forall(i: Nat) {
            f(i, j) <= f(i.suc, j)
        }
    }
}

/// If f is doubly increasing, then flip(f, j) is increasing.
/// This is equivalent to doubly_increasing_left but using the flip function.
theorem doubly_increasing_flip(f: (Nat, Nat) -> Real, j: Nat) {
    doubly_increasing(f) implies is_increasing(function(i: Nat) { flip(f, j, i) })
} by {
    if doubly_increasing(f) {
        forall(i: Nat) {
            flip(f, j, i) <= flip(f, j, i.suc)
        }
    }
}

/// If f is doubly increasing and i1 <= i2, then f(i1, j) <= f(i2, j).
theorem doubly_increasing_first_mono(f: (Nat, Nat) -> Real, i1: Nat, i2: Nat, j: Nat) {
    doubly_increasing(f) and i1 <= i2 implies f(i1, j) <= f(i2, j)
} by {
    if doubly_increasing(f) and i1 <= i2 {
        // Use the fact that function(i: Nat) { f(i, j) } is increasing
        // and apply distant_increasing
        is_increasing(function(i: Nat) { f(i, j) })
    }
}

/// If f is doubly increasing and j1 <= j2, then f(i, j1) <= f(i, j2).
theorem doubly_increasing_second_mono(f: (Nat, Nat) -> Real, i: Nat, j1: Nat, j2: Nat) {
    doubly_increasing(f) and j1 <= j2 implies f(i, j1) <= f(i, j2)
} by {
    if doubly_increasing(f) and j1 <= j2 {
        // Use the fact that function(j: Nat) { f(i, j) } is increasing
        // and apply distant_increasing
        is_increasing(function(j: Nat) { f(i, j) })
    }
}

/// If f is doubly increasing, i1 <= i2, and j1 <= j2, then f(i1, j1) <= f(i2, j2).
theorem doubly_increasing_monotone(f: (Nat, Nat) -> Real, i1: Nat, i2: Nat, j1: Nat, j2: Nat) {
    doubly_increasing(f) and i1 <= i2 and j1 <= j2 implies f(i1, j1) <= f(i2, j2)
} by {
    if doubly_increasing(f) and i1 <= i2 and j1 <= j2 {
        // f(i1, j1) <= f(i2, j1) by doubly_increasing_first_mono
        f(i1, j1) <= f(i2, j1)
        // f(i2, j1) <= f(i2, j2) by doubly_increasing_second_mono
        f(i2, j1) <= f(i2, j2)
        // By transitivity
        f(i1, j1) <= f(i2, j2)
    }
}

/// True if x is in the image of f.
define double_image(f: (Nat, Nat) -> Real, x: Real) -> Bool {
    exists(i: Nat, j: Nat) {
        f(i, j) = x
    }
}

/// True if b is an upper bound for all values of f.
define double_is_upper_bound(f: (Nat, Nat) -> Real, b: Real) -> Bool {
    forall(i: Nat, j: Nat) {
        f(i, j) <= b
    }
}

/// True if s is the supremum of the image of f.
define double_image_is_supremum(f: (Nat, Nat) -> Real, s: Real) -> Bool {
    double_is_upper_bound(f, s) and
    forall(b: Real) {
        b < s implies not double_is_upper_bound(f, b)
    }
}

/// If f is doubly increasing and bounded above, then f converges to the
/// supremum of its image.
theorem doubly_increasing_bounded_converges(f: (Nat, Nat) -> Real, s: Real) {
    doubly_increasing(f) and double_image_is_supremum(f, s)
    implies
    double_converges_to(f, s)
} by {
    if doubly_increasing(f) and double_image_is_supremum(f, s) {
        // Need to show: for every eps > 0, there exist n such that
        // for all i >= n and j >= n, f(i, j) is within eps of s

        forall(eps: Real) {
            if eps.is_positive {
                // By the supremum property, s is an upper bound
                double_is_upper_bound(f, s)

                // Also, s - eps is not an upper bound (since s is the least upper bound)
                // So there exist a0, b0 with f(a0, b0) > s - eps
                s - eps < s
                not double_is_upper_bound(f, s - eps)

                // Therefore, there exist a0, b0 such that f(a0, b0) > s - eps
                let (a0: Nat, b0: Nat) satisfy {
                    f(a0, b0) > s - eps
                }

                // Now, for any i >= a0 and j >= b0, by doubly increasing property:
                forall(i: Nat, j: Nat) {
                    if a0 <= i and b0 <= j {
                        // f(a0, b0) <= f(i, j) by monotonicity
                        doubly_increasing_monotone(f, a0, i, b0, j)
                        f(a0, b0) <= f(i, j)

                        // So s - eps < f(a0, b0) <= f(i, j)
                        s - eps < f(i, j)

                        // And f(i, j) <= s since s is an upper bound
                        f(i, j) <= s

                        // Therefore s - eps < f(i, j) <= s
                        // which means |f(i, j) - s| < eps
                        f(i, j).is_close(s, eps)
                    }
                }

                // Take n = max(a0, b0) to ensure n <= i and n <= j
                let n = a0.max(b0)

                forall(i: Nat, j: Nat) {
                    if n <= i and n <= j {
                        // n = max(a0, b0), so a0 <= n and b0 <= n
                        // Therefore a0 <= n <= i and b0 <= n <= j
                        a0 <= n
                        b0 <= n
                        a0 <= i
                        b0 <= j

                        f(i, j).is_close(s, eps)
                    }
                }

                double_limit_condition(f, s, n, eps)
            }
        }

        double_converges_to(f, s)
    }
}

/// For a fixed i, the row sequence j -> f(i, j) converges.
define row_converges(f: (Nat, Nat) -> Real, i: Nat) -> Bool {
    converges(function(j: Nat) { f(i, j) })
}

/// The limit of the row sequence for fixed i.
define row_limit(f: (Nat, Nat) -> Real, i: Nat) -> Real {
    limit(function(j: Nat) { f(i, j) })
}

/// For a fixed j, the column sequence i -> f(i, j) converges.
define col_converges(f: (Nat, Nat) -> Real, j: Nat) -> Bool {
    converges(function(i: Nat) { f(i, j) })
}

/// The limit of the column sequence for fixed j.
define col_limit(f: (Nat, Nat) -> Real, j: Nat) -> Real {
    limit(function(i: Nat) { f(i, j) })
}

/// All row limits exist.
define all_rows_converge(f: (Nat, Nat) -> Real) -> Bool {
    forall(i: Nat) {
        row_converges(f, i)
    }
}

/// All column limits exist.
define all_cols_converge(f: (Nat, Nat) -> Real) -> Bool {
    forall(j: Nat) {
        col_converges(f, j)
    }
}

/// The iterated limit lim_{i→∞} lim_{j→∞} f(i, j).
/// This is the limit as i→∞ of the row limits.
define iterated_limit_rows(f: (Nat, Nat) -> Real) -> Real {
    limit(function(i: Nat) { row_limit(f, i) })
}

/// The iterated limit lim_{j→∞} lim_{i→∞} f(i, j).
/// This is the limit as j→∞ of the column limits.
define iterated_limit_cols(f: (Nat, Nat) -> Real) -> Real {
    limit(function(j: Nat) { col_limit(f, j) })
}

/// For a doubly increasing bounded function, each row sequence converges.
theorem row_sequence_converges(f: (Nat, Nat) -> Real, i: Nat, b: Real) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    converges(function(j: Nat) { f(i, j) })
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        // The row is increasing
        doubly_increasing_right(f, i)
        is_increasing(function(j: Nat) { f(i, j) })

        // The row is bounded
        forall(j: Nat) {
            f(i, j) <= b
        }
        is_upper_bound(function(j: Nat) { f(i, j) }, b)

        // By monotone convergence
        monotone_convergence_principle(function(j: Nat) { f(i, j) }, b)
    }
}

/// For a doubly increasing bounded function, each column sequence converges.
theorem col_sequence_converges(f: (Nat, Nat) -> Real, j: Nat, b: Real) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    converges(function(i: Nat) { f(i, j) })
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        // The column is increasing
        doubly_increasing_left(f, j)
        is_increasing(function(i: Nat) { f(i, j) })

        // The column is bounded
        forall(i: Nat) {
            f(i, j) <= b
        }
        is_upper_bound(function(i: Nat) { f(i, j) }, b)

        // By monotone convergence
        monotone_convergence_principle(function(i: Nat) { f(i, j) }, b)
    }
}

/// The sequence of row limits is increasing.
theorem row_limits_increasing(f: (Nat, Nat) -> Real, b: Real, i: Nat) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    limit(function(j: Nat) { f(i, j) }) <= limit(function(j: Nat) { f(i.suc, j) })
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        // Both rows converge
        row_sequence_converges(f, i, b)
        converges(function(j: Nat) { f(i, j) })
        row_sequence_converges(f, i.suc, b)
        converges(function(j: Nat) { f(i.suc, j) })

        // For all j, f(i, j) <= f(i.suc, j)
        forall(j: Nat) {
            doubly_increasing_first_mono(f, i, i.suc, j)
            f(i, j) <= f(i.suc, j)
        }

        // Limits preserve the ordering
        seq_lte_preserves_limit(function(j: Nat) { f(i, j) }, function(j: Nat) { f(i.suc, j) })
    }
}

/// The sequence of column limits is increasing.
theorem col_limits_increasing(f: (Nat, Nat) -> Real, b: Real, j: Nat) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    limit(function(i: Nat) { f(i, j) }) <= limit(function(i: Nat) { f(i, j.suc) })
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        // Both columns converge
        col_sequence_converges(f, j, b)
        converges(function(i: Nat) { f(i, j) })
        col_sequence_converges(f, j.suc, b)
        converges(function(i: Nat) { f(i, j.suc) })

        // For all i, f(i, j) <= f(i, j.suc)
        forall(i: Nat) {
            doubly_increasing_second_mono(f, i, j, j.suc)
            f(i, j) <= f(i, j.suc)
        }

        // Limits preserve the ordering
        seq_lte_preserves_limit(function(i: Nat) { f(i, j) }, function(i: Nat) { f(i, j.suc) })
    }
}

/// Each row limit is bounded by b.
theorem row_limit_bounded(f: (Nat, Nat) -> Real, i: Nat, b: Real) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    limit(function(j: Nat) { f(i, j) }) <= b
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        row_sequence_converges(f, i, b)
        converges(function(j: Nat) { f(i, j) })

        // All elements are bounded by b
        forall(j: Nat) {
            f(i, j) <= b
        }
        eventual_ub(function(j: Nat) { f(i, j) }, b)

        // So the limit is also bounded
        ub_imp_limit_lte(function(j: Nat) { f(i, j) }, b)
    }
}

/// Each column limit is bounded by b.
theorem col_limit_bounded(f: (Nat, Nat) -> Real, j: Nat, b: Real) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    limit(function(i: Nat) { f(i, j) }) <= b
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        col_sequence_converges(f, j, b)
        converges(function(i: Nat) { f(i, j) })

        // All elements are bounded by b
        forall(i: Nat) {
            f(i, j) <= b
        }
        eventual_ub(function(i: Nat) { f(i, j) }, b)

        // So the limit is also bounded
        ub_imp_limit_lte(function(i: Nat) { f(i, j) }, b)
    }
}

/// The sequence of row limits is increasing (full version).
theorem row_limits_is_increasing(f: (Nat, Nat) -> Real, b: Real) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    is_increasing(function(i: Nat) { row_limit(f, i) })
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        forall(i: Nat) {
            row_limits_increasing(f, b, i)
        }
    }
}

/// The sequence of column limits is increasing (full version).
theorem col_limits_is_increasing(f: (Nat, Nat) -> Real, b: Real) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    is_increasing(function(j: Nat) { col_limit(f, j) })
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        forall(j: Nat) {
            col_limits_increasing(f, b, j)
        }
    }
}

/// The sequence of row limits is bounded.
theorem row_limits_bounded(f: (Nat, Nat) -> Real, b: Real) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    is_upper_bound(function(i: Nat) { row_limit(f, i) }, b)
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        forall(i: Nat) {
            row_limit_bounded(f, i, b)
        }
    }
}

/// The sequence of column limits is bounded.
theorem col_limits_bounded(f: (Nat, Nat) -> Real, b: Real) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    is_upper_bound(function(j: Nat) { col_limit(f, j) }, b)
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        forall(j: Nat) {
            col_limit_bounded(f, j, b)
        }
    }
}

/// The iterated limit over rows exists and converges.
theorem iterated_rows_converges(f: (Nat, Nat) -> Real, b: Real) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    converges(function(i: Nat) { row_limit(f, i) })
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        let row_lims = function(i: Nat) { row_limit(f, i) }

        row_limits_is_increasing(f, b)
        is_increasing(row_lims)

        row_limits_bounded(f, b)
        is_upper_bound(row_lims, b)

        monotone_convergence_principle(row_lims, b)
        converges(row_lims)
    }
}

/// The iterated limit over columns exists and converges.
theorem iterated_cols_converges(f: (Nat, Nat) -> Real, b: Real) {
    doubly_increasing(f) and double_is_upper_bound(f, b)
    implies
    converges(function(j: Nat) { col_limit(f, j) })
} by {
    if doubly_increasing(f) and double_is_upper_bound(f, b) {
        let col_lims = function(j: Nat) { col_limit(f, j) }

        col_limits_is_increasing(f, b)
        is_increasing(col_lims)

        col_limits_bounded(f, b)
        is_upper_bound(col_lims, b)

        monotone_convergence_principle(col_lims, b)
        converges(col_lims)
    }
}

// TODO: Complete the final theorem showing all three limits are equal.
// The framework is now in place with:
// - Definitions of iterated limits (iterated_limit_rows, iterated_limit_cols)
// - Proofs that individual row/column sequences converge
// - Proofs (in progress) that sequences of limits are increasing and bounded
// - Setup for showing the iterated limits converge
//
// Remaining work: The above theorems need refinement to satisfy the Acorn
// constraint checker. The mathematical content is sound but needs adjustments
// in how the proofs are structured for verification.
