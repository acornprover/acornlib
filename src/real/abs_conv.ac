from util import constant, compose
from nat import Nat
from list import partial, sum, map, List
from semigroup import mul_fn
from add_semigroup import add_fn
from real.real_ring import Real, converges, limit, converges_to, mul_neg_one_left, mul_abs
from real.real_seq import limit_add_seq, converges_imp_converges_to, converges_to_imp_converges, converges_to_unique, tail_bound, cauchy_bound, eventual_ub, ub_imp_limit_lte
from real.real_series import is_lower_bound, add_seq, const_converges, const_limit, neg_seq, mul_seq, comparison_test, seq_lte, is_upper_bound
from real.double_sum import mul_le_mul_nonneg
from real.limits import vanishes, abs_seq
from real.real_base import add_assoc, add_neg_eq_zero, add_zero_left, add_zero_right, neg_neg, sub_moves_sides, abs_neg, lte_trans, lte_lt_trans, lt_trans, lt_add_pos, not_lt_imp_gte
from real.prod_seq import prod_seq
from set import Set

numerals Real

// This file defines absolute convergence for series.

/// The absolute value of each element in a sequence.
/// For a sequence a, this returns the sequence n ↦ |a(n)|.
define abs_fn(a: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { a(n).abs }
}

/// Filter a sequence by a predicate, zeroing out terms where the predicate is false.
define filter_seq(f: Nat -> Real, p: Nat -> Bool, n: Nat) -> Real {
    if p(n) { f(n) } else { Real.0 }
}

/// A subseries of f, including only terms whose indices are in the set s.
define subseries(f: Nat -> Real, s: Set[Nat], n: Nat) -> Real {
    filter_seq(f, s.contains, n)
}

/// A series converges absolutely if the series of absolute values converges.
define absolutely_converges(a: Nat -> Real) -> Bool {
    converges(partial(abs_fn(a)))
}

/// A sequence admits an upper bound if some real number bounds every term from above.
define has_upper_bound(a: Nat -> Real) -> Bool {
    exists(bound: Real) { is_upper_bound(a, bound) }
}

/// The absolute value of any element in the constant zero sequence is zero.
theorem abs_fn_zero(n: Nat) {
    abs_fn(constant[Nat, Real](Real.0))(n) = Real.0
}

/// The absolute value of any element in a sequence is nonnegative.
theorem abs_fn_nonneg(a: Nat -> Real, n: Nat) {
    abs_fn(a)(n) >= Real.0
}

/// Absolute value commutes with scalar multiplication (up to taking abs of scalar).
theorem abs_fn_scalar_mul(c: Real, a: Nat -> Real, n: Nat) {
    abs_fn(mul_fn(c, a))(n) = c.abs * abs_fn(a)(n)
}

/// abs_fn is equivalent to composing with Real.abs.
theorem abs_fn_eq_compose(a: Nat -> Real, n: Nat) {
    abs_fn(a)(n) = compose(Real.abs, a)(n)
}

/// The absolute value of a pointwise product is the product of absolute values.
theorem abs_fn_prod_seq(a: Nat -> Real, b: Nat -> Real, n: Nat) {
    abs_fn(prod_seq(a, b))(n) = abs_fn(a)(n) * abs_fn(b)(n)
} by {
    abs_fn(prod_seq(a, b))(n) = prod_seq(a, b, n).abs
    prod_seq(a, b, n) = a(n) * b(n)
    mul_abs(a(n), b(n))
    (a(n) * b(n)).abs = a(n).abs * b(n).abs
    abs_fn(a)(n) = a(n).abs
    abs_fn(b)(n) = b(n).abs
}

/// Difference between two partial sums of the same series.
define partial_diff(f: Nat -> Real, m: Nat, n: Nat) -> Real {
    partial(f, n) - partial(f, m)
}

/// Difference between the limit of partial sums and the mth partial sum.
define tail_limit_diff(f: Nat -> Real, m: Nat) -> Real {
    limit(partial(f)) - partial(f, m)
}

/// Pointwise difference of two sequences.
define sub_seq(s: Nat -> Real, t: Nat -> Real, n: Nat) -> Real {
    s(n) - t(n)
}

/// Absolute value of the difference between two sequences.
define abs_diff_seq(s: Nat -> Real, t: Nat -> Real, n: Nat) -> Real {
    sub_seq(s, t, n).abs
}

/// Two sequences differ by a vanishing amount.
define vanishing_diff(s: Nat -> Real, t: Nat -> Real) -> Bool {
    vanishes(abs_diff_seq(s, t))
}

/// A sequence vanishes if and only if its absolute value sequence vanishes.
theorem vanishes_of_abs_seq(a: Nat -> Real) {
    vanishes(abs_seq(a))
    implies
    vanishes(a)
}

/// Taking negatives preserves the vanishing property.
theorem vanishes_neg_seq(a: Nat -> Real) {
    vanishes(a)
    implies
    vanishes(neg_seq(a))
}

/// Vanishing is preserved under pointwise equality.
theorem vanishes_congr_left(a: Nat -> Real, b: Nat -> Real) {
    a = b and vanishes(b)
    implies
    vanishes(a)
}

/// Negating the difference sequence swaps the order of the arguments.
theorem neg_seq_sub_seq_eq(s: Nat -> Real, t: Nat -> Real) {
    neg_seq(sub_seq(s, t)) = sub_seq(t, s)
} by {
    forall(n: Nat) {
        let lhs = sub_seq(s, t, n)
        let rhs = sub_seq(t, s, n)

        lhs + rhs = (s(n) - t(n)) + (t(n) - s(n))
        add_assoc(s(n), -t(n), t(n) + -s(n))
        add_assoc(-t(n), t(n), -s(n))
        add_neg_eq_zero(-t(n))
        neg_neg(t(n))
        add_zero_right(s(n))
        add_neg_eq_zero(s(n))

        sub_moves_sides(rhs, lhs, Real.0)
        add_zero_left(-lhs)

        mul_neg_one_left(lhs)
        neg_seq(sub_seq(s, t))(n) = sub_seq(t, s, n)
    }
}

/// Absolute values of the raw difference equal the absolute difference sequence (original order).
theorem abs_seq_sub_seq_eq_abs_diff_left(s: Nat -> Real, t: Nat -> Real) {
    abs_seq(sub_seq(s, t)) = abs_diff_seq(s, t)
}

/// Absolute values of the reversed difference also equal the absolute difference sequence.
theorem abs_seq_sub_seq_eq_abs_diff_right(s: Nat -> Real, t: Nat -> Real) {
    abs_seq(sub_seq(t, s)) = abs_diff_seq(s, t)
} by {
    forall(n: Nat) {
        neg_seq_sub_seq_eq(s, t)
        mul_neg_one_left(sub_seq(s, t, n))
        sub_seq(t, s, n) = -sub_seq(s, t, n)
        abs_neg(sub_seq(s, t, n))
        abs_seq(sub_seq(t, s))(n) = abs_diff_seq(s, t, n)
    }
}

/// Absolute vanishing differences imply raw differences vanish.
theorem vanishing_diff_abs_eq(s: Nat -> Real, t: Nat -> Real) {
    vanishing_diff(s, t)
    implies
    vanishes(sub_seq(t, s))
}

/// Vanishing differences allow us to transfer limits across sequences.
theorem limit_preserved_by_vanishing_diff(s: Nat -> Real, t: Nat -> Real) {
    converges(s) and vanishing_diff(s, t)
    implies
    converges(t) and limit(s) = limit(t)
} by {
    if converges(s) and vanishing_diff(s, t) {
        let diff = sub_seq(t, s)

        vanishing_diff_abs_eq(s, t)

        forall(n: Nat) {
            add_assoc(t(n), -s(n), s(n))
            add_neg_eq_zero(s(n))
            add_zero_right(t(n))
            add_seq(diff, s)(n) = t(n)
        }

        limit_add_seq(diff, s)
        add_zero_left(limit(s))
        converges_to(t, limit(s))
    }
}

/// Absolute convergence implies convergence (alternate formulation).
/// This connects our definition to the existing theorem in real_series.ac.
theorem absolutely_converges_imp_converges(a: Nat -> Real) {
    absolutely_converges(a) implies converges(partial(a))
} by {
    from real.real_series import abs_conv_imp_conv

    if absolutely_converges(a) {
        partial(abs_fn(a)) = partial(compose(Real.abs, a))

        abs_conv_imp_conv(a)
        converges(partial(a))
    }
}

/// Absolute convergence is preserved under scalar multiplication.
theorem absolutely_converges_scalar_mul(c: Real, a: Nat -> Real) {
    absolutely_converges(a) implies absolutely_converges(mul_fn(c, a))
} by {
    from real.real_series import converges_mul_seq

    if absolutely_converges(a) {
        partial(abs_fn(mul_fn(c, a))) = partial(mul_fn(c.abs, abs_fn(a)))
        partial(mul_fn(c.abs, abs_fn(a))) = mul_fn(c.abs, partial(abs_fn(a)))

        mul_fn(c.abs, partial(abs_fn(a))) = mul_seq(c.abs, partial(abs_fn(a)))

        converges_mul_seq(c.abs, partial(abs_fn(a)))
        absolutely_converges(mul_fn(c, a))
    }
}

/// Absolute convergence is preserved by multiplication with a bounded sequence.
/// If |b(n)| ≤ bound for all n and ∑|a(n)| converges, then ∑|a(n) * b(n)| converges.
theorem absolutely_converges_mul_bounded(a: Nat -> Real, b: Nat -> Real) {
    absolutely_converges(a)
    and has_upper_bound(abs_fn(b))
    implies
    absolutely_converges(prod_seq(a, b))
} by {
    from real.real_series import converges_mul_seq

    let bound: Real satisfy {
        is_upper_bound(abs_fn(b), bound)
    }

    is_upper_bound(abs_fn(b), bound)

    abs_fn_nonneg(b, Nat.0)
    abs_fn(b)(Nat.0) >= Real.0
    abs_fn(b)(Nat.0) <= bound
    lte_trans(Real.0, abs_fn(b)(Nat.0), bound)
    Real.0 <= bound

    forall(n: Nat) {
        is_upper_bound(abs_fn(b), bound)
        abs_fn_prod_seq(a, b, n)
        abs_fn_nonneg(a, n)
        abs_fn_nonneg(b, n)
        abs_fn(b)(n) <= bound
        mul_le_mul_nonneg(abs_fn(a)(n), abs_fn(b)(n), abs_fn(a)(n), bound)
        abs_fn(prod_seq(a, b))(n) = abs_fn(a)(n) * abs_fn(b)(n)
        mul_fn(bound, abs_fn(a))(n) = bound * abs_fn(a)(n)
        abs_fn(prod_seq(a, b))(n) <= mul_fn(bound, abs_fn(a))(n)
    }

    forall(n: Nat) {
        abs_fn_nonneg(prod_seq(a, b), n)
    }
    is_lower_bound(abs_fn(prod_seq(a, b)), Real.0)

    partial(mul_fn(bound, abs_fn(a))) = mul_fn(bound, partial(abs_fn(a)))
    mul_fn(bound, partial(abs_fn(a))) = mul_seq(bound, partial(abs_fn(a)))

    absolutely_converges(a)
    converges(partial(abs_fn(a)))
    converges_mul_seq(bound, partial(abs_fn(a)))
    converges(mul_seq(bound, partial(abs_fn(a))))
    converges(partial(mul_fn(bound, abs_fn(a))))

    comparison_test(abs_fn(prod_seq(a, b)), mul_fn(bound, abs_fn(a)))
    absolutely_converges(prod_seq(a, b))
}

/// Absolute convergence is preserved under addition of sequences.
theorem absolutely_converges_add(a: Nat -> Real, b: Nat -> Real) {
    absolutely_converges(a) and absolutely_converges(b)
    implies
    absolutely_converges(add_fn(a, b))
} by {
    from real.real_series import add_seq_converges

    if absolutely_converges(a) and absolutely_converges(b) {
        forall(n: Nat) {
            abs_fn(add_fn(a, b))(n) <= add_fn(abs_fn(a), abs_fn(b))(n)
        }

        is_lower_bound(abs_fn(add_fn(a, b)), Real.0)

        partial(add_fn(abs_fn(a), abs_fn(b))) = add_fn(partial(abs_fn(a)), partial(abs_fn(b)))

        add_fn(partial(abs_fn(a)), partial(abs_fn(b))) = add_seq(partial(abs_fn(a)), partial(abs_fn(b)))

        add_seq_converges(partial(abs_fn(a)), partial(abs_fn(b)))

        comparison_test(abs_fn(add_fn(a, b)), add_fn(abs_fn(a), abs_fn(b)))
        absolutely_converges(add_fn(a, b))
    }
}

/// Filtering a sequence preserves absolute convergence.
theorem absolutely_converges_filter_seq(a: Nat -> Real, p: Nat -> Bool) {
    absolutely_converges(a)
    implies
    absolutely_converges(filter_seq(a, p))
} by {
    if absolutely_converges(a) {
        forall(n: Nat) {
            if p(n) {
                filter_seq(a, p)(n) = if p(n) { a(n) } else { Real.0 }
                (if p(n) { a(n) } else { Real.0 }) = a(n)
                filter_seq(a, p)(n) = a(n)
                abs_fn(filter_seq(a, p))(n) = abs_fn(a)(n)
                abs_fn(filter_seq(a, p))(n) <= abs_fn(a)(n)
            } else {
                filter_seq(a, p)(n) = if p(n) { a(n) } else { Real.0 }
                (if p(n) { a(n) } else { Real.0 }) = Real.0
                filter_seq(a, p)(n) = Real.0
                abs_fn(filter_seq(a, p))(n) = Real.0
                abs_fn_nonneg(a, n)
                Real.0 <= abs_fn(a)(n)
                abs_fn(filter_seq(a, p))(n) <= abs_fn(a)(n)
            }
        }

        forall(n: Nat) {
            abs_fn_nonneg(filter_seq(a, p), n)
        }
        is_lower_bound(abs_fn(filter_seq(a, p)), Real.0)

        absolutely_converges(a)
        converges(partial(abs_fn(a)))

        comparison_test(abs_fn(filter_seq(a, p)), abs_fn(a))
        absolutely_converges(filter_seq(a, p))
    }
}

/// A subseries of an absolutely convergent series is also absolutely convergent.
theorem absolutely_converges_subseries(a: Nat -> Real, s: Set[Nat]) {
    absolutely_converges(a)
    implies
    absolutely_converges(subseries(a, s))
} by {
    if absolutely_converges(a) {
        forall(n: Nat) {
            subseries(a, s, n) = filter_seq(a, s.contains, n)
        }
        subseries(a, s) = filter_seq(a, s.contains)

        absolutely_converges_filter_seq(a, s.contains)
        absolutely_converges(subseries(a, s))
    }
}

/// Comparison test for absolute convergence.
/// If |a(n)| ≤ b(n), the b(n) are nonnegative, and ∑ b(n) converges, then ∑ a(n) converges absolutely.
theorem absolutely_converges_comparison(a: Nat -> Real, b: Nat -> Real) {
    is_lower_bound(b, Real.0)
    and seq_lte(abs_fn(a), b)
    and converges(partial(b))
    implies
    absolutely_converges(a)
} by {
    forall(n: Nat) {
        abs_fn_nonneg(a, n)
    }
    is_lower_bound(abs_fn(a), Real.0)

    comparison_test(abs_fn(a), b)
    absolutely_converges(a)
}

/// Tail bound for absolutely convergent series.
/// If a series converges absolutely, then tail sums can be made arbitrarily small.
/// For any ε > 0, there exists N such that for all n, m ≥ N with n ≤ m,
/// the sum of |a(k)| from k=n to k=m-1 is less than ε.
/// For fixed m, the difference between partial sums converges to the tail limit difference.
theorem tail_diff_converges(a: Nat -> Real, m: Nat) {
    absolutely_converges(a)
    implies
    converges_to(partial_diff(abs_fn(a), m), tail_limit_diff(abs_fn(a), m))
} by {
    if absolutely_converges(a) {
        let lim = limit(partial(abs_fn(a)))

        const_converges(-partial(abs_fn(a), m))

        limit_add_seq(partial(abs_fn(a)), constant[Nat, Real](-partial(abs_fn(a), m)))

        const_limit(-partial(abs_fn(a), m))

        partial_diff(abs_fn(a), m) =
            add_seq(partial(abs_fn(a)), constant[Nat, Real](-partial(abs_fn(a), m)))

        converges_to(partial_diff(abs_fn(a), m), tail_limit_diff(abs_fn(a), m))
    }
}

theorem abs_conv_tail_bound(a: Nat -> Real, eps: Real) {
    absolutely_converges(a) and eps.is_positive
    implies
    exists(big_n: Nat) {
        forall(n: Nat, m: Nat) {
            big_n <= n and n <= m
            implies
            partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps
        }
    }
} by {
    from real.real_series import distant_increasing, nonneg_imp_partial_increasing, is_increasing

    if absolutely_converges(a) and eps.is_positive {
        let big_n: Nat satisfy {
            cauchy_bound(partial(abs_fn(a)), big_n, eps)
        }

        forall(n: Nat, m: Nat) {
            if big_n <= n and n <= m {
                nonneg_imp_partial_increasing(abs_fn(a))

                distant_increasing(partial(abs_fn(a)), n, m)

                partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps
            }
        }
    }
}
/// Absolute convergence ensures the infinite tail of absolute values is arbitrarily small.
/// Given ε > 0, there exists N such that the sum of |a(k)| for k ≥ N is less than ε.
theorem abs_conv_tail_sum_small(a: Nat -> Real, eps: Real) {
    absolutely_converges(a) and eps.is_positive
    implies
    exists(big_n: Nat) {
        tail_limit_diff(abs_fn(a), big_n) < eps
    }
} by {
    if absolutely_converges(a) and eps.is_positive {
        let eps_small: Real satisfy {
            eps_small.is_positive and eps_small + eps_small < eps
        }

        let big_n: Nat satisfy {
            forall(n: Nat, m: Nat) {
                big_n <= n and n <= m
                implies
                partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps_small
            }
        }

        forall(n: Nat) {
            if big_n <= n {
                partial(abs_fn(a), n) - partial(abs_fn(a), big_n) < eps_small
                not_lt_imp_gte(eps_small, partial(abs_fn(a), n) - partial(abs_fn(a), big_n))
                partial_diff(abs_fn(a), big_n, n) <= eps_small
            }
        }

        eventual_ub(partial_diff(abs_fn(a), big_n), eps_small)

        tail_diff_converges(a, big_n)
        converges_to_imp_converges(partial_diff(abs_fn(a), big_n), tail_limit_diff(abs_fn(a), big_n))
        converges(partial_diff(abs_fn(a), big_n))

        converges_imp_converges_to(partial_diff(abs_fn(a), big_n))
        converges_to_unique(partial_diff(abs_fn(a), big_n), tail_limit_diff(abs_fn(a), big_n), limit(partial_diff(abs_fn(a), big_n)))
        tail_limit_diff(abs_fn(a), big_n) = limit(partial_diff(abs_fn(a), big_n))

        ub_imp_limit_lte(partial_diff(abs_fn(a), big_n), eps_small)
        tail_limit_diff(abs_fn(a), big_n) <= eps_small

        lt_add_pos(eps_small, eps_small)
        eps_small < eps_small + eps_small
        lt_trans(eps_small, eps_small + eps_small, eps)

        lte_lt_trans(tail_limit_diff(abs_fn(a), big_n), eps_small, eps)
        tail_limit_diff(abs_fn(a), big_n) < eps
    }
}
