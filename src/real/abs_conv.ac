from util import constant, compose
from nat import Nat
from list import partial, sum, map, List
from semigroup import mul_fn
from add_semigroup import add_fn
from real.real_ring import Real, converges, limit, converges_to, mul_neg_one_left
from real.real_seq import limit_add_seq, converges_imp_converges_to, converges_to_imp_converges, converges_to_unique, tail_bound, cauchy_bound
from real.real_series import is_lower_bound, add_seq, const_converges, const_limit, neg_seq, mul_seq
from real.limits import vanishes, abs_seq
from real.real_base import add_assoc, add_neg_eq_zero, add_zero_left, add_zero_right, neg_neg, sub_moves_sides, abs_neg

numerals Real

// This file defines absolute convergence for series.

/// The absolute value of each element in a sequence.
/// For a sequence a, this returns the sequence n ↦ |a(n)|.
define abs_fn(a: Nat -> Real) -> (Nat -> Real) {
    function(n: Nat) { a(n).abs }
}

/// A series converges absolutely if the series of absolute values converges.
define absolutely_converges(a: Nat -> Real) -> Bool {
    converges(partial(abs_fn(a)))
}

/// The absolute value of any element in the constant zero sequence is zero.
theorem abs_fn_zero(n: Nat) {
    abs_fn(constant[Nat, Real](Real.0))(n) = Real.0
}

/// The absolute value of any element in a sequence is nonnegative.
theorem abs_fn_nonneg(a: Nat -> Real, n: Nat) {
    abs_fn(a)(n) >= Real.0
}

/// Absolute value commutes with scalar multiplication (up to taking abs of scalar).
theorem abs_fn_scalar_mul(c: Real, a: Nat -> Real, n: Nat) {
    abs_fn(mul_fn(c, a))(n) = c.abs * abs_fn(a)(n)
}

/// abs_fn is equivalent to composing with Real.abs.
theorem abs_fn_eq_compose(a: Nat -> Real, n: Nat) {
    abs_fn(a)(n) = compose(Real.abs, a)(n)
}

/// Difference between two partial sums of the same series.
define partial_diff(f: Nat -> Real, m: Nat, n: Nat) -> Real {
    partial(f, n) - partial(f, m)
}

/// Difference between the limit of partial sums and the mth partial sum.
define tail_limit_diff(f: Nat -> Real, m: Nat) -> Real {
    limit(partial(f)) - partial(f, m)
}

/// Pointwise difference of two sequences.
define sub_seq(s: Nat -> Real, t: Nat -> Real, n: Nat) -> Real {
    s(n) - t(n)
}

/// Absolute value of the difference between two sequences.
define abs_diff_seq(s: Nat -> Real, t: Nat -> Real, n: Nat) -> Real {
    sub_seq(s, t, n).abs
}

/// Two sequences differ by a vanishing amount.
define vanishing_diff(s: Nat -> Real, t: Nat -> Real) -> Bool {
    vanishes(abs_diff_seq(s, t))
}

/// A sequence vanishes if and only if its absolute value sequence vanishes.
theorem vanishes_of_abs_seq(a: Nat -> Real) {
    vanishes(abs_seq(a))
    implies
    vanishes(a)
}

/// Taking negatives preserves the vanishing property.
theorem vanishes_neg_seq(a: Nat -> Real) {
    vanishes(a)
    implies
    vanishes(neg_seq(a))
}

/// Vanishing is preserved under pointwise equality.
theorem vanishes_congr_left(a: Nat -> Real, b: Nat -> Real) {
    a = b and vanishes(b)
    implies
    vanishes(a)
}

/// Negating the difference sequence swaps the order of the arguments.
theorem neg_seq_sub_seq_eq(s: Nat -> Real, t: Nat -> Real) {
    neg_seq(sub_seq(s, t)) = sub_seq(t, s)
} by {
    forall(n: Nat) {
        let lhs = sub_seq(s, t, n)
        let rhs = sub_seq(t, s, n)

        lhs + rhs = (s(n) - t(n)) + (t(n) - s(n))
        add_assoc(s(n), -t(n), t(n) + -s(n))
        add_assoc(-t(n), t(n), -s(n))
        add_neg_eq_zero(-t(n))
        neg_neg(t(n))
        add_zero_right(s(n))
        add_neg_eq_zero(s(n))

        sub_moves_sides(rhs, lhs, Real.0)
        add_zero_left(-lhs)

        mul_neg_one_left(lhs)
        neg_seq(sub_seq(s, t))(n) = sub_seq(t, s, n)
    }
}

/// Absolute values of the raw difference equal the absolute difference sequence (original order).
theorem abs_seq_sub_seq_eq_abs_diff_left(s: Nat -> Real, t: Nat -> Real) {
    abs_seq(sub_seq(s, t)) = abs_diff_seq(s, t)
}

/// Absolute values of the reversed difference also equal the absolute difference sequence.
theorem abs_seq_sub_seq_eq_abs_diff_right(s: Nat -> Real, t: Nat -> Real) {
    abs_seq(sub_seq(t, s)) = abs_diff_seq(s, t)
} by {
    forall(n: Nat) {
        neg_seq_sub_seq_eq(s, t)
        mul_neg_one_left(sub_seq(s, t, n))
        sub_seq(t, s, n) = -sub_seq(s, t, n)
        abs_neg(sub_seq(s, t, n))
        abs_seq(sub_seq(t, s))(n) = abs_diff_seq(s, t, n)
    }
}

/// Absolute vanishing differences imply raw differences vanish.
theorem vanishing_diff_abs_eq(s: Nat -> Real, t: Nat -> Real) {
    vanishing_diff(s, t)
    implies
    vanishes(sub_seq(t, s))
}

/// Vanishing differences allow us to transfer limits across sequences.
theorem limit_preserved_by_vanishing_diff(s: Nat -> Real, t: Nat -> Real) {
    converges(s) and vanishing_diff(s, t)
    implies
    converges(t) and limit(s) = limit(t)
} by {
    if converges(s) and vanishing_diff(s, t) {
        let diff = sub_seq(t, s)

        vanishing_diff_abs_eq(s, t)

        forall(n: Nat) {
            add_assoc(t(n), -s(n), s(n))
            add_neg_eq_zero(s(n))
            add_zero_right(t(n))
            add_seq(diff, s)(n) = t(n)
        }

        limit_add_seq(diff, s)
        add_zero_left(limit(s))
        converges_to(t, limit(s))
    }
}

/// Absolute convergence implies convergence (alternate formulation).
/// This connects our definition to the existing theorem in real_series.ac.
theorem absolutely_converges_imp_converges(a: Nat -> Real) {
    absolutely_converges(a) implies converges(partial(a))
} by {
    from real.real_series import abs_conv_imp_conv

    if absolutely_converges(a) {
        partial(abs_fn(a)) = partial(compose(Real.abs, a))

        abs_conv_imp_conv(a)
        converges(partial(a))
    }
}

/// Absolute convergence is preserved under scalar multiplication.
theorem absolutely_converges_scalar_mul(c: Real, a: Nat -> Real) {
    absolutely_converges(a) implies absolutely_converges(mul_fn(c, a))
} by {
    from real.real_series import converges_mul_seq

    if absolutely_converges(a) {
        partial(abs_fn(mul_fn(c, a))) = partial(mul_fn(c.abs, abs_fn(a)))
        partial(mul_fn(c.abs, abs_fn(a))) = mul_fn(c.abs, partial(abs_fn(a)))

        mul_fn(c.abs, partial(abs_fn(a))) = mul_seq(c.abs, partial(abs_fn(a)))

        converges_mul_seq(c.abs, partial(abs_fn(a)))
        absolutely_converges(mul_fn(c, a))
    }
}

/// Absolute convergence is preserved under addition of sequences.
theorem absolutely_converges_add(a: Nat -> Real, b: Nat -> Real) {
    absolutely_converges(a) and absolutely_converges(b)
    implies
    absolutely_converges(add_fn(a, b))
} by {
    from real.real_series import add_seq_converges, comparison_test

    if absolutely_converges(a) and absolutely_converges(b) {
        forall(n: Nat) {
            abs_fn(add_fn(a, b))(n) <= add_fn(abs_fn(a), abs_fn(b))(n)
        }

        is_lower_bound(abs_fn(add_fn(a, b)), Real.0)

        partial(add_fn(abs_fn(a), abs_fn(b))) = add_fn(partial(abs_fn(a)), partial(abs_fn(b)))

        add_fn(partial(abs_fn(a)), partial(abs_fn(b))) = add_seq(partial(abs_fn(a)), partial(abs_fn(b)))

        add_seq_converges(partial(abs_fn(a)), partial(abs_fn(b)))

        comparison_test(abs_fn(add_fn(a, b)), add_fn(abs_fn(a), abs_fn(b)))
        absolutely_converges(add_fn(a, b))
    }
}

/// Tail bound for absolutely convergent series.
/// If a series converges absolutely, then tail sums can be made arbitrarily small.
/// For any ε > 0, there exists N such that for all n, m ≥ N with n ≤ m,
/// the sum of |a(k)| from k=n to k=m-1 is less than ε.
/// For fixed m, the difference between partial sums converges to the tail limit difference.
theorem tail_diff_converges(a: Nat -> Real, m: Nat) {
    absolutely_converges(a)
    implies
    converges_to(partial_diff(abs_fn(a), m), tail_limit_diff(abs_fn(a), m))
} by {
    if absolutely_converges(a) {
        let lim = limit(partial(abs_fn(a)))

        const_converges(-partial(abs_fn(a), m))

        limit_add_seq(partial(abs_fn(a)), constant[Nat, Real](-partial(abs_fn(a), m)))

        const_limit(-partial(abs_fn(a), m))

        partial_diff(abs_fn(a), m) =
            add_seq(partial(abs_fn(a)), constant[Nat, Real](-partial(abs_fn(a), m)))

        converges_to(partial_diff(abs_fn(a), m), tail_limit_diff(abs_fn(a), m))
    }
}

theorem abs_conv_tail_bound(a: Nat -> Real, eps: Real) {
    absolutely_converges(a) and eps.is_positive
    implies
    exists(big_n: Nat) {
        forall(n: Nat, m: Nat) {
            big_n <= n and n <= m
            implies
            partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps
        }
    }
} by {
    from real.real_series import distant_increasing, nonneg_imp_partial_increasing, is_increasing

    if absolutely_converges(a) and eps.is_positive {
        let big_n: Nat satisfy {
            cauchy_bound(partial(abs_fn(a)), big_n, eps)
        }

        forall(n: Nat, m: Nat) {
            if big_n <= n and n <= m {
                nonneg_imp_partial_increasing(abs_fn(a))

                distant_increasing(partial(abs_fn(a)), n, m)

                partial(abs_fn(a), m) - partial(abs_fn(a), n) < eps
            }
        }
    }
}
