from nat import Nat
from set import Set, finite_constraint, functional_insert, functional_remove, functional_insert_satisfies_finite_constraint, functional_remove_satisfies_finite_constraint

numerals Nat

/// A finite set is a `Set` bundled with a finiteness proof.
structure FiniteSet[T] {
    /// The underlying set.
    underlying_set: Set[T]
} constraint { 
    underlying_set.is_finite
}

let fs_empty[T](s: Set[T]) -> result: FiniteSet[T] satisfy {
    FiniteSet.new_option(Set[T].empty_set) = Option.some(result)
}

let fs_insert[T](s: FiniteSet[T], item: T) -> result: FiniteSet[T] satisfy {
    FiniteSet.new_option(s.underlying_set.insert(item)) = Option.some(result)
} by {
    let f = s.underlying_set.contains
    finite_constraint(f)
    functional_insert_satisfies_finite_constraint(f, item)
    finite_constraint(functional_insert(f, item))
    let inserted = s.underlying_set.insert(item)
    inserted.contains = functional_insert(f, item)
    inserted.is_finite
}

let fs_remove[T](s: FiniteSet[T], item: T) -> result: FiniteSet[T] satisfy {
    FiniteSet.new_option(s.underlying_set.remove(item)) = Option.some(result)
} by {
    let f = s.underlying_set.contains
    finite_constraint(f)
    functional_remove_satisfies_finite_constraint(f, item)
    finite_constraint(functional_remove(f, item))
    let removed = s.underlying_set.remove(item)
    removed.contains = functional_remove(f, item)
    removed.is_finite
}

let fs_union[T](a: FiniteSet[T], b: FiniteSet[T]) -> result: FiniteSet[T] satisfy {
    FiniteSet.new_option(a.underlying_set.union(b.underlying_set)) = Option.some(result)
}

let fs_intersection[T](a: FiniteSet[T], b: FiniteSet[T]) -> result: FiniteSet[T] satisfy {
    FiniteSet.new_option(a.underlying_set.intersection(b.underlying_set)) = Option.some(result)
}

let fs_difference[T](a: FiniteSet[T], b: FiniteSet[T]) -> result: FiniteSet[T] satisfy {
    FiniteSet.new_option(a.underlying_set.difference(b.underlying_set)) = Option.some(result)
}

attributes FiniteSet[T] {
    /// Access the underlying set.
    define as_set(self) -> Set[T] {
        self.underlying_set
    }

    /// Membership predicate.
    define contains(self, x: T) -> Bool {
        self.underlying_set.contains(x)
    }

    /// The empty finite set.
    let empty: FiniteSet[T] = fs_empty(Set[T].empty_set)

    /// Insert preserves finiteness.
    let insert: (FiniteSet[T], T) -> FiniteSet[T] = fs_insert

    /// Remove preserves finiteness.
    let remove: (FiniteSet[T], T) -> FiniteSet[T] = fs_remove

    /// Subset relation lifted from sets.
    define subset_eq(self, other: FiniteSet[T]) -> Bool {
        self.underlying_set.subset(other.underlying_set)
    }

    /// Superset relation lifted from sets.
    define superset_eq(self, other: FiniteSet[T]) -> Bool {
        self.underlying_set.superset(other.underlying_set)
    }

    /// Union of finite sets.
    let union: (FiniteSet[T], FiniteSet[T]) -> FiniteSet[T] = fs_union

    /// Intersection of finite sets.
    let intersection: (FiniteSet[T], FiniteSet[T]) -> FiniteSet[T] = fs_intersection

    /// Difference of finite sets.
    let difference: (FiniteSet[T], FiniteSet[T]) -> FiniteSet[T] = fs_difference

    /// Disjointness predicate.
    define is_disjoint(self, other: FiniteSet[T]) -> Bool {
        self.underlying_set.is_disjoint(other.underlying_set)
    }

    /// Empty predicate.
    define is_empty(self) -> Bool {
        self.underlying_set.is_empty
    }

    /// Cardinality helper lifted from sets.
    define cardinality_at_most(self, n: Nat) -> Bool {
        self.underlying_set.cardinality_at_most(n)
    }

    /// True if the cardinality equals n.
    define cardinality_is(self, n: Nat) -> Bool {
        self.underlying_set.cardinality_is(n)
    }
}
