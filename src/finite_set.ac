from list import List
from nat import Nat

/// A constant function that always returns false, regardless of input.
define const_false[T](x: T) -> Bool {
    false
}

/// True if a boolean function represents a finite set.
/// A function satisfies the finite constraint if there exists a finite list containing all elements for which the function returns true.
define finite_constraint[T](contains: T -> Bool) -> Bool {
    exists(superset: List[T]) {
        forall(x: T) {
            contains(x) implies superset.contains(x)
        }
    }
}

theorem const_false_satisfies_finite_constraint[T] {
    finite_constraint(const_false[T])
}

theorem list_contains_satisfies_finite_constraint[T](ts: List[T]) {
    finite_constraint(ts.contains)
}

/// Creates a new function that returns true for the given item and delegates to the original function for all other inputs.
define functional_insert[T](f: T -> Bool, item: T, x: T) -> Bool {
    if x = item {
        true
    } else {
        f(x)
    }
}

theorem functional_insert_satisfies_finite_constraint[T](f: T -> Bool, item: T) {
    finite_constraint(f) implies finite_constraint(functional_insert(f, item))
}

/// Creates a new function that returns false for the given item and delegates to the original function for all other inputs.
define functional_remove[T](f: T -> Bool, item: T, x: T) -> Bool {
    if x = item {
        false
    } else {
        f(x)
    }
}

theorem functional_remove_satisfies_finite_constraint[T](f: T -> Bool, item: T) {
    finite_constraint(f) implies finite_constraint(functional_remove(f, item))
}

/// A finite set represented as a boolean membership function.
/// The constraint ensures that only finitely many elements are members.
structure FiniteSet[T] {
    /// Finite sets are defined by a membership function.
    contains: T -> Bool
} constraint {
    finite_constraint(contains)
}

/// True if an element belongs to the union of the two sets.
define elem_in_finite_union[T](a: FiniteSet[T], b: FiniteSet[T], x: T) -> Bool {
    a.contains(x) or b.contains(x)
}

/// True if an element belongs to the intersection of the two sets.
define elem_in_finite_intersection[T](a: FiniteSet[T], b: FiniteSet[T], x: T) -> Bool {
    a.contains(x) and b.contains(x)
}

/// True if an element belongs to the difference of the two sets.
define elem_in_finite_difference[T](a: FiniteSet[T], b: FiniteSet[T], x: T) -> Bool {
    a.contains(x) and not b.contains(x)
}

theorem union_contains_satisfies_finite_constraint[T](a: FiniteSet[T], b: FiniteSet[T]) {
    finite_constraint(elem_in_finite_union(a, b))
} by {
    finite_constraint(a.contains)
    finite_constraint(b.contains)

    let superset_a: List[T] satisfy {
        forall(x: T) {
            a.contains(x) implies superset_a.contains(x)
        }
    }
    let superset_b: List[T] satisfy {
        forall(x: T) {
            b.contains(x) implies superset_b.contains(x)
        }
    }

    let superset_union = superset_a + superset_b

    forall(x: T) {
        if a.contains(x) {
            superset_a.contains(x)
            superset_union.contains(x)
        }
    }

    forall(x: T) {
        if b.contains(x) {
            superset_b.contains(x)
            superset_union.contains(x)
        }
    }

    exists(superset: List[T]) {
        superset = superset_union and forall(x: T) {
            if elem_in_finite_union(a, b, x) {
                superset.contains(x)
            }
        }
    }
}

theorem intersection_contains_satisfies_finite_constraint[T](a: FiniteSet[T], b: FiniteSet[T]) {
    finite_constraint(elem_in_finite_intersection(a, b))
}

theorem difference_contains_satisfies_finite_constraint[T](a: FiniteSet[T], b: FiniteSet[T]) {
    finite_constraint(elem_in_finite_difference(a, b))
} by {
    finite_constraint(a.contains)

    let superset_a: List[T] satisfy {
        forall(x: T) {
            a.contains(x) implies superset_a.contains(x)
        }
    }

    let superset = superset_a

    forall(x: T) {
        if elem_in_finite_difference(a, b, x) {
            a.contains(x)
            superset.contains(x)
        }
    }

    exists(s: List[T]) {
        s = superset and forall(x: T) {
            if elem_in_finite_difference(a, b, x) {
                s.contains(x)
            }
        }
    }
}

attributes FiniteSet[T] {
    /// Converts a list to a finite set.
    let from_list: List[T] -> FiniteSet[T] = function(ts: List[T]) {
        FiniteSet.new(ts.contains)
    }

    /// The empty finite set.
    let empty: FiniteSet[T] = FiniteSet.new(const_false[T])

    /// True if the set contains no elements.
    define is_empty(self) -> Bool {
        forall(x: T) {
            not self.contains(x)
        }
    }

    /// Removes an element from the set. If the item isn't present, this is a no-op.
    define remove(self, item: T) -> FiniteSet[T] {
        FiniteSet.new(functional_remove(self.contains, item))
    }

    /// Adds an element to the set. If the item is already present, this is a no-op.
    define insert(self, item: T) -> FiniteSet[T] {
        FiniteSet.new(functional_insert(self.contains, item))
    }

    /// True if every element of `self` belongs to `other`.
    define subset(self, other: FiniteSet[T]) -> Bool {
        forall(x: T) {
            self.contains(x) implies other.contains(x)
        }
    }

    /// True if `self` contains every element of `other`.
    define superset(self, other: FiniteSet[T]) -> Bool {
        other.subset(self)
    }

    /// The union of two finite sets.
    define union(self, other: FiniteSet[T]) -> FiniteSet[T] {
        FiniteSet.new(elem_in_finite_union(self, other))
    }

    /// The intersection of two finite sets.
    define intersection(self, other: FiniteSet[T]) -> FiniteSet[T] {
        FiniteSet.new(elem_in_finite_intersection(self, other))
    }

    /// The difference between two finite sets.
    define difference(self, other: FiniteSet[T]) -> FiniteSet[T] {
        FiniteSet.new(elem_in_finite_difference(self, other))
    }

    /// True if the two sets have no elements in common.
    define is_disjoint(self, other: FiniteSet[T]) -> Bool {
        forall(x: T) {
            not (self.contains(x) and other.contains(x))
        }
    }
}

theorem finite_subset_refl[T](s: FiniteSet[T]) {
    s.subset(s)
}

theorem finite_subset_trans[T](a: FiniteSet[T], b: FiniteSet[T], c: FiniteSet[T]) {
    a.subset(b) and b.subset(c) implies a.subset(c)
}

theorem finite_double_inclusion[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.subset(b) and b.subset(a) implies a = b
} by {
    forall(x: T) {
        a.contains(x) implies b.contains(x)
        b.contains(x) implies a.contains(x)
        a.contains(x) = b.contains(x)
    }
    a.contains = b.contains
}

theorem finite_empty_subset_all[T](s: FiniteSet[T]) {
    FiniteSet[T].empty.subset(s)
} by {
    let e = FiniteSet[T].empty

    forall(x: T) {
        if e.contains(x) {
            false
        }
    }
}

theorem insert_contains[T](set: FiniteSet[T], item: T) {
    set.insert(item).contains(item)
}

theorem remove_does_not_contain[T](set: FiniteSet[T], item: T) {
    not set.remove(item).contains(item)
}

theorem insert_other_still_contains[T](set: FiniteSet[T], item: T, other: T) {
    set.contains(item) implies set.insert(other).contains(item)
} by {
    finite_constraint(set.contains)
    finite_constraint(set.insert(other).contains)
}

theorem remove_other_still_contains[T](set: FiniteSet[T], item: T, other: T) {
    item != other and set.contains(item) implies set.remove(other).contains(item)
} by {
    finite_constraint(set.contains)
    finite_constraint(set.remove(other).contains)
}

theorem insert_other_contains_imp_contains[T](set: FiniteSet[T], item: T, other: T) {
    item != other and set.insert(other).contains(item) implies set.contains(item)
} by {
    finite_constraint(set.contains)
    finite_constraint(set.insert(other).contains)
}

theorem remove_other_contains_imp_contains[T](set: FiniteSet[T], item: T, other: T) {
    item != other and set.remove(other).contains(item) implies set.contains(item)
} by {
    finite_constraint(set.contains)
    finite_constraint(set.remove(other).contains)
}

theorem insert_other_contains_eq[T](set: FiniteSet[T], item: T, other: T) {
    item != other implies set.contains(item) = set.insert(other).contains(item)
} by {
    if set.contains(item) {
        set.contains(item) = set.insert(other).contains(item)
    } else {
        not set.contains(item)
        not set.insert(other).contains(item)
        set.contains(item) = set.insert(other).contains(item)
    }
}

theorem remove_other_contains_eq[T](set: FiniteSet[T], item: T, other: T) {
    item != other implies set.contains(item) = set.remove(other).contains(item)
} by {
    if set.contains(item) {
        set.contains(item) = set.remove(other).contains(item)
    } else {
        not set.contains(item)
        not set.remove(other).contains(item)
        set.contains(item) = set.remove(other).contains(item)
    }
}

theorem remove_then_insert[T](set: FiniteSet[T], item: T) {
    set.contains(item) implies set.remove(item).insert(item) = set
} by {
    if set.remove(item).insert(item) != set {
        set.remove(item).insert(item).contains != set.contains
        let t: T satisfy {
            set.remove(item).insert(item).contains(t) != set.contains(t)
        }
        if item != t {
            if set.contains(t) {
                set.remove(item).contains(t)
                false
            } else {
                false
            }
        } else {
            item = t
            not set.contains(t)
            false
        }
    }
}

theorem insert_then_remove[T](set: FiniteSet[T], item: T) {
    not set.contains(item) implies set.insert(item).remove(item) = set
} by {
    if set.insert(item).remove(item) != set {
        set.insert(item).remove(item).contains != set.contains
        let t: T satisfy {
            set.insert(item).remove(item).contains(t) != set.contains(t)
        }
        if item != t {
            if set.contains(t) {
                false
            } else {
                set.insert(item).contains(t)
                false
            }
        } else {
            item = t
            not set.contains(t)
            false
        }
    }
}

// Union theorems
theorem finite_sets_subset_union[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.subset(a.union(b)) and b.subset(a.union(b))
} by {
    a.subset(a.union(b))
    b.subset(a.union(b))
}

theorem finite_sets_subset_contain_union[T](a: FiniteSet[T], b: FiniteSet[T], c: FiniteSet[T]) {
    a.subset(c) and b.subset(c) implies a.union(b).subset(c)
}

theorem finite_union_comm[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.union(b) = b.union(a)
} by {
    let u = a.union(b)
    let v = b.union(a)

    v.subset(u)
    u.subset(v)
}

theorem finite_union_assoc[T](a: FiniteSet[T], b: FiniteSet[T], c: FiniteSet[T]) {
    a.union(b.union(c)) = a.union(b).union(c)
} by {
    let u = a.union(b.union(c))
    let v = a.union(b).union(c)

    a.subset(u)
    b.subset(u)
    c.subset(u)
    v.subset(u)

    a.subset(v)
    b.subset(v)
    c.subset(v)
    u.subset(v)
}

theorem finite_union_idemp[T](s: FiniteSet[T]) {
    s.union(s) = s
}

theorem finite_union_subset_is_set[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.subset(b) implies a.union(b) = b
}

// Intersection theorems
theorem finite_sets_subset_intersection[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.intersection(b).subset(a) and a.intersection(b).subset(b)
} by {
    a.intersection(b).subset(a)
    a.intersection(b).subset(b)
}

theorem finite_set_supset_contains_intersection[T](a: FiniteSet[T], b: FiniteSet[T], c: FiniteSet[T]) {
    a.superset(c) and b.superset(c) implies a.intersection(b).superset(c)
}

theorem finite_intersection_comm[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.intersection(b) = b.intersection(a)
} by {
    let u = a.intersection(b)
    let v = b.intersection(a)

    forall(x: T) {
        if u.contains(x) {
            a.contains(x)
            b.contains(x)

            v.contains(x)
        }
    }
    u.subset(v)

    forall(x: T) {
        if v.contains(x) {
            a.contains(x)
            b.contains(x)

            u.contains(x)
        }
    }
    u.superset(v)
}

theorem finite_intersection_assoc[T](a: FiniteSet[T], b: FiniteSet[T], c: FiniteSet[T]) {
    a.intersection(b.intersection(c)) = a.intersection(b).intersection(c)
} by {
    let u = a.intersection(b.intersection(c))
    let v = a.intersection(b).intersection(c)

    a.superset(u)
    b.superset(b.intersection(c))
    b.superset(u)
    c.superset(b.intersection(c))
    c.superset(u)
    v.superset(u)

    a.superset(a.intersection(b))
    a.superset(v)
    b.superset(a.intersection(b))
    b.superset(v)
    c.superset(v)
    u.superset(v)
}

theorem finite_intersection_idemp[T](s: FiniteSet[T]) {
    s.intersection(s) = s
}

theorem finite_intersection_with_superset_is_self[T](s: FiniteSet[T], t: FiniteSet[T]) {
    s.subset(t) implies s.intersection(t) = s
}

// Difference theorems
theorem finite_difference_subset[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.difference(b).subset(a)
}

theorem finite_difference_contains_imp_not_contains[T](a: FiniteSet[T], b: FiniteSet[T], x: T) {
    a.difference(b).contains(x) implies not b.contains(x)
}

theorem finite_difference_contains_imp_contains[T](a: FiniteSet[T], b: FiniteSet[T], x: T) {
    a.difference(b).contains(x) implies a.contains(x)
}

theorem finite_difference_contains_of_membership[T](a: FiniteSet[T], b: FiniteSet[T], x: T) {
    a.contains(x) and not b.contains(x) implies a.difference(b).contains(x)
}

theorem finite_difference_of_self_is_empty[T](a: FiniteSet[T]) {
    a.difference(a) = FiniteSet.empty
}

// Length theorems
attributes FiniteSet[T] {
    define cardinality_at_most(self, n: Nat) -> Bool {
        exists (superset: List[T]) {
            forall (x: T) {
                self.contains(x) implies superset.contains(x)
            } and superset.length <= n
        }
    }

    define cardinality_is(self, n: Nat) -> Bool {
        exists (containing_list: List[T]) {
            forall(x: T) {
                self.contains(x) implies containing_list.contains(x)
            } and containing_list.filter(self.contains).unique.length = n
        }
    }
}

theorem union_is_at_most_length[T](a: FiniteSet[T], b: FiniteSet[T], n1: Nat, n2: Nat) {
    a.cardinality_at_most(n1) and b.cardinality_at_most(n2) implies a.union(b).cardinality_at_most(n1 + n2)
} by {
    let (superset_a: List[T]) satisfy {
        forall (x: T) {
            a.contains(x) implies superset_a.contains(x)
        } and superset_a.length <= n1
    }

    let (superset_b: List[T]) satisfy {
        forall (x: T) {
            b.contains(x) implies superset_b.contains(x)
        } and superset_b.length <= n2
    }

    let superset_union = superset_a + superset_b

    forall(x: T) {
        a.union(b).contains(x) implies superset_union.contains(x)
    }

    superset_union.length = superset_a.length + superset_b.length
    superset_union.length <= n1 + n2
}

theorem disjoint_union_is_length[T](a: FiniteSet[T], b: FiniteSet[T], n1: Nat, n2: Nat) {
    a.cardinality_is(n1) and b.cardinality_is(n2) and a.is_disjoint(b) implies a.union(b).cardinality_is(n1 + n2)
} by {
    let (list_a: List[T]) satisfy {
        forall(x: T) {
            a.contains(x) implies list_a.contains(x)
        } and list_a.filter(a.contains).unique.length = n1
    }

    let (list_b: List[T]) satisfy {
        forall(x: T) {
            b.contains(x) implies list_b.contains(x)
        } and list_b.filter(b.contains).unique.length = n2
    }

    let f_list_a = list_a.filter(a.contains).unique
    let f_list_b = list_b.filter(b.contains).unique

    let list_union = f_list_a + f_list_b
    list_union.length = n1 + n2

    forall(x: T) {
        f_list_a.contains(x) implies list_union.contains(x)
        a.contains(x) implies list_union.contains(x)

        f_list_b.contains(x) implies list_union.contains(x)
        b.contains(x) implies list_union.contains(x)

        a.union(b).contains(x) implies list_union.contains(x)
    }

    forall (x: T) {
        if a.contains(x) {
            not b.contains(x)
            a.union(b).contains(x) = list_union.contains(x)
        } else {
            if b.contains(x) {
                not a.contains(x)
                list_union.contains(x) implies b.contains(x)
                a.union(b).contains(x) = list_union.contains(x)
            } else {
                not a.union(b).contains(x)
                not f_list_a.contains(x)
                not f_list_b.contains(x)
                a.union(b).contains(x) = list_union.contains(x)
            }
        }

        a.union(b).contains(x) = list_union.contains(x)
    }

    a.union(b).contains = list_union.contains

    f_list_a.is_unique
    f_list_b.is_unique
    forall(x: T) {
        not (f_list_a.contains(x) and f_list_b.contains(x))
    }
    (f_list_a + f_list_b).is_unique
    list_union.is_unique

    list_union.filter(a.union(b).contains).unique.length = n1 + n2
}