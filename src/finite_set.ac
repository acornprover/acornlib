from list import List
from nat import Nat

numerals Nat

/// A constant function that always returns false, regardless of input.
define const_false[T](x: T) -> Bool {
    false
}

/// True if a boolean function represents a finite set.
/// A function satisfies the finite constraint if there exists a finite list containing all elements for which the function returns true.
define finite_constraint[T](contains: T -> Bool) -> Bool {
    exists(superset: List[T]) {
        forall(x: T) {
            contains(x) implies superset.contains(x)
        }
    }
}

theorem const_false_satisfies_finite_constraint[T] {
    finite_constraint(const_false[T])
}

theorem list_contains_satisfies_finite_constraint[T](ts: List[T]) {
    finite_constraint(ts.contains)
}

/// Creates a new function that returns true for the given item and delegates to the original function for all other inputs.
define functional_insert[T](f: T -> Bool, item: T, x: T) -> Bool {
    if x = item {
        true
    } else {
        f(x)
    }
}

theorem functional_insert_satisfies_finite_constraint[T](f: T -> Bool, item: T) {
    finite_constraint(f) implies finite_constraint(functional_insert(f, item))
}

/// Creates a new function that returns false for the given item and delegates to the original function for all other inputs.
define functional_remove[T](f: T -> Bool, item: T, x: T) -> Bool {
    if x = item {
        false
    } else {
        f(x)
    }
}

theorem functional_remove_satisfies_finite_constraint[T](f: T -> Bool, item: T) {
    finite_constraint(f) implies finite_constraint(functional_remove(f, item))
}

/// A finite set represented as a boolean membership function.
/// The constraint ensures that only finitely many elements are members.
structure FiniteSet[T] {
    /// Finite sets are defined by a membership function.
    contains: T -> Bool
} constraint {
    finite_constraint(contains)
}

/// True if an element belongs to the union of the two sets.
define elem_in_finite_union[T](a: FiniteSet[T], b: FiniteSet[T], x: T) -> Bool {
    a.contains(x) or b.contains(x)
}

/// True if an element belongs to the intersection of the two sets.
define elem_in_finite_intersection[T](a: FiniteSet[T], b: FiniteSet[T], x: T) -> Bool {
    a.contains(x) and b.contains(x)
}

/// True if an element belongs to the difference of the two sets.
define elem_in_finite_difference[T](a: FiniteSet[T], b: FiniteSet[T], x: T) -> Bool {
    a.contains(x) and not b.contains(x)
}

theorem union_contains_satisfies_finite_constraint[T](a: FiniteSet[T], b: FiniteSet[T]) {
    finite_constraint(elem_in_finite_union(a, b))
} by {
    finite_constraint(a.contains)
    finite_constraint(b.contains)

    let superset_a: List[T] satisfy {
        forall(x: T) {
            a.contains(x) implies superset_a.contains(x)
        }
    }
    let superset_b: List[T] satisfy {
        forall(x: T) {
            b.contains(x) implies superset_b.contains(x)
        }
    }

    let superset_union = superset_a + superset_b

    forall(x: T) {
        if a.contains(x) {
            superset_a.contains(x)
            superset_union.contains(x)
        }
    }

    forall(x: T) {
        if b.contains(x) {
            superset_b.contains(x)
            superset_union.contains(x)
        }
    }

    exists(superset: List[T]) {
        superset = superset_union and forall(x: T) {
            if elem_in_finite_union(a, b, x) {
                superset.contains(x)
            }
        }
    }
}

theorem intersection_contains_satisfies_finite_constraint[T](a: FiniteSet[T], b: FiniteSet[T]) {
    finite_constraint(elem_in_finite_intersection(a, b))
}

theorem difference_contains_satisfies_finite_constraint[T](a: FiniteSet[T], b: FiniteSet[T]) {
    finite_constraint(elem_in_finite_difference(a, b))
} by {
    finite_constraint(a.contains)

    let superset_a: List[T] satisfy {
        forall(x: T) {
            a.contains(x) implies superset_a.contains(x)
        }
    }

    let superset = superset_a

    forall(x: T) {
        if elem_in_finite_difference(a, b, x) {
            a.contains(x)
            superset.contains(x)
        }
    }

    exists(s: List[T]) {
        s = superset and forall(x: T) {
            if elem_in_finite_difference(a, b, x) {
                s.contains(x)
            }
        }
    }
}

attributes FiniteSet[T] {
    /// Converts a list to a finite set.
    let from_list: List[T] -> FiniteSet[T] = function(ts: List[T]) {
        FiniteSet.new(ts.contains)
    }

    /// The empty finite set.
    let empty: FiniteSet[T] = FiniteSet.new(const_false[T])

    /// True if the set contains no elements.
    define is_empty(self) -> Bool {
        forall(x: T) {
            not self.contains(x)
        }
    }

    /// Removes an element from the set. If the item isn't present, this is a no-op.
    define remove(self, item: T) -> FiniteSet[T] {
        FiniteSet.new(functional_remove(self.contains, item))
    }

    /// Adds an element to the set. If the item is already present, this is a no-op.
    define insert(self, item: T) -> FiniteSet[T] {
        FiniteSet.new(functional_insert(self.contains, item))
    }

    /// True if every element of `self` belongs to `other`.
    define subset_eq(self, other: FiniteSet[T]) -> Bool {
        forall(x: T) {
            self.contains(x) implies other.contains(x)
        }
    }

    /// True if `self` contains every element of `other`.
    define superset_eq(self, other: FiniteSet[T]) -> Bool {
        other.subset_eq(self)
    }

    /// The union of two finite sets.
    define union(self, other: FiniteSet[T]) -> FiniteSet[T] {
        FiniteSet.new(elem_in_finite_union(self, other))
    }

    /// The intersection of two finite sets.
    define intersection(self, other: FiniteSet[T]) -> FiniteSet[T] {
        FiniteSet.new(elem_in_finite_intersection(self, other))
    }

    /// The difference between two finite sets.
    define difference(self, other: FiniteSet[T]) -> FiniteSet[T] {
        FiniteSet.new(elem_in_finite_difference(self, other))
    }

    /// True if the two sets have no elements in common.
    define is_disjoint(self, other: FiniteSet[T]) -> Bool {
        forall(x: T) {
            not (self.contains(x) and other.contains(x))
        }
    }
}

theorem finite_subset_refl[T](s: FiniteSet[T]) {
    s.subset_eq(s)
}

theorem finite_subset_trans[T](a: FiniteSet[T], b: FiniteSet[T], c: FiniteSet[T]) {
    a.subset_eq(b) and b.subset_eq(c) implies a.subset_eq(c)
}

theorem finite_double_inclusion[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.subset_eq(b) and b.subset_eq(a) implies a = b
} by {
    forall(x: T) {
        a.contains(x) implies b.contains(x)
        b.contains(x) implies a.contains(x)
        a.contains(x) = b.contains(x)
    }
    a.contains = b.contains
}

theorem finite_empty_subset_all[T](s: FiniteSet[T]) {
    FiniteSet[T].empty.subset_eq(s)
} by {
    let e = FiniteSet[T].empty

    forall(x: T) {
        if e.contains(x) {
            false
        }
    }
}

theorem insert_contains[T](set: FiniteSet[T], item: T) {
    set.insert(item).contains(item)
}

theorem remove_does_not_contain[T](set: FiniteSet[T], item: T) {
    not set.remove(item).contains(item)
}

theorem insert_other_still_contains[T](set: FiniteSet[T], item: T, other: T) {
    set.contains(item) implies set.insert(other).contains(item)
} by {
    finite_constraint(set.contains)
    finite_constraint(set.insert(other).contains)
}

theorem remove_other_still_contains[T](set: FiniteSet[T], item: T, other: T) {
    item != other and set.contains(item) implies set.remove(other).contains(item)
} by {
    finite_constraint(set.contains)
    finite_constraint(set.remove(other).contains)
}

theorem insert_other_contains_imp_contains[T](set: FiniteSet[T], item: T, other: T) {
    item != other and set.insert(other).contains(item) implies set.contains(item)
} by {
    finite_constraint(set.contains)
    finite_constraint(set.insert(other).contains)
}

theorem remove_other_contains_imp_contains[T](set: FiniteSet[T], item: T, other: T) {
    item != other and set.remove(other).contains(item) implies set.contains(item)
} by {
    finite_constraint(set.contains)
    finite_constraint(set.remove(other).contains)
}

theorem insert_other_contains_eq[T](set: FiniteSet[T], item: T, other: T) {
    item != other implies set.contains(item) = set.insert(other).contains(item)
} by {
    if set.contains(item) {
        set.contains(item) = set.insert(other).contains(item)
    } else {
        not set.contains(item)
        not set.insert(other).contains(item)
        set.contains(item) = set.insert(other).contains(item)
    }
}

theorem remove_other_contains_eq[T](set: FiniteSet[T], item: T, other: T) {
    item != other implies set.contains(item) = set.remove(other).contains(item)
} by {
    if set.contains(item) {
        set.contains(item) = set.remove(other).contains(item)
    } else {
        not set.contains(item)
        not set.remove(other).contains(item)
        set.contains(item) = set.remove(other).contains(item)
    }
}

theorem remove_then_insert[T](set: FiniteSet[T], item: T) {
    set.contains(item) implies set.remove(item).insert(item) = set
} by {
    if set.remove(item).insert(item) != set {
        set.remove(item).insert(item).contains != set.contains
        let t: T satisfy {
            set.remove(item).insert(item).contains(t) != set.contains(t)
        }
        if item != t {
            if set.contains(t) {
                set.remove(item).contains(t)
                false
            } else {
                false
            }
        } else {
            item = t
            not set.contains(t)
            false
        }
    }
}

theorem insert_then_remove[T](set: FiniteSet[T], item: T) {
    not set.contains(item) implies set.insert(item).remove(item) = set
} by {
    if set.insert(item).remove(item) != set {
        set.insert(item).remove(item).contains != set.contains
        let t: T satisfy {
            set.insert(item).remove(item).contains(t) != set.contains(t)
        }
        if item != t {
            if set.contains(t) {
                false
            } else {
                set.insert(item).contains(t)
                false
            }
        } else {
            item = t
            not set.contains(t)
            false
        }
    }
}

// Union theorems
theorem finite_sets_subset_union[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.subset_eq(a.union(b)) and b.subset_eq(a.union(b))
} by {
    a.subset_eq(a.union(b))
    b.subset_eq(a.union(b))
}

theorem finite_sets_subset_contain_union[T](a: FiniteSet[T], b: FiniteSet[T], c: FiniteSet[T]) {
    a.subset_eq(c) and b.subset_eq(c) implies a.union(b).subset_eq(c)
}

theorem finite_union_comm[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.union(b) = b.union(a)
} by {
    let u = a.union(b)
    let v = b.union(a)

    v.subset_eq(u)
    u.subset_eq(v)
}

theorem finite_union_assoc[T](a: FiniteSet[T], b: FiniteSet[T], c: FiniteSet[T]) {
    a.union(b.union(c)) = a.union(b).union(c)
} by {
    let u = a.union(b.union(c))
    let v = a.union(b).union(c)

    a.subset_eq(u)
    b.subset_eq(u)
    c.subset_eq(u)
    v.subset_eq(u)

    a.subset_eq(v)
    b.subset_eq(v)
    c.subset_eq(v)
    u.subset_eq(v)
}

theorem finite_union_idemp[T](s: FiniteSet[T]) {
    s.union(s) = s
}

theorem finite_union_subset_is_set[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.subset_eq(b) implies a.union(b) = b
}

// Intersection theorems
theorem finite_sets_subset_intersection[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.intersection(b).subset_eq(a) and a.intersection(b).subset_eq(b)
} by {
    a.intersection(b).subset_eq(a)
    a.intersection(b).subset_eq(b)
}

theorem finite_set_supset_contains_intersection[T](a: FiniteSet[T], b: FiniteSet[T], c: FiniteSet[T]) {
    a.superset_eq(c) and b.superset_eq(c) implies a.intersection(b).superset_eq(c)
}

theorem finite_intersection_comm[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.intersection(b) = b.intersection(a)
} by {
    let u = a.intersection(b)
    let v = b.intersection(a)

    forall(x: T) {
        if u.contains(x) {
            a.contains(x)
            b.contains(x)

            v.contains(x)
        }
    }
    u.subset_eq(v)

    forall(x: T) {
        if v.contains(x) {
            a.contains(x)
            b.contains(x)

            u.contains(x)
        }
    }
    u.superset_eq(v)
}

theorem finite_intersection_assoc[T](a: FiniteSet[T], b: FiniteSet[T], c: FiniteSet[T]) {
    a.intersection(b.intersection(c)) = a.intersection(b).intersection(c)
} by {
    let u = a.intersection(b.intersection(c))
    let v = a.intersection(b).intersection(c)

    a.superset_eq(u)
    b.superset_eq(b.intersection(c))
    b.superset_eq(u)
    c.superset_eq(b.intersection(c))
    c.superset_eq(u)
    v.superset_eq(u)

    a.superset_eq(a.intersection(b))
    a.superset_eq(v)
    b.superset_eq(a.intersection(b))
    b.superset_eq(v)
    c.superset_eq(v)
    u.superset_eq(v)
}

theorem finite_intersection_idemp[T](s: FiniteSet[T]) {
    s.intersection(s) = s
}

theorem finite_intersection_with_superset_is_self[T](s: FiniteSet[T], t: FiniteSet[T]) {
    s.subset_eq(t) implies s.intersection(t) = s
}

// Difference theorems
theorem finite_difference_subset[T](a: FiniteSet[T], b: FiniteSet[T]) {
    a.difference(b).subset_eq(a)
}

theorem finite_difference_contains_imp_not_contains[T](a: FiniteSet[T], b: FiniteSet[T], x: T) {
    a.difference(b).contains(x) implies not b.contains(x)
}

theorem finite_difference_contains_imp_contains[T](a: FiniteSet[T], b: FiniteSet[T], x: T) {
    a.difference(b).contains(x) implies a.contains(x)
}

theorem finite_difference_contains_of_membership[T](a: FiniteSet[T], b: FiniteSet[T], x: T) {
    a.contains(x) and not b.contains(x) implies a.difference(b).contains(x)
}

theorem finite_difference_of_self_is_empty[T](a: FiniteSet[T]) {
    a.difference(a) = FiniteSet.empty
}

/// S ∪ T = T ∪ (S \ T)
theorem union_with_difference_decomp[T](s: FiniteSet[T], t: FiniteSet[T]) {
    s.union(t) = t.union(s.difference(t))
} by {
    let u = s.union(t)
    let v = t.union(s.difference(t))

    // Show s ⊆ v
    forall(x: T) {
        s.contains(x) implies v.contains(x)
    }
    s.subset_eq(v)

    // t ⊆ v (obvious by union structure)
    t.subset_eq(v)
    u.subset_eq(v)

    // Show s \ t ⊆ u
    forall(x: T) {
        if s.difference(t).contains(x) {
            s.contains(x)
            u.contains(x)
        }
    }
    s.difference(t).subset_eq(u)

    // t ⊆ u already true
    t.subset_eq(u)
}

/// S ∪ (T \ S) = S ∪ T
theorem union_with_difference_decomp_rev[T](s: FiniteSet[T], t: FiniteSet[T]) {
    s.union(t) = s.union(t.difference(s))
} by {
    let u = s.union(t)
    let v = s.union(t.difference(s))

    // Show t ⊆ v
    forall(x: T) {
        t.contains(x) implies v.contains(x)
    }
    t.subset_eq(v)

    // s ⊆ v (obvious by union structure)
    s.subset_eq(v)
    u.subset_eq(v)

    // Show t \ s ⊆ u
    forall(x: T) {
        if t.difference(s).contains(x) {
            t.contains(x)
            u.contains(x)
        }
    }
    t.difference(s).subset_eq(u)

    // s ⊆ u already true
    s.subset_eq(u)
}

/// S ∪ (T \ (S ∩ T)) = S ∪ T
theorem union_with_difference_decomp_inter[T](s: FiniteSet[T], t: FiniteSet[T]) {
    s.union(t) = s.union(t.difference(s.intersection(t)))
} by {
    let u = s.union(t)
    let v = s.union(t.difference(s.intersection(t)))

    // Show t ⊆ v
    forall(x: T) {
        t.contains(x) implies v.contains(x)
    }
    t.subset_eq(v)

    // s ⊆ v (obvious by union structure)
    s.subset_eq(v)
    u.subset_eq(v)

    // Show t \ (s ∩ t) ⊆ u
    forall(x: T) {
        if t.difference(s.intersection(t)).contains(x) {
            t.contains(x)
            u.contains(x)
        }
    }
    t.difference(s.intersection(t)).subset_eq(u)

    // s ⊆ u already true
    s.subset_eq(u)
}

// Length theorems
attributes FiniteSet[T] {
    define cardinality_at_most(self, n: Nat) -> Bool {
        exists (superset: List[T]) {
            forall (x: T) {
                self.contains(x) implies superset.contains(x)
            } and superset.length <= n
        }
    }

    define cardinality_is(self, n: Nat) -> Bool {
        exists (containing_list: List[T]) {
            forall(x: T) {
                self.contains(x) implies containing_list.contains(x)
            } and containing_list.filter(self.contains).unique.length = n
        }
    }
}

theorem cardinality_always_exists[T](s: FiniteSet[T]) {
    exists(n: Nat) {
        s.cardinality_is(n)
    }
} by {
    let (superset: List[T]) satisfy {
        forall(x: T) {
            s.contains(x) implies superset.contains(x)
        }
    }

    let n = superset.length
}

theorem union_is_at_most_length[T](a: FiniteSet[T], b: FiniteSet[T], n1: Nat, n2: Nat) {
    a.cardinality_at_most(n1) and b.cardinality_at_most(n2) implies a.union(b).cardinality_at_most(n1 + n2)
} by {
    let (superset_a: List[T]) satisfy {
        forall (x: T) {
            a.contains(x) implies superset_a.contains(x)
        } and superset_a.length <= n1
    }

    let (superset_b: List[T]) satisfy {
        forall (x: T) {
            b.contains(x) implies superset_b.contains(x)
        } and superset_b.length <= n2
    }

    let superset_union = superset_a + superset_b

    forall(x: T) {
        a.union(b).contains(x) implies superset_union.contains(x)
    }

    superset_union.length = superset_a.length + superset_b.length
    superset_union.length <= n1 + n2
}

theorem disjoint_union_is_length[T](a: FiniteSet[T], b: FiniteSet[T], n1: Nat, n2: Nat) {
    a.cardinality_is(n1) and b.cardinality_is(n2) and a.is_disjoint(b) implies a.union(b).cardinality_is(n1 + n2)
} by {
    let (list_a: List[T]) satisfy {
        forall(x: T) {
            a.contains(x) implies list_a.contains(x)
        } and list_a.filter(a.contains).unique.length = n1
    }

    let (list_b: List[T]) satisfy {
        forall(x: T) {
            b.contains(x) implies list_b.contains(x)
        } and list_b.filter(b.contains).unique.length = n2
    }

    let f_list_a = list_a.filter(a.contains).unique
    let f_list_b = list_b.filter(b.contains).unique

    let list_union = f_list_a + f_list_b
    list_union.length = n1 + n2

    forall(x: T) {
        f_list_a.contains(x) implies list_union.contains(x)
        a.contains(x) implies list_union.contains(x)

        f_list_b.contains(x) implies list_union.contains(x)
        b.contains(x) implies list_union.contains(x)

        a.union(b).contains(x) implies list_union.contains(x)
    }

    forall (x: T) {
        if a.contains(x) {
            not b.contains(x)
            a.union(b).contains(x) = list_union.contains(x)
        } else {
            if b.contains(x) {
                not a.contains(x)
                list_union.contains(x) implies b.contains(x)
                a.union(b).contains(x) = list_union.contains(x)
            } else {
                not a.union(b).contains(x)
                not f_list_a.contains(x)
                not f_list_b.contains(x)
                a.union(b).contains(x) = list_union.contains(x)
            }
        }

        a.union(b).contains(x) = list_union.contains(x)
    }

    a.union(b).contains = list_union.contains

    f_list_a.is_unique
    f_list_b.is_unique
    forall(x: T) {
        not (f_list_a.contains(x) and f_list_b.contains(x))
    }
    (f_list_a + f_list_b).is_unique
    list_union.is_unique

    list_union.filter(a.union(b).contains).unique.length = n1 + n2
}

theorem cardinality_is_well_defined[T](s: FiniteSet[T], n1: Nat, n2: Nat) {
    s.cardinality_is(n1) and s.cardinality_is(n2) implies n1 = n2
} by {
    let (list_1: List[T]) satisfy {
        forall(x: T) {
            s.contains(x) implies list_1.contains(x)
        } and list_1.filter(s.contains).unique.length = n1
    }
    let (list_2: List[T]) satisfy {
        forall(x: T) {
            s.contains(x) implies list_2.contains(x)
        } and list_2.filter(s.contains).unique.length = n2
    }

    let f_list_1 = list_1.filter(s.contains).unique
    let f_list_2 = list_2.filter(s.contains).unique

    forall(x: T) {
        if s.contains(x) {
            f_list_1.contains(x)
            f_list_2.contains(x)
            f_list_1.contains(x) = f_list_2.contains(x)
        } else {
            not f_list_1.contains(x)
            not f_list_2.contains(x)
            f_list_1.contains(x) = f_list_2.contains(x)
        }
    }

    f_list_1.unique.length <= f_list_2.unique.length
    f_list_2.unique.length <= f_list_1.unique.length
}

theorem cardinality_is_smallest_cardinality[T](s: FiniteSet[T], n: Nat) {
    s.cardinality_is(n) implies s.cardinality_at_most(n)
} by {
    let (containing_list: List[T]) satisfy {
        forall(x: T) {
            s.contains(x) implies containing_list.contains(x)
        } and containing_list.filter(s.contains).unique.length = n
    }

    let f_containing_list = containing_list.filter(s.contains).unique

    forall(x: T) {
        s.contains(x) implies f_containing_list.contains(x)
    }

    f_containing_list.length <= n
    s.cardinality_at_most(n)
}

theorem union_cardinality_with_difference[T](s: FiniteSet[T], t: FiniteSet[T], n_s: Nat, n_diff: Nat) {
    s.cardinality_is(n_s) and t.difference(s).cardinality_is(n_diff) implies s.union(t).cardinality_is(n_s + n_diff)
} by {
    s.union(t.difference(s)).cardinality_is(n_s + n_diff)
}


theorem inclusion_exclusion[T](s: FiniteSet[T], t: FiniteSet[T], n_s: Nat, n_t: Nat, n_inter: Nat) {
    s.cardinality_is(n_s) and t.cardinality_is(n_t) and s.intersection(t).cardinality_is(n_inter)
    implies s.union(t).cardinality_is(n_s + n_t - n_inter)
} by {
    let sut = s.union(t)
    let sit = s.intersection(t)
    let sym_diff = sut.difference(sit)

    sut.superset_eq(sit)
    sit.union(sut.difference(sit)) = sut
    sit.union(sym_diff) = sut

    // (S \ (S \cap T)) \cup (S \cap T) = S
    let s_diff = s.difference(sit)
    sit.union(s_diff) = s
    let n_s_diff: Nat satisfy {
        s_diff.cardinality_is(n_s_diff)
    }
    sit.is_disjoint(s_diff)
    sit.union(s_diff).cardinality_is(n_inter + n_s_diff)
    n_inter + n_s_diff = n_s
    n_s_diff = n_s - n_inter

    // T is disjoint from (S \ (S \cap T))
    forall (x: T) {
        if t.contains(x) {
            if s_diff.contains(x) {
                s.contains(x)
                s.intersection(t).contains(x)
                sit.contains(x)
                not s_diff.contains(x)
            }
        }
    }
    t.is_disjoint(s_diff)

    t.union(s_diff).cardinality_is(n_t + n_s_diff)

    n_t + n_s_diff = n_t + (n_s - n_inter)
    n_t + n_s_diff = n_t + n_s - n_inter
    t.union(s_diff) = t.union(s)
}

/// Proves essential equivalence between finite set and `unique` lists. (Note
/// that lists are ordered, while sets are not.)
theorem finite_set_has_exact_containing_list[T](s: FiniteSet[T]) {
    exists(containing_list: List[T]) {
        forall(x: T) {
            s.contains(x) = containing_list.contains(x)
        } and containing_list.is_unique
    }
} by {
    let (superset: List[T]) satisfy {
        forall(x: T) {
            s.contains(x) implies superset.contains(x)
        }
    }

    let filtered = superset.filter(s.contains).unique

    forall(x: T) {
        s.contains(x) implies filtered.contains(x)
        filtered.contains(x) implies s.contains(x)
        s.contains(x) = filtered.contains(x)
    }
}

define finite_set_union_elem[T](sets: FiniteSet[FiniteSet[T]], x: T) -> Bool {
    exists(s: FiniteSet[T]) {
        sets.contains(s) and s.contains(x)
    }
}

define finite_set_union[T](sets: FiniteSet[FiniteSet[T]]) -> FiniteSet[T] {
    FiniteSet.new(finite_set_union_elem(sets))
}

define pairwise_disjoint[T](sets: FiniteSet[FiniteSet[T]]) -> Bool {
    forall(a: FiniteSet[T], b: FiniteSet[T]) {
        sets.contains(a) and sets.contains(b) and a != b implies a.is_disjoint(b)
    }
}

define is_containing_list_of_lists_elem[T](sets_a: List[FiniteSet[T]], containing_lists: List[List[T]], s: FiniteSet[T]) -> Bool {
    sets_a.contains(s) implies exists(l: List[T]) {
        containing_lists.contains(l) and forall(y: T) {
            s.contains(y) implies l.contains(y)
        }
    }
}

define is_containing_list_of_lists[T](sets_a: List[FiniteSet[T]], containing_lists: List[List[T]]) -> Bool {
    forall(s: FiniteSet[T]) {
        is_containing_list_of_lists_elem(sets_a, containing_lists, s)
    }
}

theorem exists_containing_list_of_lists[T](sets: List[FiniteSet[T]]) {
    exists (containing_lists: List[List[T]]) {
        is_containing_list_of_lists(sets, containing_lists)
    }
} by {

    define p(sets_a: List[FiniteSet[T]]) -> Bool {
        exists (containing_lists: List[List[T]]) {
            is_containing_list_of_lists(sets_a, containing_lists)
        }
    }

    // Base case
    p(List[FiniteSet[T]].nil)

    // Inductive step
    forall(head: FiniteSet[T], tail: List[FiniteSet[T]]) {
        if p(tail) {
            let (containing_lists_tail: List[List[T]]) satisfy {
                is_containing_list_of_lists(tail, containing_lists_tail)
            }

            let (containing_list_head: List[T]) satisfy {
                forall(y: T) {
                    head.contains(y) implies containing_list_head.contains(y)
                }
            }

            let containing_cons = List.cons(containing_list_head, containing_lists_tail)

            forall(s: FiniteSet[T]) {
                if List.cons(head, tail).contains(s) {
                    if s = head {
                        let (l: List[T]) satisfy {
                            containing_cons.contains(l) and forall(y: T) {
                                s.contains(y) implies l.contains(y)
                            }
                        }

                        containing_cons.contains(l) and forall(y: T) {
                            s.contains(y) implies l.contains(y)
                        }

                        is_containing_list_of_lists_elem(List.cons(head, tail), containing_cons, s)
                    } else {
                        tail.contains(s)
                        forall(x0: FiniteSet[T]) { is_containing_list_of_lists_elem(tail, containing_lists_tail, x0) }
                        let (l: List[T]) satisfy {
                            containing_lists_tail.contains(l) and forall(y: T) {
                                s.contains(y) implies l.contains(y)
                            }
                        }

                        containing_cons.contains(l)
                        forall(y: T) {
                            s.contains(y) implies l.contains(y)
                        }
                        containing_cons.contains(l) and forall(y: T) {
                            s.contains(y) implies l.contains(y)
                        }

                        is_containing_list_of_lists_elem(List.cons(head, tail), containing_cons, s)
                    }
                }

                // Prover help?
                is_containing_list_of_lists_elem(List.cons(head, tail), containing_cons, s)
            }
            is_containing_list_of_lists(List.cons(head, tail), containing_cons)

            p(List.cons(head, tail))
        }
    }

    List.induction(p)

    p(sets)
}
