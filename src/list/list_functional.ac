from list.list_sum import List, map, partial, sum

// This file contains functional-programming-style things for lists.

define fold_left[T, U](list: List[T], f: (U, T) -> U, init: U) -> U {
    match list {
        List.nil {
            init
        }
        List.cons(head, tail) {
            fold_left(tail, f, f(init, head))
        }
    }
}

define fold_right[T, U](list: List[T], f: (T, U) -> U, init: U) -> U {
    match list {
        List.nil {
            init
        }
        List.cons(head, tail) {
            f(head, fold_right(tail, f, init))
        }
    }
}

/// Reverses a list.
define reverse[T](list: List[T]) -> List[T] {
    match list {
        List.nil {
            List.nil[T]
        }
        List.cons(head, tail) {
            reverse(tail).append(head)
        }
    }
}

theorem reverse_length[T](list: List[T]) {
    reverse(list).length = list.length
} by {
    define p(l: List[T]) -> Bool {
        reverse(l).length = l.length
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            // Induction hypothesis: reverse(tail).length = tail.length
            reverse(List.cons(head, tail)).length = (reverse(tail) + List.singleton(head)).length
            // Use add_length theorem
            (reverse(tail) + List.singleton(head)).length = reverse(tail).length + List.singleton(head).length
            reverse(tail).length = tail.length
            List.cons(head, tail).length = tail.length.suc
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l: List[T]) {
        p(l)
    })
}