from list.list_base import List
from order import LinearOrder

/// Theorems about lists of ordered types.

/// True if t is an upper bound for all items in the list.
/// An upper bound t satisfies: every element in the list is ≤ t.
define is_upper_bound[T: LinearOrder](list: List[T], t: T) -> Bool {
    match list {
        List.nil {
            true
        }
        List.cons(head, tail) {
            head <= t and is_upper_bound(tail, t)
        }
    }
}

/// If ub is an upper bound for a list and the list contains c, then c ≤ ub.
theorem upper_bound_contains[T: LinearOrder](list: List[T], ub: T, c: T) {
    is_upper_bound(list, ub) and list.contains(c) implies c <= ub
} by {
    define p(l: List[T]) -> Bool {
        is_upper_bound(l, ub) and l.contains(c) implies c <= ub
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_upper_bound(List.cons(head, tail), ub) and List.cons(head, tail).contains(c) {
                // is_upper_bound means head <= ub and tail is also bounded
                head <= ub
                is_upper_bound(tail, ub)

                // contains means c is either head or in tail
                if head = c {
                    c <= ub
                } else {
                    tail.contains(c)
                    // By induction hypothesis
                    c <= ub
                }
                c <= ub
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l: List[T]) {
        p(l)
    })
}

/// If ub is an upper bound for (list1 + list2), then ub is an upper bound for list1.
theorem upper_bound_add_left[T: LinearOrder](list1: List[T], list2: List[T], ub: T) {
    is_upper_bound(list1 + list2, ub) implies is_upper_bound(list1, ub)
} by {
    define p(l1: List[T]) -> Bool {
        is_upper_bound(l1 + list2, ub) implies is_upper_bound(l1, ub)
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_upper_bound(List.cons(head, tail) + list2, ub) {
                // Definition of add
                List.cons(head, tail) + list2 = List.cons(head, tail + list2)
                is_upper_bound(List.cons(head, tail + list2), ub)

                // This means head <= ub and (tail + list2) is bounded
                head <= ub
                is_upper_bound(tail + list2, ub)

                // By induction hypothesis
                is_upper_bound(tail, ub)

                // So cons(head, tail) is bounded
                is_upper_bound(List.cons(head, tail), ub)
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l1: List[T]) {
        p(l1)
    })
}

/// If ub is an upper bound for (list1 + list2), then ub is an upper bound for list2.
theorem upper_bound_add_right[T: LinearOrder](list1: List[T], list2: List[T], ub: T) {
    is_upper_bound(list1 + list2, ub) implies is_upper_bound(list2, ub)
} by {
    define p(l1: List[T]) -> Bool {
        is_upper_bound(l1 + list2, ub) implies is_upper_bound(list2, ub)
    }

    // Base case: empty list
    List.nil[T] + list2 = list2
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_upper_bound(List.cons(head, tail) + list2, ub) {
                // Definition of add
                List.cons(head, tail) + list2 = List.cons(head, tail + list2)
                is_upper_bound(List.cons(head, tail + list2), ub)

                // This means (tail + list2) is bounded
                is_upper_bound(tail + list2, ub)

                // By induction hypothesis
                is_upper_bound(list2, ub)
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l1: List[T]) {
        p(l1)
    })
}

/// If ub1 is an upper bound and ub1 ≤ ub2, then ub2 is also an upper bound.
theorem upper_bound_monotone[T: LinearOrder](list: List[T], ub1: T, ub2: T) {
    is_upper_bound(list, ub1) and ub1 <= ub2 implies is_upper_bound(list, ub2)
} by {
    define p(l: List[T]) -> Bool {
        is_upper_bound(l, ub1) and ub1 <= ub2 implies is_upper_bound(l, ub2)
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_upper_bound(List.cons(head, tail), ub1) and ub1 <= ub2 {
                // is_upper_bound means head <= ub1 and tail is bounded by ub1
                head <= ub1
                is_upper_bound(tail, ub1)

                // Transitivity gives us what we need
                head <= ub2
                is_upper_bound(tail, ub2)

                is_upper_bound(List.cons(head, tail), ub2)
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l: List[T]) {
        p(l)
    })
}

/// The maximum element of a non-empty list.
define list_max[T: LinearOrder](head: T, tail: List[T]) -> T {
    match tail {
        List.nil {
            head
        }
        List.cons(next, rest) {
            head.max(list_max(next, rest))
        }
    }
}

/// The maximum element of a list is an upper bound for that list.
theorem list_max_is_upper_bound[T: LinearOrder](head: T, tail: List[T]) {
    is_upper_bound(List.cons(head, tail), list_max(head, tail))
} by {
    define p(t: List[T]) -> Bool {
        forall(h: T) {
            is_upper_bound(List.cons(h, t), list_max(h, t))
        }
    }

    // Base case: tail is nil (singleton list)
    forall(h: T) {
        list_max(h, List.nil[T]) = h
        is_upper_bound(List.cons(h, List.nil[T]), h)
    }
    p(List.nil[T])

    // Inductive case
    forall(next: T, rest: List[T]) {
        if p(rest) {
            forall(h: T) {
                // By induction hypothesis for next and rest specifically
                is_upper_bound(List.cons(next, rest), list_max(next, rest))

                let m = list_max(h, List.cons(next, rest))
                m = h.max(list_max(next, rest))

                // We know h.max(x) >= h and h.max(x) >= x for any x
                h <= m
                list_max(next, rest) <= m

                // Since list_max(next, rest) is an upper bound for cons(next, rest),
                // and m >= list_max(next, rest), use monotonicity
                is_upper_bound(List.cons(next, rest), m)

                // Now we can show is_upper_bound(cons(h, cons(next, rest)), m)
                is_upper_bound(List.cons(h, List.cons(next, rest)), m)

                // This is exactly list_max(h, cons(next, rest))
                is_upper_bound(List.cons(h, List.cons(next, rest)), list_max(h, List.cons(next, rest)))
            }

            // We've shown forall(h: T) { is_upper_bound(List.cons(h, List.cons(next, rest)), list_max(h, List.cons(next, rest))) }
            // which is exactly p(List.cons(next, rest))
            forall(h: T) {
                is_upper_bound(List.cons(h, List.cons(next, rest)), list_max(h, List.cons(next, rest)))
            }
            p(List.cons(next, rest))
        }
    }

    List.induction(function (t: List[T]) {
        p(t)
    })

    // Apply to our specific head and tail
    p(tail)
    is_upper_bound(List.cons(head, tail), list_max(head, tail))
}

/// Every non-empty list has an upper bound.
theorem list_has_upper_bound[T: LinearOrder](head: T, tail: List[T]) {
    exists(ub: T) {
        is_upper_bound(List.cons(head, tail), ub)
    }
} by {
    let ub = list_max(head, tail)
    is_upper_bound(List.cons(head, tail), ub)
}

/// True if t is a lower bound for all items in the list.
/// A lower bound t satisfies: t ≤ every element in the list.
define is_lower_bound[T: LinearOrder](list: List[T], t: T) -> Bool {
    match list {
        List.nil {
            true
        }
        List.cons(head, tail) {
            t <= head and is_lower_bound(tail, t)
        }
    }
}

/// If lb is a lower bound for a list and the list contains c, then lb ≤ c.
theorem lower_bound_contains[T: LinearOrder](list: List[T], lb: T, c: T) {
    is_lower_bound(list, lb) and list.contains(c) implies lb <= c
} by {
    define p(l: List[T]) -> Bool {
        is_lower_bound(l, lb) and l.contains(c) implies lb <= c
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_lower_bound(List.cons(head, tail), lb) and List.cons(head, tail).contains(c) {
                // is_lower_bound means lb <= head and tail is also bounded
                lb <= head
                is_lower_bound(tail, lb)

                // contains means c is either head or in tail
                if head = c {
                    lb <= c
                } else {
                    tail.contains(c)
                    // By induction hypothesis
                    lb <= c
                }
                lb <= c
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l: List[T]) {
        p(l)
    })
}

/// If lb is a lower bound for (list1 + list2), then lb is a lower bound for list1.
theorem lower_bound_add_left[T: LinearOrder](list1: List[T], list2: List[T], lb: T) {
    is_lower_bound(list1 + list2, lb) implies is_lower_bound(list1, lb)
} by {
    define p(l1: List[T]) -> Bool {
        is_lower_bound(l1 + list2, lb) implies is_lower_bound(l1, lb)
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_lower_bound(List.cons(head, tail) + list2, lb) {
                // Definition of add
                List.cons(head, tail) + list2 = List.cons(head, tail + list2)
                is_lower_bound(List.cons(head, tail + list2), lb)

                // This means lb <= head and (tail + list2) is bounded
                lb <= head
                is_lower_bound(tail + list2, lb)

                // By induction hypothesis
                is_lower_bound(tail, lb)

                // So cons(head, tail) is bounded
                is_lower_bound(List.cons(head, tail), lb)
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l1: List[T]) {
        p(l1)
    })
}

/// If lb is a lower bound for (list1 + list2), then lb is a lower bound for list2.
theorem lower_bound_add_right[T: LinearOrder](list1: List[T], list2: List[T], lb: T) {
    is_lower_bound(list1 + list2, lb) implies is_lower_bound(list2, lb)
} by {
    define p(l1: List[T]) -> Bool {
        is_lower_bound(l1 + list2, lb) implies is_lower_bound(list2, lb)
    }

    // Base case: empty list
    List.nil[T] + list2 = list2
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_lower_bound(List.cons(head, tail) + list2, lb) {
                // Definition of add
                List.cons(head, tail) + list2 = List.cons(head, tail + list2)
                is_lower_bound(List.cons(head, tail + list2), lb)

                // This means (tail + list2) is bounded
                is_lower_bound(tail + list2, lb)

                // By induction hypothesis
                is_lower_bound(list2, lb)
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l1: List[T]) {
        p(l1)
    })
}

/// If lb2 is a lower bound and lb2 ≤ lb1, then lb1 is also a lower bound.
theorem lower_bound_monotone[T: LinearOrder](list: List[T], lb1: T, lb2: T) {
    is_lower_bound(list, lb1) and lb2 <= lb1 implies is_lower_bound(list, lb2)
} by {
    define p(l: List[T]) -> Bool {
        is_lower_bound(l, lb1) and lb2 <= lb1 implies is_lower_bound(l, lb2)
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_lower_bound(List.cons(head, tail), lb1) and lb2 <= lb1 {
                // is_lower_bound means lb1 <= head and tail is bounded by lb1
                lb1 <= head
                is_lower_bound(tail, lb1)

                // Transitivity gives us what we need
                lb2 <= head
                is_lower_bound(tail, lb2)

                is_lower_bound(List.cons(head, tail), lb2)
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l: List[T]) {
        p(l)
    })
}

/// The minimum element of a non-empty list.
define list_min[T: LinearOrder](head: T, tail: List[T]) -> T {
    match tail {
        List.nil {
            head
        }
        List.cons(next, rest) {
            head.min(list_min(next, rest))
        }
    }
}

/// The minimum element of a list is a lower bound for that list.
theorem list_min_is_lower_bound[T: LinearOrder](head: T, tail: List[T]) {
    is_lower_bound(List.cons(head, tail), list_min(head, tail))
} by {
    define p(t: List[T]) -> Bool {
        forall(h: T) {
            is_lower_bound(List.cons(h, t), list_min(h, t))
        }
    }

    // Base case: tail is nil (singleton list)
    forall(h: T) {
        list_min(h, List.nil[T]) = h
        is_lower_bound(List.cons(h, List.nil[T]), h)
    }
    p(List.nil[T])

    // Inductive case
    forall(next: T, rest: List[T]) {
        if p(rest) {
            forall(h: T) {
                // By induction hypothesis for next and rest specifically
                is_lower_bound(List.cons(next, rest), list_min(next, rest))

                let m = list_min(h, List.cons(next, rest))
                m = h.min(list_min(next, rest))

                // We know h.min(x) <= h and h.min(x) <= x for any x
                m <= h
                m <= list_min(next, rest)

                // Since list_min(next, rest) is a lower bound for cons(next, rest),
                // and m <= list_min(next, rest), use monotonicity
                is_lower_bound(List.cons(next, rest), m)

                // Now we can show is_lower_bound(cons(h, cons(next, rest)), m)
                is_lower_bound(List.cons(h, List.cons(next, rest)), m)

                // This is exactly list_min(h, cons(next, rest))
                is_lower_bound(List.cons(h, List.cons(next, rest)), list_min(h, List.cons(next, rest)))
            }

            // We've shown forall(h: T) { is_lower_bound(List.cons(h, List.cons(next, rest)), list_min(h, List.cons(next, rest))) }
            // which is exactly p(List.cons(next, rest))
            forall(h: T) {
                is_lower_bound(List.cons(h, List.cons(next, rest)), list_min(h, List.cons(next, rest)))
            }
            p(List.cons(next, rest))
        }
    }

    List.induction(function (t: List[T]) {
        p(t)
    })

    // Apply to our specific head and tail
    p(tail)
    is_lower_bound(List.cons(head, tail), list_min(head, tail))
}

/// Every non-empty list has a lower bound.
theorem list_has_lower_bound[T: LinearOrder](head: T, tail: List[T]) {
    exists(lb: T) {
        is_lower_bound(List.cons(head, tail), lb)
    }
} by {
    let lb = list_min(head, tail)
    is_lower_bound(List.cons(head, tail), lb)
}

