from list.list_base import List
from order import LinearOrder

/// Theorems about lists of ordered types.

/// True if t is an upper bound for all items in the list.
/// An upper bound t satisfies: every element in the list is â‰¤ t.
define is_upper_bound[T: LinearOrder](list: List[T], t: T) -> Bool {
    match list {
        List.nil {
            true
        }
        List.cons(head, tail) {
            head <= t and is_upper_bound(tail, t)
        }
    }
}

/// If ub is an upper bound for a list and the list contains c, then c â‰¤ ub.
theorem upper_bound_contains[T: LinearOrder](list: List[T], ub: T, c: T) {
    is_upper_bound(list, ub) and list.contains(c) implies c <= ub
} by {
    define p(l: List[T]) -> Bool {
        is_upper_bound(l, ub) and l.contains(c) implies c <= ub
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_upper_bound(List.cons(head, tail), ub) and List.cons(head, tail).contains(c) {
                // is_upper_bound means head <= ub and tail is also bounded
                head <= ub
                is_upper_bound(tail, ub)

                // contains means c is either head or in tail
                if head = c {
                    c <= ub
                } else {
                    tail.contains(c)
                    // By induction hypothesis
                    c <= ub
                }
                c <= ub
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l: List[T]) {
        p(l)
    })
}

/// If ub is an upper bound for (list1 + list2), then ub is an upper bound for list1.
theorem upper_bound_add_left[T: LinearOrder](list1: List[T], list2: List[T], ub: T) {
    is_upper_bound(list1 + list2, ub) implies is_upper_bound(list1, ub)
} by {
    define p(l1: List[T]) -> Bool {
        is_upper_bound(l1 + list2, ub) implies is_upper_bound(l1, ub)
    }

    // Base case: empty list
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_upper_bound(List.cons(head, tail) + list2, ub) {
                // Definition of add
                List.cons(head, tail) + list2 = List.cons(head, tail + list2)
                is_upper_bound(List.cons(head, tail + list2), ub)

                // This means head <= ub and (tail + list2) is bounded
                head <= ub
                is_upper_bound(tail + list2, ub)

                // By induction hypothesis
                is_upper_bound(tail, ub)

                // So cons(head, tail) is bounded
                is_upper_bound(List.cons(head, tail), ub)
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l1: List[T]) {
        p(l1)
    })
}

/// If ub is an upper bound for (list1 + list2), then ub is an upper bound for list2.
theorem upper_bound_add_right[T: LinearOrder](list1: List[T], list2: List[T], ub: T) {
    is_upper_bound(list1 + list2, ub) implies is_upper_bound(list2, ub)
} by {
    define p(l1: List[T]) -> Bool {
        is_upper_bound(l1 + list2, ub) implies is_upper_bound(list2, ub)
    }

    // Base case: empty list
    List.nil[T] + list2 = list2
    p(List.nil[T])

    // Induction
    forall(head: T, tail: List[T]) {
        if p(tail) {
            if is_upper_bound(List.cons(head, tail) + list2, ub) {
                // Definition of add
                List.cons(head, tail) + list2 = List.cons(head, tail + list2)
                is_upper_bound(List.cons(head, tail + list2), ub)

                // This means (tail + list2) is bounded
                is_upper_bound(tail + list2, ub)

                // By induction hypothesis
                is_upper_bound(list2, ub)
            }
            p(List.cons(head, tail))
        }
    }

    List.induction(function (l1: List[T]) {
        p(l1)
    })
}
