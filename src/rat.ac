import nat.nat_base
from nat import Nat
from int import Int, gcd

define is_reduced(a: Int, b: Int) -> Bool {
    b > Int.0 and gcd(a, b) = Int.1
}

theorem denom_one_is_reduced(a: Int) {
    is_reduced(a, Int.1)
}

structure Rat {
    num: Int
    denom: Int
} constraint {
    is_reduced(num, denom)
}

attributes Rat {
    let 0: Rat = Rat.new(Int.0, Int.1)
}

theorem zero_num {
    Rat.0.num = Int.0
}

theorem zero_denom {
    Rat.0.denom = Int.1
}

theorem denom_nonzero(r: Rat) {
    r.denom != Int.0
} by {
    r.denom > Int.0
}

theorem denom_positive(r: Rat) {
    r.denom.is_positive
} by {
    r.denom > Int.0
}

attributes Rat {
    let from_int = function(n: Int) {
        Rat.new(n, Int.1)
    }
}

theorem from_int_num(n: Int) {
    Rat.from_int(n).num = n
}

theorem from_int_denom(n: Int) {
    Rat.from_int(n).denom = Int.1
}

// We have to check the denominators are not zero, because 0/0
// checks as cross-equals with everything, so we have to disclude it.
define cross_equals(a: Int, b: Int, c: Int, d: Int) -> Bool {
    b != Int.0 and d != Int.0 and a * d = c * b
}

theorem cross_equals_trans(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) {
    cross_equals(a, b, c, d) and cross_equals(c, d, e, f) implies cross_equals(a, b, e, f)
} by {
    a * d = b * c
    c * f = d * e
    a * d * f = b * c * f
    a * d * f = b * d * e
    a * f * d = b * e * d
    d != Int.0
    a * f = b * e
}

// Either zero, or a / b reduced to simplest form.
let reduce(a: Int, b: Int) -> r: Rat satisfy {
    if b = Int.0 {
        r = Rat.0
    } else {
        cross_equals(r.num, r.denom, a, b)
    }
} by {
    if b = Int.0 {
        Rat.0 = Rat.0
    } else {
        // Factor out the gcd
        gcd(a, b) != Int.0
        let a1: Int satisfy {
            a1 * gcd(a, b) = a
        }
        let b1: Int satisfy {
            b1 * gcd(a, b) = b
        }
        b1 != Int.0
        a * b = a * b1 * gcd(a, b)
        a * b = b * a1 * gcd(a, b)
        a * b1 * gcd(a, b) = b * a1 * gcd(a, b)
        a * b1 = b * a1
        cross_equals(a1, b1, a, b)
        gcd(a1, b1) = Int.1

        // To reduce we also need to swap signs if the denominator is negative
        let a2 = a1 * int.unit_sign(b1)
        let b2 = b1 * int.unit_sign(b1)
        b2 = Int.from_nat(int.abs(b1))
        b2 != Int.0
        (a1 * int.unit_sign(b1)) * b1 = (b1 * int.unit_sign(b1)) * a1
        cross_equals(a2, b2, a1, b1)
        gcd(a2, b2) = Int.1 * Int.from_nat(int.abs(int.unit_sign(b1)))
        Int.from_nat(int.abs(int.unit_sign(b1))) = Int.1
        gcd(a2, b2) = Int.1
        b2 != Int.0
        is_reduced(a2, b2)

        let r = Rat.new(a2, b2)
        r.num = a2
        r.denom = b2
        cross_equals(r.num, r.denom, a2, b2)
        cross_equals(a2, b2, a, b)
        cross_equals(r.num, r.denom, a, b)
    }
}

theorem cross_eq_imp_eq(r1: Rat, r2: Rat) {
    cross_equals(r1.num, r1.denom, r2.num, r2.denom) implies r1 = r2
} by {
    // The r1 fields divide into the r2 ones
    gcd(r1.num, r1.denom) = Int.1
    int.divides(r1.denom, r1.num * r2.denom)
    int.divides(r1.denom, r2.denom)
    nat_base.divides(int.abs(r1.denom), int.abs(r2.denom))

    // The r2 fields divide into the r1 ones
    gcd(r2.num, r2.denom) = Int.1
    int.divides(r2.denom, r2.num * r1.denom)
    int.divides(r2.denom, r1.denom)
    nat_base.divides(int.abs(r2.denom), int.abs(r1.denom))

    // Prove int equality from nat equality
    int.abs(r1.denom) = int.abs(r2.denom)
    r1.denom.is_positive
    r2.denom.is_positive
    r1.denom = r2.denom

    // Divide out the denominators
    r1.num * r2.denom = r2.num * r1.denom
    r1.num * r2.denom = r2.num * r2.denom
    r2.denom != Int.0
    r1.num = r2.num
}

attributes Rat {
    let 1: Rat = Rat.from_int(Int.1)
    let 2: Rat = Rat.from_int(Int.2)
    let 3: Rat = Rat.from_int(Int.3)
    let 4: Rat = Rat.from_int(Int.4)
    let 5: Rat = Rat.from_int(Int.5)
    let 6: Rat = Rat.from_int(Int.6)
    let 7: Rat = Rat.from_int(Int.7)
    let 8: Rat = Rat.from_int(Int.8)
    let 9: Rat = Rat.from_int(Int.9)
    let 10: Rat = Rat.from_int(Int.10)

    define is_positive(self) -> Bool {
        self.num.is_positive
    }

    define is_negative(self) -> Bool {
        self.num.is_negative
    }

    define neg(self) -> Rat {
        Rat.new(-self.num, self.denom)
    }

    define add(self, other: Rat) -> Rat {
        reduce(self.num * other.denom + other.num * self.denom,
               self.denom * other.denom)
    }

    define mul(self, other: Rat) -> Rat {
        reduce(self.num * other.num, self.denom * other.denom)
    }

    // This defines the reciprocal of zero to be zero
    define reciprocal(self) -> Rat {
        reduce(self.denom, self.num)
    }

    // This is the weird version where dividing by zero gives you zero
    define div(self, other: Rat) -> Rat {
        self * other.reciprocal
    }

    define read(self, other: Rat) -> Rat { Rat.10 * self + other }
}

theorem reduce_idempotent(r: Rat) {
    reduce(r.num, r.denom) = r
}

theorem neg_is_reduced(r: Rat) {
    is_reduced(-r.num, r.denom)
} by {
    r.denom > Int.0
    gcd(-r.num, r.denom) = gcd(r.num, r.denom)
}

theorem neg_num(r: Rat) {
    r.neg.num = -r.num
}

theorem neg_denom(r: Rat) {
    r.neg.denom = r.denom
}

theorem add_zero_right(a: Rat) {
    a + Rat.0 = a
} by {
    a + Rat.0 = reduce(a.num * Int.1 + Int.0 * a.denom, a.denom * Int.1)
    a + Rat.0 = reduce(a.num, a.denom)
}

theorem add_zero_left(a: Rat) {
    Rat.0 + a = a
}

theorem add_comm(a: Rat, b: Rat) {
    a + b = b + a
}

theorem from_int_cancel(a: Int, b: Int) {
    Rat.from_int(a) = Rat.from_int(b) implies a = b
}

theorem mul_comm(a: Rat, b: Rat) {
    a * b = b * a
}

theorem rat_neg_one {
    -Rat.1 = Rat.from_int(-Int.1)
} by {
    Rat.1 = Rat.new(Int.1, Int.1)
    Rat.from_int(-Int.1) = Rat.new(-Int.1, Int.1)
}

theorem mul_neg_one_right(r: Rat) {
    r * -Rat.1 = -r
} by {
    r * Rat.from_int(-Int.1) = -r
}

theorem mul_neg_one_left(r: Rat) {
    -Rat.1 * r = -r
}

theorem mul_one_right(r: Rat) {
    r * Rat.1 = r
} by {
    r * Rat.from_int(Int.1) = r
}

theorem mul_one_left(r: Rat) {
    Rat.1 * r = r
}

theorem mul_int_eq_int_mul(a: Int, b: Int) {
    Rat.from_int(a) * Rat.from_int(b) = Rat.from_int(a * b)
}

theorem unreduce_right(a: Int, b: Int) {
    b != Int.0 implies exists(d: Int) {
        reduce(a, b).num * d = a and reduce(a, b).denom * d = b
    }
} by {
    let r = reduce(a, b)
    cross_equals(r.num, r.denom, a, b)
    r.num * b = a * r.denom
    int.gcd(r.num, r.denom) = Int.1
    int.divides(r.denom, r.num * b)
    int.divides(r.denom, b)
    let d: Int satisfy {
        r.denom * d = b
    }
    r.num * b * d = a * r.denom * d
    r.num * d * b = a * b
    r.num * d = a
}

theorem unreduce_left(a: Int, b: Int) {
    b != Int.0 implies exists(d: Int) {
        d * reduce(a, b).num = a and d * reduce(a, b).denom = b
    }
} by {
    let d: Int satisfy {
        reduce(a, b).num * d = a and reduce(a, b).denom * d = b
    }
    d * reduce(a, b).num = a
    d * reduce(a, b).denom = b
}

theorem mul_int_right(r: Rat, n: Int) {
    r * Rat.from_int(n) = reduce(r.num * n, r.denom)
}

theorem mul_int_left(n: Int, r: Rat) {
    Rat.from_int(n) * r = reduce(n * r.num, r.denom)
}

theorem cross_eq_imp_reduce_eq(a: Int, b: Int, c: Int, d: Int) {
    cross_equals(a, b, c, d) implies reduce(a, b) = reduce(c, d)
} by {
    b != Int.0
    d != Int.0
    let rab = reduce(a, b)
    cross_equals(rab.num, rab.denom, a, b)
    cross_equals(rab.num, rab.denom, c, d)
    let rcd = reduce(c, d)
    cross_equals(reduce(c, d).num, rcd.denom, c, d)
    cross_equals(rcd.num, rcd.denom, c, d)
    c * rab.denom = rab.num * d
    cross_equals(rcd.num, rcd.denom, rab.num, rab.denom)
    rab = rcd
}

theorem reduce_eq_imp_cross_eq(a: Int, b: Int, c: Int, d: Int) {
    b != Int.0 and d != Int.0 and reduce(a, b) = reduce(c, d)
        implies cross_equals(a, b, c, d)
} by {
    cross_equals(reduce(a, b).num, reduce(a, b).denom, a, b)
    cross_equals(reduce(c, d).num, reduce(c, d).denom, c, d)
}

theorem mul_reduced_int_right(a: Int, b: Int, c: Int) {
    reduce(a, b) * Rat.from_int(c) = reduce(a * c, b)
} by {
    if b = Int.0 {
        reduce(a, b) = Rat.0
        reduce(a * c, b) = Rat.0
        reduce(a, b) * Rat.from_int(c) = reduce(a * c, b)
    } else {
        let r = reduce(a, b)
        r * Rat.from_int(c) = reduce(r.num * c, r.denom)
        cross_equals(r.num, r.denom, a, b)
        r.num * b = r.denom * a
        r.num * c * b = r.denom * (a * c)
        reduce(r.num * c, r.denom) = reduce(a * c, b)
        reduce(a, b) * Rat.from_int(c) = reduce(a * c, b)
    }
}

theorem mul_reduced_int_left(a: Int, b: Int, c: Int) {
    Rat.from_int(c) * reduce(a, b) = reduce(c * a, b)
}

theorem mul_int_right_cancel(r1: Rat, r2: Rat, n: Int) {
    n != Int.0 and r1 * Rat.from_int(n) = r2 * Rat.from_int(n) implies r1 = r2
} by {
    r1 * Rat.from_int(n) = reduce(r1.num * n, r1.denom)
    r2 * Rat.from_int(n) = reduce(r2.num * n, r2.denom)
    reduce(r1.num * n, r1.denom) = reduce(r2.num * n, r2.denom)
    r1.num * n * r2.denom = r1.denom * r2.num * n
    r1.num * r2.denom = r1.denom * r2.num
    r1 = r2
}

theorem mul_int_left_cancel(r1: Rat, r2: Rat, n: Int) {
    n != Int.0 and Rat.from_int(n) * r1 = Rat.from_int(n) * r2 implies r1 = r2
}

theorem mul_reduced_nondegen(a: Int, b: Int, c: Int, d: Int) {
    b != Int.0 and d != Int.0 implies
        reduce(a, b) * reduce(c, d) = reduce(a * c, b * d)
} by {
    let e: Int satisfy {
        reduce(a, b).num * e = a and reduce(a, b).denom * e = b
    }
    e != Int.0
    let f: Int satisfy {
        reduce(c, d).num * f = c and reduce(c, d).denom * f = d
    }
    f != Int.0

    // Simplify numerator
    let nums = reduce(a, b).num * reduce(c, d).num
    (reduce(a, b).num * e) * (reduce(c, d).num * f) = a * c
    reduce(a, b).num * e * reduce(c, d).num * f = a * c
    (reduce(a, b).num * reduce(c, d).num) * e * f = a * c
    (reduce(a, b).num * reduce(c, d).num) * (e * f) = a * c
    nums * (e * f) = a * c

    // Simplify denominator
    let denoms: Int = reduce(a, b).denom * reduce(c, d).denom
    (reduce(a, b).denom * e) * (reduce(c, d).denom * f) = b * d
    (reduce(a, b).denom * reduce(c, d).denom) * e * f = b * d
    (reduce(a, b).denom * reduce(c, d).denom) * (e * f) = b * d
    denoms * (e * f) = b * d

    // Combining
    nums * (b * d) = denoms * (a * c)
    reduce(a, b).denom * reduce(c, d).denom != Int.0
    denoms != Int.0
    cross_equals(nums, denoms, a * c, b * d)
    cross_equals(reduce(a, b).num * reduce(c, d).num,
                 reduce(a, b).denom * reduce(c, d).denom,
                 a * c, b * d)
}

theorem reduce_zero_num(a: Int) {
    reduce(Int.0, a) = Rat.0
} by {
    if a = Int.0 {
        reduce(Int.0, a) = Rat.0
    } else {
        Rat.0 = reduce(Int.0, Int.1)
        cross_equals(Int.0, a, Int.0, Int.1)
        reduce(Int.0, a) = reduce(Int.0, Int.1)
        reduce(Int.0, a) = Rat.0
    }
}

theorem mul_zero_right(r: Rat) {
    r * Rat.0 = Rat.0
} by {
    r * Rat.0 = reduce(r.num * Int.0, r.denom)
    r * Rat.0 = reduce(Int.0, r.denom)
}

theorem mul_reduced_degen(a: Int, b: Int, c: Int) {
    reduce(a, b) * reduce(c, Int.0) = reduce(a * c, b * Int.0)
} by {
    reduce(c, Int.0) = Rat.0
    reduce(a, b) * Rat.0 = Rat.0
    reduce(a * c, b * Int.0) = Rat.0
}

theorem mul_reduced(a: Int, b: Int, c: Int, d: Int) {
    reduce(a, b) * reduce(c, d) = reduce(a * c, b * d)
} by {
    if b = Int.0 or d = Int.0 {
        // Degen cases
        if b = Int.0 {
            reduce(a, Int.0) * reduce(c, d) = reduce(a * c, Int.0 * d)
            reduce(a, b) * reduce(c, d) = reduce(a * c, b * d)
        } else {
            d = Int.0
            reduce(a, b) * reduce(c, Int.0) = reduce(a * c, b * Int.0)
            reduce(a, b) * reduce(c, d) = reduce(a * c, b * d)
        }
    } else {
        // Non-degen case
        reduce(a, b) * reduce(c, d) = reduce(a * c, b * d)
    }
}

theorem mul_assoc(a: Rat, b: Rat, c: Rat) {
    (a * b) * c = a * (b * c)
} by {
    (a * b) * c = reduce(a.num * b.num * c.num, a.denom * b.denom * c.denom)
    a * (b * c) = reduce(a.num * (b.num * c.num), a.denom * (b.denom * c.denom))
}

theorem add_int_eq_int_add(a: Int, b: Int) {
    Rat.from_int(a) + Rat.from_int(b) = Rat.from_int(a + b)
}

theorem reduce_cancels_right(a: Int, b: Int, c: Int) {
    c != Int.0 implies reduce(a, b) = reduce(a * c, b * c)
} by {
    if b = Int.0 {
        reduce(a, b) = Rat.0
        b * c = Int.0
        reduce(a * c, b * c) = Rat.0
        reduce(a, b) = reduce(a * c, b * c)
    } else {
        cross_equals(a, b, a * c, b * c)
        reduce(a, b) = reduce(a * c, b * c)
    }
}

theorem reduce_cancels_left(a: Int, b: Int, c: Int) {
    c != Int.0 implies reduce(a, b) = reduce(c * a, c * b)
}

theorem add_reduce_right(r: Rat, a: Int, b: Int) {
    b != Int.0 implies r + reduce(a, b) = reduce(r.num * b + a * r.denom, r.denom * b)
} by {
    let c: Int satisfy {
        reduce(a, b).num * c = a and reduce(a, b).denom * c = b
    }
    c != Int.0
    r + reduce(a, b) = reduce(r.num * reduce(a, b).denom + r.denom * reduce(a, b).num,
                              reduce(a, b).denom * r.denom)
    r + reduce(a, b) = reduce((r.num * reduce(a, b).denom + r.denom * reduce(a, b).num) * c,
                              reduce(a, b).denom * r.denom * c)
    r + reduce(a, b) = reduce(r.num * reduce(a, b).denom * c + r.denom * reduce(a, b).num * c,
                              reduce(a, b).denom * r.denom * c)
    r + reduce(a, b) = reduce(r.num * b + a * r.denom, r.denom * b)
}

theorem add_reduced(a: Int, b: Int, c: Int, d: Int) {
    b != Int.0 and d != Int.0 implies reduce(a, b) + reduce(c, d) = reduce(a * d + b * c, b * d)
} by {
    reduce(a, b) + reduce(c, d) = reduce(reduce(a, b).num * d + c * reduce(a, b).denom,
                                         reduce(a, b).denom * d)
    let e: Int satisfy {
        reduce(a, b).num * e = a and reduce(a, b).denom * e = b
    }
    e != Int.0
    reduce(reduce(a, b).num * d + c * reduce(a, b).denom, reduce(a, b).denom * d) = reduce(
        (reduce(a, b).num * d + c * reduce(a, b).denom) * e, reduce(a, b).denom * d * e)
    reduce(a, b) + reduce(c, d) = reduce((reduce(a, b).num * d + c * reduce(a, b).denom) * e,
                                         reduce(a, b).denom * d * e)
    reduce(a, b) + reduce(c, d) = reduce(reduce(a, b).num * d * e + c * reduce(a, b).denom * e,
                                         reduce(a, b).denom * d * e)
    reduce(a, b) + reduce(c, d) = reduce(reduce(a, b).num * e * d + reduce(a, b).denom * e * c,
                                         reduce(a, b).denom * e * d)
}

theorem add_reduced_same_denom(a: Int, b: Int, c: Int) {
    reduce(a, c) + reduce(b, c) = reduce(a + b, c)
} by {
    if c = Int.0 {
        reduce(a, c) = Rat.0
        reduce(b, c) = Rat.0
        reduce(a + b, c) = Rat.0
        reduce(a, c) + reduce(b, c) = reduce(a + b, c)
    } else {
        reduce(a, c) + reduce(b, c) = reduce(a * c + b * c, c * c)
        reduce(a, c) + reduce(b, c) = reduce((a + b) * c, c * c)
        reduce(a, c) + reduce(b, c) = reduce(a + b, c)
    }
}

theorem add_assoc(a: Rat, b: Rat, c: Rat) {
    a + b + c = a + (b + c)
} by {
    let d: Int = a.denom * b.denom * c.denom
    let an: Int = a.num * (b.denom * c.denom)
    a = reduce(a.num, a.denom)
    b.denom * c.denom != Int.0
    a = reduce(a.num * (b.denom * c.denom), a.denom * (b.denom * c.denom))
    a = reduce(an, d)

    let bn: Int = b.num * (a.denom * c.denom)
    b = reduce(b.num, b.denom)
    a.denom * c.denom != Int.0
    b = reduce(b.num * (a.denom * c.denom), b.denom * (a.denom * c.denom))
    b = reduce(bn, d)

    let cn: Int = c.num * (a.denom * b.denom)
    c = reduce(c.num, c.denom)
    a.denom * b.denom != Int.0
    c = reduce(c.num * (a.denom * b.denom), c.denom * (a.denom * b.denom))
    c = reduce(cn, d)

    a + b + c = reduce(an, d) + reduce(bn, d) + reduce(cn, d)
    a + b + c = reduce(an + bn, d) + reduce(cn, d)
    a + b + c = reduce(an + bn + cn, d)
    a + b + c = reduce(an + (bn + cn), d)
    a + b + c = reduce(an, d) + reduce(bn + cn, d)
    a + b + c = reduce(an, d) + (reduce(bn, d) + reduce(cn, d))
    a + b + c = a + (b + c)
}

theorem common_denom(r1: Rat, r2: Rat) {
    exists(n1: Int, n2: Int, d: Int) {
        r1 = reduce(n1, d) and r2 = reduce(n2, d)
    }
} by {
    let d: Int = r1.denom * r2.denom
    d != Int.0
    let n1: Int = r1.num * r2.denom
    r1 = reduce(r1.num * r2.denom, r1.denom * r2.denom)
    r1 = reduce(n1, d)
    let n2: Int = r2.num * r1.denom
    r2 = reduce(r2.num * r1.denom, r2.denom * r1.denom)
    r2 = reduce(n2, d)
}

theorem distrib_left(r1: Rat, r2: Rat, r3: Rat) {
    r1 * (r2 + r3) = r1 * r2 + r1 * r3
} by {
    let (a: Int, b: Int, c: Int) satisfy {
        r2 = reduce(a, c) and r3 = reduce(b, c)
    }

    // Simplify the left side
    r2 + r3 = reduce(a + b, c)
    r1 * (r2 + r3) = r1 * reduce(a + b, c)
    r1 * (r2 + r3) = reduce(r1.num * (a + b), r1.denom * c)
    r1 * (r2 + r3) = reduce(r1.num * a + r1.num * b, r1.denom * c)

    // Simplify the right side
    r1 * r2 = reduce(r1.num * a, r1.denom * c)
    r1 * r3 = reduce(r1.num * b, r1.denom * c)
    r1 * r2 + r1 * r3 = reduce(r1.num * a + r1.num * b, r1.denom * c)
}

theorem distrib_right(r1: Rat, r2: Rat, r3: Rat) {
    (r1 + r2) * r3 = r1 * r3 + r2 * r3
}

theorem add_inv_cancels_right(a: Rat, b: Rat) {
    a + -a = Rat.0
} by {
    a + -a = reduce(a.num * a.denom + -a.num * a.denom, a.denom * a.denom)
    a + -a = reduce(a.num * a.denom - a.num * a.denom, a.denom * a.denom)
    a + -a = reduce(Int.0, a.denom * a.denom)
    a + -a = Rat.0
}

theorem add_inv_cancels_left(a: Rat, b: Rat) {
    -a + a = Rat.0
}

// The additive algebraic structure.

from add_semigroup import AddSemigroup

instance Rat: AddSemigroup {
    let add = Rat.add
}

from add_comm_semigroup import AddCommSemigroup

instance Rat: AddCommSemigroup

from add_monoid import AddMonoid

instance Rat: AddMonoid {
    let 0 = Rat.0
}

from add_comm_monoid import AddCommMonoid

instance Rat: AddCommMonoid

from add_group import AddGroup

instance Rat: AddGroup {
    let neg = Rat.neg
}

from add_comm_group import AddCommGroup

instance Rat: AddCommGroup

attributes Rat {
    define lt(self, other: Rat) -> Bool {
        (other - self).is_positive
    }

    define lte(self, other: Rat) -> Bool {
        self < other or self = other
    }

    define gt(self, other: Rat) -> Bool {
        other < self
    }

    define gte(self, other: Rat) -> Bool {
        other <= self
    }
}

theorem sub_self(a: Rat) {
    a - a = Rat.0
}

theorem reduce_self(n: Int) {
    n != Int.0 implies reduce(n, n) = Rat.1
} by {
    Rat.1 = Rat.new(Int.1, Int.1)
    cross_equals(Int.1, Int.1, n, n)
    reduce(n, n) = Rat.1
}

theorem mul_inv_cancels_right(a: Rat) {
    a != Rat.0 implies a * a.reciprocal = Rat.1
} by {
    a * a.reciprocal = reduce(a.num * a.denom, a.denom * a.num)
    a * a.reciprocal = reduce(a.num * a.denom, a.num * a.denom)
    a.num * a.denom != Int.0
    a * a.reciprocal = Rat.1
}

theorem mul_inv_cancels_left(a: Rat) {
    a != Rat.0 implies a.reciprocal * a = Rat.1
}

theorem sub_zero(a: Rat) {
    a - Rat.0 = a
}

theorem pos_imp_zero_lt(a: Rat) {
    a.is_positive implies Rat.0 < a
} by {
    (a - Rat.0).is_positive
}

theorem zero_lt_imp_pos(a: Rat) {
    Rat.0 < a implies a.is_positive
} by {
    a - Rat.0 = a
    a.is_positive
}

theorem not_pos_and_neg(a: Rat) {
    a.is_positive implies not a.is_negative
}

theorem reduce_pos_pos(a: Int, b: Int) {
    a.is_positive and b.is_positive implies reduce(a, b).is_positive
} by {
    b != Int.0
    let d: Int satisfy {
        reduce(a, b).num * d = a and reduce(a, b).denom * d = b
    }
    reduce(a, b).denom.is_positive
    d.is_positive
}

theorem add_pos_pos(a: Rat, b: Rat) {
    a.is_positive and b.is_positive implies (a + b).is_positive
} by {
    a + b = reduce(a.num * b.denom + b.num * a.denom, a.denom * b.denom)
    (a.num * b.denom).is_positive
    (b.num * a.denom).is_positive
    (a.num * b.denom + b.num * a.denom).is_positive
    (a.denom * b.denom).is_positive
}

theorem mul_pos_pos(a: Rat, b: Rat) {
    a.is_positive and b.is_positive implies (a * b).is_positive
} by {
    a * b = reduce(a.num * b.num, a.denom * b.denom)
    (a.num * b.num).is_positive
    (a.denom * b.denom).is_positive
}

theorem pos_reciprocal(a: Rat) {
    a.is_positive implies a.reciprocal.is_positive
} by {
    a.reciprocal = reduce(a.denom, a.num)
    a.denom.is_positive
    a.num.is_positive
}

theorem add_cancels_sub(a: Rat, b: Rat) {
    a - b + b = a
} by {
    a + (-b + b) = a
    a + -b + b = a
}

theorem lt_trans(a: Rat, b: Rat, c: Rat) {
    a < b and b < c implies a < c
} by {
    (b - a).is_positive
    (c - b).is_positive
    (c - b) + (b - a) = (c - b) + b - a
    (c - b) + (b - a) = c - a
    (c - a).is_positive
}

theorem neg_neg_is_pos(a: Rat) {
    a.is_negative implies (-a).is_positive
}

theorem neg_pos_is_neg(a: Rat) {
    a.is_positive implies (-a).is_negative
}

theorem zero_minus(a: Rat) {
    Rat.0 - a = -a
}

theorem neg_imp_lt_zero(a: Rat) {
    a.is_negative implies a < Rat.0
} by {
    (-a).is_positive
    (Rat.0 - a).is_positive
}

theorem lt_zero_imp_neg(a: Rat) {
    a < Rat.0 implies a.is_negative
} by {
    (Rat.0 - a).is_positive
    (-a).is_positive
}

theorem mul_cancels_div(a: Rat, b: Rat) {
    b != Rat.0 implies (a / b) * b = a
} by {
    (a / b) * b = a * b.reciprocal * b
    (a / b) * b = a * (b.reciprocal * b)
    (a / b) * b = a * Rat.1
    (a / b) * b = a
}

theorem two_neq_zero {
    Rat.2 != Rat.0
}

theorem times_two(r: Rat) {
    Rat.2 * r = r + r
} by {
    // Simplify left
    Rat.2 * r = reduce(Int.2 * r.num, Int.1 * r.denom)
    Rat.2 * r = reduce(r.num + r.num, r.denom)

    // Simplify right
    r + r = reduce(r.num + r.num, r.denom)
}

theorem mul_cancels_right(a: Rat, b: Rat, c: Rat) {
    c != Rat.0 and a * c = b * c implies a = b
} by {
    a * c * c.reciprocal = b * c * c.reciprocal
    a * (c * c.reciprocal) = b * (c * c.reciprocal)
    a * Rat.1 = b * Rat.1
    a = b
}

theorem half_plus_half(r: Rat) {
    (r / Rat.2) + (r / Rat.2) = r
} by {
    (r / Rat.2) * Rat.2 = r
    (r / Rat.2 + r / Rat.2) * Rat.2 = r + r
    (r / Rat.2 + r / Rat.2) * Rat.2 = r * Rat.2
    r / Rat.2 + r / Rat.2 = r
}

theorem neg_mul(a: Rat, b: Rat) {
    (-a) * b = -(a * b)
}

theorem mul_neg_pos(a: Rat, b: Rat) {
    a.is_negative and b.is_positive implies (a * b).is_negative
} by {
    (-a).is_positive
    (-a * b).is_positive
    (-(a * b)).is_positive
    (a * b).is_negative
}

theorem mul_pos_neg(a: Rat, b: Rat) {
    a.is_positive and b.is_negative implies (a * b).is_negative
}

theorem mul_neg_neg(a: Rat, b: Rat) {
    a.is_negative and b.is_negative implies (a * b).is_positive
} by {
    (-b).is_positive
    (-b * a).is_negative
}

theorem one_is_pos {
    Rat.1.is_positive
}

theorem two_is_pos {
    Rat.2.is_positive
}

theorem half_is_pos {
    Rat.2.reciprocal.is_positive
}

theorem sub_add_quasi_cancel(a: Rat, b: Rat) {
    a - (a + b) = -b
} by {
    a - (a + b) = a + -Rat.1 * (a + b)
    a - (a + b) = a + (-Rat.1 * a + -Rat.1 * b)
    a - (a + b) = a + (-a + -b)
    a - (a + b) = a + -a + -b
    a - (a + b) = Rat.0 + -b
    a - (a + b) = -b
}

theorem not_lt_self(a: Rat) {
    not a < a
}

theorem not_lt_both_ways(a: Rat, b: Rat) {
    a < b implies not b < a
}

theorem lt_add_pos(a: Rat, b: Rat) {
    b.is_positive implies a < a + b
} by {
    (a + b) - a = (a + b) + -a
    (a + b) - a = -a + (a + b)
    (a + b) - a = (-a + a) + b
    (a + b) - a = Rat.0 + b
    (a + b) - a = b
}

attributes Rat {
    define abs(self) -> Rat {
        if self.is_negative {
            -self
        } else {
            self
        }
    }
}

theorem neg_sub(a: Rat, b: Rat) {
    -(a - b) = b - a
} by {
    -(a - b) = -(a + -b)
    -(a - b) = -a + --b
    -(a - b) = -a + b
    -(a - b) = b + -a
}

theorem single_trichotomy(a: Rat) {
    a.is_positive or a.is_negative or a = Rat.0
} by {
    if a.num.is_positive {
        a.is_positive
    } else {
        if a.num.is_negative {
            a.is_negative
        } else {
            a.num = Int.0
            a = Rat.0
        }
    }
}

theorem trichotomy(a: Rat, b: Rat) {
    a < b or a = b or a > b
} by {
    if (a - b).is_positive {
        a > b
    } else {
        if (a - b).is_negative {
            (-(a - b)).is_positive
            (b - a).is_positive
            a < b
        } else {
            a = b
        }
    }
}

theorem lt_add_right(a: Rat, b: Rat, c: Rat) {
    a < b implies a + c < b + c
} by {
    (b - a).is_positive
    (b + c) - (a + c) = (b + c) + (-a + -c)
    (b + c) - (a + c) = b + c + (-c + -a)
    (b + c) - (a + c) = b + (c + -c) + -a
    (b + c) - (a + c) = b + -a
    ((b + c) - (a + c)).is_positive
}

theorem add_neg_lt(a: Rat, b: Rat) {
    a.is_negative implies b + a < b
}

theorem adding_lts(a: Rat, b: Rat, c: Rat, d: Rat) {
    a < b and c < d implies a + c < b + d
} by {
    a + c < b + c
    b + c < b + d
}

theorem minus_cancels_plus(a: Rat, b: Rat) {
    a + b - b = a
} by {
    a + b - b = a + b + -b
    a + b - b = a + (b + -b)
    a + b - b = a + Rat.0
    a + b - b = a
}

theorem gt_minus_pos(a: Rat, b: Rat) {
    b.is_positive implies a > a - b
} by {
    a - (a - b) = b
    (a - (a - b)).is_positive
}

theorem sub_add(a: Rat, b: Rat, c: Rat) {
    a - (b + c) = a - b - c
} by {
    a - (b + c) = a + -(b + c)
    a - (b + c) = a + (-b + -c)
    a - (b + c) = a + -b + -c
    a - (b + c) = a - b - c
}

theorem no_greatest(a: Rat) {
    exists(b: Rat) {
        a < b
    }
}

theorem sub_from_int(a: Int, b: Int) {
    Rat.from_int(a) - Rat.from_int(b) = Rat.from_int(a - b)
} by {
    Rat.from_int(a) - Rat.from_int(b) = Rat.from_int(a) + -Rat.from_int(b)
    Rat.from_int(a) - Rat.from_int(b) = Rat.from_int(a) + Rat.from_int(-b)
    Rat.from_int(a) - Rat.from_int(b) = Rat.from_int(a + -b)
    Rat.from_int(a) - Rat.from_int(b) = Rat.from_int(a - b)
}

theorem lt_from_int(a: Int, b: Int) {
    a < b implies Rat.from_int(a) < Rat.from_int(b)
} by {
    Rat.from_int(b) - Rat.from_int(a) = Rat.from_int(b - a)
}

theorem lte_from_int(a: Int, b: Int) {
    a <= b implies Rat.from_int(a) <= Rat.from_int(b)
}

theorem gt_from_int(a: Int, b: Int) {
    a > b implies Rat.from_int(a) > Rat.from_int(b)
}

theorem gte_from_int(a: Int, b: Int) {
    a >= b implies Rat.from_int(a) >= Rat.from_int(b)
}

theorem lt_mul_pos(a: Rat, b: Rat, c: Rat) {
    a < b and c.is_positive implies a * c < b * c
} by {
    b - a > Rat.0
    c > Rat.0
    (b - a) * c > Rat.0
    b * c - a * c > Rat.0
    a * c < b * c
}

theorem lte_mul_pos(a: Rat, b: Rat, c: Rat) {
    a <= b and c.is_positive implies a * c <= b * c
} by {
    a < b or a = b
    a * c < b * c or a * c = b * c
}

theorem lt_div_pos(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a < b implies a / c < b / c
} by {
    c.reciprocal.is_positive
    a * c.reciprocal < b * c.reciprocal
}

theorem lte_div_pos(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a <= b implies a / c <= b / c
} by {
    c.reciprocal.is_positive
    a * c.reciprocal <= b * c.reciprocal
}

theorem mul_div_cancels(a: Rat, b: Rat) {
    b != Rat.0 implies (a * b) / b = a
} by {
    (a * b) / b = a * (b / b)
    (a * b) / b = a * Rat.1
}

theorem div_from_int(a: Rat) {
    Rat.from_int(a.num) / Rat.from_int(a.denom) = a
} by {
    Rat.from_int(a.num) / Rat.from_int(a.denom) = reduce(a.num, Int.1) * reduce(Int.1, a.denom)
}

theorem lt_from_int_mul_denom(a: Rat, n: Int) {
    a.num < n * a.denom implies a < Rat.from_int(n)
} by {
    Rat.from_int(a.num) < Rat.from_int(n * a.denom)
    Rat.from_int(a.num) < Rat.from_int(n) * Rat.from_int(a.denom)
    Rat.from_int(a.denom).is_positive
    Rat.from_int(a.num) / Rat.from_int(a.denom) < Rat.from_int(n) * Rat.from_int(a.denom) / Rat.from_int(a.denom)
    Rat.from_int(n) * Rat.from_int(a.denom) / Rat.from_int(a.denom) = Rat.from_int(n)
    Rat.from_int(a.num) / Rat.from_int(a.denom) < Rat.from_int(n)
}

theorem lte_from_int_mul_denom(a: Rat, n: Int) {
    a.num <= n * a.denom implies a <= Rat.from_int(n)
} by {
    if a.num = n * a.denom {
        a = Rat.from_int(n)
    } else {
        a < Rat.from_int(n)
    }
}

theorem floor_exists(a: Rat) {
    exists(q: Int) {
        Rat.from_int(q) <= a and a < Rat.from_int(q + Int.1)
    }
} by {
    a.denom.is_positive
    let (q: Int, r: Int) satisfy {
        Int.0 <= r and r < a.denom and a.num = q * a.denom + r
    }

    // Left bound
    Rat.from_int(a.num) = Rat.from_int(q * a.denom + r)
    Rat.from_int(a.num) = Rat.from_int(q * a.denom) + Rat.from_int(r)
    Rat.from_int(r) >= Rat.from_int(Int.0)
    forall(x0: Int) { x0 + Int.0 <= x0 + r }
    Rat.from_int(q * a.denom) + Rat.from_int(r) >= Rat.from_int(q * a.denom) + Rat.from_int(Int.0)
    Rat.from_int(a.num) >= Rat.from_int(q * a.denom)
    Rat.from_int(a.num) >= Rat.from_int(q) * Rat.from_int(a.denom)
    Rat.from_int(a.denom).is_positive
    Rat.from_int(q) * Rat.from_int(a.denom) / Rat.from_int(a.denom) <= Rat.from_int(a.num) / Rat.from_int(a.denom)
    Rat.from_int(q) * Rat.from_int(a.denom) / Rat.from_int(a.denom) = Rat.from_int(q)
    Rat.from_int(q) <= Rat.from_int(a.num) / Rat.from_int(a.denom)
    Rat.from_int(q) <= a

    // Right bound
    q * a.denom + r < q * a.denom + a.denom
    q * a.denom + a.denom = (q + Int.1) * a.denom
    a.num < (q + Int.1) * a.denom
    a < Rat.from_int(q + Int.1)
}

let floor(a: Rat) -> q: Int satisfy {
    Rat.from_int(q) <= a and a < Rat.from_int(q + Int.1)
}

theorem mul_lt_lt(a: Rat, b: Rat, c: Rat, d: Rat) {
    a.is_positive and c.is_positive and a < b and c < d implies a * c < b * d
} by {
    a * c < b * c
    b.is_positive
    b * c < b * d
}

theorem mul_lt_lte(a: Rat, b: Rat, c: Rat, d: Rat) {
    a.is_positive and c.is_positive and a < b and c <= d implies a * c < b * d
} by {
    a * c < b * c
    b.is_positive
    b * c <= b * d
}

theorem pos_lte(a: Rat, b: Rat) {
    a.is_positive and a <= b implies b.is_positive
} by {
    if a = b {
        b.is_positive
    } else {
        a < b
        b.is_positive
    }
}

theorem mul_lte_lt(a: Rat, b: Rat, c: Rat, d: Rat) {
    a.is_positive and c.is_positive and a <= b and c < d implies a * c < b * d
} by {
    a * c <= b * c
    b.is_positive
    b * c < b * d
}

theorem lt_pos_reciprocal(a: Rat, b: Rat) {
    a.is_positive and a < b implies b.reciprocal < a.reciprocal
} by {
    if a.reciprocal <= b.reciprocal {
        a.reciprocal * a < b.reciprocal * b
        a.reciprocal * a = Rat.1
        b.reciprocal * b = Rat.1
        Rat.1 < Rat.1
        false
    }
}

theorem reciprocal_inverts(a: Rat) {
    a != Rat.0 implies a.reciprocal.reciprocal = a
} by {
    a * a.reciprocal = Rat.1
    Rat.new(a.reciprocal.num, a.reciprocal.denom) / a * a = Rat.new(a.reciprocal.num, a.reciprocal.denom)
    a.reciprocal != Rat.0
    a * a.reciprocal / a.reciprocal = a
    Rat.1 * a.reciprocal.reciprocal = a
}

theorem smaller_int_reciprocal(a: Rat) {
    a.is_positive implies exists(n: Int) {
        n.is_positive and Rat.from_int(n).reciprocal < a
    }
} by {
    a.reciprocal.is_positive
    let n: Int satisfy {
        a.reciprocal < Rat.from_int(n)
    }
    Rat.from_int(n).reciprocal < a.reciprocal.reciprocal
    a.reciprocal.reciprocal = a
    Rat.from_int(n).is_positive
    n.is_positive
}

theorem gte_some_int(a: Rat) {
    exists(n: Int) {
        a >= Rat.from_int(n)
    }
} by {
    a >= Rat.from_int(floor(a))
}

theorem mul_denom(r: Rat) {
    r * Rat.from_int(r.denom) = Rat.from_int(r.num)
} by {
    Rat.from_int(r.denom).num != Int.0
    Rat.from_int(r.denom) != Rat.0
    Rat.from_int(r.num) / Rat.from_int(r.denom) * Rat.from_int(r.denom) = Rat.from_int(r.num)
}

theorem half_pos(r: Rat) {
    r.is_positive implies (r / Rat.2).is_positive
}

theorem add_half_half(r: Rat) {
    (r / Rat.2) + (r / Rat.2) = r
} by {
    (r / Rat.2) + (r / Rat.2) = r / Rat.2 + r / Rat.2
    (r / Rat.2) + (r / Rat.2) = (r + r) / Rat.2
    (r / Rat.2) + (r / Rat.2) = (Rat.2 * r) / Rat.2
    (r / Rat.2) + (r / Rat.2) = r
}

theorem lt_neg(p: Rat, q: Rat) {
    p < q implies -q < -p
} by {
    (q - p).is_positive
    (-p - -q).is_positive
}

theorem lt_lte_trans(a: Rat, b: Rat, c: Rat) {
    a < b and b <= c implies a < c
} by {
    if b = c {
        a < c
    } else {
        b < c
        a < c
    }
}

theorem lte_lt_trans(a: Rat, b: Rat, c: Rat) {
    a <= b and b < c implies a < c
} by {
    if a = b {
        a < c
    } else {
        a < b
        a < c
    }
}

theorem lt_imp_rat_between(a: Rat, b: Rat) {
    a < b implies exists(c: Rat) {
        a < c and c < b
    }
} by {
    a / Rat.2 < b / Rat.2
    a < (a + b) * Rat.2.reciprocal
    (a + b) * Rat.2.reciprocal < b
}

theorem gt_imp_rat_between(a: Rat, b: Rat) {
    a > b implies exists(c: Rat) {
        a > c and c > b
    }
} by {
    b < a
    let c: Rat satisfy {
        b < c and c < a
    }
    a > c
    c > b
}

theorem lt_cancel_pos_mul_right(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a * c < b * c implies a < b
} by {
    not b * c < a * c
    b != a
    b > a
}

theorem lt_cancel_pos_mul_left(a: Rat, b: Rat, c: Rat) {
    c.is_positive and c * a < c * b implies a < b
} by {
    not c * b < c * a
    b != a
    b > a
}

theorem gt_cancel_pos_mul_right(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a * c > b * c implies a > b
} by {
    not b * c > a * c
    b != a
    b < a
}

theorem gt_cancel_pos_mul_left(a: Rat, b: Rat, c: Rat) {
    c.is_positive and c * a > c * b implies a > b
} by {
    not c * b > c * a
    b != a
    b < a
}

theorem cancel_positivity_left(a: Rat, b: Rat) {
    a.is_positive and (a * b).is_positive implies b.is_positive
} by {
    if b.is_negative {
        (a * b).is_negative
        false
    }
}

theorem cancel_positivity_right(a: Rat, b: Rat) {
    b.is_positive and (a * b).is_positive implies a.is_positive
}

theorem mul_cancels_div_left(a: Rat, b: Rat) {
    b != Rat.0 implies b * (a / b) = a
}

theorem lte_trans(a: Rat, b: Rat, c: Rat) {
    a <= b and b <= c implies a <= c
} by {
    if not a <= c {
        not c < b
        not a < c
        not c > a
        c != a
        false
    }
}

theorem neg_abs(a: Rat) {
    (-a).abs = a.abs
} by {
    if a.is_negative {
        a.abs = -a
        (-a).abs = -a
        (-a).abs = a.abs
    } else {
        if a = Rat.0 {
            (-a).abs = a.abs
        } else {
            a.is_positive
            a.abs = a
            (-a).is_negative
            (-a).abs = a
            (-a).abs = a.abs
        }
    }
}

theorem abs_non_pos(a: Rat) {
    not a.is_positive implies a.abs = -a
}

theorem abs_non_neg(a: Rat) {
    not a.is_negative implies a.abs = a
}

theorem abs_mul_abs(a: Rat, b: Rat) {
    (a * b).abs = (a * b.abs).abs
} by {
    if b.is_positive {
        b.abs = b
        (a * b).abs = (a * b.abs).abs
    } else {
        b.abs = -b
        (a * b.abs) = a * -b
        (a * b.abs) = -(a * b)
        (a * b.abs).abs = (a * b).abs
    }
}

theorem mul_non_neg(a: Rat, b: Rat) {
    not a.is_negative and not b.is_negative implies not (a * b).is_negative
} by {
    if a = Rat.0 {
        not (a * b).is_negative
    } else {
        if b = Rat.0 {
            not (a * b).is_negative
        } else {
            a.is_positive
            b.is_positive
            (a * b).is_positive
            not (a * b).is_negative
        }
    }
}

theorem mul_two_abs(a: Rat, b: Rat) {
    a.abs * b.abs = (a * b).abs
} by {
    (a * b).abs = (a.abs * b.abs).abs
    not a.abs.is_negative
    not b.abs.is_negative
    not (a.abs * b.abs).is_negative
    (a.abs * b.abs).abs = a.abs * b.abs
}

theorem abs_zero_imp_zero(a: Rat) {
    a.abs = Rat.0 implies a = Rat.0
} by {
    if a != Rat.0 {
        a.abs != a
        a.is_negative
        a.abs = -a
        a + Rat.0 != Rat.0
        a + a.abs != Rat.0
        false
    }
}

theorem zero_lte_abs(a: Rat) {
    Rat.0 <= a.abs
} by {
    if a = Rat.0 {
        a.abs = Rat.0
        Rat.0 <= a.abs
    } else {
        a.abs != Rat.0
        a.abs.is_positive
        Rat.0 <= a.abs
    }
}

theorem pos_inverses_lt(p: Rat, q: Rat, r: Rat) {
    p.is_positive and q.is_positive and r.is_positive
    and r / p < r / q
    implies
    q < p
} by {
    r / p * p < r / q * p
    r / p * p = r
    r < r / q * p
    r * q < p * r / q * q
    (p * r) / q * q = p * r
    r * q < p * r
    q * r < p * r
}

theorem inverses_eq(p: Rat, q: Rat, r: Rat) {
    p != Rat.0 and q != Rat.0 and r != Rat.0
    and r / p = r / q
    implies
    q = p
} by {
    r / p * p = r / q * p
    r = r / q * p
    r = p * r / q
    r * q = p * r / q * q
    r * q = p * r
    q * r = p * r
}

theorem pos_inverses_lte(p: Rat, q: Rat, r: Rat) {
    p.is_positive and q.is_positive and r.is_positive
    and r / p <= r / q
    implies
    q <= p
} by {
    if r / p = r / q {
        p != Rat.0
        q != Rat.0
        q = p
        q <= p
    } else {
        q < p
        q <= p
    }
}

theorem pos_inverses_gt(p: Rat, q: Rat, r: Rat) {
    p.is_positive and q.is_positive and r.is_positive
    and r / p > r / q
    implies
    q > p
}

theorem pos_inverses_gte(p: Rat, q: Rat, r: Rat) {
    p.is_positive and q.is_positive and r.is_positive
    and r / p >= r / q
    implies
    q >= p
}

theorem lt_cancel_add_right(p: Rat, q: Rat, r: Rat) {
    p + r < q + r implies p < q
} by {
    not q + r < p + r
    q != p
    q > p
}

theorem sub_distrib(p: Rat, q: Rat, r: Rat) {
    p * (q - r) = p * q - p * r
} by {
    p * (q - r) = p * (q + -r)
    p * (q - r) = p * q + p * -r
    p * (q - r) = p * q - p * r
}

theorem half_lt_one {
    Rat.2.reciprocal < Rat.1
} by {
    (Rat.1 / Rat.2).is_positive
    Rat.2.reciprocal < Rat.2.reciprocal + Rat.1 / Rat.2
    Rat.2.reciprocal < Rat.1 / Rat.2 + Rat.1 / Rat.2
}

theorem lower_squared(a: Rat) {
    a.is_positive
    implies
    exists(eps: Rat) {
        eps.is_positive and eps * eps < a
    }
} by {
    if Rat.1 <= a {
        let eps: Rat = Rat.2.reciprocal
        eps.is_positive
        eps < Rat.1
        eps * eps < Rat.1
        eps.is_positive and eps * eps < a
    } else {
        a < Rat.1
        let eps: Rat = a * a
        eps.is_positive
        eps.is_positive and eps * eps < a
    }
}

theorem square_lt_imp_lt(a: Rat, b: Rat) {
    a.is_positive and b.is_positive and a * a < b * b
    implies
    a < b
} by {
    if a >= b {
        false
    }
}

theorem smaller_positive(a: Rat) {
    a.is_positive implies
    exists(r: Rat) {
        r.is_positive and r < a
    }
}

theorem lt_both_pos(a: Rat, b: Rat) {
    a.is_positive and b.is_positive implies
    exists(r: Rat) {
        r.is_positive and r < a and r < b
    }
} by {
    if a < b {
        let r: Rat satisfy {
            r.is_positive and r < a
        }
        r.is_positive and r < a and r < b
    } else {
        let r: Rat satisfy {
            r.is_positive and r < b
        }
        r.is_positive and r < a and r < b
    }
}

theorem lt_rhs_div_pos(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a < b / c implies a * c < b
} by {
    a * c < b / c * c
    b / c * c = b
}

attributes Rat {
    define is_close(self, other: Rat, eps: Rat) -> Bool {
        (self - other).abs < eps
    }
}

theorem lte_abs(q: Rat) {
    q <= q.abs
}

theorem close_comm(a: Rat, b: Rat, eps: Rat) {
    a.is_close(b, eps) implies b.is_close(a, eps)
} by {
    a - b = -(b - a)
    (a - b).abs = (b - a).abs
    (a - b).abs < eps
    (b - a).abs < eps
}

theorem close_imp_bounds(a: Rat, b: Rat, eps: Rat) {
    a.is_close(b, eps) implies a < b + eps and a > b - eps
} by {
    // Left ineq
    (a - b).abs < eps
    a - b <= (a - b).abs
    a - b < eps
    a - b + b < eps + b
    a < eps + b
    a < b + eps

    // Right ineq
    (b - a).abs < eps
    b - a <= (b - a).abs
    b - a < eps
    b - a + a < eps + a
    b - a + a = b
    b < eps + a
    eps + a > b
    a + eps > b
    a + eps + -eps > b + -eps
    a > b + -eps
}

theorem bounds_imp_close(a: Rat, b: Rat, eps: Rat) {
    a < b + eps and a > b - eps implies a.is_close(b, eps)
} by {
    if (a - b).is_negative {
        (a - b).abs = b - a
        a > b + -eps
        a + eps + -eps > b + -eps
        a + eps > b
        eps + a > b
        b < eps + a
        b - a + a = b
        b - a + a < eps + a
        b - a < eps
        (a - b).abs < eps
        a.is_close(b, eps)
    } else {
        (a - b).abs = a - b
        a < eps + b
        a - b + b < eps + b
        a - b < eps
        a - b < eps
        (a - b).abs < eps
        a.is_close(b, eps)
    }
}

attributes Rat {
    let from_nat: Nat -> Rat = function(n: Nat) {
        Rat.from_int(Int.from_nat(n))
    }
}

theorem nat_lt_imp_rat_lt(a: Nat, b: Nat) {
    a < b implies Rat.from_nat(a) < Rat.from_nat(b)
} by {
    Rat.from_nat(a) < Rat.from_nat(b)
}

theorem from_nat_nonneg(n: Nat) {
    Rat.0 <= Rat.from_nat(n)
} by {
    if n = Nat.0 {
        Rat.from_nat(n) = Rat.0
        Rat.0 <= Rat.from_nat(n)
    } else {
        Nat.0 < n
        Rat.from_nat(Nat.0) < Rat.from_nat(n)
        Rat.0 < Rat.from_nat(n)
        Rat.0 <= Rat.from_nat(n)
    }
}

theorem recip_eq_one_div(a: Rat) {
    a != Rat.0 implies a.reciprocal = Rat.1 / a
}

// It will be convenient to have a particular function that
// approaches zero.
define iop(n: Nat) -> Rat {
    Rat.1 / (Rat.1 + Rat.from_nat(n))
}

theorem iop_pos(n: Nat) {
    iop(n).is_positive
} by {
    Rat.0 <= Rat.from_nat(n)
    Rat.1 + Rat.0 <= Rat.1 + Rat.from_nat(n)
    Rat.0 < Rat.1 + Rat.from_nat(n)
    (Rat.1 + Rat.from_nat(n)).is_positive
    Rat.1.is_positive
}

theorem pos_ne_zero(a: Rat) {
    a.is_positive implies a != Rat.0
}

theorem iop_ne_zero(n: Nat) {
    iop(n) != Rat.0
}

theorem iop_recip(n: Nat) {
    iop(n).reciprocal = Rat.1 + Rat.from_nat(n)
} by {
    Rat.1.is_positive
    Rat.from_nat(n) >= Rat.0
    Rat.0 <= Rat.from_nat(n)
    (Rat.1 + Rat.from_nat(n)).is_positive 
    (Rat.1 + Rat.from_nat(n)) != Rat.0
    (Rat.1 + Rat.from_nat(n)).reciprocal = iop(n)
}

theorem iop_mul_lt_one(n: Nat) {
    iop(n) * Rat.from_nat(n) < Rat.1
} by {
    iop(n) * iop(n).reciprocal = Rat.1
    iop(n) * (Rat.1 + Rat.from_nat(n)) = Rat.1
    iop(n) * Rat.1 + iop(n) * Rat.from_nat(n) = Rat.1
    iop(n) + iop(n) * Rat.from_nat(n) = Rat.1
    iop(n) * Rat.from_nat(n) < iop(n) * Rat.from_nat(n) + iop(n)
}

theorem pos_lte_num(a: Rat) {
    a.is_positive implies a <= Rat.from_int(a.num)
} by {
    a.num.is_positive
    a.num <= a.denom * a.num
    a.num <= a.num * a.denom
}

theorem lt_some_int(a: Rat) {
    exists(n: Int) {
        a < Rat.from_int(n)
    }
}

theorem lt_some_nat(a: Rat) {
    exists(n: Nat) {
        a < Rat.from_nat(n)
    }
} by {
    let i: Int satisfy {
        a < Rat.from_int(i)
    }
    let n = int.abs(i)
    i <= Int.from_nat(n)
    Rat.from_int(i) <= Rat.from_nat(n)
}

theorem iop_gets_lt(eps: Rat) {
    eps.is_positive implies exists(n: Nat) {
        forall(i: Nat) {
            n <= i implies iop(i) < eps
        }
    }
} by {
    eps.reciprocal.is_positive
    let n: Nat satisfy {
        eps.reciprocal < Rat.from_nat(n)
    }
    forall(i: Nat) {
        if n <= i {
            Rat.from_nat(n) <= Rat.from_nat(i)
            eps.reciprocal < Rat.from_nat(i)
            eps.reciprocal * eps < Rat.from_nat(i) * eps
            Rat.1 < Rat.from_nat(i) * eps
            Rat.from_nat(i) * iop(i) < Rat.1
            Rat.from_nat(i) * iop(i) < Rat.from_nat(i) * eps
            iop(i) < eps
        }
    }
}

theorem three_is_positive {
    Rat.3.is_positive
}

theorem times_three(x: Rat) {
    Rat.3 * x = x + x + x
} by {
    Int.3 = Int.2 + Int.1
    Rat.3 = Rat.2 + Rat.1
    Rat.3 * x = (Rat.2 + Rat.1) * x
    Rat.3 * x = Rat.2 * x + Rat.1 * x
}

theorem three_thirds(x: Rat) {
    (x / Rat.3) + (x / Rat.3) + (x / Rat.3) = x
} by {
    (x / Rat.3) + (x / Rat.3) + (x / Rat.3) = x / Rat.3 + x / Rat.3 + x / Rat.3
    (x / Rat.3) + (x / Rat.3) + (x / Rat.3) = (x + x + x) / Rat.3
    (x / Rat.3) + (x / Rat.3) + (x / Rat.3) = (Rat.3 * x) / Rat.3
    Rat.3 != Rat.0
    x * Rat.3 / Rat.3 = x
    (x / Rat.3) + (x / Rat.3) + (x / Rat.3) = x
}

theorem some_mul_lt(a: Rat, b: Rat) {
    Rat.0 <= a and b.is_positive implies
    exists(eps: Rat) {
        eps.is_positive and a * eps < b
    }
} by {
    if a = Rat.0 {
        let eps = b
        eps.is_positive
        a * eps = Rat.0
        a * eps < b
        eps.is_positive and a * eps < b
    } else {
        a.is_positive
        let c: Rat satisfy {
            c.is_positive and c < b
        }
        let eps = c / a
        eps.is_positive
        a * eps = c
        a * eps < b
        eps.is_positive and a * eps < b
    }
}

theorem close_mul_pos(a: Rat, b: Rat, eps: Rat, r: Rat) {
    r.is_positive and a.is_close(b, eps)
    implies
    (a * r).is_close(b * r, eps * r)
} by {
    a < b + eps
    a * r < (b * r) + (eps * r)
    b < a + eps
    b * r < a * r + (eps * r)
    b - eps < a
    r * (b - eps) < a * r
}

theorem close_neg(a: Rat, b: Rat, eps: Rat) {
    a.is_close(b, eps) implies (-a).is_close(-b, eps)
} by {
    (a - b).abs < eps
    (-a - -b).abs = (b - a).abs
    (-a - -b).abs < eps
}

theorem lte_mul_nonneg(a: Rat, b: Rat, c: Rat) {
    a <= b and Rat.0 <= c implies a * c <= b * c
} by {
    if c = Rat.0 {
        a * c = Rat.0
        b * c = Rat.0
        a * c <= b * c
    } else {
        c.is_positive
        a * c <= b * c
    }
}

theorem bounding_both(a: Rat, b: Rat) {
    exists(c: Rat) {
        a < c and b < c
    }
} by {
    if not exists(k0: Rat) { a < k0 and b < k0 } {
        not b < a
        not a <= b
        b != a
        not a < b
        false
    }
}

theorem finite_seq_abs_bounded(a: Nat -> Rat, n: Nat) {
    exists(bound: Rat) {
        forall(i: Nat) {
            i <= n implies a(i).abs < bound
        }
    }
} by {
    let f = finite_seq_abs_bounded(a)
    let zero_bound: Rat satisfy {
        a(Nat.0).abs < zero_bound
    }
    forall(i: Nat) {
        i <= Nat.0 implies a(i).abs < zero_bound
    }
    finite_seq_abs_bounded(a, Nat.0)
    f(Nat.0)
    forall(k: Nat) {
        if f(k) {
            let base_bound: Rat satisfy {
                forall(i: Nat) {
                    i <= k implies a(i).abs < base_bound
                }
            }
            let extra_bound: Rat satisfy {
                a(k.suc).abs < extra_bound
            }
            let bound: Rat satisfy {
                base_bound < bound and extra_bound < bound
            }
            forall(i: Nat) {
                if i <= k.suc {
                    if i <= k {
                        a(i).abs < bound
                    } else {
                        i = k.suc
                        a(i).abs < extra_bound
                        a(i).abs < bound
                    }
                }
            }
            finite_seq_abs_bounded(a, k.suc)
            f(k.suc)
        }
    }
}

theorem abs_reduce_left(a: Int, b: Int) {
    reduce(a.abs, b).abs = reduce(a, b).abs
} by {
    if a.is_negative {
        a.abs = -a
        reduce(a.abs, b).abs = reduce(a, b).abs
    } else {
        a.abs = a
        reduce(a.abs, b).abs = reduce(a, b).abs
    }
}

theorem reduce_neg_num(a: Int, b: Int) {
    reduce(-a, b) = -reduce(a, b)
}

theorem reduce_neg_denom(a: Int, b: Int) {
    reduce(a, -b) = -reduce(a, b)
} by {
    reduce(a, -b) = reduce(-Int.1 * a, -Int.1 * -b)
    -Int.1 * -b = b
}

theorem abs_reduce_right(a: Int, b: Int) {
    reduce(a, b.abs).abs = reduce(a, b).abs
} by {
    if b.is_negative {
        b.abs = -b
        reduce(a, b.abs).abs = reduce(a, b).abs
    } else {
        b.abs = b
        reduce(a, b.abs).abs = reduce(a, b).abs
    }
}

theorem reduce_nonneg(a: Int, b: Int) {
    not a.is_negative and not b.is_negative
    implies
    not reduce(a, b).is_negative
} by {
    if a = Int.0 {
        not reduce(a, b).is_negative
    } else {
        if b = Int.0 {
            not reduce(a, b).is_negative
        } else {
            a.is_positive
            b.is_positive
            reduce(a, b).is_positive
            not reduce(a, b).is_negative
        }
    }
}

theorem reduce_abs(a: Int, b: Int) {
    reduce(a.abs, b.abs) = reduce(a, b).abs
} by {
    not a.abs.is_negative
    not b.abs.is_negative
    not reduce(a.abs, b.abs).is_negative
}

theorem lte_cancel_mul_pos(p: Rat, q: Rat, r: Rat) {
    r.is_positive and p * r <= q * r
    implies
    p <= q
} by {
    if p * r = q * r {
        p = q
        p <= q
    } else {
        p * r < q * r
        p < q
        p <= q
    }
}

theorem reduce_lte(a: Int, b: Int, c: Int) {
    not c.is_negative and a <= b implies
    reduce(a, c) <= reduce(b, c)
} by {
    if c = Int.0 {
        reduce(a, c) = reduce(b, c)
        reduce(a, c) <= reduce(b, c)
    } else {
        c.is_positive
        reduce(a, c) * Rat.from_int(c) = Rat.from_int(a)
        reduce(b, c) * Rat.from_int(c) = Rat.from_int(b)
        Rat.from_int(a) <= Rat.from_int(b)
        reduce(a, c) * Rat.from_int(c) <= reduce(b, c) * Rat.from_int(c)
        Rat.from_int(c).is_positive
        reduce(a, c) <= reduce(b, c)
    }
}

theorem triangle_ineq(a: Rat, b: Rat) {
    (a + b).abs <= a.abs + b.abs
} by {
    let (an: Int, bn: Int, c: Int) satisfy {
        a = reduce(an, c) and b = reduce(bn, c)
    }
    a + b = reduce(an + bn, c)
    (a + b).abs = reduce((an + bn).abs, c.abs)
    (an + bn).abs <= an.abs + bn.abs
    Int.from_nat(int.abs(c.abs)) = c.abs
    not c.abs.is_negative
    reduce((an + bn).abs, c.abs) <= reduce(an.abs + bn.abs, c.abs)
    (a + b).abs <= reduce(an.abs + bn.abs, c.abs)
    reduce(an.abs + bn.abs, c.abs) = reduce(an, c).abs + reduce(bn, c).abs
    reduce(an.abs + bn.abs, c.abs) = a.abs + b.abs
}

// Not all that generally useful.
theorem diff_mul_bound(a0: Rat, b0: Rat, a1: Rat, b1: Rat) {
    (a0 * b0 - a1 * b1).abs <= a0.abs * (b0 - b1).abs + b1.abs * (a0 - a1).abs
} by {
    a0 * (b0 - b1) + b1 * (a0 - a1) = a0 * b0 - a0 * b1 + b1 * a0 - b1 * a1
    a0 * (b0 - b1) + b1 * (a0 - a1) = a0 * b0 - a1 * b1
    (a0 * b0 - a1 * b1).abs = (a0 * (b0 - b1) + b1 * (a0 - a1)).abs
    (a0 * (b0 - b1) + b1 * (a0 - a1)).abs <= (a0 * (b0 - b1)).abs + (b1 * (a0 - a1)).abs
}

theorem nonneg_lt_imp_pos(a: Rat, b: Rat) {
    not a.is_negative and a < b implies
    b.is_positive
}

theorem lt_pos_mul_lt_pos(a: Rat, b: Rat, c: Rat, d: Rat) {
    not a.is_negative and not c.is_negative and a < b and c < d
    implies
    a * c < b * d
} by {
    a * c <= b * c
    b.is_positive
    b * c < b * d
}

theorem abs_nonneg(a: Rat) {
    not a.abs.is_negative
}

theorem lte_mul_lte(a: Rat, b: Rat, c: Rat, d: Rat) {
    not a.is_negative and not c.is_negative and a <= b and c <= d
    implies
    a * c <= b * d
} by {
    not b.is_negative
    not d.is_negative
    if a = b {
        c * b <= d * b
        a * c <= b * d
    } else {
        a < b
        if c = d {
            a * c <= b * d
        } else {
            c < d
            a * c < b * d
            a * c <= b * d
        }
    }
}

theorem add_div_distrib(a: Rat, b: Rat, c: Rat) {
    (a + b) / c = a / c + b / c
}

theorem sub_div_distrib(a: Rat, b: Rat, c: Rat) {
    (a - b) / c = a / c - b / c
}

theorem recip_mul(a: Rat, b: Rat) {
    (a * b).reciprocal = a.reciprocal * b.reciprocal
} by {
    if a = Rat.0 {
        // Degenerate but it works
        a * b = Rat.0
        (a * b).reciprocal = Rat.0
        (a * b).reciprocal = a.reciprocal * b.reciprocal
    } else {
        if b = Rat.0 {
            (a * b).reciprocal = a.reciprocal * b.reciprocal
        } else {
            (a * b).reciprocal * (a * b) = Rat.1
            (a * b).reciprocal = a.reciprocal * b.reciprocal
        }
    }
}

theorem mul_fractions(a: Rat, b: Rat, c: Rat, d: Rat) {
    (a / b) * (c / d) = (a * c) / (b * d)
} by {
    (a / b) * (c / d) = (a * b.reciprocal) * (c * d.reciprocal)
    (a / b) * (c / d) = (a * c) * (b.reciprocal * d.reciprocal)
    (b.reciprocal * d.reciprocal) = (b * d).reciprocal
    (a / b) * (c / d) = (a * c) * (b * d).reciprocal
}

theorem cancel_left_num_denom(a: Rat, b: Rat, c: Rat) {
    a != Rat.0 implies
    (a * b) / (a * c) = b / c
} by {
    (a / a) * (b / c) = (a * b) / (a * c)
}

theorem cancel_to_reciprocal(a: Rat, b: Rat) {
    a != Rat.0 and b != Rat.0 implies
    a / (a * b) = b.reciprocal
}

theorem recip_diff(a: Rat, b: Rat) {
    a != Rat.0 and b != Rat.0 implies
    a.reciprocal - b.reciprocal = (b - a) / (a * b)
} by {
    (b - a) / (a * b) = (b / (a * b)) - (a / (a * b))
    b / (a * b) = a.reciprocal
    a / (a * b) = b.reciprocal
}
theorem lt_mul_lte(a: Rat, b: Rat, c: Rat, d: Rat) {
    not a.is_negative and c.is_positive and a < b and c <= d
    implies
    a * c < b * d
}

// This isn't ideal but this is how we have defined division.
theorem div_zero(a: Rat) {
    a / Rat.0 = Rat.0
} by {
    a * reduce(Rat.0.denom, Int.0) = Rat.0
    a * Rat.0.reciprocal = Rat.0
}

theorem pos_recip(a: Rat) {
    a.is_positive implies a.reciprocal.is_positive
}

theorem recip_recip(a: Rat) {
    a.reciprocal.reciprocal = a
}

theorem neg_recip(a: Rat) {
    a.is_negative implies a.reciprocal.is_negative
} by {
    if a.reciprocal.is_positive {
        a.reciprocal.reciprocal.is_positive
        a.is_positive
        false
    }
    if a.reciprocal = Rat.0 {
        false
    }
}

theorem div_neg_neg(a: Rat, b: Rat) {
    a.is_negative and b.is_negative
    implies
    (a / b).is_positive
} by {
    a < Rat.0
    b.reciprocal.is_negative
}

theorem div_negs_cancel(a: Rat, b: Rat) {
    a / b = (-a) / (-b)
} by {
    -Rat.1 != Rat.0
    -Rat.1 * a / (-Rat.1 * b) = a / b
    -Rat.1 * a / -b = a / b
}

theorem abs_div(a: Rat, b: Rat) {
    b != Rat.0 implies
    (a / b).abs = a.abs / b.abs
} by {
    if a.is_negative {
        a.abs = -a
        if b.is_negative {
            (a / b).is_positive
            (a / b).abs = a / b
            b.abs = -b
            a.abs / b.abs = (-a) / (-b)
            (-a) / (-b) = a / b
            (a / b).abs = a.abs / b.abs
        } else {
            b.abs = b
            not (a / b).is_positive
            (a / b).abs = -(a / b)
            (a / b).abs = a.abs / b.abs
        }
    } else {
        a.abs = a
        if b.is_negative {
            b.abs = -b
            not (a / b).is_positive
            (a / b).abs = -(a / b)
            (a / b).abs = a.abs / b.abs
        } else {
            b.abs = b
            not (a / b).is_negative
            (a / b).abs = (a / b)
            (a / b).abs = a.abs / b.abs
        }
    }
}

theorem lt_make_left_denom(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a < b * c implies a / c < b
}

theorem lt_make_right_denom(a: Rat, b: Rat, c: Rat) {
    b.is_positive and a * b < c implies a < c / b
} by {
    b.reciprocal.is_positive
    a * b * b.reciprocal < c * b.reciprocal
    a * b * b.reciprocal = a
    a < c * b.reciprocal
}

theorem lt_elim_left_denom(a: Rat, b: Rat, c: Rat) {
    b.is_positive and a / b < c implies a < c * b
}

theorem abs_of_div(a: Rat, b: Rat) {
    (a / b).abs = a.abs / b.abs
} by {
    if (a / b).abs != a.abs / b.abs {
        not b.is_positive
        b.abs = -b
        false
    }
}

theorem mul_div_swap(a: Rat, b: Rat, c: Rat) {
    a * b / c = (a / c) * b
}

theorem zero_recip(a: Rat) {
    Rat.0.reciprocal = Rat.0
}

// The multiplicative algebraic structure.

from semigroup import Semigroup

instance Rat: Semigroup {
    let mul = Rat.mul
}

from monoid import Monoid

instance Rat: Monoid {
    let 1 = Rat.1
}

from semiring import Semiring

instance Rat: Semiring

from ring import Ring

instance Rat: Ring

from comm_ring import CommRing

instance Rat: CommRing

from field import Field

instance Rat: Field {
    let inverse = Rat.reciprocal
}

from util import is_reflexive, is_transitive, is_antisymmetric

theorem rat_is_reflexive {
    is_reflexive(Rat.lte)
}

theorem rat_is_transitive {
    is_transitive(Rat.lte)
}

theorem rat_is_antisymmetric {
    is_antisymmetric(Rat.lte)
}

theorem rat_total(a: Rat, b: Rat) { a <= b or b <= a } by {
    trichotomy(a, b)
    if a < b {
        a <= b
    } else {
        if a = b {
            a <= b
        } else {
            b < a
            b <= a
        }
    }
}

from order import PartialOrder, LinearOrder

instance Rat: PartialOrder {
    let lte = Rat.lte
}

instance Rat: LinearOrder
