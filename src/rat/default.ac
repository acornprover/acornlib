from nat import Nat
from int import Int
from int.lattice import abs
from rat.rat_base import Rat, reduce
from order import LinearOrder

// It will be convenient to have a particular function that
// approaches zero.
define iop(n: Nat) -> Rat {
    Rat.1 / (Rat.1 + Rat.from_nat(n))
}

theorem iop_pos(n: Nat) {
    iop(n).is_positive
} by {
    (Rat.1 + Rat.from_nat(n)).is_positive
}

theorem pos_ne_zero(a: Rat) {
    a.is_positive implies a != Rat.0
}

theorem iop_ne_zero(n: Nat) {
    iop(n) != Rat.0
}

theorem iop_recip(n: Nat) {
    iop(n).reciprocal = Rat.1 + Rat.from_nat(n)
} by {
    (Rat.1 + Rat.from_nat(n)).is_positive
    (Rat.1 + Rat.from_nat(n)).reciprocal = iop(n)
}

theorem iop_mul_lt_one(n: Nat) {
    iop(n) * Rat.from_nat(n) < Rat.1
} by {
    iop(n) + iop(n) * Rat.from_nat(n) = Rat.1
}

theorem pos_lte_num(a: Rat) {
    a.is_positive implies a <= Rat.from_int(a.num)
} by {
    a.num <= a.denom * a.num
}

theorem lt_some_int(a: Rat) {
    exists(n: Int) {
        a < Rat.from_int(n)
    }
}

theorem lt_some_nat(a: Rat) {
    exists(n: Nat) {
        a < Rat.from_nat(n)
    }
} by {
    let i: Int satisfy {
        a < Rat.from_int(i)
    }
    let n = abs(i)
    Rat.from_int(i) <= Rat.from_nat(n)
}

theorem iop_gets_lt(eps: Rat) {
    eps.is_positive implies exists(n: Nat) {
        forall(i: Nat) {
            n <= i implies iop(i) < eps
        }
    }
} by {
    let n: Nat satisfy {
        eps.reciprocal < Rat.from_nat(n)
    }
    forall(i: Nat) {
        if n <= i {
            Rat.from_nat(n) <= Rat.from_nat(i)
            eps.reciprocal * eps < Rat.from_nat(i) * eps
            Rat.1 < Rat.from_nat(i) * eps
            Rat.from_nat(i) * iop(i) < Rat.from_nat(i) * eps
            iop(i) < eps
        }
    }
}

theorem three_is_positive {
    Rat.3.is_positive
}

theorem times_three(x: Rat) {
    Rat.3 * x = x + x + x
} by {
    Int.3 = Int.2 + Int.1
}

theorem three_thirds(x: Rat) {
    (x / Rat.3) + (x / Rat.3) + (x / Rat.3) = x
}

theorem some_mul_lt(a: Rat, b: Rat) {
    Rat.0 <= a and b.is_positive implies
    exists(eps: Rat) {
        eps.is_positive and a * eps < b
    }
} by {
    if a = Rat.0 {
        let eps = b
        eps.is_positive and a * eps < b
    } else {
        a.is_positive
        let c: Rat satisfy {
            c.is_positive and c < b
        }
        let eps = c / a
        a * eps < b
        eps.is_positive and a * eps < b
    }
}

theorem close_mul_pos(a: Rat, b: Rat, eps: Rat, r: Rat) {
    r.is_positive and a.is_close(b, eps)
    implies
    (a * r).is_close(b * r, eps * r)
} by {
    a * r < (b * r) + (eps * r)
}

theorem close_neg(a: Rat, b: Rat, eps: Rat) {
    a.is_close(b, eps) implies (-a).is_close(-b, eps)
} by {
    (-a - -b).abs < eps
}

theorem lte_mul_nonneg(a: Rat, b: Rat, c: Rat) {
    a <= b and Rat.0 <= c implies a * c <= b * c
} by {
    if c = Rat.0 {
    } else {
        a * c <= b * c
    }
}

theorem bounding_both(a: Rat, b: Rat) {
    exists(c: Rat) {
        a < c and b < c
    }
}

theorem finite_seq_abs_bounded(a: Nat -> Rat, n: Nat) {
    exists(bound: Rat) {
        forall(i: Nat) {
            i <= n implies a(i).abs < bound
        }
    }
} by {
    let f = finite_seq_abs_bounded(a)
    let zero_bound: Rat satisfy {
        a(Nat.0).abs < zero_bound
    }
    forall(i: Nat) {
        i <= Nat.0 implies a(i).abs < zero_bound
    }
    f(Nat.0)
    forall(k: Nat) {
        if f(k) {
            let base_bound: Rat satisfy {
                forall(i: Nat) {
                    i <= k implies a(i).abs < base_bound
                }
            }
            let extra_bound: Rat satisfy {
                a(k.suc).abs < extra_bound
            }
            let bound: Rat satisfy {
                base_bound < bound and extra_bound < bound
            }
            forall(i: Nat) {
                if i <= k.suc {
                    if i <= k {
                        a(i).abs < bound
                    } else {
                        i = k.suc
                        a(i).abs < bound
                    }
                }
            }
            finite_seq_abs_bounded(a, k.suc)
        }
    }
}

theorem abs_reduce_left(a: Int, b: Int) {
    reduce(a.abs, b).abs = reduce(a, b).abs
} by {
    if a.is_negative {
    } else {
    }
}

theorem reduce_neg_num(a: Int, b: Int) {
    reduce(-a, b) = -reduce(a, b)
}

theorem reduce_neg_denom(a: Int, b: Int) {
    reduce(a, -b) = -reduce(a, b)
} by {
    reduce(a, -b) = reduce(-Int.1 * a, -Int.1 * -b)
}

theorem abs_reduce_right(a: Int, b: Int) {
    reduce(a, b.abs).abs = reduce(a, b).abs
} by {
    if b.is_negative {
    } else {
    }
}

theorem reduce_nonneg(a: Int, b: Int) {
    not a.is_negative and not b.is_negative
    implies
    not reduce(a, b).is_negative
} by {
    if a = Int.0 {
    } else {
        if b = Int.0 {
            not reduce(a, b).is_negative
        } else {
            not reduce(a, b).is_negative
        }
    }
}

theorem reduce_abs(a: Int, b: Int) {
    reduce(a.abs, b.abs) = reduce(a, b).abs
} by {
    not b.abs.is_negative
    not reduce(a.abs, b.abs).is_negative
}

theorem lte_cancel_mul_pos(p: Rat, q: Rat, r: Rat) {
    r.is_positive and p * r <= q * r
    implies
    p <= q
} by {
    if p * r = q * r {
    } else {
        p <= q
    }
}

theorem reduce_lte(a: Int, b: Int, c: Int) {
    not c.is_negative and a <= b implies
    reduce(a, c) <= reduce(b, c)
} by {
    if c = Int.0 {
    } else {
        Rat.from_int(c).is_positive
        reduce(a, c) <= reduce(b, c)
    }
}

theorem triangle_ineq(a: Rat, b: Rat) {
    (a + b).abs <= a.abs + b.abs
} by {
    let (an: Int, bn: Int, c: Int) satisfy {
        a = reduce(an, c) and b = reduce(bn, c)
    }
    reduce((an + bn).abs, c.abs) <= reduce(an.abs + bn.abs, c.abs)
}

// Not all that generally useful.
theorem diff_mul_bound(a0: Rat, b0: Rat, a1: Rat, b1: Rat) {
    (a0 * b0 - a1 * b1).abs <= a0.abs * (b0 - b1).abs + b1.abs * (a0 - a1).abs
} by {
    a0 * (b0 - b1) + b1 * (a0 - a1) = a0 * b0 - a0 * b1 + b1 * a0 - b1 * a1
    (a0 * (b0 - b1) + b1 * (a0 - a1)).abs <= (a0 * (b0 - b1)).abs + (b1 * (a0 - a1)).abs
}

theorem nonneg_lt_imp_pos(a: Rat, b: Rat) {
    not a.is_negative and a < b implies
    b.is_positive
}

theorem lt_pos_mul_lt_pos(a: Rat, b: Rat, c: Rat, d: Rat) {
    not a.is_negative and not c.is_negative and a < b and c < d
    implies
    a * c < b * d
} by {
    a * c <= b * c
}

theorem abs_nonneg(a: Rat) {
    not a.abs.is_negative
}

theorem lte_mul_lte(a: Rat, b: Rat, c: Rat, d: Rat) {
    not a.is_negative and not c.is_negative and a <= b and c <= d
    implies
    a * c <= b * d
} by {
    if a = b {
        c * b <= d * b
    } else {
        if c = d {
            a * c <= b * d
        } else {
            a * c < b * d
            a * c <= b * d
        }
    }
}

theorem add_div_distrib(a: Rat, b: Rat, c: Rat) {
    (a + b) / c = a / c + b / c
}

theorem sub_div_distrib(a: Rat, b: Rat, c: Rat) {
    (a - b) / c = a / c - b / c
}

theorem recip_mul(a: Rat, b: Rat) {
    (a * b).reciprocal = a.reciprocal * b.reciprocal
} by {
    if a = Rat.0 {
        // Degenerate but it works
        (a * b).reciprocal = Rat.0
    } else {
        if b = Rat.0 {
            (a * b).reciprocal = a.reciprocal * b.reciprocal
        } else {
            (a * b).reciprocal * (a * b) = Rat.1
            (a * b).reciprocal = a.reciprocal * b.reciprocal
        }
    }
}

theorem mul_fractions(a: Rat, b: Rat, c: Rat, d: Rat) {
    (a / b) * (c / d) = (a * c) / (b * d)
} by {
    (a / b) * (c / d) = (a * c) * (b.reciprocal * d.reciprocal)
}

theorem cancel_left_num_denom(a: Rat, b: Rat, c: Rat) {
    a != Rat.0 implies
    (a * b) / (a * c) = b / c
}

theorem cancel_to_reciprocal(a: Rat, b: Rat) {
    a != Rat.0 and b != Rat.0 implies
    a / (a * b) = b.reciprocal
}

theorem recip_diff(a: Rat, b: Rat) {
    a != Rat.0 and b != Rat.0 implies
    a.reciprocal - b.reciprocal = (b - a) / (a * b)
}
theorem lt_mul_lte(a: Rat, b: Rat, c: Rat, d: Rat) {
    not a.is_negative and c.is_positive and a < b and c <= d
    implies
    a * c < b * d
}

// This isn't ideal but this is how we have defined division.
theorem div_zero(a: Rat) {
    a / Rat.0 = Rat.0
}

theorem pos_recip(a: Rat) {
    a.is_positive implies a.reciprocal.is_positive
}

theorem recip_recip(a: Rat) {
    a.reciprocal.reciprocal = a
}

theorem neg_recip(a: Rat) {
    a.is_negative implies a.reciprocal.is_negative
} by {
    if a.reciprocal = Rat.0 {
        false
    }
}

theorem div_neg_neg(a: Rat, b: Rat) {
    a.is_negative and b.is_negative
    implies
    (a / b).is_positive
}

theorem div_negs_cancel(a: Rat, b: Rat) {
    a / b = (-a) / (-b)
}

theorem abs_div(a: Rat, b: Rat) {
    b != Rat.0 implies
    (a / b).abs = a.abs / b.abs
} by {
    if a.is_negative {
        if b.is_negative {
        } else {
            (a / b).abs = -(a / b)
            (a / b).abs = a.abs / b.abs
        }
    } else {
        if b.is_negative {
            (a / b).abs = -(a / b)
            (a / b).abs = a.abs / b.abs
        } else {
            not (a / b).is_negative
            (a / b).abs = a.abs / b.abs
        }
    }
}

theorem lt_make_left_denom(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a < b * c implies a / c < b
}

theorem lt_make_right_denom(a: Rat, b: Rat, c: Rat) {
    b.is_positive and a * b < c implies a < c / b
} by {
    a * b * b.reciprocal = a
}

theorem lt_elim_left_denom(a: Rat, b: Rat, c: Rat) {
    b.is_positive and a / b < c implies a < c * b
}

theorem abs_of_div(a: Rat, b: Rat) {
    (a / b).abs = a.abs / b.abs
}

theorem mul_div_swap(a: Rat, b: Rat, c: Rat) {
    a * b / c = (a / c) * b
}

theorem zero_recip(a: Rat) {
    Rat.0.reciprocal = Rat.0
}

// The multiplicative algebraic structure.

from mul import Mul

from semigroup import Semigroup

instance Rat: Mul {
    let mul = Rat.mul
}

instance Rat: Semigroup

from one import One

from monoid import Monoid

instance Rat: One {
    let 1 = Rat.1
}

instance Rat: Monoid

from semiring import Semiring

instance Rat: Semiring

from ring import Ring

instance Rat: Ring

from comm_semigroup import CommSemigroup

instance Rat: CommSemigroup

from comm_monoid import CommMonoid

instance Rat: CommMonoid

from comm_ring import CommRing

instance Rat: CommRing

from inverse import Inverse

from field import Field

instance Rat: Inverse {
    let inverse = Rat.reciprocal
}

theorem zero_is_different_than_one {
    Rat.0 != Rat.1
}

instance Rat: Field

theorem rat_total(a: Rat, b: Rat) { a <= b or b <= a } by {
    if a < b {
    } else {
        if a = b {
        } else {
        }
    }
}

instance Rat: LinearOrder

from add_ordered_group import AddLeftOrderedGroup, AddOrderedGroup

instance Rat: AddLeftOrderedGroup
instance Rat: AddOrderedGroup

from ordered_field import OrderedField

instance Rat: OrderedField