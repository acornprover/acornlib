from nat import Nat
from int import Int
from int.lattice import unit_sign, abs

/// True if a fraction a/b is in reduced form (lowest terms).
/// The denominator must be positive and gcd(a,b) must be 1.
define is_reduced(a: Int, b: Int) -> Bool {
    b > Int.0 and a.gcd(b) = Int.1
}

theorem denom_one_is_reduced(a: Int) {
    is_reduced(a, Int.1)
} by {
    Int.1 > Int.0
    a.gcd(Int.1) = Int.1
}

/// Rational numbers represented as fractions in reduced form.
/// The constraint ensures the fraction is always in lowest terms with positive denominator.
structure Rat {
    /// The numerator of the rational number.
    num: Int
    /// The denominator of the rational number (always positive).
    denom: Int
} constraint {
    is_reduced(num, denom)
}

attributes Rat {
    /// The rational zero.
    let 0: Rat = Rat.new(Int.0, Int.1)
}

theorem zero_num {
    Rat.0.num = Int.0
}

theorem zero_denom {
    Rat.0.denom = Int.1
}

theorem denom_nonzero(r: Rat) {
    r.denom != Int.0
} by {
    r.denom > Int.0
}

theorem denom_positive(r: Rat) {
    r.denom.is_positive
} by {
    r.denom > Int.0
}

attributes Rat {
    /// Converts an integer to a rational number.
    let from_int = function(n: Int) {
        Rat.new(n, Int.1)
    }
}

theorem from_int_num(n: Int) {
    Rat.from_int(n).num = n
}

theorem from_int_denom(n: Int) {
    Rat.from_int(n).denom = Int.1
}

/// True if two fractions a/b and c/d are equal using cross multiplication.
/// Requires non-zero denominators to avoid the 0/0 edge case.
define cross_equals(a: Int, b: Int, c: Int, d: Int) -> Bool {
    b != Int.0 and d != Int.0 and a * d = c * b
}

theorem cross_equals_trans(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) {
    cross_equals(a, b, c, d) and cross_equals(c, d, e, f) implies cross_equals(a, b, e, f)
} by {
    a * d = b * c
    c * f = d * e
    a * d * f = b * c * f
    a * d * f = b * d * e
    a * f * d = b * e * d
    d != Int.0
    a * f = b * e
}

/// Reduces a fraction a/b to its simplest form as a Rat.
/// Yields 0 if b = 0 (treating division by zero as zero).
let reduce(a: Int, b: Int) -> r: Rat satisfy {
    if b = Int.0 {
        r = Rat.0
    } else {
        cross_equals(r.num, r.denom, a, b)
    }
} by {
    if b = Int.0 {
        Rat.0 = Rat.0
    } else {
        // Factor out the gcd
        a.gcd(b) != Int.0
        let a1: Int satisfy {
            a1 * a.gcd(b) = a
        }
        let b1: Int satisfy {
            b1 * a.gcd(b) = b
        }
        b1 != Int.0
        a * b = a * b1 * a.gcd(b)
        a * b = b * a1 * a.gcd(b)
        a * b1 * a.gcd(b) = b * a1 * a.gcd(b)
        a * b1 = b * a1
        cross_equals(a1, b1, a, b)
        a1.gcd(b1) = Int.1

        // To reduce we also need to swap signs if the denominator is negative
        let a2 = a1 * unit_sign(b1)
        let b2 = b1 * unit_sign(b1)
        b2 = Int.from_nat(abs(b1))
        b2 != Int.0
        (a1 * unit_sign(b1)) * b1 = (b1 * unit_sign(b1)) * a1
        cross_equals(a2, b2, a1, b1)
        a2.gcd(b2) = Int.1 * Int.from_nat(abs(unit_sign(b1)))
        Int.from_nat(abs(unit_sign(b1))) = Int.1
        a2.gcd(b2) = Int.1
        b2 != Int.0
        b2 > Int.0
        is_reduced(a2, b2)

        let r = Rat.new(a2, b2)
        r.num = a2
        r.denom = b2
        cross_equals(r.num, r.denom, a2, b2)
        cross_equals(a2, b2, a, b)
        cross_equals(r.num, r.denom, a, b)
    }
}

theorem cross_eq_imp_eq(r1: Rat, r2: Rat) {
    cross_equals(r1.num, r1.denom, r2.num, r2.denom) implies r1 = r2
} by {
    // The r1 fields divide into the r2 ones
    r1.num.gcd(r1.denom) = Int.1
    r1.denom.divides(r1.num * r2.denom)
    r1.denom.divides(r2.denom)
    abs(r1.denom).divides(abs(r2.denom))

    // The r2 fields divide into the r1 ones
    r2.num.gcd(r2.denom) = Int.1
    r2.denom.divides(r2.num * r1.denom)
    r2.denom.divides(r1.denom)
    abs(r2.denom).divides(abs(r1.denom))

    // Prove int equality from nat equality
    abs(r1.denom) = abs(r2.denom)
    r1.denom.is_positive
    r2.denom.is_positive
    r1.denom = r2.denom

    // Divide out the denominators
    r1.num * r2.denom = r2.num * r1.denom
    r1.num * r2.denom = r2.num * r2.denom
    r2.denom != Int.0
    r1.num = r2.num
}

attributes Rat {
    /// The rational one.
    let 1: Rat = Rat.from_int(Int.1)
    /// The rational two.
    let 2: Rat = Rat.from_int(Int.2)
    /// The rational three.
    let 3: Rat = Rat.from_int(Int.3)
    /// The rational four.
    let 4: Rat = Rat.from_int(Int.4)
    /// The rational five.
    let 5: Rat = Rat.from_int(Int.5)
    /// The rational six.
    let 6: Rat = Rat.from_int(Int.6)
    /// The rational seven.
    let 7: Rat = Rat.from_int(Int.7)
    /// The rational eight.
    let 8: Rat = Rat.from_int(Int.8)
    /// The rational nine.
    let 9: Rat = Rat.from_int(Int.9)
    /// The rational ten.
    let 10: Rat = Rat.from_int(Int.10)

    /// True if the rational is positive.
    define is_positive(self) -> Bool {
        self.num.is_positive
    }

    /// True if the rational is negative.
    define is_negative(self) -> Bool {
        self.num.is_negative
    }

    /// The negation of a rational number.
    define neg(self) -> Rat {
        Rat.new(-self.num, self.denom)
    }

    /// The sum of two rational numbers.
    define add(self, other: Rat) -> Rat {
        reduce(self.num * other.denom + other.num * self.denom,
               self.denom * other.denom)
    }

    /// The product of two rational numbers.
    define mul(self, other: Rat) -> Rat {
        reduce(self.num * other.num, self.denom * other.denom)
    }

    /// The reciprocal of a rational number (1/x).
    /// The reciprocal of zero is defined to be zero.
    define reciprocal(self) -> Rat {
        reduce(self.denom, self.num)
    }

    /// The quotient of two rational numbers.
    /// Division by zero is defined to yield zero.
    define div(self, other: Rat) -> Rat {
        self * other.reciprocal
    }

    /// The rational formed by appending a digit to this rational in base 10.
    define read(self, other: Rat) -> Rat { Rat.10 * self + other }
}

theorem reduce_idempotent(r: Rat) {
    reduce(r.num, r.denom) = r
}

theorem neg_is_reduced(r: Rat) {
    is_reduced(-r.num, r.denom)
} by {
    r.denom > Int.0
    (-r.num).gcd(r.denom) = r.num.gcd(r.denom)
}

theorem neg_num(r: Rat) {
    r.neg.num = -r.num
}

theorem neg_denom(r: Rat) {
    r.neg.denom = r.denom
}

theorem add_zero_right(a: Rat) {
    a + Rat.0 = a
} by {
    a + Rat.0 = reduce(a.num * Int.1 + Int.0 * a.denom, a.denom * Int.1)
    a + Rat.0 = reduce(a.num, a.denom)
}

theorem add_zero_left(a: Rat) {
    Rat.0 + a = a
}

theorem add_comm(a: Rat, b: Rat) {
    a + b = b + a
}

theorem from_int_cancel(a: Int, b: Int) {
    Rat.from_int(a) = Rat.from_int(b) implies a = b
}

theorem mul_comm(a: Rat, b: Rat) {
    a * b = b * a
}

theorem rat_neg_one {
    -Rat.1 = Rat.from_int(-Int.1)
} by {
    Rat.1 = Rat.new(Int.1, Int.1)
    Rat.from_int(-Int.1) = Rat.new(-Int.1, Int.1)
}

theorem mul_neg_one_right(r: Rat) {
    r * -Rat.1 = -r
} by {
    r * Rat.from_int(-Int.1) = -r
}

theorem mul_neg_one_left(r: Rat) {
    -Rat.1 * r = -r
}

theorem mul_one_right(r: Rat) {
    r * Rat.1 = r
} by {
    r * Rat.from_int(Int.1) = r
}

theorem mul_one_left(r: Rat) {
    Rat.1 * r = r
}

theorem mul_int_eq_int_mul(a: Int, b: Int) {
    Rat.from_int(a) * Rat.from_int(b) = Rat.from_int(a * b)
}

theorem unreduce_right(a: Int, b: Int) {
    b != Int.0 implies exists(d: Int) {
        reduce(a, b).num * d = a and reduce(a, b).denom * d = b
    }
} by {
    let r = reduce(a, b)
    cross_equals(r.num, r.denom, a, b)
    r.num * b = a * r.denom
    r.num.gcd(r.denom) = Int.1
    r.denom.divides(r.num * b)
    r.denom.divides(b)
    let d: Int satisfy {
        r.denom * d = b
    }
    r.num * b * d = a * r.denom * d
    r.num * d * b = a * b
    r.num * d = a
}

theorem unreduce_left(a: Int, b: Int) {
    b != Int.0 implies exists(d: Int) {
        d * reduce(a, b).num = a and d * reduce(a, b).denom = b
    }
} by {
    let d: Int satisfy {
        reduce(a, b).num * d = a and reduce(a, b).denom * d = b
    }
    d * reduce(a, b).num = a
    d * reduce(a, b).denom = b
}

theorem mul_int_right(r: Rat, n: Int) {
    r * Rat.from_int(n) = reduce(r.num * n, r.denom)
}

theorem mul_int_left(n: Int, r: Rat) {
    Rat.from_int(n) * r = reduce(n * r.num, r.denom)
}

theorem cross_eq_imp_reduce_eq(a: Int, b: Int, c: Int, d: Int) {
    cross_equals(a, b, c, d) implies reduce(a, b) = reduce(c, d)
} by {
    b != Int.0
    d != Int.0
    let rab = reduce(a, b)
    cross_equals(reduce(a, b).num, rab.denom, a, b)
    cross_equals(rab.num, rab.denom, a, b)
    cross_equals(rab.num, rab.denom, c, d)
    let rcd = reduce(c, d)
    cross_equals(reduce(c, d).num, rcd.denom, c, d)
    cross_equals(rcd.num, rcd.denom, c, d)
    c * rab.denom = rab.num * d
    cross_equals(rcd.num, rcd.denom, rab.num, rab.denom)
    rab = rcd
}

theorem reduce_eq_imp_cross_eq(a: Int, b: Int, c: Int, d: Int) {
    b != Int.0 and d != Int.0 and reduce(a, b) = reduce(c, d)
        implies cross_equals(a, b, c, d)
} by {
    cross_equals(reduce(a, b).num, reduce(a, b).denom, a, b)
    cross_equals(reduce(c, d).num, reduce(c, d).denom, c, d)
    cross_equals(reduce(a, b).num, reduce(c, d).denom, a, b)
    cross_equals(a, b, reduce(a, b).num, reduce(c, d).denom)
}

theorem mul_reduced_int_right(a: Int, b: Int, c: Int) {
    reduce(a, b) * Rat.from_int(c) = reduce(a * c, b)
} by {
    if b = Int.0 {
        reduce(a, b) = Rat.0
        reduce(a * c, b) = Rat.0
        reduce(a, b) * Rat.from_int(c) = reduce(a * c, b)
    } else {
        let r = reduce(a, b)
        r * Rat.from_int(c) = reduce(r.num * c, r.denom)
        cross_equals(r.num, r.denom, a, b)
        r.num * b = r.denom * a
        r.num * c * b = r.denom * (a * c)
        reduce(r.num * c, r.denom) = reduce(a * c, b)
        reduce(a, b) * Rat.from_int(c) = reduce(a * c, b)
    }
}

theorem mul_reduced_int_left(a: Int, b: Int, c: Int) {
    Rat.from_int(c) * reduce(a, b) = reduce(c * a, b)
}

theorem mul_int_right_cancel(r1: Rat, r2: Rat, n: Int) {
    n != Int.0 and r1 * Rat.from_int(n) = r2 * Rat.from_int(n) implies r1 = r2
} by {
    r1 * Rat.from_int(n) = reduce(r1.num * n, r1.denom)
    r2 * Rat.from_int(n) = reduce(r2.num * n, r2.denom)
    reduce(r1.num * n, r1.denom) = reduce(r2.num * n, r2.denom)
    r1.num * n * r2.denom = r1.denom * r2.num * n
    r1.num * r2.denom = r1.denom * r2.num
    r1 = r2
}

theorem mul_int_left_cancel(r1: Rat, r2: Rat, n: Int) {
    n != Int.0 and Rat.from_int(n) * r1 = Rat.from_int(n) * r2 implies r1 = r2
}

theorem mul_reduced_nondegen(a: Int, b: Int, c: Int, d: Int) {
    b != Int.0 and d != Int.0 implies
        reduce(a, b) * reduce(c, d) = reduce(a * c, b * d)
} by {
    let e: Int satisfy {
        reduce(a, b).num * e = a and reduce(a, b).denom * e = b
    }
    e != Int.0
    let f: Int satisfy {
        reduce(c, d).num * f = c and reduce(c, d).denom * f = d
    }
    f != Int.0

    // Simplify numerator
    let nums = reduce(a, b).num * reduce(c, d).num
    (reduce(a, b).num * e) * (reduce(c, d).num * f) = a * c
    reduce(a, b).num * e * reduce(c, d).num * f = a * c
    (reduce(a, b).num * reduce(c, d).num) * e * f = a * c
    (reduce(a, b).num * reduce(c, d).num) * (e * f) = a * c
    nums * (e * f) = a * c

    // Simplify denominator
    let denoms: Int = reduce(a, b).denom * reduce(c, d).denom
    (reduce(a, b).denom * e) * (reduce(c, d).denom * f) = b * d
    (reduce(a, b).denom * reduce(c, d).denom) * e * f = b * d
    (reduce(a, b).denom * reduce(c, d).denom) * (e * f) = b * d
    denoms * (e * f) = b * d

    // Combining
    nums * (b * d) = denoms * (a * c)
    reduce(a, b).denom * reduce(c, d).denom != Int.0
    denoms != Int.0
    cross_equals(nums, denoms, a * c, b * d)
    cross_equals(reduce(a, b).num * reduce(c, d).num,
                 reduce(a, b).denom * reduce(c, d).denom,
                 a * c, b * d)
}

theorem reduce_zero_num(a: Int) {
    reduce(Int.0, a) = Rat.0
} by {
    if a = Int.0 {
        reduce(Int.0, a) = Rat.0
    } else {
        Rat.0 = reduce(Int.0, Int.1)
        cross_equals(Int.0, a, Int.0, Int.1)
        reduce(Int.0, a) = reduce(Int.0, Int.1)
        reduce(Int.0, a) = Rat.0
    }
}

theorem mul_zero_right(r: Rat) {
    r * Rat.0 = Rat.0
} by {
    r * Rat.0 = reduce(r.num * Int.0, r.denom)
    r * Rat.0 = reduce(Int.0, r.denom)
}

theorem mul_reduced_degen(a: Int, b: Int, c: Int) {
    reduce(a, b) * reduce(c, Int.0) = reduce(a * c, b * Int.0)
} by {
    reduce(c, Int.0) = Rat.0
    reduce(a, b) * Rat.0 = Rat.0
    reduce(a * c, b * Int.0) = Rat.0
}

theorem mul_reduced(a: Int, b: Int, c: Int, d: Int) {
    reduce(a, b) * reduce(c, d) = reduce(a * c, b * d)
} by {
    if b = Int.0 or d = Int.0 {
        // Degen cases
        if b = Int.0 {
            reduce(a, Int.0) * reduce(c, d) = reduce(a * c, Int.0 * d)
            reduce(a, b) * reduce(c, d) = reduce(a * c, b * d)
        } else {
            d = Int.0
            reduce(a, b) * reduce(c, Int.0) = reduce(a * c, b * Int.0)
            reduce(a, b) * reduce(c, d) = reduce(a * c, b * d)
        }
    } else {
        // Non-degen case
        reduce(a, b) * reduce(c, d) = reduce(a * c, b * d)
    }
}

theorem mul_assoc(a: Rat, b: Rat, c: Rat) {
    (a * b) * c = a * (b * c)
} by {
    (a * b) * c = reduce(a.num * b.num * c.num, a.denom * b.denom * c.denom)
    a * (b * c) = reduce(a.num * (b.num * c.num), a.denom * (b.denom * c.denom))
}

theorem add_int_eq_int_add(a: Int, b: Int) {
    Rat.from_int(a) + Rat.from_int(b) = Rat.from_int(a + b)
}

theorem reduce_cancels_right(a: Int, b: Int, c: Int) {
    c != Int.0 implies reduce(a, b) = reduce(a * c, b * c)
} by {
    if b = Int.0 {
        reduce(a, b) = Rat.0
        b * c = Int.0
        reduce(a * c, b * c) = Rat.0
        reduce(a, b) = reduce(a * c, b * c)
    } else {
        cross_equals(a, b, a * c, b * c)
        reduce(a, b) = reduce(a * c, b * c)
    }
}

theorem reduce_cancels_left(a: Int, b: Int, c: Int) {
    c != Int.0 implies reduce(a, b) = reduce(c * a, c * b)
}

theorem add_reduce_right(r: Rat, a: Int, b: Int) {
    b != Int.0 implies r + reduce(a, b) = reduce(r.num * b + a * r.denom, r.denom * b)
} by {
    let c: Int satisfy {
        reduce(a, b).num * c = a and reduce(a, b).denom * c = b
    }
    c != Int.0
    r + reduce(a, b) = reduce(r.num * reduce(a, b).denom + r.denom * reduce(a, b).num,
                              reduce(a, b).denom * r.denom)
    forall(x0: Int, x1: Int) { reduce(x0 * c, x1 * c) = reduce(x0, x1) }
    r + reduce(a, b) = reduce((r.num * reduce(a, b).denom + r.denom * reduce(a, b).num) * c,
                              reduce(a, b).denom * r.denom * c)
    r + reduce(a, b) = reduce(r.num * reduce(a, b).denom * c + r.denom * reduce(a, b).num * c,
                              reduce(a, b).denom * r.denom * c)
    r + reduce(a, b) = reduce(r.num * b + a * r.denom, r.denom * b)
}

theorem add_reduced(a: Int, b: Int, c: Int, d: Int) {
    b != Int.0 and d != Int.0 implies reduce(a, b) + reduce(c, d) = reduce(a * d + b * c, b * d)
} by {
    reduce(a, b) + reduce(c, d) = reduce(reduce(a, b).num * d + c * reduce(a, b).denom,
                                         reduce(a, b).denom * d)
    let e: Int satisfy {
        reduce(a, b).num * e = a and reduce(a, b).denom * e = b
    }
    e != Int.0
    reduce(reduce(a, b).num * d + c * reduce(a, b).denom, reduce(a, b).denom * d) = reduce(
        (reduce(a, b).num * d + c * reduce(a, b).denom) * e, reduce(a, b).denom * d * e)
    reduce(a, b) + reduce(c, d) = reduce((reduce(a, b).num * d + c * reduce(a, b).denom) * e,
                                         reduce(a, b).denom * d * e)
    reduce(a, b) + reduce(c, d) = reduce(reduce(a, b).num * d * e + c * reduce(a, b).denom * e,
                                         reduce(a, b).denom * d * e)
    reduce(a, b) + reduce(c, d) = reduce(reduce(a, b).num * e * d + reduce(a, b).denom * e * c,
                                         reduce(a, b).denom * e * d)
}

theorem add_reduced_same_denom(a: Int, b: Int, c: Int) {
    reduce(a, c) + reduce(b, c) = reduce(a + b, c)
} by {
    if c = Int.0 {
        reduce(a, c) = Rat.0
        reduce(b, c) = Rat.0
        reduce(a + b, c) = Rat.0
        reduce(a, c) + reduce(b, c) = reduce(a + b, c)
    } else {
        reduce(a, c) + reduce(b, c) = reduce(a * c + b * c, c * c)
        reduce(a, c) + reduce(b, c) = reduce((a + b) * c, c * c)
        reduce(a, c) + reduce(b, c) = reduce(a + b, c)
    }
}

theorem add_assoc(a: Rat, b: Rat, c: Rat) {
    a + b + c = a + (b + c)
} by {
    let d: Int = a.denom * b.denom * c.denom
    let an: Int = a.num * (b.denom * c.denom)
    a = reduce(a.num, a.denom)
    b.denom * c.denom != Int.0
    a = reduce(a.num * (b.denom * c.denom), a.denom * (b.denom * c.denom))
    a = reduce(an, d)

    let bn: Int = b.num * (a.denom * c.denom)
    b = reduce(b.num, b.denom)
    a.denom * c.denom != Int.0
    b = reduce(b.num * (a.denom * c.denom), b.denom * (a.denom * c.denom))
    b = reduce(bn, d)

    let cn: Int = c.num * (a.denom * b.denom)
    c = reduce(c.num, c.denom)
    a.denom * b.denom != Int.0
    c = reduce(c.num * (a.denom * b.denom), c.denom * (a.denom * b.denom))
    c = reduce(cn, d)

    a + b + c = reduce(an, d) + reduce(bn, d) + reduce(cn, d)
    a + b + c = reduce(an + bn, d) + reduce(cn, d)
    a + b + c = reduce(an + bn + cn, d)
    a + b + c = reduce(an + (bn + cn), d)
    a + b + c = reduce(an, d) + reduce(bn + cn, d)
    a + b + c = reduce(an, d) + (reduce(bn, d) + reduce(cn, d))
    a + b + c = a + (b + c)
}

theorem common_denom(r1: Rat, r2: Rat) {
    exists(n1: Int, n2: Int, d: Int) {
        r1 = reduce(n1, d) and r2 = reduce(n2, d)
    }
} by {
    let d: Int = r1.denom * r2.denom
    d != Int.0
    let n1: Int = r1.num * r2.denom
    r1 = reduce(r1.num * r2.denom, r1.denom * r2.denom)
    r1 = reduce(n1, d)
    let n2: Int = r2.num * r1.denom
    r2 = reduce(r2.num * r1.denom, r2.denom * r1.denom)
    r2 = reduce(n2, d)
}

theorem distrib_left(r1: Rat, r2: Rat, r3: Rat) {
    r1 * (r2 + r3) = r1 * r2 + r1 * r3
} by {
    let (a: Int, b: Int, c: Int) satisfy {
        r2 = reduce(a, c) and r3 = reduce(b, c)
    }

    // Simplify the left side
    r2 + r3 = reduce(a + b, c)
    r1 * (r2 + r3) = r1 * reduce(a + b, c)
    r1 * (r2 + r3) = reduce(r1.num * (a + b), r1.denom * c)
    r1 * (r2 + r3) = reduce(r1.num * a + r1.num * b, r1.denom * c)

    // Simplify the right side
    r1 * r2 = reduce(r1.num * a, r1.denom * c)
    r1 * r3 = reduce(r1.num * b, r1.denom * c)
    r1 * r2 + r1 * r3 = reduce(r1.num * a + r1.num * b, r1.denom * c)
}

theorem distrib_right(r1: Rat, r2: Rat, r3: Rat) {
    (r1 + r2) * r3 = r1 * r3 + r2 * r3
}

theorem add_inv_cancels_right(a: Rat, b: Rat) {
    a + -a = Rat.0
} by {
    a + -a = reduce(a.num * a.denom + -a.num * a.denom, a.denom * a.denom)
    a + -a = reduce(a.num * a.denom - a.num * a.denom, a.denom * a.denom)
    a + -a = reduce(Int.0, a.denom * a.denom)
    a + -a = Rat.0
}

theorem add_inv_cancels_left(a: Rat, b: Rat) {
    -a + a = Rat.0
}

// The additive algebraic structure.

from add_semigroup import AddSemigroup

instance Rat: AddSemigroup {
    let add = Rat.add
}

from add_comm_semigroup import AddCommSemigroup

instance Rat: AddCommSemigroup

from add_monoid import AddMonoid

instance Rat: AddMonoid {
    let 0 = Rat.0
}

from add_comm_monoid import AddCommMonoid

instance Rat: AddCommMonoid

from add_group import AddGroup

instance Rat: AddGroup {
    let neg = Rat.neg
}

from add_comm_group import AddCommGroup

instance Rat: AddCommGroup

theorem sub_self(a: Rat) {
    a - a = Rat.0
}

theorem reduce_one_one {
    reduce(Int.1, Int.1) = Rat.1
}

theorem reduce_self(n: Int) {
    n != Int.0 implies reduce(n, n) = Rat.1
} by {
    Rat.1 = Rat.new(Int.1, Int.1)
    cross_equals(Int.1, Int.1, n, n)
    reduce(n, n) = reduce(Int.1, Int.1)
    reduce(n, n) = Rat.1
}

theorem mul_inv_cancels_right(a: Rat) {
    a != Rat.0 implies a * a.reciprocal = Rat.1
} by {
    a * a.reciprocal = reduce(a.num * a.denom, a.denom * a.num)
    a * a.reciprocal = reduce(a.num * a.denom, a.num * a.denom)
    a.num * a.denom != Int.0
    a * a.reciprocal = Rat.1
}

theorem mul_inv_cancels_left(a: Rat) {
    a != Rat.0 implies a.reciprocal * a = Rat.1
}

theorem sub_zero(a: Rat) {
    a - Rat.0 = a
}

theorem not_pos_and_neg(a: Rat) {
    a.is_positive implies not a.is_negative
}

theorem reduce_pos_pos(a: Int, b: Int) {
    a.is_positive and b.is_positive implies reduce(a, b).is_positive
} by {
    b != Int.0
    let d: Int satisfy {
        reduce(a, b).num * d = a and reduce(a, b).denom * d = b
    }
    reduce(a, b).denom.is_positive
    d.is_positive
}

theorem add_pos_pos(a: Rat, b: Rat) {
    a.is_positive and b.is_positive implies (a + b).is_positive
} by {
    a + b = reduce(a.num * b.denom + b.num * a.denom, a.denom * b.denom)
    (a.num * b.denom).is_positive
    (b.num * a.denom).is_positive
    (a.num * b.denom + b.num * a.denom).is_positive
    (a.denom * b.denom).is_positive
}

theorem mul_pos_pos(a: Rat, b: Rat) {
    a.is_positive and b.is_positive implies (a * b).is_positive
} by {
    a * b = reduce(a.num * b.num, a.denom * b.denom)
    (a.num * b.num).is_positive
    (a.denom * b.denom).is_positive
}

theorem pos_reciprocal(a: Rat) {
    a.is_positive implies a.reciprocal.is_positive
} by {
    a.reciprocal = reduce(a.denom, a.num)
    a.denom.is_positive
    a.num.is_positive
}

theorem add_cancels_sub(a: Rat, b: Rat) {
    a - b + b = a
} by {
    a + (-b + b) = a
    a + -b + b = a
}

theorem neg_neg_is_pos(a: Rat) {
    a.is_negative implies (-a).is_positive
}

theorem neg_pos_is_neg(a: Rat) {
    a.is_positive implies (-a).is_negative
}

theorem zero_minus(a: Rat) {
    Rat.0 - a = -a
}

theorem mul_cancels_div(a: Rat, b: Rat) {
    b != Rat.0 implies (a / b) * b = a
} by {
    (a / b) * b = a * b.reciprocal * b
    (a / b) * b = a * (b.reciprocal * b)
    (a / b) * b = a * Rat.1
    (a / b) * b = a
}

attributes Rat {
    /// True if this rational is less than or equal to the other.
    define lte(self, other: Rat) -> Bool {
        (other - self).is_positive or self = other
    }
}

from util import is_reflexive, is_transitive, is_antisymmetric

theorem rat_is_reflexive {
    is_reflexive(Rat.lte)
}

theorem lte_trans(a: Rat, b: Rat, c: Rat) {
    a <= b and b <= c implies a <= c
} by {
    if a = b {
        a <= c
    } else {
        (b - a).is_positive
        if b = c {
            a <= c
        } else {
            (c - b).is_positive
            ((c - b) + (b - a)).is_positive
            (c - a).is_positive
            a <= c
        }
    }
}

theorem rat_is_transitive {
    is_transitive(Rat.lte)
}

theorem lte_antisymm(a: Rat, b: Rat) {
    a <= b and b <= a implies a = b
} by {
    if a = b {
        a = b
    } else {
        (b - a).is_positive
        (a - b).is_positive
        ((b - a) + (a - b)).is_positive
        Rat.0.is_positive
        false
    }
}

theorem rat_is_antisymmetric {
    is_antisymmetric(Rat.lte)
}

from order import PartialOrder

instance Rat: PartialOrder {
    let lte = Rat.lte
}

theorem pos_imp_zero_lt(a: Rat) {
    a.is_positive implies Rat.0 < a
} by {
    (a - Rat.0).is_positive
}

theorem zero_lt_imp_pos(a: Rat) {
    Rat.0 < a implies a.is_positive
} by {
    a - Rat.0 = a
    a.is_positive
}

theorem lt_trans(a: Rat, b: Rat, c: Rat) {
    a < b and b < c implies a < c
} by {
    (b - a).is_positive
    (c - b).is_positive
    (c - b) + (b - a) = (c - b) + b - a
    (c - b) + (b - a) = c - a
    (c - a).is_positive
}

theorem neg_imp_lt_zero(a: Rat) {
    a.is_negative implies a < Rat.0
} by {
    (-a).is_positive
    (Rat.0 - a).is_positive
}

theorem lt_zero_imp_neg(a: Rat) {
    a < Rat.0 implies a.is_negative
} by {
    (Rat.0 - a).is_positive
    (-a).is_positive
}

theorem two_neq_zero {
    Rat.2 != Rat.0
}

theorem times_two(r: Rat) {
    Rat.2 * r = r + r
} by {
    // Simplify left
    Rat.2 * r = reduce(Int.2 * r.num, Int.1 * r.denom)
    Rat.2 * r = reduce(r.num + r.num, r.denom)

    // Simplify right
    r + r = reduce(r.num + r.num, r.denom)
}

theorem mul_cancels_right(a: Rat, b: Rat, c: Rat) {
    c != Rat.0 and a * c = b * c implies a = b
} by {
    a * c * c.reciprocal = b * c * c.reciprocal
    a * (c * c.reciprocal) = b * (c * c.reciprocal)
    a * Rat.1 = b * Rat.1
    a = b
}

theorem half_plus_half(r: Rat) {
    (r / Rat.2) + (r / Rat.2) = r
} by {
    (r / Rat.2) * Rat.2 = r
    (r / Rat.2 + r / Rat.2) * Rat.2 = r + r
    (r / Rat.2 + r / Rat.2) * Rat.2 = r * Rat.2
    r / Rat.2 + r / Rat.2 = r
}

theorem neg_mul(a: Rat, b: Rat) {
    (-a) * b = -(a * b)
}

theorem mul_neg_pos(a: Rat, b: Rat) {
    a.is_negative and b.is_positive implies (a * b).is_negative
} by {
    (-a).is_positive
    (-a * b).is_positive
    (-(a * b)).is_positive
    (a * b).is_negative
}

theorem mul_pos_neg(a: Rat, b: Rat) {
    a.is_positive and b.is_negative implies (a * b).is_negative
}

theorem mul_neg_neg(a: Rat, b: Rat) {
    a.is_negative and b.is_negative implies (a * b).is_positive
} by {
    (-b).is_positive
    (-b * a).is_negative
}

theorem one_is_pos {
    Rat.1.is_positive
}

theorem two_is_pos {
    Rat.2.is_positive
}

theorem half_is_pos {
    Rat.2.reciprocal.is_positive
}

theorem sub_add_quasi_cancel(a: Rat, b: Rat) {
    a - (a + b) = -b
} by {
    a - (a + b) = a + -Rat.1 * (a + b)
    a - (a + b) = a + (-Rat.1 * a + -Rat.1 * b)
    a - (a + b) = a + (-a + -b)
    a - (a + b) = a + -a + -b
    a - (a + b) = Rat.0 + -b
    a - (a + b) = -b
}

theorem not_lt_self(a: Rat) {
    not a < a
}

theorem not_lt_both_ways(a: Rat, b: Rat) {
    a < b implies not b < a
}

theorem lt_add_pos(a: Rat, b: Rat) {
    b.is_positive implies a < a + b
} by {
    (a + b) - a = (a + b) + -a
    (a + b) - a = -a + (a + b)
    (a + b) - a = (-a + a) + b
    (a + b) - a = Rat.0 + b
    (a + b) - a = b
    a <= a + b
    a != a + b
}

attributes Rat {
    /// The absolute value of a rational number.
    define abs(self) -> Rat {
        if self.is_negative {
            -self
        } else {
            self
        }
    }
}

theorem neg_sub(a: Rat, b: Rat) {
    -(a - b) = b - a
} by {
    -(a - b) = -(a + -b)
    -(a - b) = -a + --b
    -(a - b) = -a + b
    -(a - b) = b + -a
}

theorem single_trichotomy(a: Rat) {
    a.is_positive or a.is_negative or a = Rat.0
} by {
    if a.num.is_positive {
        a.is_positive
    } else {
        if a.num.is_negative {
            a.is_negative
        } else {
            a.num = Int.0
            a = Rat.0
        }
    }
}

theorem trichotomy(a: Rat, b: Rat) {
    a < b or a = b or a > b
} by {
    if (a - b).is_positive {
        a > b
    } else {
        if (a - b).is_negative {
            (-(a - b)).is_positive
            (b - a).is_positive
            a < b
        } else {
            a = b
        }
    }
}

theorem lt_add_right(a: Rat, b: Rat, c: Rat) {
    a < b implies a + c < b + c
} by {
    (b - a).is_positive
    (b + c) - (a + c) = (b + c) + (-a + -c)
    (b + c) - (a + c) = b + c + (-c + -a)
    (b + c) - (a + c) = b + (c + -c) + -a
    (b + c) - (a + c) = b + -a
    ((b + c) - (a + c)).is_positive
}

theorem add_neg_lt(a: Rat, b: Rat) {
    a.is_negative implies b + a < b
}

theorem adding_lts(a: Rat, b: Rat, c: Rat, d: Rat) {
    a < b and c < d implies a + c < b + d
} by {
    a + c < b + c
    b + c < b + d
}

theorem minus_cancels_plus(a: Rat, b: Rat) {
    a + b - b = a
} by {
    a + b - b = a + b + -b
    a + b - b = a + (b + -b)
    a + b - b = a + Rat.0
    a + b - b = a
}

theorem gt_minus_pos(a: Rat, b: Rat) {
    b.is_positive implies a > a - b
} by {
    a - (a - b) = b
    (a - (a - b)).is_positive
}

theorem sub_add(a: Rat, b: Rat, c: Rat) {
    a - (b + c) = a - b - c
} by {
    a - (b + c) = a + -(b + c)
    a - (b + c) = a + (-b + -c)
    a - (b + c) = a + -b + -c
    a - (b + c) = a - b - c
}

theorem no_greatest(a: Rat) {
    exists(b: Rat) {
        a < b
    }
}

theorem sub_from_int(a: Int, b: Int) {
    Rat.from_int(a) - Rat.from_int(b) = Rat.from_int(a - b)
} by {
    Rat.from_int(a) - Rat.from_int(b) = Rat.from_int(a) + -Rat.from_int(b)
    Rat.from_int(a) - Rat.from_int(b) = Rat.from_int(a) + Rat.from_int(-b)
    Rat.from_int(a) - Rat.from_int(b) = Rat.from_int(a + -b)
    Rat.from_int(a) - Rat.from_int(b) = Rat.from_int(a - b)
}

theorem lt_from_int(a: Int, b: Int) {
    a < b implies Rat.from_int(a) < Rat.from_int(b)
} by {
    Rat.from_int(b) - Rat.from_int(a) = Rat.from_int(b - a)
    Rat.from_int(a) <= Rat.from_int(b)
    Rat.from_int(a) != Rat.from_int(b)
}

theorem lte_from_int(a: Int, b: Int) {
    a <= b implies Rat.from_int(a) <= Rat.from_int(b)
}

theorem gt_from_int(a: Int, b: Int) {
    a > b implies Rat.from_int(a) > Rat.from_int(b)
}

theorem gte_from_int(a: Int, b: Int) {
    a >= b implies Rat.from_int(a) >= Rat.from_int(b)
}

theorem lt_mul_pos(a: Rat, b: Rat, c: Rat) {
    a < b and c.is_positive implies a * c < b * c
} by {
    b - a > Rat.0
    c > Rat.0
    (b - a) * c > Rat.0
    b * c - a * c > Rat.0
    a * c != b * c
    a * c <= b * c
    a * c < b * c
}

theorem lte_mul_pos(a: Rat, b: Rat, c: Rat) {
    a <= b and c.is_positive implies a * c <= b * c
} by {
    a < b or a = b
    a * c < b * c or a * c = b * c
}

theorem lt_div_pos(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a < b implies a / c < b / c
} by {
    c.reciprocal.is_positive
    a * c.reciprocal < b * c.reciprocal
}

theorem lte_div_pos(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a <= b implies a / c <= b / c
} by {
    c.reciprocal.is_positive
    a * c.reciprocal <= b * c.reciprocal
}

theorem mul_div_cancels(a: Rat, b: Rat) {
    b != Rat.0 implies (a * b) / b = a
} by {
    (a * b) / b = a * (b / b)
    (a * b) / b = a * Rat.1
}

theorem div_from_int(a: Rat) {
    Rat.from_int(a.num) / Rat.from_int(a.denom) = a
} by {
    Rat.from_int(a.num) / Rat.from_int(a.denom) = reduce(a.num, Int.1) * reduce(Int.1, a.denom)
}

theorem lt_from_int_mul_denom(a: Rat, n: Int) {
    a.num < n * a.denom implies a < Rat.from_int(n)
} by {
    Rat.from_int(a.num) < Rat.from_int(n * a.denom)
    Rat.from_int(a.num) < Rat.from_int(n) * Rat.from_int(a.denom)
    Rat.from_int(a.denom).is_positive
    Rat.from_int(a.num) / Rat.from_int(a.denom) < Rat.from_int(n) * Rat.from_int(a.denom) / Rat.from_int(a.denom)
    Rat.from_int(n) * Rat.from_int(a.denom) / Rat.from_int(a.denom) = Rat.from_int(n)
    Rat.from_int(a.num) / Rat.from_int(a.denom) < Rat.from_int(n)
}

theorem lte_from_int_mul_denom(a: Rat, n: Int) {
    a.num <= n * a.denom implies a <= Rat.from_int(n)
} by {
    if a.num = n * a.denom {
        a = Rat.from_int(n)
    } else {
        a.num < n * a.denom
        a < Rat.from_int(n)
    }
}

theorem floor_exists(a: Rat) {
    exists(q: Int) {
        Rat.from_int(q) <= a and a < Rat.from_int(q + Int.1)
    }
} by {
    a.denom.is_positive
    let (q: Int, r: Int) satisfy {
        Int.0 <= r and r < a.denom and a.num = q * a.denom + r
    }

    // Left bound
    Rat.from_int(a.num) = Rat.from_int(q * a.denom + r)
    Rat.from_int(a.num) = Rat.from_int(q * a.denom) + Rat.from_int(r)
    Rat.from_int(r) >= Rat.from_int(Int.0)
    forall(x0: Int) { x0 + Int.0 <= x0 + r }
    Rat.from_int(q * a.denom) + Rat.from_int(r) >= Rat.from_int(q * a.denom) + Rat.from_int(Int.0)
    Rat.from_int(a.num) >= Rat.from_int(q * a.denom)
    Rat.from_int(a.num) >= Rat.from_int(q) * Rat.from_int(a.denom)
    Rat.from_int(a.denom).is_positive
    Rat.from_int(q) * Rat.from_int(a.denom) / Rat.from_int(a.denom) <= Rat.from_int(a.num) / Rat.from_int(a.denom)
    Rat.from_int(q) * Rat.from_int(a.denom) / Rat.from_int(a.denom) = Rat.from_int(q)
    Rat.from_int(q) <= Rat.from_int(a.num) / Rat.from_int(a.denom)
    Rat.from_int(q) <= a

    // Right bound
    q * a.denom + r < q * a.denom + a.denom
    q * a.denom + a.denom = (q + Int.1) * a.denom
    a.num < (q + Int.1) * a.denom
    a < Rat.from_int(q + Int.1)
}

let floor_impl(a: Rat) -> q: Int satisfy {
    Rat.from_int(q) <= a and a < Rat.from_int(q + Int.1)
}

attributes Rat {
    /// The floor of a rational number (the greatest integer less than or equal to it).
    define floor(self) -> Int {
        floor_impl(self)
    }
}

theorem mul_lt_lt(a: Rat, b: Rat, c: Rat, d: Rat) {
    a.is_positive and c.is_positive and a < b and c < d implies a * c < b * d
} by {
    a * c < b * c
    b.is_positive
    b * c < b * d
}

theorem mul_lt_lte(a: Rat, b: Rat, c: Rat, d: Rat) {
    a.is_positive and c.is_positive and a < b and c <= d implies a * c < b * d
} by {
    a * c < b * c
    b.is_positive
    b * c <= b * d
}

theorem pos_lte(a: Rat, b: Rat) {
    a.is_positive and a <= b implies b.is_positive
} by {
    if a = b {
        b.is_positive
    } else {
        a < b
        b.is_positive
    }
}

theorem mul_lte_lt(a: Rat, b: Rat, c: Rat, d: Rat) {
    a.is_positive and c.is_positive and a <= b and c < d implies a * c < b * d
} by {
    a * c <= b * c
    b.is_positive
    b * c < b * d
}

theorem lt_pos_reciprocal(a: Rat, b: Rat) {
    a.is_positive and a < b implies b.reciprocal < a.reciprocal
} by {
    if a.reciprocal <= b.reciprocal {
        a.reciprocal * a < b.reciprocal * b
        a.reciprocal * a = Rat.1
        b.reciprocal * b = Rat.1
        Rat.1 < Rat.1
        false
    }
}

theorem reciprocal_inverts(a: Rat) {
    a != Rat.0 implies a.reciprocal.reciprocal = a
} by {
    a * a.reciprocal = Rat.1
    Rat.new(a.reciprocal.num, a.reciprocal.denom) / a * a = Rat.new(a.reciprocal.num, a.reciprocal.denom)
    a.reciprocal != Rat.0
    a * a.reciprocal / a.reciprocal = a
    Rat.1 * a.reciprocal.reciprocal = a
}

theorem smaller_int_reciprocal(a: Rat) {
    a.is_positive implies exists(n: Int) {
        n.is_positive and Rat.from_int(n).reciprocal < a
    }
} by {
    a.reciprocal.is_positive
    let n: Int satisfy {
        a.reciprocal < Rat.from_int(n)
    }
    Rat.from_int(n).reciprocal < a.reciprocal.reciprocal
    a.reciprocal.reciprocal = a
    Rat.from_int(n).is_positive
    n.is_positive
}

theorem gte_some_int(a: Rat) {
    exists(n: Int) {
        a >= Rat.from_int(n)
    }
} by {
    a >= Rat.from_int(a.floor)
}

theorem mul_denom(r: Rat) {
    r * Rat.from_int(r.denom) = Rat.from_int(r.num)
} by {
    Rat.from_int(r.denom).num != Int.0
    Rat.from_int(r.denom) != Rat.0
    Rat.from_int(r.num) / Rat.from_int(r.denom) * Rat.from_int(r.denom) = Rat.from_int(r.num)
}

theorem half_pos(r: Rat) {
    r.is_positive implies (r / Rat.2).is_positive
}

theorem add_half_half(r: Rat) {
    (r / Rat.2) + (r / Rat.2) = r
} by {
    (r / Rat.2) + (r / Rat.2) = r / Rat.2 + r / Rat.2
    (r / Rat.2) + (r / Rat.2) = (r + r) / Rat.2
    (r / Rat.2) + (r / Rat.2) = (Rat.2 * r) / Rat.2
    (r / Rat.2) + (r / Rat.2) = r
}

theorem lt_neg(p: Rat, q: Rat) {
    p < q implies -q < -p
} by {
    (q - p).is_positive
    (-p - -q).is_positive
}

theorem lt_lte_trans(a: Rat, b: Rat, c: Rat) {
    a < b and b <= c implies a < c
} by {
    if b = c {
        a < c
    } else {
        b < c
        a < c
    }
}

theorem lte_lt_trans(a: Rat, b: Rat, c: Rat) {
    a <= b and b < c implies a < c
} by {
    if a = b {
        a < c
    } else {
        a < b
        a < c
    }
}

theorem lt_imp_rat_between(a: Rat, b: Rat) {
    a < b implies exists(c: Rat) {
        a < c and c < b
    }
} by {
    a / Rat.2 < b / Rat.2
    a < (a + b) * Rat.2.reciprocal
    a / Rat.2 + b / Rat.2 < b
    (a + b) * Rat.2.reciprocal < b
}

theorem gt_imp_rat_between(a: Rat, b: Rat) {
    a > b implies exists(c: Rat) {
        a > c and c > b
    }
} by {
    b < a
    let c: Rat satisfy {
        b < c and c < a
    }
    a > c
    c > b
}

theorem lt_cancel_pos_mul_right(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a * c < b * c implies a < b
} by {
    not b * c < a * c
    b != a
    b > a
}

theorem lt_cancel_pos_mul_left(a: Rat, b: Rat, c: Rat) {
    c.is_positive and c * a < c * b implies a < b
} by {
    not c * b < c * a
    b != a
    b > a
}

theorem gt_cancel_pos_mul_right(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a * c > b * c implies a > b
} by {
    not b * c > a * c
    b != a
    b < a
}

theorem gt_cancel_pos_mul_left(a: Rat, b: Rat, c: Rat) {
    c.is_positive and c * a > c * b implies a > b
} by {
    not c * b > c * a
    b != a
    b < a
}

theorem cancel_positivity_left(a: Rat, b: Rat) {
    a.is_positive and (a * b).is_positive implies b.is_positive
} by {
    if b.is_negative {
        (a * b).is_negative
        false
    }
}

theorem cancel_positivity_right(a: Rat, b: Rat) {
    b.is_positive and (a * b).is_positive implies a.is_positive
}

theorem mul_cancels_div_left(a: Rat, b: Rat) {
    b != Rat.0 implies b * (a / b) = a
}

theorem neg_abs(a: Rat) {
    (-a).abs = a.abs
} by {
    if a.is_negative {
        a.abs = -a
        (-a).abs = -a
        (-a).abs = a.abs
    } else {
        if a = Rat.0 {
            (-a).abs = a.abs
        } else {
            a.is_positive
            a.abs = a
            (-a).is_negative
            (-a).abs = a
            (-a).abs = a.abs
        }
    }
}

theorem abs_non_pos(a: Rat) {
    not a.is_positive implies a.abs = -a
}

theorem abs_non_neg(a: Rat) {
    not a.is_negative implies a.abs = a
}

theorem abs_mul_abs(a: Rat, b: Rat) {
    (a * b).abs = (a * b.abs).abs
} by {
    if b.is_positive {
        b.abs = b
        (a * b).abs = (a * b.abs).abs
    } else {
        b.abs = -b
        (a * b.abs) = a * -b
        (a * b.abs) = -(a * b)
        (a * b.abs).abs = (a * b).abs
    }
}

theorem mul_non_neg(a: Rat, b: Rat) {
    not a.is_negative and not b.is_negative implies not (a * b).is_negative
} by {
    if a = Rat.0 {
        not (a * b).is_negative
    } else {
        if b = Rat.0 {
            not (a * b).is_negative
        } else {
            a.is_positive
            b.is_positive
            (a * b).is_positive
            not (a * b).is_negative
        }
    }
}

theorem mul_two_abs(a: Rat, b: Rat) {
    a.abs * b.abs = (a * b).abs
} by {
    (a * b).abs = (a.abs * b.abs).abs
    not a.abs.is_negative
    not b.abs.is_negative
    not (a.abs * b.abs).is_negative
    (a.abs * b.abs).abs = a.abs * b.abs
}

theorem abs_zero_imp_zero(a: Rat) {
    a.abs = Rat.0 implies a = Rat.0
} by {
    if a != Rat.0 {
        a.abs != a
        a.is_negative
        a.abs = -a
        a + Rat.0 != Rat.0
        a + a.abs != Rat.0
        false
    }
}

theorem zero_lte_abs(a: Rat) {
    Rat.0 <= a.abs
} by {
    if a = Rat.0 {
        a.abs = Rat.0
        Rat.0 <= a.abs
    } else {
        a.abs != Rat.0
        a.abs.is_positive
        Rat.0 <= a.abs
    }
}

theorem pos_inverses_lt(p: Rat, q: Rat, r: Rat) {
    p.is_positive and q.is_positive and r.is_positive
    and r / p < r / q
    implies
    q < p
} by {
    r / p * p < r / q * p
    r / p * p = r
    r < r / q * p
    r * q < p * r / q * q
    (p * r) / q * q = p * r
    r * q < p * r
    q * r < p * r
}

theorem inverses_eq(p: Rat, q: Rat, r: Rat) {
    p != Rat.0 and q != Rat.0 and r != Rat.0
    and r / p = r / q
    implies
    q = p
} by {
    r / p * p = r / q * p
    r = r / q * p
    r = p * r / q
    r * q = p * r / q * q
    r * q = p * r
    q * r = p * r
}

theorem pos_inverses_lte(p: Rat, q: Rat, r: Rat) {
    p.is_positive and q.is_positive and r.is_positive
    and r / p <= r / q
    implies
    q <= p
} by {
    if r / p = r / q {
        p != Rat.0
        q != Rat.0
        q = p
        q <= p
    } else {
        q < p
        q <= p
    }
}

theorem pos_inverses_gt(p: Rat, q: Rat, r: Rat) {
    p.is_positive and q.is_positive and r.is_positive
    and r / p > r / q
    implies
    q > p
}

theorem pos_inverses_gte(p: Rat, q: Rat, r: Rat) {
    p.is_positive and q.is_positive and r.is_positive
    and r / p >= r / q
    implies
    q >= p
}

theorem lt_cancel_add_right(p: Rat, q: Rat, r: Rat) {
    p + r < q + r implies p < q
} by {
    not q + r < p + r
    q != p
    q > p
}

theorem sub_distrib(p: Rat, q: Rat, r: Rat) {
    p * (q - r) = p * q - p * r
} by {
    p * (q - r) = p * (q + -r)
    p * (q - r) = p * q + p * -r
    p * (q - r) = p * q - p * r
}

theorem half_lt_one {
    Rat.2.reciprocal < Rat.1
} by {
    (Rat.1 / Rat.2).is_positive
    Rat.2.reciprocal < Rat.2.reciprocal + Rat.1 / Rat.2
    Rat.2.reciprocal < Rat.1 / Rat.2 + Rat.1 / Rat.2
}

theorem lower_squared(a: Rat) {
    a.is_positive
    implies
    exists(eps: Rat) {
        eps.is_positive and eps * eps < a
    }
} by {
    if Rat.1 <= a {
        let eps: Rat = Rat.2.reciprocal
        eps.is_positive
        eps < Rat.1
        eps * eps < Rat.1
        eps.is_positive and eps * eps < a
    } else {
        a < Rat.1
        let eps: Rat = a * a
        eps.is_positive
        eps.is_positive and eps * eps < a
    }
}

theorem square_lt_imp_lt(a: Rat, b: Rat) {
    a.is_positive and b.is_positive and a * a < b * b
    implies
    a < b
} by {
    if a >= b {
        false
    }
}

theorem smaller_positive(a: Rat) {
    a.is_positive implies
    exists(r: Rat) {
        r.is_positive and r < a
    }
}

theorem lt_both_pos(a: Rat, b: Rat) {
    a.is_positive and b.is_positive implies
    exists(r: Rat) {
        r.is_positive and r < a and r < b
    }
} by {
    if a < b {
        let r: Rat satisfy {
            r.is_positive and r < a
        }
        r.is_positive and r < a and r < b
    } else {
        let r: Rat satisfy {
            r.is_positive and r < b
        }
        r.is_positive and r < a and r < b
    }
}

theorem lt_rhs_div_pos(a: Rat, b: Rat, c: Rat) {
    c.is_positive and a < b / c implies a * c < b
} by {
    a * c < b / c * c
    b / c * c = b
}

attributes Rat {
    /// True if the absolute difference between two rationals is less than epsilon.
    define is_close(self, other: Rat, eps: Rat) -> Bool {
        (self - other).abs < eps
    }
}

theorem lte_abs(q: Rat) {
    q <= q.abs
}

theorem close_comm(a: Rat, b: Rat, eps: Rat) {
    a.is_close(b, eps) implies b.is_close(a, eps)
} by {
    a - b = -(b - a)
    (a - b).abs = (b - a).abs
    (a - b).abs < eps
    (b - a).abs < eps
}

theorem close_imp_bounds(a: Rat, b: Rat, eps: Rat) {
    a.is_close(b, eps) implies a < b + eps and a > b - eps
} by {
    // Left ineq
    (a - b).abs < eps
    a - b <= (a - b).abs
    a - b < eps
    a - b + b < eps + b
    a < eps + b
    a < b + eps

    // Right ineq
    (b - a).abs < eps
    b - a <= (b - a).abs
    b - a < eps
    b - a + a < eps + a
    b - a + a = b
    b < eps + a
    eps + a > b
    a + eps > b
    a + eps + -eps > b + -eps
    a > b + -eps
}

theorem bounds_imp_close(a: Rat, b: Rat, eps: Rat) {
    a < b + eps and a > b - eps implies a.is_close(b, eps)
} by {
    if (a - b).is_negative {
        (a - b).abs = b - a
        a > b + -eps
        a + eps + -eps > b + -eps
        a + eps > b
        eps + a > b
        b < eps + a
        b - a + a = b
        b - a + a < eps + a
        b - a < eps
        (a - b).abs < eps
        a.is_close(b, eps)
    } else {
        (a - b).abs = a - b
        a < eps + b
        a - b + b < eps + b
        a - b < eps
        a - b < eps
        (a - b).abs < eps
        a.is_close(b, eps)
    }
}

attributes Rat {
    /// Converts a natural number to a rational number.
    let from_nat: Nat -> Rat = function(n: Nat) {
        Rat.from_int(Int.from_nat(n))
    }
}

theorem nat_lt_imp_rat_lt(a: Nat, b: Nat) {
    a < b implies Rat.from_nat(a) < Rat.from_nat(b)
} by {
    Rat.from_nat(a) < Rat.from_nat(b)
}

theorem from_nat_nonneg(n: Nat) {
    Rat.0 <= Rat.from_nat(n)
} by {
    if n = Nat.0 {
        Rat.from_nat(n) = Rat.0
        Rat.0 <= Rat.from_nat(n)
    } else {
        Nat.0 < n
        Rat.from_nat(Nat.0) < Rat.from_nat(n)
        Rat.0 < Rat.from_nat(n)
        Rat.0 <= Rat.from_nat(n)
    }
}

theorem recip_eq_one_div(a: Rat) {
    a != Rat.0 implies a.reciprocal = Rat.1 / a
}